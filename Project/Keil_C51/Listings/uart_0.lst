C51 COMPILER V9.56.0.0   UART_0                                                            10/28/2016 17:37:02 PAGE 1   


C51 COMPILER V9.56.0.0, COMPILATION OF MODULE UART_0
OBJECT MODULE PLACED IN .\Objects\uart_0.obj
COMPILER INVOKED BY: D:\MyProKits\MucKits\Keil_C51_Rev956\C51\BIN\C51.EXE ..\..\SdkTool\EFM8UB2\Perip\Src\uart_0.c LARGE
                    - OMF2 OPTIMIZE(0,SPEED) BROWSE INCDIR(..\..\SrcCode\Bsp\Inc;..\..\SrcCode\Logic\Inc;..\..\SrcCode\Middle\Gui\Inc;..\..\S
                    -rcCode\Middle\Input\Inc;..\..\SdkTool\Si8051Base;..\..\SdkTool\EFM8UB2\Inc;..\..\SdkTool\EFM8UB2\Perip\Inc;..\..\SdkTool
                    -\EFM8UB2\Xpress\Inc) DEBUG CODE LISTINCLUDE SYMBOLS PRINT(.\Listings\uart_0.lst) TABS(2) PREPRINT(.\Listings\uart_0.i) O
                    -BJECT(.\Objects\uart_0.obj)

line level    source

   1          /**************************************************************************//**
   2           * Copyright (c) 2015 by Silicon Laboratories Inc. All rights reserved.
   3           *
   4           * http://developer.silabs.com/legal/version/v11/Silicon_Labs_Software_License_Agreement.txt
   5           *****************************************************************************/
   6          
   7          #include "uart_0.h"
   1      =1  /******************************************************************************
   2      =1   * Copyright (c) 2014 by Silicon Laboratories Inc. All rights reserved.
   3      =1   *
   4      =1   * http://developer.silabs.com/legal/version/v11/Silicon_Labs_Software_License_Agreement.txt
   5      =1   *****************************************************************************/
   6      =1  
   7      =1  #ifndef __UART_0_H__
   8      =1  #define __UART_0_H__
   9      =1  
  10      =1  #include "SI_EFM8UB2_Defs.h"
   1      =2  //------------------------------------------------------------------------------
   2      =2  // Copyright 2014 Silicon Laboratories, Inc.
   3      =2  // All rights reserved. This program and the accompanying materials
   4      =2  // are made available under the terms of the Silicon Laboratories End User
   5      =2  // License Agreement which accompanies this distribution, and is available at
   6      =2  // http://developer.silabs.com/legal/version/v11/Silicon_Labs_Software_License_Agreement.txt
   7      =2  // Original content and implementation provided by Silicon Laboratories.
   8      =2  //------------------------------------------------------------------------------
   9      =2  //Supported Devices:
  10      =2  //  EFM8UB20F32G_QFN32
  11      =2  //  EFM8UB20F32G_QFP32
  12      =2  //  EFM8UB20F32G_QFP48
  13      =2  //  EFM8UB20F64G_QFN32
  14      =2  //  EFM8UB20F64G_QFP32
  15      =2  //  EFM8UB20F64G_QFP48
  16      =2  
  17      =2  #ifndef SI_EFM8UB2_DEFS_H
  18      =2  #define SI_EFM8UB2_DEFS_H
  19      =2  
  20      =2  #include <si_toolchain.h>
   1      =3  /******************************************************************************
   2      =3   * Copyright (c) 2015 by Silicon Laboratories Inc. All rights reserved.
   3      =3   *
   4      =3   * http://developer.silabs.com/legal/version/v11/Silicon_Labs_Software_License_Agreement.txt
   5      =3   *****************************************************************************/
   6      =3  
   7      =3  #ifndef __SI_TOOLCHAIN_H__
   8      =3  #define __SI_TOOLCHAIN_H__
   9      =3  
  10      =3  #include <stdint.h>
   1      =4  /**************************************************************************//**
   2      =4   * Copyright (c) 2015 by Silicon Laboratories Inc. All rights reserved.
   3      =4   *
   4      =4   * http://developer.silabs.com/legal/version/v11/Silicon_Labs_Software_License_Agreement.txt
C51 COMPILER V9.56.0.0   UART_0                                                            10/28/2016 17:37:02 PAGE 2   

   5      =4   *****************************************************************************/
   6      =4  
   7      =4  #ifndef STDINT_H
   8      =4  #define STDINT_H
   9      =4  
  10      =4  #if defined __C51__
  11      =4  
  12      =4  typedef unsigned char     uint8_t;
  13      =4  typedef unsigned short    uint16_t;
  14      =4  typedef unsigned long     uint32_t;
  15      =4  typedef uint32_t          uint64_t[2];
  16      =4  
  17      =4  typedef signed char       int8_t;
  18      =4  typedef short             int16_t;
  19      =4  typedef long              int32_t;
  20      =4  typedef int32_t           int64_t[2];
  21      =4  
  22      =4  #endif
  23      =4  
  24      =4  #endif
  11      =3  #include <stdbool.h>
   1      =4  /**************************************************************************//**
   2      =4   * Copyright (c) 2015 by Silicon Laboratories Inc. All rights reserved.
   3      =4   *
   4      =4   * http://developer.silabs.com/legal/version/v11/Silicon_Labs_Software_License_Agreement.txt
   5      =4   *****************************************************************************/
   6      =4  
   7      =4  #ifndef STDBOOL_H
   8      =4  #define STDBOOL_H
   9      =4  
  10      =4  #if defined __C51__
  11      =4  
  12      =4  typedef bit bool;
  13      =4  enum{
  14      =4    false = 0,
  15      =4    true = 1,
  16      =4  };
  17      =4  
  18      =4  #endif //__C51__
  19      =4  #endif //STDBOOL_H
  20      =4  
  12      =3  
  13      =3  /**************************************************************************//**
  14      =3   *
  15      =3   * @addtogroup toolchain_group Toolchain Abstraction
  16      =3   *
  17      =3   * @brief Macros for toolchain abstraction.
  18      =3   *
  19      =3   * # Introduction #
  20      =3   *
  21      =3   * This header file contains macros that are used to provide an abstraction
  22      =3   * for toolchain use in source code.  The 8051 compiler requires C-language
  23      =3   * extensions in order to fully use features of the 8051 architecture.  All
  24      =3   * compilers for 8051 implement a set of extensions but use different names
  25      =3   * and ways of implementing those extensions.  This header file provides
  26      =3   * macros that are defined for each supported toolchain and can be used in
  27      =3   * the source code.  This allows the source code to use 8051 extensions and
  28      =3   * remain independent of which toolchain is used for compilation.
  29      =3   *
  30      =3   * ## Variable and Pointer Declarations ##
  31      =3   *
  32      =3   * It is often useful to specify the memory area (or segment) of a variable,
C51 COMPILER V9.56.0.0   UART_0                                                            10/28/2016 17:37:02 PAGE 3   

  33      =3   * pointer, or pointer target.  For example, you may wish to place all
  34      =3   * variables in XDATA by default, but for variables used in time-sensitive
  35      =3   * code you use DATA for efficient access.  In this case you declare the
  36      =3   * XDATA variable in the normal C way, but declare the variables to be located
  37      =3   * in the DATA segment using @ref SI_SEGMENT_VARIABLE.
  38      =3   *
  39      =3   * Pointers are more complicated because there are two memory spaces
  40      =3   * associated with a pointer, the pointer target, and the pointer variable
  41      =3   * itself.  When using default memory segment for the pointer location and
  42      =3   * target, then no special macro is needed.  But if you wish to specify the
  43      =3   * pointer variable location, or target memory segment, then you can use one
  44      =3   * of the following macros to do this in a toolchain-independent way.
  45      =3   *
  46      =3   * |Pointer segment|Target segment|Macro                                   |
  47      =3   * |---------------|--------------|----------------------------------------|
  48      =3   * |default        |generic       |None                                    |
  49      =3   * |default        |specific      |@ref SI_VARIABLE_SEGMENT_POINTER        |
  50      =3   * |specific       |generic       |@ref SI_SEGMENT_POINTER                 |
  51      =3   * |specific       |specific      |@ref SI_SEGMENT_VARIABLE_SEGMENT_POINTER|
  52      =3   *
  53      =3   * ## Prior Toolchain Abstraction Header File ##
  54      =3   *
  55      =3   * This file supercedes an earlier header file named `compiler_defs.h`.  We
  56      =3   * are deprecating the use of compiler_defs.h, however it will remain for
  57      =3   * backwards compatibility.  This file was created to normalize macro names,
  58      =3   * remove unused macros, and to provide documentation.
  59      =3   *
  60      =3   * ## Supported Toolchains ##
  61      =3   *
  62      =3   * - Keil/ARM C51
  63      =3   *
  64      =3   * @{
  65      =3   *
  66      =3   *****************************************************************************/
  67      =3  
  68      =3  // Make sure there is a NULL defined if the toolchain does not provide it.
  69      =3  #ifndef NULL
  70      =3  #define NULL ((void *)0)
  71      =3  #endif
  72      =3  
  73      =3  // -------------------------------
  74      =3  // Keil/ARM C51
  75      =3  //
  76      =3  #if defined(__C51__)
  77      =3  
  78      =3  /// Used with pointers, declares a generic pointer.  Generic pointers
  79      =3  /// work with any memory space but are inefficient.
  80      =3  #define SI_SEG_GENERIC
  81      =3  
  82      =3  /// Declares a variable to be located in 8051 DATA space.
  83      =3  #define SI_SEG_DATA data
  84      =3  
  85      =3  /// Declares a variable to be located in 8051 IDATA space.
  86      =3  #define SI_SEG_IDATA idata
  87      =3  
  88      =3  /// Declares a variable to be located in 8051 XDATA space.
  89      =3  #define SI_SEG_XDATA xdata
  90      =3  
  91      =3  /// Declares a variable to be located in 8051 PDATA space.
  92      =3  #define SI_SEG_PDATA pdata
  93      =3  
  94      =3  /// Declares a variable to be located in 8051 BDATA (bit-addressable) space.
C51 COMPILER V9.56.0.0   UART_0                                                            10/28/2016 17:37:02 PAGE 4   

  95      =3  #define SI_SEG_BDATA bdata
  96      =3  
  97      =3  /// Declares a variable to be located in 8051 CODE space.
  98      =3  #define SI_SEG_CODE code
  99      =3  
 100      =3  /**************************************************************************//**
 101      =3   * Declares a bit variable in a bit-addressable SFR or memory space.
 102      =3   *
 103      =3   * @param name The name of the bit variable.
 104      =3   * @param address The address of the byte containing the bit.
 105      =3   * @param bitnum The bit number (0-7) within the byte.
 106      =3   *
 107      =3   * This cannot be used to make any arbitrary SFR or variable into
 108      =3   * a bit variable.  The underlying memory must support bit-addressability.
 109      =3   *****************************************************************************/
 110      =3  #define SI_SBIT(name, address, bitnum) sbit name = address^bitnum
 111      =3  
 112      =3  /**************************************************************************//**
 113      =3   * Declares an 8-bit special function register (SFR) variable.
 114      =3   *
 115      =3   * @param name The name of the SFR variable.
 116      =3   * @param address The address of the SFR.
 117      =3   *
 118      =3   * This creates a C variable (8-bit) that maps to a physical special function
 119      =3   * register of the 8051.  This cannot be used to make any arbitrary memory
 120      =3   * location into an SFR.  The _address_ must map to a real SFR in the memory
 121      =3   * map.
 122      =3   *****************************************************************************/
 123      =3  #define SI_SFR(name, address) sfr name = address
 124      =3  
 125      =3  /**************************************************************************//**
 126      =3   * Declares a 16-bit special function register (SFR) variable.
 127      =3   *
 128      =3   * @param name The name of the SFR variable.
 129      =3   * @param address The address of the 16-bit SFR.
 130      =3   *
 131      =3   * This creates a C variable (16-bit) that maps to a physical special function
 132      =3   * register of the 8051.  This cannot be used to make any arbitrary memory
 133      =3   * location into an SFR.  The _address_ must map to a real 16-bit SFR in the
 134      =3   * memory map.
 135      =3   *****************************************************************************/
 136      =3  #define SI_SFR16(name, address) sfr16 name = address
 137      =3  
 138      =3  #ifndef __SLS_IDE__
 139      =3  /**************************************************************************//**
 140      =3   * Define an interrupt handler function for an interrupt vector.
 141      =3   *
 142      =3   * @param name The name of the interrupt handler function.
 143      =3   * @param vector The interrupt vector number.
 144      =3   *
 145      =3   * This macro defines a function to be an interrupt handler.  The _vector_
 146      =3   * parameter is the 8051 interrupt vector number, not the address.  This
 147      =3   * will cause the compiler to treat the function as the interrupt handler
 148      =3   * and generate the appropriate prolog/epilog code.
 149      =3   *
 150      =3   * @note This macro is used to define the function implementation.  To declare
 151      =3   * the interrupt function prototype, use @ref SI_INTERRUPT_PROTO.
 152      =3   *****************************************************************************/
 153      =3  #define SI_INTERRUPT(name, vector) void name (void) interrupt vector
 154      =3  
 155      =3  /**************************************************************************//**
 156      =3   * Define an interrupt handler function using a specific register bank.
C51 COMPILER V9.56.0.0   UART_0                                                            10/28/2016 17:37:02 PAGE 5   

 157      =3   *
 158      =3   * @param name The name of the interrupt handler function.
 159      =3   * @param vector The interrupt vector number.
 160      =3   * @param regnum The register bank number (0-3).
 161      =3   *
 162      =3   * This macro defines a function to be an interrupt handler, using a specific
 163      =3   * register bank for the interrupt code.  The _vector_ parameter is the 8051
 164      =3   * interrupt vector number, not the address.  The _regnum_ parameter is the
 165      =3   * register bank number (0-3) that will be used as general purpose registers
 166      =3   * for the instructions in the compiled code.  Using dedicated register banks
 167      =3   * for interrupt handlers allows the prolog code to just switch banks instead
 168      =3   * of saving and restoring all the general purpose registers.  This can make
 169      =3   * interrupt entry/exit faster but requires dedicating a register bank for
 170      =3   * the interrupt handler.
 171      =3   *
 172      =3   * @note This macro is used to define the function implementation.  To declare
 173      =3   * the interrupt function prototype, use @ref SI_INTERRUPT_PROTO_USING.
 174      =3   *****************************************************************************/
 175      =3  #define SI_INTERRUPT_USING(name, vector, regnum)                             \
 176      =3               void name (void) interrupt vector using regnum
 177      =3  
 178      =3  /**************************************************************************//**
 179      =3   * Declare an interrupt handler prototype for an interrupt vector.
 180      =3   *
 181      =3   * @param name The name of the interrupt handler function.
 182      =3   * @param vector The interrupt vector number.
 183      =3   *
 184      =3   * This macro declares a function prototype for an interrupt handler.  The
 185      =3   * _vector_ parameter is the 8051 interrupt vector number, not the address.
 186      =3   * Declaring the function prototype this way will cause the compiler to
 187      =3   * recognize that the function is an interrupt handler and not a normal C
 188      =3   * function.
 189      =3   *
 190      =3   * @note This macro is used to declare a prototype for the interrupt function.
 191      =3   * To define the interrupt function implementation, use @ref SI_INTERRUPT.
 192      =3   *****************************************************************************/
 193      =3  #define SI_INTERRUPT_PROTO(name, vector) void name (void)
 194      =3  
 195      =3  /**************************************************************************//**
 196      =3   * Declare an interrupt handler prototype using a specific register bank.
 197      =3   *
 198      =3   * @param name The name of the interrupt handler function.
 199      =3   * @param vector The interrupt vector number.
 200      =3   * @param regnum The register bank number (0-3).
 201      =3   *
 202      =3   * This macro declares a function prototype for an interrupt handler, for a
 203      =3   * function that uses a specific register bank for the interrupt code.  The
 204      =3   * _vector_ parameter is the 8051 interrupt vector number, not the address.
 205      =3   * The _regnum_ parameter is the register bank number (0-3) that will be used
 206      =3   * as general purpose registers in the function.  Declaring the function
 207      =3   * prototype this way will cause the compiler to recognize that the function
 208      =3   * is an interrupt handler and is not a normal C function.
 209      =3   *
 210      =3   * @note This macro is used to declare a prototype for the interrupt function.
 211      =3   * To define the interrupt function implementation,
 212      =3   * use @ref SI_INTERRUPT_USING.
 213      =3   *****************************************************************************/
 214      =3  #define SI_INTERRUPT_PROTO_USING(name, vector, regnum) void name (void)
 215      =3  
 216      =3  /**************************************************************************//**
 217      =3   * Define a function to use a specific register bank.
 218      =3   *
C51 COMPILER V9.56.0.0   UART_0                                                            10/28/2016 17:37:02 PAGE 6   

 219      =3   * @param name The name of the function.
 220      =3   * @param return_value The data type of the function return value
 221      =3   * (void, int, etc).
 222      =3   * @param parameter One C function parameter (or "void") (type and name).
 223      =3   * @param regnum The register bank number (0-3).
 224      =3   *
 225      =3   * This macro defines a function that uses a specific register bank.  The
 226      =3   * _regnum_ parameter is the register bank number (0-3) that will be used as
 227      =3   * general purpose registers for the instructions in the compiled function
 228      =3   * code.  Using dedicated register banks for a function can reduce the amount
 229      =3   * of registers saving and restoring needed on entry and exit to the
 230      =3   * function.  However, this is an advanced feature and you should not use it
 231      =3   * unless you fully understand how and when to use register banking.
 232      =3   *
 233      =3   * You must specify the _return_value_ which is the type of the function.  It
 234      =3   * can be `void` or any other C type or typedef.  The _parameters_ argument
 235      =3   * is the list of function parameters.  It can be `void` or else it must be
 236      =3   * a parameter data type and name.  It can also be multiple parameters but
 237      =3   * they must be enclosed in parentheses and separated by commas.
 238      =3   *
 239      =3   * __Example__
 240      =3   *
 241      =3   * ~~~~~~~~.c
 242      =3   * // The following is used to implement a function with the following
 243      =3   * // signature, and that uses register bank 3 ...
 244      =3   * uint16_t myFunction(uint8_t parm1, uint8_t parm2);
 245      =3   *
 246      =3   * SI_FUNCTION_USING(myFunction, uint16_t, (uint8_t parm1, uint8_t parm2), 3)
 247      =3   * {
 248      =3   *   // Function implementation body
 249      =3   * }
 250      =3   * ~~~~~~~~
 251      =3   *
 252      =3   * @note This macro is used to define the function implementation.  To declare
 253      =3   * the function prototype, use @ref SI_FUNCTION_PROTO_USING.
 254      =3   *****************************************************************************/
 255      =3  #define SI_FUNCTION_USING(name, return_value, parameter, regnum)              \
 256      =3               return_value name (parameter) using regnum
 257      =3  
 258      =3  /**************************************************************************//**
 259      =3   * Declare a function that uses a specific register bank.
 260      =3   *
 261      =3   * @param name The name of the function.
 262      =3   * @param return_value The data type of the function return value
 263      =3   * (void, int, etc).
 264      =3   * @param parameter One C function parameter (or "void") (type and name).
 265      =3   * @param regnum The register bank number (0-3).
 266      =3   *
 267      =3   * This macro declares a function prototype for a C function that uses a
 268      =3   * specific register its working registers.  See the documentation for
 269      =3   * @ref SI_FUNCTION_USING for an explanation of the macro arguments.  This is
 270      =3   * an advanced feature.
 271      =3   *
 272      =3   * @note This macro is used to declare a prototype for the function.  To
 273      =3   * define the function implementation, use @ref SI_FUNCTION_USING.
 274      =3   *****************************************************************************/
 275      =3  #define SI_FUNCTION_PROTO_USING(name, return_value, parameter, regnum)        \
 276      =3               return_value name (parameter)
 277      =3  
 278      =3  /**************************************************************************//**
 279      =3   * Declare a variable to be located in a specific memory segment.
 280      =3   *
C51 COMPILER V9.56.0.0   UART_0                                                            10/28/2016 17:37:02 PAGE 7   

 281      =3   * @param name The variable name.
 282      =3   * @param vartype The variable data type.
 283      =3   * @param memseg The memory segment to use for the variable.
 284      =3   *
 285      =3   * This macro declares a variable to be located in a specific memory area
 286      =3   * (or segment) of the 8051 memory space.  It is only necessary to use this
 287      =3   * macro if you want to force the variable into a specific memory space instead
 288      =3   * of the default memory space used by the compiler.  The segment can be
 289      =3   * one of the following:
 290      =3   *
 291      =3   * - @ref SI_SEG_DATA
 292      =3   * - @ref SI_SEG_IDATA
 293      =3   * - @ref SI_SEG_BDATA
 294      =3   * - @ref SI_SEG_PDATA
 295      =3   * - @ref SI_SEG_XDATA
 296      =3   * - @ref SI_SEG_CODE
 297      =3   *
 298      =3   * __Example__
 299      =3   *
 300      =3   * ~~~~~~~~.c
 301      =3   * // The following macro can be used to create a variable located in
 302      =3   * // XDATA with the following signature:
 303      =3   * uint8_t myVar;
 304      =3   *
 305      =3   * SI_SEGMENT_VARIABLE(myVar, uint8_t, SEG_XDATA);
 306      =3   * ~~~~~~~~
 307      =3   *****************************************************************************/
 308      =3  #define SI_SEGMENT_VARIABLE(name, vartype, memseg) vartype memseg name
 309      =3  
 310      =3  /**************************************************************************//**
 311      =3   * Declare a memory segment specific pointer variable.
 312      =3   *
 313      =3   * @param name The pointer variable name.
 314      =3   * @param vartype The pointer data type.
 315      =3   * @param targseg The target memory segment for the pointer.
 316      =3   *
 317      =3   * This macro declares a pointer that points at a specific memory area
 318      =3   * (or segment).  The memory segment of the pointer variable itself is not
 319      =3   * specified and the default is used.  The segment can be one of the following:
 320      =3   *
 321      =3   * - @ref SI_SEG_DATA
 322      =3   * - @ref SI_SEG_IDATA
 323      =3   * - @ref SI_SEG_BDATA
 324      =3   * - @ref SI_SEG_PDATA
 325      =3   * - @ref SI_SEG_XDATA
 326      =3   * - @ref SI_SEG_CODE
 327      =3   *
 328      =3   * __Example__
 329      =3   *
 330      =3   * ~~~~~~~~.c
 331      =3   * // The following macro can be used to create a pointer that points to
 332      =3   * // a location in XDATA with the following signature:
 333      =3   * uint8_t *pVar; // where pVar is pointing at XDATA
 334      =3   *
 335      =3   * SI_VARIABLE_SEGMENT_POINTER(pVar, uint8_t, SEG_XDATA);
 336      =3   * ~~~~~~~~
 337      =3   *****************************************************************************/
 338      =3  #define SI_VARIABLE_SEGMENT_POINTER(name, vartype, targseg)                  \
 339      =3               vartype targseg * name
 340      =3  
 341      =3  /**************************************************************************//**
 342      =3   * Declare a memory segment specific pointer variable, in a specific segment.
C51 COMPILER V9.56.0.0   UART_0                                                            10/28/2016 17:37:02 PAGE 8   

 343      =3   *
 344      =3   * @param name The pointer variable name.
 345      =3   * @param vartype The pointer data type.
 346      =3   * @param targseg The target memory segment for the pointer.
 347      =3   * @param memseg The memory segment to use for the pointer variable.
 348      =3   *
 349      =3   * This macro declares a pointer that points at a specific memory area
 350      =3   * (or segment).  The pointer variable itself is also located in a specified
 351      =3   * memory segment by _memseg_.  The arguments _targseg_ and _memseg_ can be
 352      =3   * one of the following:
 353      =3   *
 354      =3   * - @ref SI_SEG_DATA
 355      =3   * - @ref SI_SEG_IDATA
 356      =3   * - @ref SI_SEG_BDATA
 357      =3   * - @ref SI_SEG_PDATA
 358      =3   * - @ref SI_SEG_XDATA
 359      =3   * - @ref SI_SEG_CODE
 360      =3   *
 361      =3   * __Example__
 362      =3   *
 363      =3   * ~~~~~~~~.c
 364      =3   * // The following macro can be used to create a pointer that points to
 365      =3   * // a location in XDATA while the pointer itself is located in DATA, with
 366      =3   * // the following signature:
 367      =3   * uint8_t *pVar; // where pVar is located in DATA and is pointing at XDATA
 368      =3   *
 369      =3   * SI_SEGMENT_VARIABLE_SEGMENT_POINTER(pVar, uint8_t, SEG_XDATA, SEG_DATA);
 370      =3   * ~~~~~~~~
 371      =3   *****************************************************************************/
 372      =3  #define SI_SEGMENT_VARIABLE_SEGMENT_POINTER(name, vartype, targseg, memseg)  \
 373      =3               vartype targseg * memseg name
 374      =3  
 375      =3  /**************************************************************************//**
 376      =3   * Declare a generic pointer variable that is located in a specific segment.
 377      =3   *
 378      =3   * @param name The pointer variable name.
 379      =3   * @param vartype The pointer data type.
 380      =3   * @param memseg The memory segment to use for the pointer variable.
 381      =3   *
 382      =3   * This macro declares a pointer that is a generic pointer.  This means it can
 383      =3   * point at any kind of memory location.  However the pointer variable itself
 384      =3   * is located in a specific memory segment by _memseg_, which can be one of
 385      =3   * the following:
 386      =3   *
 387      =3   * - @ref SI_SEG_DATA
 388      =3   * - @ref SI_SEG_IDATA
 389      =3   * - @ref SI_SEG_BDATA
 390      =3   * - @ref SI_SEG_PDATA
 391      =3   * - @ref SI_SEG_XDATA
 392      =3   * - @ref SI_SEG_CODE
 393      =3   *
 394      =3   * __Example__
 395      =3   *
 396      =3   * ~~~~~~~~.c
 397      =3   * // The following macro can be used to create a generic pointer that
 398      =3   * // is located in DATA and points at any memory type, with the
 399      =3   * // following signature:
 400      =3   * uint8_t *pVar; // where pVar is located in DATA and is a generic pointer
 401      =3   *
 402      =3   * SI_SEGMENT_POINTER(pVar, uint8_t, SEG_DATA);
 403      =3   * ~~~~~~~~
 404      =3   *****************************************************************************/
C51 COMPILER V9.56.0.0   UART_0                                                            10/28/2016 17:37:02 PAGE 9   

 405      =3  #define SI_SEGMENT_POINTER(name, vartype, memseg) vartype * memseg name
 406      =3  
 407      =3  /**************************************************************************//**
 408      =3   * Declare an uninitialized variable that is located at a specific address.
 409      =3   *
 410      =3   * @param name The variable name.
 411      =3   * @param vartype The variable data type.
 412      =3   * @param memseg The memory segment to use for the variable.
 413      =3   * @param address The memory address of the variable.
 414      =3   *
 415      =3   * This macro allows declaring a variable that can be placed at a specific
 416      =3   * location in memory.  This can only be used for variables that do not need
 417      =3   * initializers.  The _address_ is the memory address within the specified
 418      =3   * segment.  The memory segment, _memseg_, can be one of the following:
 419      =3   *
 420      =3   * - @ref SI_SEG_DATA
 421      =3   * - @ref SI_SEG_IDATA
 422      =3   * - @ref SI_SEG_BDATA
 423      =3   * - @ref SI_SEG_PDATA
 424      =3   * - @ref SI_SEG_XDATA
 425      =3   * - @ref SI_SEG_CODE
 426      =3   *
 427      =3   * __Example__
 428      =3   *
 429      =3   * ~~~~~~~~.c
 430      =3   * // The following declares a variable located at 0x4000 in XDATA with
 431      =3   * // the following signature:
 432      =3   * uint8_t myMemVar;
 433      =3   *
 434      =3   * SI_LOCATED_VARIABLE_NO_INIT(myMemVar, uint8_t, SEG_DATA, 0x4000);
 435      =3   * ~~~~~~~~
 436      =3   *****************************************************************************/
 437      =3  #define SI_LOCATED_VARIABLE_NO_INIT(name, vartype, memseg, address)          \
 438      =3               vartype memseg name _at_ address
 439      =3  
 440      =3  
 441      =3  #else  // __SLS_IDE__ : Macros defined to remove syntax errors within Simplicity Studio
           =3 #define SI_INTERRUPT(name, vector) void name (void)
           =3 #define SI_INTERRUPT_USING(name, vector, regnum) void name (void)
           =3 #define SI_INTERRUPT_PROTO(name, vector) void name (void)
           =3 #define SI_INTERRUPT_PROTO_USING(name, vector, regnum) void name (void)
           =3 
           =3 #define SI_FUNCTION_USING(name, return_value, parameter, regnum) return_value name (parameter)
           =3 #define SI_FUNCTION_PROTO_USING(name, return_value, parameter, regnum) return_value name (parameter)
           =3 // Note: Parameter must be either 'void' or include a variable type and name. (Ex: char temp_variable)
           =3 
           =3 #define SI_SEGMENT_VARIABLE(name, vartype, locsegment) vartype name
           =3 #define SI_VARIABLE_SEGMENT_POINTER(name, vartype, targsegment) vartype * name
           =3 #define SI_SEGMENT_VARIABLE_SEGMENT_POINTER(name, vartype, targsegment, locsegment) vartype * name
           =3 #define SI_SEGMENT_POINTER(name, vartype, locsegment) vartype * name
           =3 #define SI_LOCATED_VARIABLE_NO_INIT(name, vartype, locsegment, addr) vartype name
           =3 #endif // __SLS_IDE__
 457      =3  
 458      =3  // The following are used for byte ordering when referring to individual
 459      =3  // bytes within a SI_UU32_t.  B0 is the least significant byte.
 460      =3  #define B0 3 ///< Least significant byte of a 4 byte word
 461      =3  #define B1 2 ///< Byte 1 of a 4-byte word, where byte 0 is LSB
 462      =3  #define B2 1 ///< Byte 2 of a 4-byte word, where byte 0 is LSB
 463      =3  #define B3 0 ///< Most significant byte of a 4-byte word
 464      =3  
 465      =3  #define LSB 1 ///< Index to least significant bit of a 2 byte word
 466      =3  #define MSB 0 ///< Index to most significant bit of a 2 byte word
C51 COMPILER V9.56.0.0   UART_0                                                            10/28/2016 17:37:02 PAGE 10  

 467      =3  
 468      =3  /// A union type to make it easier to access individual bytes of a 16-bit
 469      =3  /// word, and to use as signed or unsigned type.
 470      =3  typedef union SI_UU16
 471      =3  {
 472      =3    uint16_t u16;   ///< The two byte value as a 16-bit unsigned integer.
 473      =3    int16_t s16;    ///< The two byte value as a 16-bit signed integer.
 474      =3    uint8_t u8[2];  ///< The two byte value as two unsigned 8-bit integers.
 475      =3    int8_t s8[2];   ///< The two byte value as two signed 8-bit integers.
 476      =3  } SI_UU16_t;
 477      =3  
 478      =3  /// A union type to make it easier to access individual bytes within a
 479      =3  /// 32-bit word, or to access it as variations of 16-bit words, or to
 480      =3  /// use as signed or unsigned type.
 481      =3  typedef union SI_UU32
 482      =3  {
 483      =3    uint32_t u32;       ///< The 4-byte value as a 32-bit unsigned integer.
 484      =3    int32_t s32;        ///< The 4-byte value as a 32-bit signed integer.
 485      =3    SI_UU16_t uu16[2];  ///< The 4-byte value as a SI_UU16_t.
 486      =3    uint16_t u16[2];    ///< The 4-byte value as two unsigned 16-bit integers.
 487      =3    int16_t s16[2];     ///< The 4-byte value as two signed 16-bit integers.
 488      =3    uint8_t u8[4];      ///< The 4-byte value as 4 unsigned 8-bit integers.
 489      =3    int8_t s8[4];       ///< The 4-byte value as 4 signed 8-bit integers.
 490      =3  } SI_UU32_t;
 491      =3  
 492      =3  // Generic pointer memory segment constants.
 493      =3  #define SI_GPTR                   ///< Generic pointer indeterminate type.
 494      =3  #define SI_GPTR_MTYPE_DATA  0x00  ///< Generic pointer for DATA segment.
 495      =3  #define SI_GPTR_MTYPE_IDATA 0x00  ///< Generic pointer for IDATA segment.
 496      =3  #define SI_GPTR_MTYPE_BDATA 0x00  ///< Generic pointer for BDATA segment.
 497      =3  #define SI_GPTR_MTYPE_PDATA 0xFE  ///< Generic pointer for PDATA segment.
 498      =3  #define SI_GPTR_MTYPE_XDATA 0x01  ///< Generic pointer for XDATA segment.
 499      =3  #define SI_GPTR_MTYPE_CODE  0xFF  ///< Generic pointer for CODE segment.
 500      =3  
 501      =3  /// Generic pointer structure containing the type and address.
 502      =3  typedef struct
 503      =3  {
 504      =3    uint8_t memtype;    ///< The type of memory of the generic pointer.
 505      =3    SI_UU16_t address;  ///< The address of the generic pointer.
 506      =3  } GPTR_t;
 507      =3  
 508      =3  /// A union type to allow access to the fields of a generic pointer.
 509      =3  /// A generic pointer has a field indicating the type of memory and an
 510      =3  /// address within the memory.
 511      =3  typedef union SI_GEN_PTR
 512      =3  {
 513      =3    uint8_t u8[3];    ///< 3-byte generic pointer as 3 unsigned 8-bit integers.
 514      =3    GPTR_t gptr;      ///< 3-byte generic pointer as pointer structure
 515      =3  } SI_GEN_PTR_t;
 516      =3  
 517      =3  // Declaration of Keil intrinisc
 518      =3  extern void _nop_(void);
 519      =3  /// Macro to insert a no-operation (NOP) instruction.
 520      =3  #define NOP() _nop_()
 521      =3  
 522      =3  // -------------------------------
 523      =3  // GCC for ARM Cortex-M
 524      =3  // Provides support for code that can be compiled for 8 or 32-bit
 525      =3  //
 526      =3  #elif defined (__GNUC__)
           =3 #if defined(__ARMEL__) && ((__ARMEL__ == 1) && ((__ARM_ARCH == 6) || (__ARM_ARCH == 7)))
           =3 
C51 COMPILER V9.56.0.0   UART_0                                                            10/28/2016 17:37:02 PAGE 11  

           =3 // these ignore any memory segment directives
           =3 #define SI_SEG_GENERIC
           =3 #define SI_SEG_DATA
           =3 #define SI_SEG_IDATA
           =3 #define SI_SEG_XDATA
           =3 #define SI_SEG_PDATA
           =3 #define SI_SEG_BDATA
           =3 #define SI_SEG_CODE
           =3 
           =3 // the following create a variable of the specified name but ignore the
           =3 // address and bit number.  If the using-code cares about the actual
           =3 // address or bit number, this probably will break it
           =3 #define SI_SBIT(name, address, bitnum) uint8_t name
           =3 #define SI_SFR(name, address) uint8_t name
           =3 #define SI_SFR16(name, address) uint16_t name
           =3 
           =3 // the following create function and variable names of the specified types
           =3 // but the 8051-specific aspects (like memory segment) are ignored
           =3 #define SI_INTERRUPT(name, vector) void name (void)
           =3 #define SI_INTERRUPT_USING(name, vector, regnum) void name (void)
           =3 #define SI_INTERRUPT_PROTO(name, vector) void name (void)
           =3 #define SI_INTERRUPT_PROTO_USING(name, vector, regnum) void name (void)
           =3 #define SI_FUNCTION_USING(name, return_value, parameter, regnum)              \
           =3              return_value name (parameter)
           =3 #define SI_FUNCTION_PROTO_USING(name, return_value, parameter, regnum)        \
           =3              return_value name (parameter)
           =3 #define SI_SEGMENT_VARIABLE(name, vartype, memseg) vartype name
           =3 #define SI_VARIABLE_SEGMENT_POINTER(name, vartype, targseg)                  \
           =3              vartype * name
           =3 #define SI_SEGMENT_VARIABLE_SEGMENT_POINTER(name, vartype, targseg, memseg)  \
           =3              vartype * name
           =3 #define SI_SEGMENT_POINTER(name, vartype, memseg) vartype * name
           =3 #define SI_LOCATED_VARIABLE_NO_INIT(name, vartype, memseg, address)          \
           =3              vartype name
           =3 
           =3 #define B0 0
           =3 #define B1 1
           =3 #define B2 2
           =3 #define B3 3
           =3 #define LSB 0
           =3 #define MSB 1
           =3 typedef union SI_UU16
           =3 {
           =3   uint16_t u16;
           =3   int16_t s16;
           =3   uint8_t u8[2];
           =3   int8_t s8[2];
           =3 } SI_UU16_t;
           =3 
           =3 typedef union SI_UU32
           =3 {
           =3   uint32_t u32;
           =3   int32_t s32;
           =3   SI_UU16_t uu16[2];
           =3   uint16_t u16[2];
           =3   int16_t s16[2];
           =3   uint8_t u8[4];
           =3   int8_t s8[4];
           =3 } SI_UU32_t;
           =3 
           =3 // Generic pointer stuff is left out because if you are accessing
           =3 // generic pointer fields then it will need to be rewritten for 32-bit
C51 COMPILER V9.56.0.0   UART_0                                                            10/28/2016 17:37:02 PAGE 12  

           =3 
           =3 // __NOP should be declared in cmsis header core_cmInstr.h
           =3 extern void __NOP(void);
           =3 /// Macro to insert a no-operation (NOP) instruction.
           =3 #define NOP() __NOP()
           =3 
           =3 #else // ARM_ARCH 6 | 7
           =3 #error unsupported ARM arch
           =3 #endif
           =3 
           =3 #else // unknown toolchain
           =3 #error Unrecognized toolchain in si_toolchain.h
           =3 #endif
 604      =3  
 605      =3  /** @} */
 606      =3  
 607      =3  #endif
  21      =2  
  22      =2  //-----------------------------------------------------------------------------
  23      =2  // Register Definitions
  24      =2  //-----------------------------------------------------------------------------
  25      =2  SI_SFR (ACC,      0xE0); ///< Accumulator                           
  26      =2  SI_SFR (ADC0CF,   0xBC); ///< ADC0 Configuration                    
  27      =2  SI_SFR (ADC0CN0,  0xE8); ///< ADC0 Control                          
  28      =2  SI_SFR (ADC0GTH,  0xC4); ///< ADC0 Greater-Than High Byte           
  29      =2  SI_SFR (ADC0GTL,  0xC3); ///< ADC0 Greater-Than Low Byte            
  30      =2  SI_SFR (ADC0H,    0xBE); ///< ADC0 Data Word High Byte              
  31      =2  SI_SFR (ADC0L,    0xBD); ///< ADC0 Data Word Low Byte               
  32      =2  SI_SFR (ADC0LTH,  0xC6); ///< ADC0 Less-Than High Byte              
  33      =2  SI_SFR (ADC0LTL,  0xC5); ///< ADC0 Less-Than Low Byte               
  34      =2  SI_SFR (AMX0N,    0xBA); ///< AMUX0 Negative Multiplexer Selection  
  35      =2  SI_SFR (AMX0P,    0xBB); ///< AMUX0 Positive Multiplexer Selection  
  36      =2  SI_SFR (B,        0xF0); ///< B Register                            
  37      =2  SI_SFR (CKCON0,   0x8E); ///< Clock Control 0                       
  38      =2  SI_SFR (CKCON1,   0xE4); ///< Clock Control 1                       
  39      =2  SI_SFR (CLKSEL,   0xA9); ///< Clock Select                          
  40      =2  SI_SFR (CMP0CN0,  0x9B); ///< Comparator 0 Control 0                
  41      =2  SI_SFR (CMP0MD,   0x9D); ///< Comparator 0 Mode                     
  42      =2  SI_SFR (CMP0MX,   0x9F); ///< Comparator 0 Multiplexer Selection    
  43      =2  SI_SFR (CMP1CN0,  0x9A); ///< Comparator 1 Control 0                
  44      =2  SI_SFR (CMP1MD,   0x9C); ///< Comparator 1 Mode                     
  45      =2  SI_SFR (CMP1MX,   0x9E); ///< Comparator 1 Multiplexer Selection    
  46      =2  SI_SFR (DPH,      0x83); ///< Data Pointer High                     
  47      =2  SI_SFR (DPL,      0x82); ///< Data Pointer Low                      
  48      =2  SI_SFR (EIE1,     0xE6); ///< Extended Interrupt Enable 1           
  49      =2  SI_SFR (EIE2,     0xE7); ///< Extended Interrupt Enable 2           
  50      =2  SI_SFR (EIP1,     0xF6); ///< Extended Interrupt Priority 1         
  51      =2  SI_SFR (EIP2,     0xF7); ///< Extended Interrupt Priority 2         
  52      =2  SI_SFR (EMI0CF,   0x85); ///< External Memory Configuration         
  53      =2  SI_SFR (EMI0CN,   0xAA); ///< External Memory Interface Control     
  54      =2  SI_SFR (EMI0TC,   0x84); ///< External Memory Timing Control        
  55      =2  SI_SFR (FLKEY,    0xB7); ///< Flash Lock and Key                    
  56      =2  SI_SFR (FLSCL,    0xB6); ///< Flash Scale                           
  57      =2  SI_SFR (HFO0CAL,  0xB3); ///< High Frequency Oscillator Calibration 
  58      =2  SI_SFR (HFO0CN,   0xB2); ///< High Frequency Oscillator Control     
  59      =2  SI_SFR (IE,       0xA8); ///< Interrupt Enable                      
  60      =2  SI_SFR (IP,       0xB8); ///< Interrupt Priority                    
  61      =2  SI_SFR (IT01CF,   0xE4); ///< INT0/INT1 Configuration               
  62      =2  SI_SFR (LFO0CN,   0x86); ///< Low Frequency Oscillator Control      
  63      =2  SI_SFR (P0,       0x80); ///< Port 0 Pin Latch                      
  64      =2  SI_SFR (P0MDIN,   0xF1); ///< Port 0 Input Mode                     
  65      =2  SI_SFR (P0MDOUT,  0xA4); ///< Port 0 Output Mode                    
C51 COMPILER V9.56.0.0   UART_0                                                            10/28/2016 17:37:02 PAGE 13  

  66      =2  SI_SFR (P0SKIP,   0xD4); ///< Port 0 Skip                           
  67      =2  SI_SFR (P1,       0x90); ///< Port 1 Pin Latch                      
  68      =2  SI_SFR (P1MDIN,   0xF2); ///< Port 1 Input Mode                     
  69      =2  SI_SFR (P1MDOUT,  0xA5); ///< Port 1 Output Mode                    
  70      =2  SI_SFR (P1SKIP,   0xD5); ///< Port 1 Skip                           
  71      =2  SI_SFR (P2,       0xA0); ///< Port 2 Pin Latch                      
  72      =2  SI_SFR (P2MDIN,   0xF3); ///< Port 2 Input Mode                     
  73      =2  SI_SFR (P2MDOUT,  0xA6); ///< Port 2 Output Mode                    
  74      =2  SI_SFR (P2SKIP,   0xD6); ///< Port 2 Skip                           
  75      =2  SI_SFR (P3,       0xB0); ///< Port 3 Pin Latch                      
  76      =2  SI_SFR (P3MDIN,   0xF4); ///< Port 3 Input Mode                     
  77      =2  SI_SFR (P3MDOUT,  0xA7); ///< Port 3 Output Mode                    
  78      =2  SI_SFR (P3SKIP,   0xDF); ///< Port 3 Skip                           
  79      =2  SI_SFR (P4,       0xC7); ///< Port 4 Pin Latch                      
  80      =2  SI_SFR (P4MDIN,   0xF5); ///< Port 4 Input Mode                     
  81      =2  SI_SFR (P4MDOUT,  0xAE); ///< Port 4 Output Mode                    
  82      =2  SI_SFR (PCA0CN0,  0xD8); ///< PCA Control 0                         
  83      =2  SI_SFR (PCA0CPH0, 0xFC); ///< PCA Channel 0 Capture Module High Byte
  84      =2  SI_SFR (PCA0CPH1, 0xEA); ///< PCA Channel 1 Capture Module High Byte
  85      =2  SI_SFR (PCA0CPH2, 0xEC); ///< PCA Channel 2 Capture Module High Byte
  86      =2  SI_SFR (PCA0CPH3, 0xEE); ///< PCA Channel 3 Capture Module High Byte
  87      =2  SI_SFR (PCA0CPH4, 0xFE); ///< PCA Channel 4 Capture Module High Byte
  88      =2  SI_SFR (PCA0CPL0, 0xFB); ///< PCA Channel 0 Capture Module Low Byte 
  89      =2  SI_SFR (PCA0CPL1, 0xE9); ///< PCA Channel 1 Capture Module Low Byte 
  90      =2  SI_SFR (PCA0CPL2, 0xEB); ///< PCA Channel 2 Capture Module Low Byte 
  91      =2  SI_SFR (PCA0CPL3, 0xED); ///< PCA Channel 3 Capture Module Low Byte 
  92      =2  SI_SFR (PCA0CPL4, 0xFD); ///< PCA Channel 4 Capture Module Low Byte 
  93      =2  SI_SFR (PCA0CPM0, 0xDA); ///< PCA Channel 0 Capture/Compare Mode    
  94      =2  SI_SFR (PCA0CPM1, 0xDB); ///< PCA Channel 1 Capture/Compare Mode    
  95      =2  SI_SFR (PCA0CPM2, 0xDC); ///< PCA Channel 2 Capture/Compare Mode    
  96      =2  SI_SFR (PCA0CPM3, 0xDD); ///< PCA Channel 3 Capture/Compare Mode    
  97      =2  SI_SFR (PCA0CPM4, 0xDE); ///< PCA Channel 4 Capture/Compare Mode    
  98      =2  SI_SFR (PCA0H,    0xFA); ///< PCA Counter/Timer High Byte           
  99      =2  SI_SFR (PCA0L,    0xF9); ///< PCA Counter/Timer Low Byte            
 100      =2  SI_SFR (PCA0MD,   0xD9); ///< PCA Mode                              
 101      =2  SI_SFR (PCON0,    0x87); ///< Power Control                         
 102      =2  SI_SFR (PFE0CN,   0xAF); ///< Prefetch Engine Control               
 103      =2  SI_SFR (PSCTL,    0x8F); ///< Program Store Control                 
 104      =2  SI_SFR (PSW,      0xD0); ///< Program Status Word                   
 105      =2  SI_SFR (REF0CN,   0xD1); ///< Voltage Reference Control             
 106      =2  SI_SFR (REG01CN,  0xC9); ///< Voltage Regulator Control             
 107      =2  SI_SFR (RSTSRC,   0xEF); ///< Reset Source                          
 108      =2  SI_SFR (SBCON1,   0xAC); ///< UART1 Baud Rate Generator Control     
 109      =2  SI_SFR (SBRLH1,   0xB5); ///< UART1 Baud Rate Generator High Byte   
 110      =2  SI_SFR (SBRLL1,   0xB4); ///< UART1 Baud Rate Generator Low Byte    
 111      =2  SI_SFR (SBUF0,    0x99); ///< UART0 Serial Port Data Buffer         
 112      =2  SI_SFR (SBUF1,    0xD3); ///< UART1 Serial Port Data Buffer         
 113      =2  SI_SFR (SCON0,    0x98); ///< UART0 Serial Port Control             
 114      =2  SI_SFR (SCON1,    0xD2); ///< UART1 Serial Port Control             
 115      =2  SI_SFR (SFRPAGE,  0xBF); ///< SFR Page                              
 116      =2  SI_SFR (SMB0ADM,  0xCE); ///< SMBus 0 Slave Address Mask            
 117      =2  SI_SFR (SMB0ADR,  0xCF); ///< SMBus 0 Slave Address                 
 118      =2  SI_SFR (SMB0CF,   0xC1); ///< SMBus 0 Configuration                 
 119      =2  SI_SFR (SMB0CN0,  0xC0); ///< SMBus 0 Control                       
 120      =2  SI_SFR (SMB0DAT,  0xC2); ///< SMBus 0 Data                          
 121      =2  SI_SFR (SMB1ADM,  0xCE); ///< SMBus 1 Slave Address Mask            
 122      =2  SI_SFR (SMB1ADR,  0xCF); ///< SMBus 1 Slave Address                 
 123      =2  SI_SFR (SMB1CF,   0xC1); ///< SMBus 1 Configuration                 
 124      =2  SI_SFR (SMB1CN0,  0xC0); ///< SMBus 1 Control                       
 125      =2  SI_SFR (SMB1DAT,  0xC2); ///< SMBus 1 Data                          
 126      =2  SI_SFR (SMBTC,    0xB9); ///< SMBus Timing and Pin Control          
 127      =2  SI_SFR (SMOD1,    0xE5); ///< UART1 Mode                            
C51 COMPILER V9.56.0.0   UART_0                                                            10/28/2016 17:37:02 PAGE 14  

 128      =2  SI_SFR (SP,       0x81); ///< Stack Pointer                         
 129      =2  SI_SFR (SPI0CFG,  0xA1); ///< SPI0 Configuration                    
 130      =2  SI_SFR (SPI0CKR,  0xA2); ///< SPI0 Clock Rate                       
 131      =2  SI_SFR (SPI0CN0,  0xF8); ///< SPI0 Control                          
 132      =2  SI_SFR (SPI0DAT,  0xA3); ///< SPI0 Data                             
 133      =2  SI_SFR (TCON,     0x88); ///< Timer 0/1 Control                     
 134      =2  SI_SFR (TH0,      0x8C); ///< Timer 0 High Byte                     
 135      =2  SI_SFR (TH1,      0x8D); ///< Timer 1 High Byte                     
 136      =2  SI_SFR (TL0,      0x8A); ///< Timer 0 Low Byte                      
 137      =2  SI_SFR (TL1,      0x8B); ///< Timer 1 Low Byte                      
 138      =2  SI_SFR (TMOD,     0x89); ///< Timer 0/1 Mode                        
 139      =2  SI_SFR (TMR2CN0,  0xC8); ///< Timer 2 Control 0                     
 140      =2  SI_SFR (TMR2H,    0xCD); ///< Timer 2 High Byte                     
 141      =2  SI_SFR (TMR2L,    0xCC); ///< Timer 2 Low Byte                      
 142      =2  SI_SFR (TMR2RLH,  0xCB); ///< Timer 2 Reload High Byte              
 143      =2  SI_SFR (TMR2RLL,  0xCA); ///< Timer 2 Reload Low Byte               
 144      =2  SI_SFR (TMR3CN0,  0x91); ///< Timer 3 Control 0                     
 145      =2  SI_SFR (TMR3H,    0x95); ///< Timer 3 High Byte                     
 146      =2  SI_SFR (TMR3L,    0x94); ///< Timer 3 Low Byte                      
 147      =2  SI_SFR (TMR3RLH,  0x93); ///< Timer 3 Reload High Byte              
 148      =2  SI_SFR (TMR3RLL,  0x92); ///< Timer 3 Reload Low Byte               
 149      =2  SI_SFR (TMR4CN0,  0x91); ///< Timer 4 Control 0                     
 150      =2  SI_SFR (TMR4H,    0x95); ///< Timer 4 High Byte                     
 151      =2  SI_SFR (TMR4L,    0x94); ///< Timer 4 Low Byte                      
 152      =2  SI_SFR (TMR4RLH,  0x93); ///< Timer 4 Reload High Byte              
 153      =2  SI_SFR (TMR4RLL,  0x92); ///< Timer 4 Reload Low Byte               
 154      =2  SI_SFR (TMR5CN0,  0xC8); ///< Timer 5 Control 0                     
 155      =2  SI_SFR (TMR5H,    0xCD); ///< Timer 5 High Byte                     
 156      =2  SI_SFR (TMR5L,    0xCC); ///< Timer 5 Low Byte                      
 157      =2  SI_SFR (TMR5RLH,  0xCB); ///< Timer 5 Reload High Byte              
 158      =2  SI_SFR (TMR5RLL,  0xCA); ///< Timer 5 Reload Low Byte               
 159      =2  SI_SFR (USB0ADR,  0x96); ///< USB0 Indirect Address                 
 160      =2  SI_SFR (USB0DAT,  0x97); ///< USB0 Data                             
 161      =2  SI_SFR (USB0XCN,  0xD7); ///< USB0 Transceiver Control              
 162      =2  SI_SFR (VDM0CN,   0xFF); ///< Supply Monitor Control                
 163      =2  SI_SFR (XBR0,     0xE1); ///< Port I/O Crossbar 0                   
 164      =2  SI_SFR (XBR1,     0xE2); ///< Port I/O Crossbar 1                   
 165      =2  SI_SFR (XBR2,     0xE3); ///< Port I/O Crossbar 2                   
 166      =2  SI_SFR (XOSC0CN,  0xB1); ///< External Oscillator Control           
 167      =2  
 168      =2  //------------------------------------------------------------------------------
 169      =2  // 16-bit Register Definitions (may not work on all compilers)
 170      =2  //------------------------------------------------------------------------------
 171      =2  SI_SFR16 (ADC0GT,  0xC3); ///< ADC0 Greater-Than            
 172      =2  SI_SFR16 (ADC0,    0xBD); ///< ADC0 Data Word               
 173      =2  SI_SFR16 (ADC0LT,  0xC5); ///< ADC0 Less-Than               
 174      =2  SI_SFR16 (DP,      0x82); ///< Data Pointer                 
 175      =2  SI_SFR16 (PCA0CP0, 0xFB); ///< PCA Channel 0 Capture Module 
 176      =2  SI_SFR16 (PCA0CP1, 0xE9); ///< PCA Channel 1 Capture Module 
 177      =2  SI_SFR16 (PCA0CP2, 0xEB); ///< PCA Channel 2 Capture Module 
 178      =2  SI_SFR16 (PCA0CP3, 0xED); ///< PCA Channel 3 Capture Module 
 179      =2  SI_SFR16 (PCA0CP4, 0xFD); ///< PCA Channel 4 Capture Module 
 180      =2  SI_SFR16 (PCA0,    0xF9); ///< PCA Counter/Timer            
 181      =2  SI_SFR16 (SBRL1,   0xB4); ///< UART1 Baud Rate Generator    
 182      =2  SI_SFR16 (TMR2,    0xCC); ///< Timer 2                      
 183      =2  SI_SFR16 (TMR2RL,  0xCA); ///< Timer 2 Reload               
 184      =2  SI_SFR16 (TMR3,    0x94); ///< Timer 3                      
 185      =2  SI_SFR16 (TMR3RL,  0x92); ///< Timer 3 Reload               
 186      =2  SI_SFR16 (TMR4,    0x94); ///< Timer 4                      
 187      =2  SI_SFR16 (TMR4RL,  0x92); ///< Timer 4 Reload               
 188      =2  SI_SFR16 (TMR5,    0xCC); ///< Timer 5                      
 189      =2  SI_SFR16 (TMR5RL,  0xCA); ///< Timer 5 Reload               
C51 COMPILER V9.56.0.0   UART_0                                                            10/28/2016 17:37:02 PAGE 15  

 190      =2  
 191      =2  //------------------------------------------------------------------------------
 192      =2  // Indirect Register Definitions
 193      =2  //------------------------------------------------------------------------------
 194      =2  #define CLKREC   0x0F ///< USB0 Clock Recovery Control       
 195      =2  #define CMIE     0x0B ///< USB0 Common Interrupt Enable      
 196      =2  #define CMINT    0x06 ///< USB0 Common Interrupt             
 197      =2  #define E0CNT    0x16 ///< USB0 Endpoint0 Data Count         
 198      =2  #define E0CSR    0x11 ///< USB0 Endpoint0 Control            
 199      =2  #define EENABLE  0x1E ///< USB0 Endpoint Enable              
 200      =2  #define EINCSRH  0x12 ///< USB0 IN Endpoint Control High     
 201      =2  #define EINCSRL  0x11 ///< USB0 IN Endpoint Control          
 202      =2  #define EOUTCNTH 0x17 ///< USB0 OUT Endpoint Count High      
 203      =2  #define EOUTCNTL 0x16 ///< USB0 OUT Endpoint Count           
 204      =2  #define EOUTCSRH 0x15 ///< USB0 OUT Endpoint Control High    
 205      =2  #define EOUTCSRL 0x14 ///< USB0 OUT Endpoint Control         
 206      =2  #define FADDR    0x00 ///< USB0 Function Address             
 207      =2  #define FIFO0    0x20 ///< USB0 Endpoint 0 FIFO Access       
 208      =2  #define FIFO1    0x21 ///< USB0 Endpoint 1 FIFO Access       
 209      =2  #define FIFO2    0x22 ///< USB0 Endpoint 2 FIFO Access       
 210      =2  #define FIFO3    0x23 ///< USB0 Endpoint 3 FIFO Access       
 211      =2  #define FRAMEH   0x0D ///< USB0 Frame Number High            
 212      =2  #define FRAMEL   0x0C ///< USB0 Frame Number                 
 213      =2  #define IN1IE    0x07 ///< USB0 IN Endpoint Interrupt Enable 
 214      =2  #define IN1INT   0x02 ///< USB0 IN Endpoint Interrupt        
 215      =2  #define INDEX    0x0E ///< USB0 Endpoint Index               
 216      =2  #define OUT1IE   0x09 ///< USB0 OUT Endpoint Interrupt Enable
 217      =2  #define OUT1INT  0x04 ///< USB0 OUT Endpoint Interrupt       
 218      =2  #define POWER    0x01 ///< USB0 Power                        
 219      =2  
 220      =2  //------------------------------------------------------------------------------
 221      =2  // Bit Definitions
 222      =2  //------------------------------------------------------------------------------
 223      =2  
 224      =2  // ACC (Accumulator)
 225      =2  #define SFR_ACC 0xE0
 226      =2  SI_SBIT (ACC_ACC0, SFR_ACC, 0); ///< Accumulator Bit 0
 227      =2  SI_SBIT (ACC_ACC1, SFR_ACC, 1); ///< Accumulator Bit 1
 228      =2  SI_SBIT (ACC_ACC2, SFR_ACC, 2); ///< Accumulator Bit 2
 229      =2  SI_SBIT (ACC_ACC3, SFR_ACC, 3); ///< Accumulator Bit 3
 230      =2  SI_SBIT (ACC_ACC4, SFR_ACC, 4); ///< Accumulator Bit 4
 231      =2  SI_SBIT (ACC_ACC5, SFR_ACC, 5); ///< Accumulator Bit 5
 232      =2  SI_SBIT (ACC_ACC6, SFR_ACC, 6); ///< Accumulator Bit 6
 233      =2  SI_SBIT (ACC_ACC7, SFR_ACC, 7); ///< Accumulator Bit 7
 234      =2  
 235      =2  // ADC0CN0 (ADC0 Control)
 236      =2  #define SFR_ADC0CN0 0xE8
 237      =2  SI_SBIT (ADC0CN0_ADCM0,  SFR_ADC0CN0, 0); ///< Start of Conversion Mode Select Bit 0
 238      =2  SI_SBIT (ADC0CN0_ADCM1,  SFR_ADC0CN0, 1); ///< Start of Conversion Mode Select Bit 1
 239      =2  SI_SBIT (ADC0CN0_ADCM2,  SFR_ADC0CN0, 2); ///< Start of Conversion Mode Select Bit 2
 240      =2  SI_SBIT (ADC0CN0_ADWINT, SFR_ADC0CN0, 3); ///< Window Compare Interrupt Flag        
 241      =2  SI_SBIT (ADC0CN0_ADBUSY, SFR_ADC0CN0, 4); ///< ADC Busy                             
 242      =2  SI_SBIT (ADC0CN0_ADINT,  SFR_ADC0CN0, 5); ///< Conversion Complete Interrupt Flag   
 243      =2  SI_SBIT (ADC0CN0_ADTM,   SFR_ADC0CN0, 6); ///< Track Mode                           
 244      =2  SI_SBIT (ADC0CN0_ADEN,   SFR_ADC0CN0, 7); ///< ADC Enable                           
 245      =2  
 246      =2  // B (B Register)
 247      =2  #define SFR_B 0xF0
 248      =2  SI_SBIT (B_B0, SFR_B, 0); ///< B Register Bit 0
 249      =2  SI_SBIT (B_B1, SFR_B, 1); ///< B Register Bit 1
 250      =2  SI_SBIT (B_B2, SFR_B, 2); ///< B Register Bit 2
 251      =2  SI_SBIT (B_B3, SFR_B, 3); ///< B Register Bit 3
C51 COMPILER V9.56.0.0   UART_0                                                            10/28/2016 17:37:02 PAGE 16  

 252      =2  SI_SBIT (B_B4, SFR_B, 4); ///< B Register Bit 4
 253      =2  SI_SBIT (B_B5, SFR_B, 5); ///< B Register Bit 5
 254      =2  SI_SBIT (B_B6, SFR_B, 6); ///< B Register Bit 6
 255      =2  SI_SBIT (B_B7, SFR_B, 7); ///< B Register Bit 7
 256      =2  
 257      =2  // IE (Interrupt Enable)
 258      =2  #define SFR_IE 0xA8
 259      =2  SI_SBIT (IE_EX0,   SFR_IE, 0); ///< External Interrupt 0 Enable
 260      =2  SI_SBIT (IE_ET0,   SFR_IE, 1); ///< Timer 0 Interrupt Enable   
 261      =2  SI_SBIT (IE_EX1,   SFR_IE, 2); ///< External Interrupt 1 Enable
 262      =2  SI_SBIT (IE_ET1,   SFR_IE, 3); ///< Timer 1 Interrupt Enable   
 263      =2  SI_SBIT (IE_ES0,   SFR_IE, 4); ///< UART0 Interrupt Enable     
 264      =2  SI_SBIT (IE_ET2,   SFR_IE, 5); ///< Timer 2 Interrupt Enable   
 265      =2  SI_SBIT (IE_ESPI0, SFR_IE, 6); ///< SPI0 Interrupt Enable      
 266      =2  SI_SBIT (IE_EA,    SFR_IE, 7); ///< All Interrupts Enable      
 267      =2  
 268      =2  // IP (Interrupt Priority)
 269      =2  #define SFR_IP 0xB8
 270      =2  SI_SBIT (IP_PX0,   SFR_IP, 0); ///< External Interrupt 0 Priority Control                        
 271      =2  SI_SBIT (IP_PT0,   SFR_IP, 1); ///< Timer 0 Interrupt Priority Control                           
 272      =2  SI_SBIT (IP_PX1,   SFR_IP, 2); ///< External Interrupt 1 Priority Control                        
 273      =2  SI_SBIT (IP_PT1,   SFR_IP, 3); ///< Timer 1 Interrupt Priority Control                           
 274      =2  SI_SBIT (IP_PS0,   SFR_IP, 4); ///< UART0 Interrupt Priority Control                             
 275      =2  SI_SBIT (IP_PT2,   SFR_IP, 5); ///< Timer 2 Interrupt Priority Control                           
 276      =2  SI_SBIT (IP_PSPI0, SFR_IP, 6); ///< Serial Peripheral Interface (SPI0) Interrupt Priority Control
 277      =2  
 278      =2  // P0 (Port 0 Pin Latch)
 279      =2  #define SFR_P0 0x80
 280      =2  SI_SBIT (P0_B0, SFR_P0, 0); ///< Port 0 Bit 0 Latch
 281      =2  SI_SBIT (P0_B1, SFR_P0, 1); ///< Port 0 Bit 1 Latch
 282      =2  SI_SBIT (P0_B2, SFR_P0, 2); ///< Port 0 Bit 2 Latch
 283      =2  SI_SBIT (P0_B3, SFR_P0, 3); ///< Port 0 Bit 3 Latch
 284      =2  SI_SBIT (P0_B4, SFR_P0, 4); ///< Port 0 Bit 4 Latch
 285      =2  SI_SBIT (P0_B5, SFR_P0, 5); ///< Port 0 Bit 5 Latch
 286      =2  SI_SBIT (P0_B6, SFR_P0, 6); ///< Port 0 Bit 6 Latch
 287      =2  SI_SBIT (P0_B7, SFR_P0, 7); ///< Port 0 Bit 7 Latch
 288      =2  
 289      =2  // P1 (Port 1 Pin Latch)
 290      =2  #define SFR_P1 0x90
 291      =2  SI_SBIT (P1_B0, SFR_P1, 0); ///< Port 1 Bit 0 Latch
 292      =2  SI_SBIT (P1_B1, SFR_P1, 1); ///< Port 1 Bit 1 Latch
 293      =2  SI_SBIT (P1_B2, SFR_P1, 2); ///< Port 1 Bit 2 Latch
 294      =2  SI_SBIT (P1_B3, SFR_P1, 3); ///< Port 1 Bit 3 Latch
 295      =2  SI_SBIT (P1_B4, SFR_P1, 4); ///< Port 1 Bit 4 Latch
 296      =2  SI_SBIT (P1_B5, SFR_P1, 5); ///< Port 1 Bit 5 Latch
 297      =2  SI_SBIT (P1_B6, SFR_P1, 6); ///< Port 1 Bit 6 Latch
 298      =2  SI_SBIT (P1_B7, SFR_P1, 7); ///< Port 1 Bit 7 Latch
 299      =2  
 300      =2  // P2 (Port 2 Pin Latch)
 301      =2  #define SFR_P2 0xA0
 302      =2  SI_SBIT (P2_B0, SFR_P2, 0); ///< Port 2 Bit 0 Latch
 303      =2  SI_SBIT (P2_B1, SFR_P2, 1); ///< Port 2 Bit 1 Latch
 304      =2  SI_SBIT (P2_B2, SFR_P2, 2); ///< Port 2 Bit 2 Latch
 305      =2  SI_SBIT (P2_B3, SFR_P2, 3); ///< Port 2 Bit 3 Latch
 306      =2  SI_SBIT (P2_B4, SFR_P2, 4); ///< Port 2 Bit 4 Latch
 307      =2  SI_SBIT (P2_B5, SFR_P2, 5); ///< Port 2 Bit 5 Latch
 308      =2  SI_SBIT (P2_B6, SFR_P2, 6); ///< Port 2 Bit 6 Latch
 309      =2  SI_SBIT (P2_B7, SFR_P2, 7); ///< Port 2 Bit 7 Latch
 310      =2  
 311      =2  // P3 (Port 3 Pin Latch)
 312      =2  #define SFR_P3 0xB0
 313      =2  SI_SBIT (P3_B0, SFR_P3, 0); ///< Port 3 Bit 0 Latch
C51 COMPILER V9.56.0.0   UART_0                                                            10/28/2016 17:37:02 PAGE 17  

 314      =2  SI_SBIT (P3_B1, SFR_P3, 1); ///< Port 3 Bit 1 Latch
 315      =2  SI_SBIT (P3_B2, SFR_P3, 2); ///< Port 3 Bit 2 Latch
 316      =2  SI_SBIT (P3_B3, SFR_P3, 3); ///< Port 3 Bit 3 Latch
 317      =2  SI_SBIT (P3_B4, SFR_P3, 4); ///< Port 3 Bit 4 Latch
 318      =2  SI_SBIT (P3_B5, SFR_P3, 5); ///< Port 3 Bit 5 Latch
 319      =2  SI_SBIT (P3_B6, SFR_P3, 6); ///< Port 3 Bit 6 Latch
 320      =2  SI_SBIT (P3_B7, SFR_P3, 7); ///< Port 3 Bit 7 Latch
 321      =2  
 322      =2  // PCA0CN0 (PCA Control 0)
 323      =2  #define SFR_PCA0CN0 0xD8
 324      =2  SI_SBIT (PCA0CN0_CCF0, SFR_PCA0CN0, 0); ///< PCA Module 0 Capture/Compare Flag
 325      =2  SI_SBIT (PCA0CN0_CCF1, SFR_PCA0CN0, 1); ///< PCA Module 1 Capture/Compare Flag
 326      =2  SI_SBIT (PCA0CN0_CCF2, SFR_PCA0CN0, 2); ///< PCA Module 2 Capture/Compare Flag
 327      =2  SI_SBIT (PCA0CN0_CCF3, SFR_PCA0CN0, 3); ///< PCA Module 3 Capture/Compare Flag
 328      =2  SI_SBIT (PCA0CN0_CCF4, SFR_PCA0CN0, 4); ///< PCA Module 4 Capture/Compare Flag
 329      =2  SI_SBIT (PCA0CN0_CR,   SFR_PCA0CN0, 6); ///< PCA Counter/Timer Run Control    
 330      =2  SI_SBIT (PCA0CN0_CF,   SFR_PCA0CN0, 7); ///< PCA Counter/Timer Overflow Flag  
 331      =2  
 332      =2  // PSW (Program Status Word)
 333      =2  #define SFR_PSW 0xD0
 334      =2  SI_SBIT (PSW_PARITY, SFR_PSW, 0); ///< Parity Flag               
 335      =2  SI_SBIT (PSW_F1,     SFR_PSW, 1); ///< User Flag 1               
 336      =2  SI_SBIT (PSW_OV,     SFR_PSW, 2); ///< Overflow Flag             
 337      =2  SI_SBIT (PSW_RS0,    SFR_PSW, 3); ///< Register Bank Select Bit 0
 338      =2  SI_SBIT (PSW_RS1,    SFR_PSW, 4); ///< Register Bank Select Bit 1
 339      =2  SI_SBIT (PSW_F0,     SFR_PSW, 5); ///< User Flag 0               
 340      =2  SI_SBIT (PSW_AC,     SFR_PSW, 6); ///< Auxiliary Carry Flag      
 341      =2  SI_SBIT (PSW_CY,     SFR_PSW, 7); ///< Carry Flag                
 342      =2  
 343      =2  // SCON0 (UART0 Serial Port Control)
 344      =2  #define SFR_SCON0 0x98
 345      =2  SI_SBIT (SCON0_RI,    SFR_SCON0, 0); ///< Receive Interrupt Flag             
 346      =2  SI_SBIT (SCON0_TI,    SFR_SCON0, 1); ///< Transmit Interrupt Flag            
 347      =2  SI_SBIT (SCON0_RB8,   SFR_SCON0, 2); ///< Ninth Receive Bit                  
 348      =2  SI_SBIT (SCON0_TB8,   SFR_SCON0, 3); ///< Ninth Transmission Bit             
 349      =2  SI_SBIT (SCON0_REN,   SFR_SCON0, 4); ///< Receive Enable                     
 350      =2  SI_SBIT (SCON0_MCE,   SFR_SCON0, 5); ///< Multiprocessor Communication Enable
 351      =2  SI_SBIT (SCON0_SMODE, SFR_SCON0, 7); ///< Serial Port 0 Operation Mode       
 352      =2  
 353      =2  // SMB0CN0 (SMBus 0 Control)
 354      =2  #define SFR_SMB0CN0 0xC0
 355      =2  SI_SBIT (SMB0CN0_SI,      SFR_SMB0CN0, 0); ///< SMBus Interrupt Flag            
 356      =2  SI_SBIT (SMB0CN0_ACK,     SFR_SMB0CN0, 1); ///< SMBus Acknowledge               
 357      =2  SI_SBIT (SMB0CN0_ARBLOST, SFR_SMB0CN0, 2); ///< SMBus Arbitration Lost Indicator
 358      =2  SI_SBIT (SMB0CN0_ACKRQ,   SFR_SMB0CN0, 3); ///< SMBus Acknowledge Request       
 359      =2  SI_SBIT (SMB0CN0_STO,     SFR_SMB0CN0, 4); ///< SMBus Stop Flag                 
 360      =2  SI_SBIT (SMB0CN0_STA,     SFR_SMB0CN0, 5); ///< SMBus Start Flag                
 361      =2  SI_SBIT (SMB0CN0_TXMODE,  SFR_SMB0CN0, 6); ///< SMBus Transmit Mode Indicator   
 362      =2  SI_SBIT (SMB0CN0_MASTER,  SFR_SMB0CN0, 7); ///< SMBus Master/Slave Indicator    
 363      =2  
 364      =2  // SMB1CN0 (SMBus 1 Control)
 365      =2  #define SFR_SMB1CN0 0xC0
 366      =2  SI_SBIT (SMB1CN0_SI,      SFR_SMB1CN0, 0); ///< SMBus Interrupt Flag            
 367      =2  SI_SBIT (SMB1CN0_ACK,     SFR_SMB1CN0, 1); ///< SMBus Acknowledge               
 368      =2  SI_SBIT (SMB1CN0_ARBLOST, SFR_SMB1CN0, 2); ///< SMBus Arbitration Lost Indicator
 369      =2  SI_SBIT (SMB1CN0_ACKRQ,   SFR_SMB1CN0, 3); ///< SMBus Acknowledge Request       
 370      =2  SI_SBIT (SMB1CN0_STO,     SFR_SMB1CN0, 4); ///< SMBus Stop Flag                 
 371      =2  SI_SBIT (SMB1CN0_STA,     SFR_SMB1CN0, 5); ///< SMBus Start Flag                
 372      =2  SI_SBIT (SMB1CN0_TXMODE,  SFR_SMB1CN0, 6); ///< SMBus Transmit Mode Indicator   
 373      =2  SI_SBIT (SMB1CN0_MASTER,  SFR_SMB1CN0, 7); ///< SMBus Master/Slave Indicator    
 374      =2  
 375      =2  // SPI0CN0 (SPI0 Control)
C51 COMPILER V9.56.0.0   UART_0                                                            10/28/2016 17:37:02 PAGE 18  

 376      =2  #define SFR_SPI0CN0 0xF8
 377      =2  SI_SBIT (SPI0CN0_SPIEN,  SFR_SPI0CN0, 0); ///< SPI0 Enable            
 378      =2  SI_SBIT (SPI0CN0_TXBMT,  SFR_SPI0CN0, 1); ///< Transmit Buffer Empty  
 379      =2  SI_SBIT (SPI0CN0_NSSMD0, SFR_SPI0CN0, 2); ///< Slave Select Mode Bit 0
 380      =2  SI_SBIT (SPI0CN0_NSSMD1, SFR_SPI0CN0, 3); ///< Slave Select Mode Bit 1
 381      =2  SI_SBIT (SPI0CN0_RXOVRN, SFR_SPI0CN0, 4); ///< Receive Overrun Flag   
 382      =2  SI_SBIT (SPI0CN0_MODF,   SFR_SPI0CN0, 5); ///< Mode Fault Flag        
 383      =2  SI_SBIT (SPI0CN0_WCOL,   SFR_SPI0CN0, 6); ///< Write Collision Flag   
 384      =2  SI_SBIT (SPI0CN0_SPIF,   SFR_SPI0CN0, 7); ///< SPI0 Interrupt Flag    
 385      =2  
 386      =2  // TCON (Timer 0/1 Control)
 387      =2  #define SFR_TCON 0x88
 388      =2  SI_SBIT (TCON_IT0, SFR_TCON, 0); ///< Interrupt 0 Type Select
 389      =2  SI_SBIT (TCON_IE0, SFR_TCON, 1); ///< External Interrupt 0   
 390      =2  SI_SBIT (TCON_IT1, SFR_TCON, 2); ///< Interrupt 1 Type Select
 391      =2  SI_SBIT (TCON_IE1, SFR_TCON, 3); ///< External Interrupt 1   
 392      =2  SI_SBIT (TCON_TR0, SFR_TCON, 4); ///< Timer 0 Run Control    
 393      =2  SI_SBIT (TCON_TF0, SFR_TCON, 5); ///< Timer 0 Overflow Flag  
 394      =2  SI_SBIT (TCON_TR1, SFR_TCON, 6); ///< Timer 1 Run Control    
 395      =2  SI_SBIT (TCON_TF1, SFR_TCON, 7); ///< Timer 1 Overflow Flag  
 396      =2  
 397      =2  // TMR2CN0 (Timer 2 Control 0)
 398      =2  #define SFR_TMR2CN0 0xC8
 399      =2  SI_SBIT (TMR2CN0_T2XCLK,  SFR_TMR2CN0, 0); ///< Timer 2 External Clock Select    
 400      =2  SI_SBIT (TMR2CN0_T2CSS,   SFR_TMR2CN0, 1); ///< Timer 2 Capture Source Select    
 401      =2  SI_SBIT (TMR2CN0_TR2,     SFR_TMR2CN0, 2); ///< Timer 2 Run Control              
 402      =2  SI_SBIT (TMR2CN0_T2SPLIT, SFR_TMR2CN0, 3); ///< Timer 2 Split Mode Enable        
 403      =2  SI_SBIT (TMR2CN0_TF2CEN,  SFR_TMR2CN0, 4); ///< Timer 2 Capture Enable           
 404      =2  SI_SBIT (TMR2CN0_TF2LEN,  SFR_TMR2CN0, 5); ///< Timer 2 Low Byte Interrupt Enable
 405      =2  SI_SBIT (TMR2CN0_TF2L,    SFR_TMR2CN0, 6); ///< Timer 2 Low Byte Overflow Flag   
 406      =2  SI_SBIT (TMR2CN0_TF2H,    SFR_TMR2CN0, 7); ///< Timer 2 High Byte Overflow Flag  
 407      =2  
 408      =2  // TMR5CN0 (Timer 5 Control 0)
 409      =2  #define SFR_TMR5CN0 0xC8
 410      =2  SI_SBIT (TMR5CN0_T5XCLK,  SFR_TMR5CN0, 0); ///< Timer 5 External Clock Select    
 411      =2  SI_SBIT (TMR5CN0_TR5,     SFR_TMR5CN0, 2); ///< Timer 5 Run Control              
 412      =2  SI_SBIT (TMR5CN0_T5SPLIT, SFR_TMR5CN0, 3); ///< Timer 5 Split Mode Enable        
 413      =2  SI_SBIT (TMR5CN0_TF5LEN,  SFR_TMR5CN0, 5); ///< Timer 5 Low Byte Interrupt Enable
 414      =2  SI_SBIT (TMR5CN0_TF5L,    SFR_TMR5CN0, 6); ///< Timer 5 Low Byte Overflow Flag   
 415      =2  SI_SBIT (TMR5CN0_TF5H,    SFR_TMR5CN0, 7); ///< Timer 5 High Byte Overflow Flag  
 416      =2  
 417      =2  //------------------------------------------------------------------------------
 418      =2  // Interrupt Definitions
 419      =2  //------------------------------------------------------------------------------
 420      =2  #define INT0_IRQn    0  ///< External Interrupt 0  
 421      =2  #define TIMER0_IRQn  1  ///< Timer 0 Overflow      
 422      =2  #define INT1_IRQn    2  ///< External Interrupt 1  
 423      =2  #define TIMER1_IRQn  3  ///< Timer 1 Overflow      
 424      =2  #define UART0_IRQn   4  ///< UART 0                
 425      =2  #define TIMER2_IRQn  5  ///< Timer 2 Overflow      
 426      =2  #define SPI0_IRQn    6  ///< SPI0                  
 427      =2  #define SMBUS0_IRQn  7  ///< SMBus 0               
 428      =2  #define USB0_IRQn    8  ///< USB0                  
 429      =2  #define ADC0WC_IRQn  9  ///< ADC0 Window Compare   
 430      =2  #define ADC0EOC_IRQn 10 ///< ADC0 End of Conversion
 431      =2  #define PCA0_IRQn    11 ///< PCA0                  
 432      =2  #define CMP0_IRQn    12 ///< Comparator 0          
 433      =2  #define CMP1_IRQn    13 ///< Comparator 1          
 434      =2  #define TIMER3_IRQn  14 ///< Timer 3 Overflow      
 435      =2  #define VBUSLVL_IRQn 15 ///< VBUS Level            
 436      =2  #define UART1_IRQn   16 ///< UART 1                
 437      =2  #define SMBUS1_IRQn  18 ///< SMBus 1               
C51 COMPILER V9.56.0.0   UART_0                                                            10/28/2016 17:37:02 PAGE 19  

 438      =2  #define TIMER4_IRQn  19 ///< Timer 4 Overflow      
 439      =2  #define TIMER5_IRQn  20 ///< Timer 5 Overflow      
 440      =2  
 441      =2  //------------------------------------------------------------------------------
 442      =2  // SFR Page Definitions
 443      =2  //------------------------------------------------------------------------------
 444      =2  #define LEGACY_PAGE 0x00 ///< Legacy SFR Page                   
 445      =2  #define CONFIG_PAGE 0x0F ///< System and Port Configuration Page
 446      =2  #define SMB1_PAGE   0x0F ///< SMBus 1 Page                      
 447      =2  
 448      =2  //-----------------------------------------------------------------------------
 449      =2  // SDCC PDATA External Memory Paging Support
 450      =2  //-----------------------------------------------------------------------------
 451      =2  
 452      =2  #if defined SDCC
           =2 
           =2 SI_SFR(_XPAGE, 0xAA); // Point to the EMI0CN register
           =2 
           =2 #endif
 457      =2  
 458      =2  #endif // SI_EFM8UB2_DEFS_H
 459      =2  //-eof--------------------------------------------------------------------------
 460      =2  
  11      =1  #include "SI_EFM8UB2_Register_Enums.h"
   1      =2  //------------------------------------------------------------------------------
   2      =2  // Copyright 2014 Silicon Laboratories, Inc.
   3      =2  // All rights reserved. This program and the accompanying materials
   4      =2  // are made available under the terms of the Silicon Laboratories End User
   5      =2  // License Agreement which accompanies this distribution, and is available at
   6      =2  // http://developer.silabs.com/legal/version/v11/Silicon_Labs_Software_License_Agreement.txt
   7      =2  // Original content and implementation provided by Silicon Laboratories.
   8      =2  //------------------------------------------------------------------------------
   9      =2  //Supported Devices:
  10      =2  //  EFM8UB20F32G_QFN32
  11      =2  //  EFM8UB20F32G_QFP32
  12      =2  //  EFM8UB20F32G_QFP48
  13      =2  //  EFM8UB20F64G_QFN32
  14      =2  //  EFM8UB20F64G_QFP32
  15      =2  //  EFM8UB20F64G_QFP48
  16      =2  
  17      =2  #ifndef SI_EFM8UB2_REGISTER_ENUMS_H
  18      =2  #define SI_EFM8UB2_REGISTER_ENUMS_H
  19      =2  
  20      =2  //Standard device includes
  21      =2  #include "SI_EFM8UB2_Defs.h"
   1      =3  //------------------------------------------------------------------------------
   2      =3  // Copyright 2014 Silicon Laboratories, Inc.
   3      =3  // All rights reserved. This program and the accompanying materials
   4      =3  // are made available under the terms of the Silicon Laboratories End User
   5      =3  // License Agreement which accompanies this distribution, and is available at
   6      =3  // http://developer.silabs.com/legal/version/v11/Silicon_Labs_Software_License_Agreement.txt
   7      =3  // Original content and implementation provided by Silicon Laboratories.
   8      =3  //------------------------------------------------------------------------------
   9      =3  //Supported Devices:
  10      =3  //  EFM8UB20F32G_QFN32
  11      =3  //  EFM8UB20F32G_QFP32
  12      =3  //  EFM8UB20F32G_QFP48
  13      =3  //  EFM8UB20F64G_QFN32
  14      =3  //  EFM8UB20F64G_QFP32
  15      =3  //  EFM8UB20F64G_QFP48
  16      =3  
  17      =3  #ifndef SI_EFM8UB2_DEFS_H
C51 COMPILER V9.56.0.0   UART_0                                                            10/28/2016 17:37:02 PAGE 20  

           =3 #define SI_EFM8UB2_DEFS_H
           =3 
           =3 #include <si_toolchain.h>
           =3 
           =3 //-----------------------------------------------------------------------------
           =3 // Register Definitions
           =3 //-----------------------------------------------------------------------------
           =3 SI_SFR (ACC,      0xE0); ///< Accumulator                           
           =3 SI_SFR (ADC0CF,   0xBC); ///< ADC0 Configuration                    
           =3 SI_SFR (ADC0CN0,  0xE8); ///< ADC0 Control                          
           =3 SI_SFR (ADC0GTH,  0xC4); ///< ADC0 Greater-Than High Byte           
           =3 SI_SFR (ADC0GTL,  0xC3); ///< ADC0 Greater-Than Low Byte            
           =3 SI_SFR (ADC0H,    0xBE); ///< ADC0 Data Word High Byte              
           =3 SI_SFR (ADC0L,    0xBD); ///< ADC0 Data Word Low Byte               
           =3 SI_SFR (ADC0LTH,  0xC6); ///< ADC0 Less-Than High Byte              
           =3 SI_SFR (ADC0LTL,  0xC5); ///< ADC0 Less-Than Low Byte               
           =3 SI_SFR (AMX0N,    0xBA); ///< AMUX0 Negative Multiplexer Selection  
           =3 SI_SFR (AMX0P,    0xBB); ///< AMUX0 Positive Multiplexer Selection  
           =3 SI_SFR (B,        0xF0); ///< B Register                            
           =3 SI_SFR (CKCON0,   0x8E); ///< Clock Control 0                       
           =3 SI_SFR (CKCON1,   0xE4); ///< Clock Control 1                       
           =3 SI_SFR (CLKSEL,   0xA9); ///< Clock Select                          
           =3 SI_SFR (CMP0CN0,  0x9B); ///< Comparator 0 Control 0                
           =3 SI_SFR (CMP0MD,   0x9D); ///< Comparator 0 Mode                     
           =3 SI_SFR (CMP0MX,   0x9F); ///< Comparator 0 Multiplexer Selection    
           =3 SI_SFR (CMP1CN0,  0x9A); ///< Comparator 1 Control 0                
           =3 SI_SFR (CMP1MD,   0x9C); ///< Comparator 1 Mode                     
           =3 SI_SFR (CMP1MX,   0x9E); ///< Comparator 1 Multiplexer Selection    
           =3 SI_SFR (DPH,      0x83); ///< Data Pointer High                     
           =3 SI_SFR (DPL,      0x82); ///< Data Pointer Low                      
           =3 SI_SFR (EIE1,     0xE6); ///< Extended Interrupt Enable 1           
           =3 SI_SFR (EIE2,     0xE7); ///< Extended Interrupt Enable 2           
           =3 SI_SFR (EIP1,     0xF6); ///< Extended Interrupt Priority 1         
           =3 SI_SFR (EIP2,     0xF7); ///< Extended Interrupt Priority 2         
           =3 SI_SFR (EMI0CF,   0x85); ///< External Memory Configuration         
           =3 SI_SFR (EMI0CN,   0xAA); ///< External Memory Interface Control     
           =3 SI_SFR (EMI0TC,   0x84); ///< External Memory Timing Control        
           =3 SI_SFR (FLKEY,    0xB7); ///< Flash Lock and Key                    
           =3 SI_SFR (FLSCL,    0xB6); ///< Flash Scale                           
           =3 SI_SFR (HFO0CAL,  0xB3); ///< High Frequency Oscillator Calibration 
           =3 SI_SFR (HFO0CN,   0xB2); ///< High Frequency Oscillator Control     
           =3 SI_SFR (IE,       0xA8); ///< Interrupt Enable                      
           =3 SI_SFR (IP,       0xB8); ///< Interrupt Priority                    
           =3 SI_SFR (IT01CF,   0xE4); ///< INT0/INT1 Configuration               
           =3 SI_SFR (LFO0CN,   0x86); ///< Low Frequency Oscillator Control      
           =3 SI_SFR (P0,       0x80); ///< Port 0 Pin Latch                      
           =3 SI_SFR (P0MDIN,   0xF1); ///< Port 0 Input Mode                     
           =3 SI_SFR (P0MDOUT,  0xA4); ///< Port 0 Output Mode                    
           =3 SI_SFR (P0SKIP,   0xD4); ///< Port 0 Skip                           
           =3 SI_SFR (P1,       0x90); ///< Port 1 Pin Latch                      
           =3 SI_SFR (P1MDIN,   0xF2); ///< Port 1 Input Mode                     
           =3 SI_SFR (P1MDOUT,  0xA5); ///< Port 1 Output Mode                    
           =3 SI_SFR (P1SKIP,   0xD5); ///< Port 1 Skip                           
           =3 SI_SFR (P2,       0xA0); ///< Port 2 Pin Latch                      
           =3 SI_SFR (P2MDIN,   0xF3); ///< Port 2 Input Mode                     
           =3 SI_SFR (P2MDOUT,  0xA6); ///< Port 2 Output Mode                    
           =3 SI_SFR (P2SKIP,   0xD6); ///< Port 2 Skip                           
           =3 SI_SFR (P3,       0xB0); ///< Port 3 Pin Latch                      
           =3 SI_SFR (P3MDIN,   0xF4); ///< Port 3 Input Mode                     
           =3 SI_SFR (P3MDOUT,  0xA7); ///< Port 3 Output Mode                    
           =3 SI_SFR (P3SKIP,   0xDF); ///< Port 3 Skip                           
           =3 SI_SFR (P4,       0xC7); ///< Port 4 Pin Latch                      
C51 COMPILER V9.56.0.0   UART_0                                                            10/28/2016 17:37:02 PAGE 21  

           =3 SI_SFR (P4MDIN,   0xF5); ///< Port 4 Input Mode                     
           =3 SI_SFR (P4MDOUT,  0xAE); ///< Port 4 Output Mode                    
           =3 SI_SFR (PCA0CN0,  0xD8); ///< PCA Control 0                         
           =3 SI_SFR (PCA0CPH0, 0xFC); ///< PCA Channel 0 Capture Module High Byte
           =3 SI_SFR (PCA0CPH1, 0xEA); ///< PCA Channel 1 Capture Module High Byte
           =3 SI_SFR (PCA0CPH2, 0xEC); ///< PCA Channel 2 Capture Module High Byte
           =3 SI_SFR (PCA0CPH3, 0xEE); ///< PCA Channel 3 Capture Module High Byte
           =3 SI_SFR (PCA0CPH4, 0xFE); ///< PCA Channel 4 Capture Module High Byte
           =3 SI_SFR (PCA0CPL0, 0xFB); ///< PCA Channel 0 Capture Module Low Byte 
           =3 SI_SFR (PCA0CPL1, 0xE9); ///< PCA Channel 1 Capture Module Low Byte 
           =3 SI_SFR (PCA0CPL2, 0xEB); ///< PCA Channel 2 Capture Module Low Byte 
           =3 SI_SFR (PCA0CPL3, 0xED); ///< PCA Channel 3 Capture Module Low Byte 
           =3 SI_SFR (PCA0CPL4, 0xFD); ///< PCA Channel 4 Capture Module Low Byte 
           =3 SI_SFR (PCA0CPM0, 0xDA); ///< PCA Channel 0 Capture/Compare Mode    
           =3 SI_SFR (PCA0CPM1, 0xDB); ///< PCA Channel 1 Capture/Compare Mode    
           =3 SI_SFR (PCA0CPM2, 0xDC); ///< PCA Channel 2 Capture/Compare Mode    
           =3 SI_SFR (PCA0CPM3, 0xDD); ///< PCA Channel 3 Capture/Compare Mode    
           =3 SI_SFR (PCA0CPM4, 0xDE); ///< PCA Channel 4 Capture/Compare Mode    
           =3 SI_SFR (PCA0H,    0xFA); ///< PCA Counter/Timer High Byte           
           =3 SI_SFR (PCA0L,    0xF9); ///< PCA Counter/Timer Low Byte            
           =3 SI_SFR (PCA0MD,   0xD9); ///< PCA Mode                              
           =3 SI_SFR (PCON0,    0x87); ///< Power Control                         
           =3 SI_SFR (PFE0CN,   0xAF); ///< Prefetch Engine Control               
           =3 SI_SFR (PSCTL,    0x8F); ///< Program Store Control                 
           =3 SI_SFR (PSW,      0xD0); ///< Program Status Word                   
           =3 SI_SFR (REF0CN,   0xD1); ///< Voltage Reference Control             
           =3 SI_SFR (REG01CN,  0xC9); ///< Voltage Regulator Control             
           =3 SI_SFR (RSTSRC,   0xEF); ///< Reset Source                          
           =3 SI_SFR (SBCON1,   0xAC); ///< UART1 Baud Rate Generator Control     
           =3 SI_SFR (SBRLH1,   0xB5); ///< UART1 Baud Rate Generator High Byte   
           =3 SI_SFR (SBRLL1,   0xB4); ///< UART1 Baud Rate Generator Low Byte    
           =3 SI_SFR (SBUF0,    0x99); ///< UART0 Serial Port Data Buffer         
           =3 SI_SFR (SBUF1,    0xD3); ///< UART1 Serial Port Data Buffer         
           =3 SI_SFR (SCON0,    0x98); ///< UART0 Serial Port Control             
           =3 SI_SFR (SCON1,    0xD2); ///< UART1 Serial Port Control             
           =3 SI_SFR (SFRPAGE,  0xBF); ///< SFR Page                              
           =3 SI_SFR (SMB0ADM,  0xCE); ///< SMBus 0 Slave Address Mask            
           =3 SI_SFR (SMB0ADR,  0xCF); ///< SMBus 0 Slave Address                 
           =3 SI_SFR (SMB0CF,   0xC1); ///< SMBus 0 Configuration                 
           =3 SI_SFR (SMB0CN0,  0xC0); ///< SMBus 0 Control                       
           =3 SI_SFR (SMB0DAT,  0xC2); ///< SMBus 0 Data                          
           =3 SI_SFR (SMB1ADM,  0xCE); ///< SMBus 1 Slave Address Mask            
           =3 SI_SFR (SMB1ADR,  0xCF); ///< SMBus 1 Slave Address                 
           =3 SI_SFR (SMB1CF,   0xC1); ///< SMBus 1 Configuration                 
           =3 SI_SFR (SMB1CN0,  0xC0); ///< SMBus 1 Control                       
           =3 SI_SFR (SMB1DAT,  0xC2); ///< SMBus 1 Data                          
           =3 SI_SFR (SMBTC,    0xB9); ///< SMBus Timing and Pin Control          
           =3 SI_SFR (SMOD1,    0xE5); ///< UART1 Mode                            
           =3 SI_SFR (SP,       0x81); ///< Stack Pointer                         
           =3 SI_SFR (SPI0CFG,  0xA1); ///< SPI0 Configuration                    
           =3 SI_SFR (SPI0CKR,  0xA2); ///< SPI0 Clock Rate                       
           =3 SI_SFR (SPI0CN0,  0xF8); ///< SPI0 Control                          
           =3 SI_SFR (SPI0DAT,  0xA3); ///< SPI0 Data                             
           =3 SI_SFR (TCON,     0x88); ///< Timer 0/1 Control                     
           =3 SI_SFR (TH0,      0x8C); ///< Timer 0 High Byte                     
           =3 SI_SFR (TH1,      0x8D); ///< Timer 1 High Byte                     
           =3 SI_SFR (TL0,      0x8A); ///< Timer 0 Low Byte                      
           =3 SI_SFR (TL1,      0x8B); ///< Timer 1 Low Byte                      
           =3 SI_SFR (TMOD,     0x89); ///< Timer 0/1 Mode                        
           =3 SI_SFR (TMR2CN0,  0xC8); ///< Timer 2 Control 0                     
           =3 SI_SFR (TMR2H,    0xCD); ///< Timer 2 High Byte                     
           =3 SI_SFR (TMR2L,    0xCC); ///< Timer 2 Low Byte                      
C51 COMPILER V9.56.0.0   UART_0                                                            10/28/2016 17:37:02 PAGE 22  

           =3 SI_SFR (TMR2RLH,  0xCB); ///< Timer 2 Reload High Byte              
           =3 SI_SFR (TMR2RLL,  0xCA); ///< Timer 2 Reload Low Byte               
           =3 SI_SFR (TMR3CN0,  0x91); ///< Timer 3 Control 0                     
           =3 SI_SFR (TMR3H,    0x95); ///< Timer 3 High Byte                     
           =3 SI_SFR (TMR3L,    0x94); ///< Timer 3 Low Byte                      
           =3 SI_SFR (TMR3RLH,  0x93); ///< Timer 3 Reload High Byte              
           =3 SI_SFR (TMR3RLL,  0x92); ///< Timer 3 Reload Low Byte               
           =3 SI_SFR (TMR4CN0,  0x91); ///< Timer 4 Control 0                     
           =3 SI_SFR (TMR4H,    0x95); ///< Timer 4 High Byte                     
           =3 SI_SFR (TMR4L,    0x94); ///< Timer 4 Low Byte                      
           =3 SI_SFR (TMR4RLH,  0x93); ///< Timer 4 Reload High Byte              
           =3 SI_SFR (TMR4RLL,  0x92); ///< Timer 4 Reload Low Byte               
           =3 SI_SFR (TMR5CN0,  0xC8); ///< Timer 5 Control 0                     
           =3 SI_SFR (TMR5H,    0xCD); ///< Timer 5 High Byte                     
           =3 SI_SFR (TMR5L,    0xCC); ///< Timer 5 Low Byte                      
           =3 SI_SFR (TMR5RLH,  0xCB); ///< Timer 5 Reload High Byte              
           =3 SI_SFR (TMR5RLL,  0xCA); ///< Timer 5 Reload Low Byte               
           =3 SI_SFR (USB0ADR,  0x96); ///< USB0 Indirect Address                 
           =3 SI_SFR (USB0DAT,  0x97); ///< USB0 Data                             
           =3 SI_SFR (USB0XCN,  0xD7); ///< USB0 Transceiver Control              
           =3 SI_SFR (VDM0CN,   0xFF); ///< Supply Monitor Control                
           =3 SI_SFR (XBR0,     0xE1); ///< Port I/O Crossbar 0                   
           =3 SI_SFR (XBR1,     0xE2); ///< Port I/O Crossbar 1                   
           =3 SI_SFR (XBR2,     0xE3); ///< Port I/O Crossbar 2                   
           =3 SI_SFR (XOSC0CN,  0xB1); ///< External Oscillator Control           
           =3 
           =3 //------------------------------------------------------------------------------
           =3 // 16-bit Register Definitions (may not work on all compilers)
           =3 //------------------------------------------------------------------------------
           =3 SI_SFR16 (ADC0GT,  0xC3); ///< ADC0 Greater-Than            
           =3 SI_SFR16 (ADC0,    0xBD); ///< ADC0 Data Word               
           =3 SI_SFR16 (ADC0LT,  0xC5); ///< ADC0 Less-Than               
           =3 SI_SFR16 (DP,      0x82); ///< Data Pointer                 
           =3 SI_SFR16 (PCA0CP0, 0xFB); ///< PCA Channel 0 Capture Module 
           =3 SI_SFR16 (PCA0CP1, 0xE9); ///< PCA Channel 1 Capture Module 
           =3 SI_SFR16 (PCA0CP2, 0xEB); ///< PCA Channel 2 Capture Module 
           =3 SI_SFR16 (PCA0CP3, 0xED); ///< PCA Channel 3 Capture Module 
           =3 SI_SFR16 (PCA0CP4, 0xFD); ///< PCA Channel 4 Capture Module 
           =3 SI_SFR16 (PCA0,    0xF9); ///< PCA Counter/Timer            
           =3 SI_SFR16 (SBRL1,   0xB4); ///< UART1 Baud Rate Generator    
           =3 SI_SFR16 (TMR2,    0xCC); ///< Timer 2                      
           =3 SI_SFR16 (TMR2RL,  0xCA); ///< Timer 2 Reload               
           =3 SI_SFR16 (TMR3,    0x94); ///< Timer 3                      
           =3 SI_SFR16 (TMR3RL,  0x92); ///< Timer 3 Reload               
           =3 SI_SFR16 (TMR4,    0x94); ///< Timer 4                      
           =3 SI_SFR16 (TMR4RL,  0x92); ///< Timer 4 Reload               
           =3 SI_SFR16 (TMR5,    0xCC); ///< Timer 5                      
           =3 SI_SFR16 (TMR5RL,  0xCA); ///< Timer 5 Reload               
           =3 
           =3 //------------------------------------------------------------------------------
           =3 // Indirect Register Definitions
           =3 //------------------------------------------------------------------------------
           =3 #define CLKREC   0x0F ///< USB0 Clock Recovery Control       
           =3 #define CMIE     0x0B ///< USB0 Common Interrupt Enable      
           =3 #define CMINT    0x06 ///< USB0 Common Interrupt             
           =3 #define E0CNT    0x16 ///< USB0 Endpoint0 Data Count         
           =3 #define E0CSR    0x11 ///< USB0 Endpoint0 Control            
           =3 #define EENABLE  0x1E ///< USB0 Endpoint Enable              
           =3 #define EINCSRH  0x12 ///< USB0 IN Endpoint Control High     
           =3 #define EINCSRL  0x11 ///< USB0 IN Endpoint Control          
           =3 #define EOUTCNTH 0x17 ///< USB0 OUT Endpoint Count High      
           =3 #define EOUTCNTL 0x16 ///< USB0 OUT Endpoint Count           
C51 COMPILER V9.56.0.0   UART_0                                                            10/28/2016 17:37:02 PAGE 23  

           =3 #define EOUTCSRH 0x15 ///< USB0 OUT Endpoint Control High    
           =3 #define EOUTCSRL 0x14 ///< USB0 OUT Endpoint Control         
           =3 #define FADDR    0x00 ///< USB0 Function Address             
           =3 #define FIFO0    0x20 ///< USB0 Endpoint 0 FIFO Access       
           =3 #define FIFO1    0x21 ///< USB0 Endpoint 1 FIFO Access       
           =3 #define FIFO2    0x22 ///< USB0 Endpoint 2 FIFO Access       
           =3 #define FIFO3    0x23 ///< USB0 Endpoint 3 FIFO Access       
           =3 #define FRAMEH   0x0D ///< USB0 Frame Number High            
           =3 #define FRAMEL   0x0C ///< USB0 Frame Number                 
           =3 #define IN1IE    0x07 ///< USB0 IN Endpoint Interrupt Enable 
           =3 #define IN1INT   0x02 ///< USB0 IN Endpoint Interrupt        
           =3 #define INDEX    0x0E ///< USB0 Endpoint Index               
           =3 #define OUT1IE   0x09 ///< USB0 OUT Endpoint Interrupt Enable
           =3 #define OUT1INT  0x04 ///< USB0 OUT Endpoint Interrupt       
           =3 #define POWER    0x01 ///< USB0 Power                        
           =3 
           =3 //------------------------------------------------------------------------------
           =3 // Bit Definitions
           =3 //------------------------------------------------------------------------------
           =3 
           =3 // ACC (Accumulator)
           =3 #define SFR_ACC 0xE0
           =3 SI_SBIT (ACC_ACC0, SFR_ACC, 0); ///< Accumulator Bit 0
           =3 SI_SBIT (ACC_ACC1, SFR_ACC, 1); ///< Accumulator Bit 1
           =3 SI_SBIT (ACC_ACC2, SFR_ACC, 2); ///< Accumulator Bit 2
           =3 SI_SBIT (ACC_ACC3, SFR_ACC, 3); ///< Accumulator Bit 3
           =3 SI_SBIT (ACC_ACC4, SFR_ACC, 4); ///< Accumulator Bit 4
           =3 SI_SBIT (ACC_ACC5, SFR_ACC, 5); ///< Accumulator Bit 5
           =3 SI_SBIT (ACC_ACC6, SFR_ACC, 6); ///< Accumulator Bit 6
           =3 SI_SBIT (ACC_ACC7, SFR_ACC, 7); ///< Accumulator Bit 7
           =3 
           =3 // ADC0CN0 (ADC0 Control)
           =3 #define SFR_ADC0CN0 0xE8
           =3 SI_SBIT (ADC0CN0_ADCM0,  SFR_ADC0CN0, 0); ///< Start of Conversion Mode Select Bit 0
           =3 SI_SBIT (ADC0CN0_ADCM1,  SFR_ADC0CN0, 1); ///< Start of Conversion Mode Select Bit 1
           =3 SI_SBIT (ADC0CN0_ADCM2,  SFR_ADC0CN0, 2); ///< Start of Conversion Mode Select Bit 2
           =3 SI_SBIT (ADC0CN0_ADWINT, SFR_ADC0CN0, 3); ///< Window Compare Interrupt Flag        
           =3 SI_SBIT (ADC0CN0_ADBUSY, SFR_ADC0CN0, 4); ///< ADC Busy                             
           =3 SI_SBIT (ADC0CN0_ADINT,  SFR_ADC0CN0, 5); ///< Conversion Complete Interrupt Flag   
           =3 SI_SBIT (ADC0CN0_ADTM,   SFR_ADC0CN0, 6); ///< Track Mode                           
           =3 SI_SBIT (ADC0CN0_ADEN,   SFR_ADC0CN0, 7); ///< ADC Enable                           
           =3 
           =3 // B (B Register)
           =3 #define SFR_B 0xF0
           =3 SI_SBIT (B_B0, SFR_B, 0); ///< B Register Bit 0
           =3 SI_SBIT (B_B1, SFR_B, 1); ///< B Register Bit 1
           =3 SI_SBIT (B_B2, SFR_B, 2); ///< B Register Bit 2
           =3 SI_SBIT (B_B3, SFR_B, 3); ///< B Register Bit 3
           =3 SI_SBIT (B_B4, SFR_B, 4); ///< B Register Bit 4
           =3 SI_SBIT (B_B5, SFR_B, 5); ///< B Register Bit 5
           =3 SI_SBIT (B_B6, SFR_B, 6); ///< B Register Bit 6
           =3 SI_SBIT (B_B7, SFR_B, 7); ///< B Register Bit 7
           =3 
           =3 // IE (Interrupt Enable)
           =3 #define SFR_IE 0xA8
           =3 SI_SBIT (IE_EX0,   SFR_IE, 0); ///< External Interrupt 0 Enable
           =3 SI_SBIT (IE_ET0,   SFR_IE, 1); ///< Timer 0 Interrupt Enable   
           =3 SI_SBIT (IE_EX1,   SFR_IE, 2); ///< External Interrupt 1 Enable
           =3 SI_SBIT (IE_ET1,   SFR_IE, 3); ///< Timer 1 Interrupt Enable   
           =3 SI_SBIT (IE_ES0,   SFR_IE, 4); ///< UART0 Interrupt Enable     
           =3 SI_SBIT (IE_ET2,   SFR_IE, 5); ///< Timer 2 Interrupt Enable   
           =3 SI_SBIT (IE_ESPI0, SFR_IE, 6); ///< SPI0 Interrupt Enable      
C51 COMPILER V9.56.0.0   UART_0                                                            10/28/2016 17:37:02 PAGE 24  

           =3 SI_SBIT (IE_EA,    SFR_IE, 7); ///< All Interrupts Enable      
           =3 
           =3 // IP (Interrupt Priority)
           =3 #define SFR_IP 0xB8
           =3 SI_SBIT (IP_PX0,   SFR_IP, 0); ///< External Interrupt 0 Priority Control                        
           =3 SI_SBIT (IP_PT0,   SFR_IP, 1); ///< Timer 0 Interrupt Priority Control                           
           =3 SI_SBIT (IP_PX1,   SFR_IP, 2); ///< External Interrupt 1 Priority Control                        
           =3 SI_SBIT (IP_PT1,   SFR_IP, 3); ///< Timer 1 Interrupt Priority Control                           
           =3 SI_SBIT (IP_PS0,   SFR_IP, 4); ///< UART0 Interrupt Priority Control                             
           =3 SI_SBIT (IP_PT2,   SFR_IP, 5); ///< Timer 2 Interrupt Priority Control                           
           =3 SI_SBIT (IP_PSPI0, SFR_IP, 6); ///< Serial Peripheral Interface (SPI0) Interrupt Priority Control
           =3 
           =3 // P0 (Port 0 Pin Latch)
           =3 #define SFR_P0 0x80
           =3 SI_SBIT (P0_B0, SFR_P0, 0); ///< Port 0 Bit 0 Latch
           =3 SI_SBIT (P0_B1, SFR_P0, 1); ///< Port 0 Bit 1 Latch
           =3 SI_SBIT (P0_B2, SFR_P0, 2); ///< Port 0 Bit 2 Latch
           =3 SI_SBIT (P0_B3, SFR_P0, 3); ///< Port 0 Bit 3 Latch
           =3 SI_SBIT (P0_B4, SFR_P0, 4); ///< Port 0 Bit 4 Latch
           =3 SI_SBIT (P0_B5, SFR_P0, 5); ///< Port 0 Bit 5 Latch
           =3 SI_SBIT (P0_B6, SFR_P0, 6); ///< Port 0 Bit 6 Latch
           =3 SI_SBIT (P0_B7, SFR_P0, 7); ///< Port 0 Bit 7 Latch
           =3 
           =3 // P1 (Port 1 Pin Latch)
           =3 #define SFR_P1 0x90
           =3 SI_SBIT (P1_B0, SFR_P1, 0); ///< Port 1 Bit 0 Latch
           =3 SI_SBIT (P1_B1, SFR_P1, 1); ///< Port 1 Bit 1 Latch
           =3 SI_SBIT (P1_B2, SFR_P1, 2); ///< Port 1 Bit 2 Latch
           =3 SI_SBIT (P1_B3, SFR_P1, 3); ///< Port 1 Bit 3 Latch
           =3 SI_SBIT (P1_B4, SFR_P1, 4); ///< Port 1 Bit 4 Latch
           =3 SI_SBIT (P1_B5, SFR_P1, 5); ///< Port 1 Bit 5 Latch
           =3 SI_SBIT (P1_B6, SFR_P1, 6); ///< Port 1 Bit 6 Latch
           =3 SI_SBIT (P1_B7, SFR_P1, 7); ///< Port 1 Bit 7 Latch
           =3 
           =3 // P2 (Port 2 Pin Latch)
           =3 #define SFR_P2 0xA0
           =3 SI_SBIT (P2_B0, SFR_P2, 0); ///< Port 2 Bit 0 Latch
           =3 SI_SBIT (P2_B1, SFR_P2, 1); ///< Port 2 Bit 1 Latch
           =3 SI_SBIT (P2_B2, SFR_P2, 2); ///< Port 2 Bit 2 Latch
           =3 SI_SBIT (P2_B3, SFR_P2, 3); ///< Port 2 Bit 3 Latch
           =3 SI_SBIT (P2_B4, SFR_P2, 4); ///< Port 2 Bit 4 Latch
           =3 SI_SBIT (P2_B5, SFR_P2, 5); ///< Port 2 Bit 5 Latch
           =3 SI_SBIT (P2_B6, SFR_P2, 6); ///< Port 2 Bit 6 Latch
           =3 SI_SBIT (P2_B7, SFR_P2, 7); ///< Port 2 Bit 7 Latch
           =3 
           =3 // P3 (Port 3 Pin Latch)
           =3 #define SFR_P3 0xB0
           =3 SI_SBIT (P3_B0, SFR_P3, 0); ///< Port 3 Bit 0 Latch
           =3 SI_SBIT (P3_B1, SFR_P3, 1); ///< Port 3 Bit 1 Latch
           =3 SI_SBIT (P3_B2, SFR_P3, 2); ///< Port 3 Bit 2 Latch
           =3 SI_SBIT (P3_B3, SFR_P3, 3); ///< Port 3 Bit 3 Latch
           =3 SI_SBIT (P3_B4, SFR_P3, 4); ///< Port 3 Bit 4 Latch
           =3 SI_SBIT (P3_B5, SFR_P3, 5); ///< Port 3 Bit 5 Latch
           =3 SI_SBIT (P3_B6, SFR_P3, 6); ///< Port 3 Bit 6 Latch
           =3 SI_SBIT (P3_B7, SFR_P3, 7); ///< Port 3 Bit 7 Latch
           =3 
           =3 // PCA0CN0 (PCA Control 0)
           =3 #define SFR_PCA0CN0 0xD8
           =3 SI_SBIT (PCA0CN0_CCF0, SFR_PCA0CN0, 0); ///< PCA Module 0 Capture/Compare Flag
           =3 SI_SBIT (PCA0CN0_CCF1, SFR_PCA0CN0, 1); ///< PCA Module 1 Capture/Compare Flag
           =3 SI_SBIT (PCA0CN0_CCF2, SFR_PCA0CN0, 2); ///< PCA Module 2 Capture/Compare Flag
           =3 SI_SBIT (PCA0CN0_CCF3, SFR_PCA0CN0, 3); ///< PCA Module 3 Capture/Compare Flag
C51 COMPILER V9.56.0.0   UART_0                                                            10/28/2016 17:37:02 PAGE 25  

           =3 SI_SBIT (PCA0CN0_CCF4, SFR_PCA0CN0, 4); ///< PCA Module 4 Capture/Compare Flag
           =3 SI_SBIT (PCA0CN0_CR,   SFR_PCA0CN0, 6); ///< PCA Counter/Timer Run Control    
           =3 SI_SBIT (PCA0CN0_CF,   SFR_PCA0CN0, 7); ///< PCA Counter/Timer Overflow Flag  
           =3 
           =3 // PSW (Program Status Word)
           =3 #define SFR_PSW 0xD0
           =3 SI_SBIT (PSW_PARITY, SFR_PSW, 0); ///< Parity Flag               
           =3 SI_SBIT (PSW_F1,     SFR_PSW, 1); ///< User Flag 1               
           =3 SI_SBIT (PSW_OV,     SFR_PSW, 2); ///< Overflow Flag             
           =3 SI_SBIT (PSW_RS0,    SFR_PSW, 3); ///< Register Bank Select Bit 0
           =3 SI_SBIT (PSW_RS1,    SFR_PSW, 4); ///< Register Bank Select Bit 1
           =3 SI_SBIT (PSW_F0,     SFR_PSW, 5); ///< User Flag 0               
           =3 SI_SBIT (PSW_AC,     SFR_PSW, 6); ///< Auxiliary Carry Flag      
           =3 SI_SBIT (PSW_CY,     SFR_PSW, 7); ///< Carry Flag                
           =3 
           =3 // SCON0 (UART0 Serial Port Control)
           =3 #define SFR_SCON0 0x98
           =3 SI_SBIT (SCON0_RI,    SFR_SCON0, 0); ///< Receive Interrupt Flag             
           =3 SI_SBIT (SCON0_TI,    SFR_SCON0, 1); ///< Transmit Interrupt Flag            
           =3 SI_SBIT (SCON0_RB8,   SFR_SCON0, 2); ///< Ninth Receive Bit                  
           =3 SI_SBIT (SCON0_TB8,   SFR_SCON0, 3); ///< Ninth Transmission Bit             
           =3 SI_SBIT (SCON0_REN,   SFR_SCON0, 4); ///< Receive Enable                     
           =3 SI_SBIT (SCON0_MCE,   SFR_SCON0, 5); ///< Multiprocessor Communication Enable
           =3 SI_SBIT (SCON0_SMODE, SFR_SCON0, 7); ///< Serial Port 0 Operation Mode       
           =3 
           =3 // SMB0CN0 (SMBus 0 Control)
           =3 #define SFR_SMB0CN0 0xC0
           =3 SI_SBIT (SMB0CN0_SI,      SFR_SMB0CN0, 0); ///< SMBus Interrupt Flag            
           =3 SI_SBIT (SMB0CN0_ACK,     SFR_SMB0CN0, 1); ///< SMBus Acknowledge               
           =3 SI_SBIT (SMB0CN0_ARBLOST, SFR_SMB0CN0, 2); ///< SMBus Arbitration Lost Indicator
           =3 SI_SBIT (SMB0CN0_ACKRQ,   SFR_SMB0CN0, 3); ///< SMBus Acknowledge Request       
           =3 SI_SBIT (SMB0CN0_STO,     SFR_SMB0CN0, 4); ///< SMBus Stop Flag                 
           =3 SI_SBIT (SMB0CN0_STA,     SFR_SMB0CN0, 5); ///< SMBus Start Flag                
           =3 SI_SBIT (SMB0CN0_TXMODE,  SFR_SMB0CN0, 6); ///< SMBus Transmit Mode Indicator   
           =3 SI_SBIT (SMB0CN0_MASTER,  SFR_SMB0CN0, 7); ///< SMBus Master/Slave Indicator    
           =3 
           =3 // SMB1CN0 (SMBus 1 Control)
           =3 #define SFR_SMB1CN0 0xC0
           =3 SI_SBIT (SMB1CN0_SI,      SFR_SMB1CN0, 0); ///< SMBus Interrupt Flag            
           =3 SI_SBIT (SMB1CN0_ACK,     SFR_SMB1CN0, 1); ///< SMBus Acknowledge               
           =3 SI_SBIT (SMB1CN0_ARBLOST, SFR_SMB1CN0, 2); ///< SMBus Arbitration Lost Indicator
           =3 SI_SBIT (SMB1CN0_ACKRQ,   SFR_SMB1CN0, 3); ///< SMBus Acknowledge Request       
           =3 SI_SBIT (SMB1CN0_STO,     SFR_SMB1CN0, 4); ///< SMBus Stop Flag                 
           =3 SI_SBIT (SMB1CN0_STA,     SFR_SMB1CN0, 5); ///< SMBus Start Flag                
           =3 SI_SBIT (SMB1CN0_TXMODE,  SFR_SMB1CN0, 6); ///< SMBus Transmit Mode Indicator   
           =3 SI_SBIT (SMB1CN0_MASTER,  SFR_SMB1CN0, 7); ///< SMBus Master/Slave Indicator    
           =3 
           =3 // SPI0CN0 (SPI0 Control)
           =3 #define SFR_SPI0CN0 0xF8
           =3 SI_SBIT (SPI0CN0_SPIEN,  SFR_SPI0CN0, 0); ///< SPI0 Enable            
           =3 SI_SBIT (SPI0CN0_TXBMT,  SFR_SPI0CN0, 1); ///< Transmit Buffer Empty  
           =3 SI_SBIT (SPI0CN0_NSSMD0, SFR_SPI0CN0, 2); ///< Slave Select Mode Bit 0
           =3 SI_SBIT (SPI0CN0_NSSMD1, SFR_SPI0CN0, 3); ///< Slave Select Mode Bit 1
           =3 SI_SBIT (SPI0CN0_RXOVRN, SFR_SPI0CN0, 4); ///< Receive Overrun Flag   
           =3 SI_SBIT (SPI0CN0_MODF,   SFR_SPI0CN0, 5); ///< Mode Fault Flag        
           =3 SI_SBIT (SPI0CN0_WCOL,   SFR_SPI0CN0, 6); ///< Write Collision Flag   
           =3 SI_SBIT (SPI0CN0_SPIF,   SFR_SPI0CN0, 7); ///< SPI0 Interrupt Flag    
           =3 
           =3 // TCON (Timer 0/1 Control)
           =3 #define SFR_TCON 0x88
           =3 SI_SBIT (TCON_IT0, SFR_TCON, 0); ///< Interrupt 0 Type Select
           =3 SI_SBIT (TCON_IE0, SFR_TCON, 1); ///< External Interrupt 0   
C51 COMPILER V9.56.0.0   UART_0                                                            10/28/2016 17:37:02 PAGE 26  

           =3 SI_SBIT (TCON_IT1, SFR_TCON, 2); ///< Interrupt 1 Type Select
           =3 SI_SBIT (TCON_IE1, SFR_TCON, 3); ///< External Interrupt 1   
           =3 SI_SBIT (TCON_TR0, SFR_TCON, 4); ///< Timer 0 Run Control    
           =3 SI_SBIT (TCON_TF0, SFR_TCON, 5); ///< Timer 0 Overflow Flag  
           =3 SI_SBIT (TCON_TR1, SFR_TCON, 6); ///< Timer 1 Run Control    
           =3 SI_SBIT (TCON_TF1, SFR_TCON, 7); ///< Timer 1 Overflow Flag  
           =3 
           =3 // TMR2CN0 (Timer 2 Control 0)
           =3 #define SFR_TMR2CN0 0xC8
           =3 SI_SBIT (TMR2CN0_T2XCLK,  SFR_TMR2CN0, 0); ///< Timer 2 External Clock Select    
           =3 SI_SBIT (TMR2CN0_T2CSS,   SFR_TMR2CN0, 1); ///< Timer 2 Capture Source Select    
           =3 SI_SBIT (TMR2CN0_TR2,     SFR_TMR2CN0, 2); ///< Timer 2 Run Control              
           =3 SI_SBIT (TMR2CN0_T2SPLIT, SFR_TMR2CN0, 3); ///< Timer 2 Split Mode Enable        
           =3 SI_SBIT (TMR2CN0_TF2CEN,  SFR_TMR2CN0, 4); ///< Timer 2 Capture Enable           
           =3 SI_SBIT (TMR2CN0_TF2LEN,  SFR_TMR2CN0, 5); ///< Timer 2 Low Byte Interrupt Enable
           =3 SI_SBIT (TMR2CN0_TF2L,    SFR_TMR2CN0, 6); ///< Timer 2 Low Byte Overflow Flag   
           =3 SI_SBIT (TMR2CN0_TF2H,    SFR_TMR2CN0, 7); ///< Timer 2 High Byte Overflow Flag  
           =3 
           =3 // TMR5CN0 (Timer 5 Control 0)
           =3 #define SFR_TMR5CN0 0xC8
           =3 SI_SBIT (TMR5CN0_T5XCLK,  SFR_TMR5CN0, 0); ///< Timer 5 External Clock Select    
           =3 SI_SBIT (TMR5CN0_TR5,     SFR_TMR5CN0, 2); ///< Timer 5 Run Control              
           =3 SI_SBIT (TMR5CN0_T5SPLIT, SFR_TMR5CN0, 3); ///< Timer 5 Split Mode Enable        
           =3 SI_SBIT (TMR5CN0_TF5LEN,  SFR_TMR5CN0, 5); ///< Timer 5 Low Byte Interrupt Enable
           =3 SI_SBIT (TMR5CN0_TF5L,    SFR_TMR5CN0, 6); ///< Timer 5 Low Byte Overflow Flag   
           =3 SI_SBIT (TMR5CN0_TF5H,    SFR_TMR5CN0, 7); ///< Timer 5 High Byte Overflow Flag  
           =3 
           =3 //------------------------------------------------------------------------------
           =3 // Interrupt Definitions
           =3 //------------------------------------------------------------------------------
           =3 #define INT0_IRQn    0  ///< External Interrupt 0  
           =3 #define TIMER0_IRQn  1  ///< Timer 0 Overflow      
           =3 #define INT1_IRQn    2  ///< External Interrupt 1  
           =3 #define TIMER1_IRQn  3  ///< Timer 1 Overflow      
           =3 #define UART0_IRQn   4  ///< UART 0                
           =3 #define TIMER2_IRQn  5  ///< Timer 2 Overflow      
           =3 #define SPI0_IRQn    6  ///< SPI0                  
           =3 #define SMBUS0_IRQn  7  ///< SMBus 0               
           =3 #define USB0_IRQn    8  ///< USB0                  
           =3 #define ADC0WC_IRQn  9  ///< ADC0 Window Compare   
           =3 #define ADC0EOC_IRQn 10 ///< ADC0 End of Conversion
           =3 #define PCA0_IRQn    11 ///< PCA0                  
           =3 #define CMP0_IRQn    12 ///< Comparator 0          
           =3 #define CMP1_IRQn    13 ///< Comparator 1          
           =3 #define TIMER3_IRQn  14 ///< Timer 3 Overflow      
           =3 #define VBUSLVL_IRQn 15 ///< VBUS Level            
           =3 #define UART1_IRQn   16 ///< UART 1                
           =3 #define SMBUS1_IRQn  18 ///< SMBus 1               
           =3 #define TIMER4_IRQn  19 ///< Timer 4 Overflow      
           =3 #define TIMER5_IRQn  20 ///< Timer 5 Overflow      
           =3 
           =3 //------------------------------------------------------------------------------
           =3 // SFR Page Definitions
           =3 //------------------------------------------------------------------------------
           =3 #define LEGACY_PAGE 0x00 ///< Legacy SFR Page                   
           =3 #define CONFIG_PAGE 0x0F ///< System and Port Configuration Page
           =3 #define SMB1_PAGE   0x0F ///< SMBus 1 Page                      
           =3 
           =3 //-----------------------------------------------------------------------------
           =3 // SDCC PDATA External Memory Paging Support
           =3 //-----------------------------------------------------------------------------
           =3 
C51 COMPILER V9.56.0.0   UART_0                                                            10/28/2016 17:37:02 PAGE 27  

           =3 #if defined SDCC
           =3 
           =3 SI_SFR(_XPAGE, 0xAA); // Point to the EMI0CN register
           =3 
           =3 #endif
           =3 
           =3 #endif // SI_EFM8UB2_DEFS_H
 459      =3  //-eof--------------------------------------------------------------------------
 460      =3  
  22      =2  //------------------------------------------------------------------------------
  23      =2  // ADC0CF Enums (ADC0 Configuration @ 0xBC)
  24      =2  //------------------------------------------------------------------------------
  25      =2  #define ADC0CF_ADLJST__BMASK           0x04 ///< ADC0 Left Justify Select                   
  26      =2  #define ADC0CF_ADLJST__SHIFT           0x02 ///< ADC0 Left Justify Select                   
  27      =2  #define ADC0CF_ADLJST__RIGHT_JUSTIFIED 0x00 ///< Data in the ADC0H:ADC0L registers is right-
  28      =2                                              ///< justified.                                 
  29      =2  #define ADC0CF_ADLJST__LEFT_JUSTIFIED  0x04 ///< Data in the ADC0H:ADC0L registers is left- 
  30      =2                                              ///< justified.                                 
  31      =2                                                                                              
  32      =2  #define ADC0CF_ADSC__FMASK             0xF8 ///< SAR Clock Divider                          
  33      =2  #define ADC0CF_ADSC__SHIFT             0x03 ///< SAR Clock Divider                          
  34      =2                                                                                              
  35      =2  //------------------------------------------------------------------------------
  36      =2  // ADC0CN0 Enums (ADC0 Control @ 0xE8)
  37      =2  //------------------------------------------------------------------------------
  38      =2  #define ADC0CN0_ADCM__FMASK         0x07 ///< Start of Conversion Mode Select                   
  39      =2  #define ADC0CN0_ADCM__SHIFT         0x00 ///< Start of Conversion Mode Select                   
  40      =2  #define ADC0CN0_ADCM__ADBUSY        0x00 ///< ADC0 conversion initiated on write of 1 to ADBUSY.
  41      =2  #define ADC0CN0_ADCM__TIMER0        0x01 ///< ADC0 conversion initiated on overflow of Timer 0. 
  42      =2  #define ADC0CN0_ADCM__TIMER2        0x02 ///< ADC0 conversion initiated on overflow of Timer 2. 
  43      =2  #define ADC0CN0_ADCM__TIMER1        0x03 ///< ADC0 conversion initiated on overflow of Timer 1. 
  44      =2  #define ADC0CN0_ADCM__CNVSTR        0x04 ///< ADC0 conversion initiated on rising edge of       
  45      =2                                           ///< CNVSTR.                                           
  46      =2  #define ADC0CN0_ADCM__TIMER3        0x05 ///< ADC0 conversion initiated on overflow of Timer 3. 
  47      =2  #define ADC0CN0_ADCM__TIMER4        0x06 ///< ADC0 conversion initiated on overflow of Timer 4. 
  48      =2  #define ADC0CN0_ADCM__TIMER5        0x07 ///< ADC0 conversion initiated on overflow of Timer 5. 
  49      =2                                                                                                  
  50      =2  #define ADC0CN0_ADWINT__BMASK       0x08 ///< Window Compare Interrupt Flag                     
  51      =2  #define ADC0CN0_ADWINT__SHIFT       0x03 ///< Window Compare Interrupt Flag                     
  52      =2  #define ADC0CN0_ADWINT__NOT_SET     0x00 ///< An ADC window compare event did not occur.        
  53      =2  #define ADC0CN0_ADWINT__SET         0x08 ///< An ADC window compare event occurred.             
  54      =2                                                                                                  
  55      =2  #define ADC0CN0_ADBUSY__BMASK       0x10 ///< ADC Busy                                          
  56      =2  #define ADC0CN0_ADBUSY__SHIFT       0x04 ///< ADC Busy                                          
  57      =2  #define ADC0CN0_ADBUSY__NOT_SET     0x00 ///< An ADC0 conversion is not currently in progress.  
  58      =2  #define ADC0CN0_ADBUSY__SET         0x10 ///< ADC0 conversion is in progress or start an ADC0   
  59      =2                                           ///< conversion.                                       
  60      =2                                                                                                  
  61      =2  #define ADC0CN0_ADINT__BMASK        0x20 ///< Conversion Complete Interrupt Flag                
  62      =2  #define ADC0CN0_ADINT__SHIFT        0x05 ///< Conversion Complete Interrupt Flag                
  63      =2  #define ADC0CN0_ADINT__NOT_SET      0x00 ///< ADC0 has not completed a conversion since the last
  64      =2                                           ///< time ADINT was cleared.                           
  65      =2  #define ADC0CN0_ADINT__SET          0x20 ///< ADC0 completed a data conversion.                 
  66      =2                                                                                                  
  67      =2  #define ADC0CN0_ADTM__BMASK         0x40 ///< Track Mode                                        
  68      =2  #define ADC0CN0_ADTM__SHIFT         0x06 ///< Track Mode                                        
  69      =2  #define ADC0CN0_ADTM__TRACK_NORMAL  0x00 ///< Normal Track Mode. When ADC0 is enabled,          
  70      =2                                           ///< conversion begins immediately following the start-
  71      =2                                           ///< of-conversion signal.                             
  72      =2  #define ADC0CN0_ADTM__TRACK_DELAYED 0x40 ///< Delayed Track Mode. When ADC0 is enabled,         
  73      =2                                           ///< conversion begins 3 SAR clock cycles following the
  74      =2                                           ///< start-of-conversion signal. The ADC is allowed to 
C51 COMPILER V9.56.0.0   UART_0                                                            10/28/2016 17:37:02 PAGE 28  

  75      =2                                           ///< track during this time. Note that there is not a  
  76      =2                                           ///< tracking delay when the external conversion start 
  77      =2                                           ///< (CNVSTR) is used as the start-of-conversion       
  78      =2                                           ///< source.                                           
  79      =2                                                                                                  
  80      =2  #define ADC0CN0_ADEN__BMASK         0x80 ///< ADC Enable                                        
  81      =2  #define ADC0CN0_ADEN__SHIFT         0x07 ///< ADC Enable                                        
  82      =2  #define ADC0CN0_ADEN__DISABLED      0x00 ///< ADC0 Disabled (low-power shutdown).               
  83      =2  #define ADC0CN0_ADEN__ENABLED       0x80 ///< ADC0 Enabled (active and ready for data           
  84      =2                                           ///< conversions).                                     
  85      =2                                                                                                  
  86      =2  //------------------------------------------------------------------------------
  87      =2  // ADC0GTH Enums (ADC0 Greater-Than High Byte @ 0xC4)
  88      =2  //------------------------------------------------------------------------------
  89      =2  #define ADC0GTH_ADC0GTH__FMASK 0xFF ///< Greater-Than High Byte
  90      =2  #define ADC0GTH_ADC0GTH__SHIFT 0x00 ///< Greater-Than High Byte
  91      =2                                                                 
  92      =2  //------------------------------------------------------------------------------
  93      =2  // ADC0GTL Enums (ADC0 Greater-Than Low Byte @ 0xC3)
  94      =2  //------------------------------------------------------------------------------
  95      =2  #define ADC0GTL_ADC0GTL__FMASK 0xFF ///< Greater-Than Low Byte
  96      =2  #define ADC0GTL_ADC0GTL__SHIFT 0x00 ///< Greater-Than Low Byte
  97      =2                                                                
  98      =2  //------------------------------------------------------------------------------
  99      =2  // ADC0H Enums (ADC0 Data Word High Byte @ 0xBE)
 100      =2  //------------------------------------------------------------------------------
 101      =2  #define ADC0H_ADC0H__FMASK 0xFF ///< Data Word High Byte
 102      =2  #define ADC0H_ADC0H__SHIFT 0x00 ///< Data Word High Byte
 103      =2                                                          
 104      =2  //------------------------------------------------------------------------------
 105      =2  // ADC0L Enums (ADC0 Data Word Low Byte @ 0xBD)
 106      =2  //------------------------------------------------------------------------------
 107      =2  #define ADC0L_ADC0L__FMASK 0xFF ///< Data Word Low Byte
 108      =2  #define ADC0L_ADC0L__SHIFT 0x00 ///< Data Word Low Byte
 109      =2                                                         
 110      =2  //------------------------------------------------------------------------------
 111      =2  // ADC0LTH Enums (ADC0 Less-Than High Byte @ 0xC6)
 112      =2  //------------------------------------------------------------------------------
 113      =2  #define ADC0LTH_ADC0LTH__FMASK 0xFF ///< Less-Than High Byte
 114      =2  #define ADC0LTH_ADC0LTH__SHIFT 0x00 ///< Less-Than High Byte
 115      =2                                                              
 116      =2  //------------------------------------------------------------------------------
 117      =2  // ADC0LTL Enums (ADC0 Less-Than Low Byte @ 0xC5)
 118      =2  //------------------------------------------------------------------------------
 119      =2  #define ADC0LTL_ADC0LTL__FMASK 0xFF ///< Less-Than Low Byte
 120      =2  #define ADC0LTL_ADC0LTL__SHIFT 0x00 ///< Less-Than Low Byte
 121      =2                                                             
 122      =2  //------------------------------------------------------------------------------
 123      =2  // AMX0N Enums (AMUX0 Negative Multiplexer Selection @ 0xBA)
 124      =2  //------------------------------------------------------------------------------
 125      =2  #define AMX0N_AMX0N__FMASK   0x3F ///< AMUX0 Negative Input Selection
 126      =2  #define AMX0N_AMX0N__SHIFT   0x00 ///< AMUX0 Negative Input Selection
 127      =2  #define AMX0N_AMX0N__ADC0N0  0x00 ///< Select ADC0N.0.               
 128      =2  #define AMX0N_AMX0N__ADC0N1  0x01 ///< Select ADC0N.1.               
 129      =2  #define AMX0N_AMX0N__ADC0N2  0x02 ///< Select ADC0N.2.               
 130      =2  #define AMX0N_AMX0N__ADC0N3  0x03 ///< Select ADC0N.3.               
 131      =2  #define AMX0N_AMX0N__ADC0N4  0x04 ///< Select ADC0N.4.               
 132      =2  #define AMX0N_AMX0N__ADC0N5  0x05 ///< Select ADC0N.5.               
 133      =2  #define AMX0N_AMX0N__ADC0N6  0x06 ///< Select ADC0N.6.               
 134      =2  #define AMX0N_AMX0N__ADC0N7  0x07 ///< Select ADC0N.7.               
 135      =2  #define AMX0N_AMX0N__ADC0N8  0x08 ///< Select ADC0N.8.               
 136      =2  #define AMX0N_AMX0N__ADC0N9  0x09 ///< Select ADC0N.9.               
C51 COMPILER V9.56.0.0   UART_0                                                            10/28/2016 17:37:02 PAGE 29  

 137      =2  #define AMX0N_AMX0N__ADC0N10 0x0A ///< Select ADC0N.10.              
 138      =2  #define AMX0N_AMX0N__ADC0N11 0x0B ///< Select ADC0N.11.              
 139      =2  #define AMX0N_AMX0N__ADC0N12 0x0C ///< Select ADC0N.12.              
 140      =2  #define AMX0N_AMX0N__ADC0N13 0x0D ///< Select ADC0N.13.              
 141      =2  #define AMX0N_AMX0N__ADC0N14 0x0E ///< Select ADC0N.14.              
 142      =2  #define AMX0N_AMX0N__ADC0N15 0x0F ///< Select ADC0N.15.              
 143      =2  #define AMX0N_AMX0N__ADC0N16 0x10 ///< Select ADC0N.16.              
 144      =2  #define AMX0N_AMX0N__ADC0N17 0x11 ///< Select ADC0N.17.              
 145      =2  #define AMX0N_AMX0N__ADC0N18 0x12 ///< Select ADC0N.18.              
 146      =2  #define AMX0N_AMX0N__ADC0N19 0x13 ///< Select ADC0N.19.              
 147      =2  #define AMX0N_AMX0N__ADC0N20 0x14 ///< Select ADC0N.20.              
 148      =2  #define AMX0N_AMX0N__ADC0N21 0x15 ///< Select ADC0N.21.              
 149      =2  #define AMX0N_AMX0N__ADC0N22 0x16 ///< Select ADC0N.22.              
 150      =2  #define AMX0N_AMX0N__ADC0N23 0x17 ///< Select ADC0N.23.              
 151      =2  #define AMX0N_AMX0N__ADC0N24 0x18 ///< Select ADC0N.24.              
 152      =2  #define AMX0N_AMX0N__ADC0N25 0x19 ///< Select ADC0N.25.              
 153      =2  #define AMX0N_AMX0N__ADC0N26 0x1A ///< Select ADC0N.26.              
 154      =2  #define AMX0N_AMX0N__ADC0N27 0x1B ///< Select ADC0N.27.              
 155      =2  #define AMX0N_AMX0N__ADC0N28 0x1C ///< Select ADC0N.28.              
 156      =2  #define AMX0N_AMX0N__ADC0N29 0x1D ///< Select ADC0N.29.              
 157      =2  #define AMX0N_AMX0N__VREF    0x1E ///< Internal Voltage Reference.   
 158      =2  #define AMX0N_AMX0N__GND     0x1F ///< Ground (single-ended mode).   
 159      =2  #define AMX0N_AMX0N__ADC0N32 0x20 ///< Select ADC0N.32.              
 160      =2  #define AMX0N_AMX0N__ADC0N33 0x21 ///< Select ADC0N.33.              
 161      =2  #define AMX0N_AMX0N__ADC0N34 0x22 ///< Select ADC0N.34.              
 162      =2                                                                       
 163      =2  //------------------------------------------------------------------------------
 164      =2  // AMX0P Enums (AMUX0 Positive Multiplexer Selection @ 0xBB)
 165      =2  //------------------------------------------------------------------------------
 166      =2  #define AMX0P_AMX0P__FMASK   0x3F ///< AMUX0 Positive Input Selection
 167      =2  #define AMX0P_AMX0P__SHIFT   0x00 ///< AMUX0 Positive Input Selection
 168      =2  #define AMX0P_AMX0P__ADC0P0  0x00 ///< Select ADC0P.0.               
 169      =2  #define AMX0P_AMX0P__ADC0P1  0x01 ///< Select ADC0P.1.               
 170      =2  #define AMX0P_AMX0P__ADC0P2  0x02 ///< Select ADC0P.2.               
 171      =2  #define AMX0P_AMX0P__ADC0P3  0x03 ///< Select ADC0P.3.               
 172      =2  #define AMX0P_AMX0P__ADC0P4  0x04 ///< Select ADC0P.4.               
 173      =2  #define AMX0P_AMX0P__ADC0P5  0x05 ///< Select ADC0P.5.               
 174      =2  #define AMX0P_AMX0P__ADC0P6  0x06 ///< Select ADC0P.6.               
 175      =2  #define AMX0P_AMX0P__ADC0P7  0x07 ///< Select ADC0P.7.               
 176      =2  #define AMX0P_AMX0P__ADC0P8  0x08 ///< Select ADC0P.8.               
 177      =2  #define AMX0P_AMX0P__ADC0P9  0x09 ///< Select ADC0P.9.               
 178      =2  #define AMX0P_AMX0P__ADC0P10 0x0A ///< Select ADC0P.10.              
 179      =2  #define AMX0P_AMX0P__ADC0P11 0x0B ///< Select ADC0P.11.              
 180      =2  #define AMX0P_AMX0P__ADC0P12 0x0C ///< Select ADC0P.12.              
 181      =2  #define AMX0P_AMX0P__ADC0P13 0x0D ///< Select ADC0P.13.              
 182      =2  #define AMX0P_AMX0P__ADC0P14 0x0E ///< Select ADC0P.14.              
 183      =2  #define AMX0P_AMX0P__ADC0P15 0x0F ///< Select ADC0P.15.              
 184      =2  #define AMX0P_AMX0P__ADC0P16 0x10 ///< Select ADC0P.16.              
 185      =2  #define AMX0P_AMX0P__ADC0P17 0x11 ///< Select ADC0P.17.              
 186      =2  #define AMX0P_AMX0P__ADC0P18 0x12 ///< Select ADC0P.18.              
 187      =2  #define AMX0P_AMX0P__ADC0P19 0x13 ///< Select ADC0P.19.              
 188      =2  #define AMX0P_AMX0P__ADC0P20 0x14 ///< Select ADC0P.20.              
 189      =2  #define AMX0P_AMX0P__ADC0P21 0x15 ///< Select ADC0P.21.              
 190      =2  #define AMX0P_AMX0P__ADC0P22 0x16 ///< Select ADC0P.22.              
 191      =2  #define AMX0P_AMX0P__ADC0P23 0x17 ///< Select ADC0P.23.              
 192      =2  #define AMX0P_AMX0P__ADC0P24 0x18 ///< Select ADC0P.24.              
 193      =2  #define AMX0P_AMX0P__ADC0P25 0x19 ///< Select ADC0P.25.              
 194      =2  #define AMX0P_AMX0P__ADC0P26 0x1A ///< Select ADC0P.26.              
 195      =2  #define AMX0P_AMX0P__ADC0P27 0x1B ///< Select ADC0P.27.              
 196      =2  #define AMX0P_AMX0P__ADC0P28 0x1C ///< Select ADC0P.28.              
 197      =2  #define AMX0P_AMX0P__ADC0P29 0x1D ///< Select ADC0P.29.              
 198      =2  #define AMX0P_AMX0P__TEMP    0x1E ///< Temperature sensor.           
C51 COMPILER V9.56.0.0   UART_0                                                            10/28/2016 17:37:02 PAGE 30  

 199      =2  #define AMX0P_AMX0P__VDD     0x1F ///< VDD Supply Voltage.           
 200      =2  #define AMX0P_AMX0P__ADC0P32 0x20 ///< Select ADC0P.32.              
 201      =2  #define AMX0P_AMX0P__ADC0P33 0x21 ///< Select ADC0P.33.              
 202      =2  #define AMX0P_AMX0P__ADC0P34 0x22 ///< Select ADC0P.34.              
 203      =2                                                                       
 204      =2  //------------------------------------------------------------------------------
 205      =2  // ACC Enums (Accumulator @ 0xE0)
 206      =2  //------------------------------------------------------------------------------
 207      =2  #define ACC_ACC__FMASK 0xFF ///< Accumulator
 208      =2  #define ACC_ACC__SHIFT 0x00 ///< Accumulator
 209      =2                                              
 210      =2  //------------------------------------------------------------------------------
 211      =2  // B Enums (B Register @ 0xF0)
 212      =2  //------------------------------------------------------------------------------
 213      =2  #define B_B__FMASK 0xFF ///< B Register
 214      =2  #define B_B__SHIFT 0x00 ///< B Register
 215      =2                                         
 216      =2  //------------------------------------------------------------------------------
 217      =2  // DPH Enums (Data Pointer High @ 0x83)
 218      =2  //------------------------------------------------------------------------------
 219      =2  #define DPH_DPH__FMASK 0xFF ///< Data Pointer High
 220      =2  #define DPH_DPH__SHIFT 0x00 ///< Data Pointer High
 221      =2                                                    
 222      =2  //------------------------------------------------------------------------------
 223      =2  // DPL Enums (Data Pointer Low @ 0x82)
 224      =2  //------------------------------------------------------------------------------
 225      =2  #define DPL_DPL__FMASK 0xFF ///< Data Pointer Low
 226      =2  #define DPL_DPL__SHIFT 0x00 ///< Data Pointer Low
 227      =2                                                   
 228      =2  //------------------------------------------------------------------------------
 229      =2  // PFE0CN Enums (Prefetch Engine Control @ 0xAF)
 230      =2  //------------------------------------------------------------------------------
 231      =2  #define PFE0CN_FLBWE__BMASK                0x01 ///< Flash Block Write Enable                      
 232      =2  #define PFE0CN_FLBWE__SHIFT                0x00 ///< Flash Block Write Enable                      
 233      =2  #define PFE0CN_FLBWE__BLOCK_WRITE_DISABLED 0x00 ///< Each byte of a firmware flash write is written
 234      =2                                                  ///< individually.                                 
 235      =2  #define PFE0CN_FLBWE__BLOCK_WRITE_ENABLED  0x01 ///< Flash bytes are written in groups of two.     
 236      =2                                                                                                     
 237      =2  #define PFE0CN_PFEN__BMASK                 0x20 ///< Prefetch Enable                               
 238      =2  #define PFE0CN_PFEN__SHIFT                 0x05 ///< Prefetch Enable                               
 239      =2  #define PFE0CN_PFEN__DISABLED              0x00 ///< Disable the prefetch engine (SYSCLK < 25 MHz).
 240      =2  #define PFE0CN_PFEN__ENABLED               0x20 ///< Enable the prefetch engine (SYSCLK > 25 MHz). 
 241      =2                                                                                                     
 242      =2  //------------------------------------------------------------------------------
 243      =2  // PSW Enums (Program Status Word @ 0xD0)
 244      =2  //------------------------------------------------------------------------------
 245      =2  #define PSW_PARITY__BMASK   0x01 ///< Parity Flag                                       
 246      =2  #define PSW_PARITY__SHIFT   0x00 ///< Parity Flag                                       
 247      =2  #define PSW_PARITY__NOT_SET 0x00 ///< The sum of the 8 bits in the accumulator is even. 
 248      =2  #define PSW_PARITY__SET     0x01 ///< The sum of the 8 bits in the accumulator is odd.  
 249      =2                                                                                          
 250      =2  #define PSW_F1__BMASK       0x02 ///< User Flag 1                                       
 251      =2  #define PSW_F1__SHIFT       0x01 ///< User Flag 1                                       
 252      =2  #define PSW_F1__NOT_SET     0x00 ///< Flag is not set.                                  
 253      =2  #define PSW_F1__SET         0x02 ///< Flag is set.                                      
 254      =2                                                                                          
 255      =2  #define PSW_OV__BMASK       0x04 ///< Overflow Flag                                     
 256      =2  #define PSW_OV__SHIFT       0x02 ///< Overflow Flag                                     
 257      =2  #define PSW_OV__NOT_SET     0x00 ///< An overflow did not occur.                        
 258      =2  #define PSW_OV__SET         0x04 ///< An overflow occurred.                             
 259      =2                                                                                          
 260      =2  #define PSW_RS__FMASK       0x18 ///< Register Bank Select                              
C51 COMPILER V9.56.0.0   UART_0                                                            10/28/2016 17:37:02 PAGE 31  

 261      =2  #define PSW_RS__SHIFT       0x03 ///< Register Bank Select                              
 262      =2  #define PSW_RS__BANK0       0x00 ///< Bank 0, Addresses 0x00-0x07                       
 263      =2  #define PSW_RS__BANK1       0x08 ///< Bank 1, Addresses 0x08-0x0F                       
 264      =2  #define PSW_RS__BANK2       0x10 ///< Bank 2, Addresses 0x10-0x17                       
 265      =2  #define PSW_RS__BANK3       0x18 ///< Bank 3, Addresses 0x18-0x1F                       
 266      =2                                                                                          
 267      =2  #define PSW_F0__BMASK       0x20 ///< User Flag 0                                       
 268      =2  #define PSW_F0__SHIFT       0x05 ///< User Flag 0                                       
 269      =2  #define PSW_F0__NOT_SET     0x00 ///< Flag is not set.                                  
 270      =2  #define PSW_F0__SET         0x20 ///< Flag is set.                                      
 271      =2                                                                                          
 272      =2  #define PSW_AC__BMASK       0x40 ///< Auxiliary Carry Flag                              
 273      =2  #define PSW_AC__SHIFT       0x06 ///< Auxiliary Carry Flag                              
 274      =2  #define PSW_AC__NOT_SET     0x00 ///< A carry into (addition) or borrow from            
 275      =2                                   ///< (subtraction) the high order nibble did not occur.
 276      =2  #define PSW_AC__SET         0x40 ///< A carry into (addition) or borrow from            
 277      =2                                   ///< (subtraction) the high order nibble occurred.     
 278      =2                                                                                          
 279      =2  #define PSW_CY__BMASK       0x80 ///< Carry Flag                                        
 280      =2  #define PSW_CY__SHIFT       0x07 ///< Carry Flag                                        
 281      =2  #define PSW_CY__NOT_SET     0x00 ///< A carry (addition) or borrow (subtraction) did not
 282      =2                                   ///< occur.                                            
 283      =2  #define PSW_CY__SET         0x80 ///< A carry (addition) or borrow (subtraction)        
 284      =2                                   ///< occurred.                                         
 285      =2                                                                                          
 286      =2  //------------------------------------------------------------------------------
 287      =2  // SP Enums (Stack Pointer @ 0x81)
 288      =2  //------------------------------------------------------------------------------
 289      =2  #define SP_SP__FMASK 0xFF ///< Stack Pointer
 290      =2  #define SP_SP__SHIFT 0x00 ///< Stack Pointer
 291      =2                                              
 292      =2  //------------------------------------------------------------------------------
 293      =2  // CLKSEL Enums (Clock Select @ 0xA9)
 294      =2  //------------------------------------------------------------------------------
 295      =2  #define CLKSEL_CLKSL__FMASK               0x07 ///< System Clock Source Select Bits                   
 296      =2  #define CLKSEL_CLKSL__SHIFT               0x00 ///< System Clock Source Select Bits                   
 297      =2  #define CLKSEL_CLKSL__DIVIDED_HFOSC_DIV_4 0x00 ///< Clock (SYSCLK) derived from the Internal High-    
 298      =2                                                 ///< Frequency Oscillator / 4 and scaled per the IFCN  
 299      =2                                                 ///< bits in register OSCICN.                          
 300      =2  #define CLKSEL_CLKSL__EXTOSC              0x01 ///< Clock (SYSCLK) derived from the External          
 301      =2                                                 ///< Oscillator circuit.                               
 302      =2  #define CLKSEL_CLKSL__HFOSC_DIV_2         0x02 ///< Clock (SYSCLK) derived from the Internal High-    
 303      =2                                                 ///< Frequency Oscillator / 2.                         
 304      =2  #define CLKSEL_CLKSL__HFOSC               0x03 ///< Clock (SYSCLK) derived from the Internal High-    
 305      =2                                                 ///< Frequency Oscillator.                             
 306      =2  #define CLKSEL_CLKSL__LFOSC               0x04 ///< Clock (SYSCLK) derived from the Internal Low-     
 307      =2                                                 ///< Frequency Oscillator and scaled per the OSCLD bits
 308      =2                                                 ///< in register OSCLCN.                               
 309      =2                                                                                                        
 310      =2  #define CLKSEL_OUTCLK__BMASK              0x08 ///< Crossbar Clock Out Select                         
 311      =2  #define CLKSEL_OUTCLK__SHIFT              0x03 ///< Crossbar Clock Out Select                         
 312      =2  #define CLKSEL_OUTCLK__SYSCLK             0x00 ///< Enabling the Crossbar SYSCLK signal outputs       
 313      =2                                                 ///< SYSCLK.                                           
 314      =2  #define CLKSEL_OUTCLK__SYSCLK_SYNC_IO     0x08 ///< Enabling the Crossbar SYSCLK signal outputs SYSCLK
 315      =2                                                 ///< synchronized with the Port I/O.                   
 316      =2                                                                                                        
 317      =2  #define CLKSEL_USBCLK__FMASK              0x70 ///< USB Clock Source Select Bits                      
 318      =2  #define CLKSEL_USBCLK__SHIFT              0x04 ///< USB Clock Source Select Bits                      
 319      =2  #define CLKSEL_USBCLK__HFOSC              0x00 ///< USB clock (USBCLK) derived from the Internal High-
 320      =2                                                 ///< Frequency Oscillator.                             
 321      =2  #define CLKSEL_USBCLK__HFOSC_DIV_8        0x10 ///< USB clock (USBCLK) derived from the Internal High-
 322      =2                                                 ///< Frequency Oscillator / 8.                         
C51 COMPILER V9.56.0.0   UART_0                                                            10/28/2016 17:37:02 PAGE 32  

 323      =2  #define CLKSEL_USBCLK__EXTOSC             0x20 ///< USB clock (USBCLK) derived from the External      
 324      =2                                                 ///< Oscillator.                                       
 325      =2  #define CLKSEL_USBCLK__EXTOSC_DIV_2       0x30 ///< USB clock (USBCLK) derived from the External      
 326      =2                                                 ///< Oscillator / 2.                                   
 327      =2  #define CLKSEL_USBCLK__EXTOSC_DIV_3       0x40 ///< USB clock (USBCLK) derived from the External      
 328      =2                                                 ///< Oscillator / 3.                                   
 329      =2  #define CLKSEL_USBCLK__EXTOSC_DIV_4       0x50 ///< USB clock (USBCLK) derived from the External      
 330      =2                                                 ///< Oscillator / 4.                                   
 331      =2  #define CLKSEL_USBCLK__LFOSC              0x60 ///< USB clock (USBCLK) derived from the Internal Low- 
 332      =2                                                 ///< Frequency Oscillator.                             
 333      =2                                                                                                        
 334      =2  //------------------------------------------------------------------------------
 335      =2  // CMP0CN0 Enums (Comparator 0 Control 0 @ 0x9B)
 336      =2  //------------------------------------------------------------------------------
 337      =2  #define CMP0CN0_CPHYN__FMASK                0x03 ///< Comparator Negative Hysteresis Control            
 338      =2  #define CMP0CN0_CPHYN__SHIFT                0x00 ///< Comparator Negative Hysteresis Control            
 339      =2  #define CMP0CN0_CPHYN__DISABLED             0x00 ///< Negative Hysteresis disabled.                     
 340      =2  #define CMP0CN0_CPHYN__ENABLED_MODE1        0x01 ///< Negative Hysteresis = Hysteresis 1.               
 341      =2  #define CMP0CN0_CPHYN__ENABLED_MODE2        0x02 ///< Negative Hysteresis = Hysteresis 2.               
 342      =2  #define CMP0CN0_CPHYN__ENABLED_MODE3        0x03 ///< Negative Hysteresis = Hysteresis 3 (Maximum).     
 343      =2                                                                                                          
 344      =2  #define CMP0CN0_CPHYP__FMASK                0x0C ///< Comparator Positive Hysteresis Control            
 345      =2  #define CMP0CN0_CPHYP__SHIFT                0x02 ///< Comparator Positive Hysteresis Control            
 346      =2  #define CMP0CN0_CPHYP__DISABLED             0x00 ///< Positive Hysteresis disabled.                     
 347      =2  #define CMP0CN0_CPHYP__ENABLED_MODE1        0x04 ///< Positive Hysteresis = Hysteresis 1.               
 348      =2  #define CMP0CN0_CPHYP__ENABLED_MODE2        0x08 ///< Positive Hysteresis = Hysteresis 2.               
 349      =2  #define CMP0CN0_CPHYP__ENABLED_MODE3        0x0C ///< Positive Hysteresis = Hysteresis 3 (Maximum).     
 350      =2                                                                                                          
 351      =2  #define CMP0CN0_CPFIF__BMASK                0x10 ///< Comparator Falling-Edge Flag                      
 352      =2  #define CMP0CN0_CPFIF__SHIFT                0x04 ///< Comparator Falling-Edge Flag                      
 353      =2  #define CMP0CN0_CPFIF__NOT_SET              0x00 ///< No comparator falling edge has occurred since this
 354      =2                                                   ///< flag was last cleared.                            
 355      =2  #define CMP0CN0_CPFIF__FALLING_EDGE         0x10 ///< Comparator falling edge has occurred.             
 356      =2                                                                                                          
 357      =2  #define CMP0CN0_CPRIF__BMASK                0x20 ///< Comparator Rising-Edge Flag                       
 358      =2  #define CMP0CN0_CPRIF__SHIFT                0x05 ///< Comparator Rising-Edge Flag                       
 359      =2  #define CMP0CN0_CPRIF__NOT_SET              0x00 ///< No comparator rising edge has occurred since this 
 360      =2                                                   ///< flag was last cleared.                            
 361      =2  #define CMP0CN0_CPRIF__RISING_EDGE          0x20 ///< Comparator rising edge has occurred.              
 362      =2                                                                                                          
 363      =2  #define CMP0CN0_CPOUT__BMASK                0x40 ///< Comparator Output State Flag                      
 364      =2  #define CMP0CN0_CPOUT__SHIFT                0x06 ///< Comparator Output State Flag                      
 365      =2  #define CMP0CN0_CPOUT__POS_LESS_THAN_NEG    0x00 ///< Voltage on CP0P < CP0N.                           
 366      =2  #define CMP0CN0_CPOUT__POS_GREATER_THAN_NEG 0x40 ///< Voltage on CP0P > CP0N.                           
 367      =2                                                                                                          
 368      =2  #define CMP0CN0_CPEN__BMASK                 0x80 ///< Comparator Enable                                 
 369      =2  #define CMP0CN0_CPEN__SHIFT                 0x07 ///< Comparator Enable                                 
 370      =2  #define CMP0CN0_CPEN__DISABLED              0x00 ///< Comparator disabled.                              
 371      =2  #define CMP0CN0_CPEN__ENABLED               0x80 ///< Comparator enabled.                               
 372      =2                                                                                                          
 373      =2  //------------------------------------------------------------------------------
 374      =2  // CMP0MD Enums (Comparator 0 Mode @ 0x9D)
 375      =2  //------------------------------------------------------------------------------
 376      =2  #define CMP0MD_CPMD__FMASK              0x03 ///< Comparator Mode Select                      
 377      =2  #define CMP0MD_CPMD__SHIFT              0x00 ///< Comparator Mode Select                      
 378      =2  #define CMP0MD_CPMD__MODE0              0x00 ///< Mode 0 (Fastest Response Time, Highest Power
 379      =2                                               ///< Consumption)                                
 380      =2  #define CMP0MD_CPMD__MODE1              0x01 ///< Mode 1                                      
 381      =2  #define CMP0MD_CPMD__MODE2              0x02 ///< Mode 2                                      
 382      =2  #define CMP0MD_CPMD__MODE3              0x03 ///< Mode 3 (Slowest Response Time, Lowest Power 
 383      =2                                               ///< Consumption)                                
 384      =2                                                                                                
C51 COMPILER V9.56.0.0   UART_0                                                            10/28/2016 17:37:02 PAGE 33  

 385      =2  #define CMP0MD_CPFIE__BMASK             0x10 ///< Comparator Falling-Edge Interrupt Enable    
 386      =2  #define CMP0MD_CPFIE__SHIFT             0x04 ///< Comparator Falling-Edge Interrupt Enable    
 387      =2  #define CMP0MD_CPFIE__FALL_INT_DISABLED 0x00 ///< Comparator falling-edge interrupt disabled. 
 388      =2  #define CMP0MD_CPFIE__FALL_INT_ENABLED  0x10 ///< Comparator falling-edge interrupt enabled.  
 389      =2                                                                                                
 390      =2  #define CMP0MD_CPRIE__BMASK             0x20 ///< Comparator Rising-Edge Interrupt Enable     
 391      =2  #define CMP0MD_CPRIE__SHIFT             0x05 ///< Comparator Rising-Edge Interrupt Enable     
 392      =2  #define CMP0MD_CPRIE__RISE_INT_DISABLED 0x00 ///< Comparator rising-edge interrupt disabled.  
 393      =2  #define CMP0MD_CPRIE__RISE_INT_ENABLED  0x20 ///< Comparator rising-edge interrupt enabled.   
 394      =2                                                                                                
 395      =2  //------------------------------------------------------------------------------
 396      =2  // CMP0MX Enums (Comparator 0 Multiplexer Selection @ 0x9F)
 397      =2  //------------------------------------------------------------------------------
 398      =2  #define CMP0MX_CMXP__FMASK  0x07 ///< Comparator Positive Input MUX Selection
 399      =2  #define CMP0MX_CMXP__SHIFT  0x00 ///< Comparator Positive Input MUX Selection
 400      =2  #define CMP0MX_CMXP__CMP0P0 0x00 ///< External pin CMP0P.0.                  
 401      =2  #define CMP0MX_CMXP__CMP0P1 0x01 ///< External pin CMP0P.1.                  
 402      =2  #define CMP0MX_CMXP__CMP0P2 0x02 ///< External pin CMP0P.2.                  
 403      =2  #define CMP0MX_CMXP__CMP0P3 0x03 ///< External pin CMP0P.3.                  
 404      =2  #define CMP0MX_CMXP__CMP0P4 0x04 ///< External pin CMP0P.4.                  
 405      =2                                                                               
 406      =2  #define CMP0MX_CMXN__FMASK  0x70 ///< Comparator Negative Input MUX Selection
 407      =2  #define CMP0MX_CMXN__SHIFT  0x04 ///< Comparator Negative Input MUX Selection
 408      =2  #define CMP0MX_CMXN__CMP0N0 0x00 ///< External pin CMP0N.0.                  
 409      =2  #define CMP0MX_CMXN__CMP0N1 0x10 ///< External pin CMP0N.1.                  
 410      =2  #define CMP0MX_CMXN__CMP0N2 0x20 ///< External pin CMP0N.2.                  
 411      =2  #define CMP0MX_CMXN__CMP0N3 0x30 ///< External pin CMP0N.3.                  
 412      =2  #define CMP0MX_CMXN__CMP0N4 0x40 ///< External pin CMP0N.4.                  
 413      =2                                                                               
 414      =2  //------------------------------------------------------------------------------
 415      =2  // CMP1CN0 Enums (Comparator 1 Control 0 @ 0x9A)
 416      =2  //------------------------------------------------------------------------------
 417      =2  #define CMP1CN0_CPHYN__FMASK                0x03 ///< Comparator Negative Hysteresis Control            
 418      =2  #define CMP1CN0_CPHYN__SHIFT                0x00 ///< Comparator Negative Hysteresis Control            
 419      =2  #define CMP1CN0_CPHYN__DISABLED             0x00 ///< Negative Hysteresis disabled.                     
 420      =2  #define CMP1CN0_CPHYN__ENABLED_MODE1        0x01 ///< Negative Hysteresis = Hysteresis 1.               
 421      =2  #define CMP1CN0_CPHYN__ENABLED_MODE2        0x02 ///< Negative Hysteresis = Hysteresis 2.               
 422      =2  #define CMP1CN0_CPHYN__ENABLED_MODE3        0x03 ///< Negative Hysteresis = Hysteresis 3 (Maximum).     
 423      =2                                                                                                          
 424      =2  #define CMP1CN0_CPHYP__FMASK                0x0C ///< Comparator Positive Hysteresis Control            
 425      =2  #define CMP1CN0_CPHYP__SHIFT                0x02 ///< Comparator Positive Hysteresis Control            
 426      =2  #define CMP1CN0_CPHYP__DISABLED             0x00 ///< Positive Hysteresis disabled.                     
 427      =2  #define CMP1CN0_CPHYP__ENABLED_MODE1        0x04 ///< Positive Hysteresis = Hysteresis 1.               
 428      =2  #define CMP1CN0_CPHYP__ENABLED_MODE2        0x08 ///< Positive Hysteresis = Hysteresis 2.               
 429      =2  #define CMP1CN0_CPHYP__ENABLED_MODE3        0x0C ///< Positive Hysteresis = Hysteresis 3 (Maximum).     
 430      =2                                                                                                          
 431      =2  #define CMP1CN0_CPFIF__BMASK                0x10 ///< Comparator Falling-Edge Flag                      
 432      =2  #define CMP1CN0_CPFIF__SHIFT                0x04 ///< Comparator Falling-Edge Flag                      
 433      =2  #define CMP1CN0_CPFIF__NOT_SET              0x00 ///< No comparator falling edge has occurred since this
 434      =2                                                   ///< flag was last cleared.                            
 435      =2  #define CMP1CN0_CPFIF__FALLING_EDGE         0x10 ///< Comparator falling edge has occurred.             
 436      =2                                                                                                          
 437      =2  #define CMP1CN0_CPRIF__BMASK                0x20 ///< Comparator Rising-Edge Flag                       
 438      =2  #define CMP1CN0_CPRIF__SHIFT                0x05 ///< Comparator Rising-Edge Flag                       
 439      =2  #define CMP1CN0_CPRIF__NOT_SET              0x00 ///< No comparator rising edge has occurred since this 
 440      =2                                                   ///< flag was last cleared.                            
 441      =2  #define CMP1CN0_CPRIF__RISING_EDGE          0x20 ///< Comparator rising edge has occurred.              
 442      =2                                                                                                          
 443      =2  #define CMP1CN0_CPOUT__BMASK                0x40 ///< Comparator Output State Flag                      
 444      =2  #define CMP1CN0_CPOUT__SHIFT                0x06 ///< Comparator Output State Flag                      
 445      =2  #define CMP1CN0_CPOUT__POS_LESS_THAN_NEG    0x00 ///< Voltage on CP1P < CP1N.                           
 446      =2  #define CMP1CN0_CPOUT__POS_GREATER_THAN_NEG 0x40 ///< Voltage on CP1P > CP1N.                           
C51 COMPILER V9.56.0.0   UART_0                                                            10/28/2016 17:37:02 PAGE 34  

 447      =2                                                                                                          
 448      =2  #define CMP1CN0_CPEN__BMASK                 0x80 ///< Comparator Enable                                 
 449      =2  #define CMP1CN0_CPEN__SHIFT                 0x07 ///< Comparator Enable                                 
 450      =2  #define CMP1CN0_CPEN__DISABLED              0x00 ///< Comparator disabled.                              
 451      =2  #define CMP1CN0_CPEN__ENABLED               0x80 ///< Comparator enabled.                               
 452      =2                                                                                                          
 453      =2  //------------------------------------------------------------------------------
 454      =2  // CMP1MD Enums (Comparator 1 Mode @ 0x9C)
 455      =2  //------------------------------------------------------------------------------
 456      =2  #define CMP1MD_CPMD__FMASK              0x03 ///< Comparator Mode Select                      
 457      =2  #define CMP1MD_CPMD__SHIFT              0x00 ///< Comparator Mode Select                      
 458      =2  #define CMP1MD_CPMD__MODE0              0x00 ///< Mode 0 (Fastest Response Time, Highest Power
 459      =2                                               ///< Consumption)                                
 460      =2  #define CMP1MD_CPMD__MODE1              0x01 ///< Mode 1                                      
 461      =2  #define CMP1MD_CPMD__MODE2              0x02 ///< Mode 2                                      
 462      =2  #define CMP1MD_CPMD__MODE3              0x03 ///< Mode 3 (Slowest Response Time, Lowest Power 
 463      =2                                               ///< Consumption)                                
 464      =2                                                                                                
 465      =2  #define CMP1MD_CPFIE__BMASK             0x10 ///< Comparator Falling-Edge Interrupt Enable    
 466      =2  #define CMP1MD_CPFIE__SHIFT             0x04 ///< Comparator Falling-Edge Interrupt Enable    
 467      =2  #define CMP1MD_CPFIE__FALL_INT_DISABLED 0x00 ///< Comparator falling-edge interrupt disabled. 
 468      =2  #define CMP1MD_CPFIE__FALL_INT_ENABLED  0x10 ///< Comparator falling-edge interrupt enabled.  
 469      =2                                                                                                
 470      =2  #define CMP1MD_CPRIE__BMASK             0x20 ///< Comparator Rising-Edge Interrupt Enable     
 471      =2  #define CMP1MD_CPRIE__SHIFT             0x05 ///< Comparator Rising-Edge Interrupt Enable     
 472      =2  #define CMP1MD_CPRIE__RISE_INT_DISABLED 0x00 ///< Comparator rising-edge interrupt disabled.  
 473      =2  #define CMP1MD_CPRIE__RISE_INT_ENABLED  0x20 ///< Comparator rising-edge interrupt enabled.   
 474      =2                                                                                                
 475      =2  //------------------------------------------------------------------------------
 476      =2  // CMP1MX Enums (Comparator 1 Multiplexer Selection @ 0x9E)
 477      =2  //------------------------------------------------------------------------------
 478      =2  #define CMP1MX_CMXP__FMASK  0x07 ///< Comparator Positive Input MUX Selection
 479      =2  #define CMP1MX_CMXP__SHIFT  0x00 ///< Comparator Positive Input MUX Selection
 480      =2  #define CMP1MX_CMXP__CMP1P0 0x00 ///< External pin CMP1P.0.                  
 481      =2  #define CMP1MX_CMXP__CMP1P1 0x01 ///< External pin CMP1P.1.                  
 482      =2  #define CMP1MX_CMXP__CMP1P2 0x02 ///< External pin CMP1P.2.                  
 483      =2  #define CMP1MX_CMXP__CMP1P3 0x03 ///< External pin CMP1P.3.                  
 484      =2  #define CMP1MX_CMXP__CMP1P4 0x04 ///< External pin CMP1P.4.                  
 485      =2                                                                               
 486      =2  #define CMP1MX_CMXN__FMASK  0x70 ///< Comparator Negative Input MUX Selection
 487      =2  #define CMP1MX_CMXN__SHIFT  0x04 ///< Comparator Negative Input MUX Selection
 488      =2  #define CMP1MX_CMXN__CMP1N0 0x00 ///< External pin CMP1N.0.                  
 489      =2  #define CMP1MX_CMXN__CMP1N1 0x10 ///< External pin CMP1N.1.                  
 490      =2  #define CMP1MX_CMXN__CMP1N2 0x20 ///< External pin CMP1N.2.                  
 491      =2  #define CMP1MX_CMXN__CMP1N3 0x30 ///< External pin CMP1N.3.                  
 492      =2  #define CMP1MX_CMXN__CMP1N4 0x40 ///< External pin CMP1N.4.                  
 493      =2                                                                               
 494      =2  //------------------------------------------------------------------------------
 495      =2  // IT01CF Enums (INT0/INT1 Configuration @ 0xE4)
 496      =2  //------------------------------------------------------------------------------
 497      =2  #define IT01CF_IN0SL__FMASK       0x07 ///< INT0 Port Pin Selection   
 498      =2  #define IT01CF_IN0SL__SHIFT       0x00 ///< INT0 Port Pin Selection   
 499      =2  #define IT01CF_IN0SL__P0_0        0x00 ///< Select P0.0.              
 500      =2  #define IT01CF_IN0SL__P0_1        0x01 ///< Select P0.1.              
 501      =2  #define IT01CF_IN0SL__P0_2        0x02 ///< Select P0.2.              
 502      =2  #define IT01CF_IN0SL__P0_3        0x03 ///< Select P0.3.              
 503      =2  #define IT01CF_IN0SL__P0_4        0x04 ///< Select P0.4.              
 504      =2  #define IT01CF_IN0SL__P0_5        0x05 ///< Select P0.5.              
 505      =2  #define IT01CF_IN0SL__P0_6        0x06 ///< Select P0.6.              
 506      =2  #define IT01CF_IN0SL__P0_7        0x07 ///< Select P0.7.              
 507      =2                                                                        
 508      =2  #define IT01CF_IN0PL__BMASK       0x08 ///< INT0 Polarity             
C51 COMPILER V9.56.0.0   UART_0                                                            10/28/2016 17:37:02 PAGE 35  

 509      =2  #define IT01CF_IN0PL__SHIFT       0x03 ///< INT0 Polarity             
 510      =2  #define IT01CF_IN0PL__ACTIVE_LOW  0x00 ///< INT0 input is active low. 
 511      =2  #define IT01CF_IN0PL__ACTIVE_HIGH 0x08 ///< INT0 input is active high.
 512      =2                                                                        
 513      =2  #define IT01CF_IN1SL__FMASK       0x70 ///< INT1 Port Pin Selection   
 514      =2  #define IT01CF_IN1SL__SHIFT       0x04 ///< INT1 Port Pin Selection   
 515      =2  #define IT01CF_IN1SL__P0_0        0x00 ///< Select P0.0.              
 516      =2  #define IT01CF_IN1SL__P0_1        0x10 ///< Select P0.1.              
 517      =2  #define IT01CF_IN1SL__P0_2        0x20 ///< Select P0.2.              
 518      =2  #define IT01CF_IN1SL__P0_3        0x30 ///< Select P0.3.              
 519      =2  #define IT01CF_IN1SL__P0_4        0x40 ///< Select P0.4.              
 520      =2  #define IT01CF_IN1SL__P0_5        0x50 ///< Select P0.5.              
 521      =2  #define IT01CF_IN1SL__P0_6        0x60 ///< Select P0.6.              
 522      =2  #define IT01CF_IN1SL__P0_7        0x70 ///< Select P0.7.              
 523      =2                                                                        
 524      =2  #define IT01CF_IN1PL__BMASK       0x80 ///< INT1 Polarity             
 525      =2  #define IT01CF_IN1PL__SHIFT       0x07 ///< INT1 Polarity             
 526      =2  #define IT01CF_IN1PL__ACTIVE_LOW  0x00 ///< INT1 input is active low. 
 527      =2  #define IT01CF_IN1PL__ACTIVE_HIGH 0x80 ///< INT1 input is active high.
 528      =2                                                                        
 529      =2  //------------------------------------------------------------------------------
 530      =2  // XOSC0CN Enums (External Oscillator Control @ 0xB1)
 531      =2  //------------------------------------------------------------------------------
 532      =2  #define XOSC0CN_XFCN__FMASK           0x07 ///< External Oscillator Frequency Control            
 533      =2  #define XOSC0CN_XFCN__SHIFT           0x00 ///< External Oscillator Frequency Control            
 534      =2  #define XOSC0CN_XFCN__MODE0           0x00 ///< Select external oscillator mode 0: Crystal       
 535      =2                                             ///< frequency <= 20 kHz, RC/C frequency <= 25 kHz, C 
 536      =2                                             ///< mode K factor = 0.87.                            
 537      =2  #define XOSC0CN_XFCN__MODE1           0x01 ///< Select external oscillator mode 1: 20 kHz <      
 538      =2                                             ///< Crystal frequency <= 58 kHz, 25 kHz < RC/C       
 539      =2                                             ///< frequency <= 50 kHz, C mode K factor = 2.6.      
 540      =2  #define XOSC0CN_XFCN__MODE2           0x02 ///< Select external oscillator mode 2: 58 kHz <      
 541      =2                                             ///< Crystal frequency <= 155 kHz, 50 kHz < RC/C      
 542      =2                                             ///< frequency <= 100 kHz, C mode K factor = 7.7.     
 543      =2  #define XOSC0CN_XFCN__MODE3           0x03 ///< Select external oscillator mode 3: 155 kHz <     
 544      =2                                             ///< Crystal frequency <= 415 kHz, 100 kHz < RC/C     
 545      =2                                             ///< frequency <= 200 kHz, C mode K factor = 22.      
 546      =2  #define XOSC0CN_XFCN__MODE4           0x04 ///< Select external oscillator mode 4: 415 kHz <     
 547      =2                                             ///< Crystal frequency <= 1.1 MHz, 200 kHz < RC/C     
 548      =2                                             ///< frequency <= 400 kHz, C mode K factor = 65.      
 549      =2  #define XOSC0CN_XFCN__MODE5           0x05 ///< Select external oscillator mode 5: 1.1 MHz <     
 550      =2                                             ///< Crystal frequency <= 3.1 MHz, 400 kHz < RC/C     
 551      =2                                             ///< frequency <= 800 kHz, C mode K factor = 180.     
 552      =2  #define XOSC0CN_XFCN__MODE6           0x06 ///< Select external oscillator mode 6: 3.1 MHz <     
 553      =2                                             ///< Crystal frequency <= 8.2 kHz, 800 kHz < RC/C     
 554      =2                                             ///< frequency <= 1.6 MHz, C mode K factor = 664.     
 555      =2  #define XOSC0CN_XFCN__MODE7           0x07 ///< Select external oscillator mode 7: 8.2 MHz <     
 556      =2                                             ///< Crystal frequency <= 25 MHz, 1.6 MHz < RC/C      
 557      =2                                             ///< frequency <= 3.2 MHz, C mode K factor = 1590.    
 558      =2                                                                                                   
 559      =2  #define XOSC0CN_XOSCMD__FMASK         0x70 ///< External Oscillator Mode                         
 560      =2  #define XOSC0CN_XOSCMD__SHIFT         0x04 ///< External Oscillator Mode                         
 561      =2  #define XOSC0CN_XOSCMD__DISABLED      0x00 ///< External Oscillator circuit disabled.            
 562      =2  #define XOSC0CN_XOSCMD__CMOS          0x20 ///< External CMOS Clock Mode.                        
 563      =2  #define XOSC0CN_XOSCMD__CMOS_DIV_2    0x30 ///< External CMOS Clock Mode with divide by 2 stage. 
 564      =2  #define XOSC0CN_XOSCMD__RC_DIV_2      0x40 ///< RC Oscillator Mode with divide by 2 stage.       
 565      =2  #define XOSC0CN_XOSCMD__C_DIV_2       0x50 ///< Capacitor Oscillator Mode with divide by 2 stage.
 566      =2  #define XOSC0CN_XOSCMD__CRYSTAL       0x60 ///< Crystal Oscillator Mode.                         
 567      =2  #define XOSC0CN_XOSCMD__CRYSTAL_DIV_2 0x70 ///< Crystal Oscillator Mode with divide by 2 stage.  
 568      =2                                                                                                   
 569      =2  #define XOSC0CN_XCLKVLD__BMASK        0x80 ///< External Oscillator Valid Flag                   
 570      =2  #define XOSC0CN_XCLKVLD__SHIFT        0x07 ///< External Oscillator Valid Flag                   
C51 COMPILER V9.56.0.0   UART_0                                                            10/28/2016 17:37:02 PAGE 36  

 571      =2  #define XOSC0CN_XCLKVLD__NOT_SET      0x00 ///< External Oscillator is unused or not yet stable. 
 572      =2  #define XOSC0CN_XCLKVLD__SET          0x80 ///< External Oscillator is running and stable.       
 573      =2                                                                                                   
 574      =2  //------------------------------------------------------------------------------
 575      =2  // FLKEY Enums (Flash Lock and Key @ 0xB7)
 576      =2  //------------------------------------------------------------------------------
 577      =2  #define FLKEY_FLKEY__FMASK    0xFF ///< Flash Lock and Key                             
 578      =2  #define FLKEY_FLKEY__SHIFT    0x00 ///< Flash Lock and Key                             
 579      =2  #define FLKEY_FLKEY__LOCKED   0x00 ///< Flash is write/erase locked.                   
 580      =2  #define FLKEY_FLKEY__FIRST    0x01 ///< The first key code has been written (0xA5).    
 581      =2  #define FLKEY_FLKEY__UNLOCKED 0x02 ///< Flash is unlocked (writes/erases allowed).     
 582      =2  #define FLKEY_FLKEY__DISABLED 0x03 ///< Flash writes/erases are disabled until the next
 583      =2                                     ///< reset.                                         
 584      =2  #define FLKEY_FLKEY__KEY1     0xA5 ///< Flash writes and erases are enabled by writing 
 585      =2                                     ///< 0xA5 followed by 0xF1 to the FLKEY register.   
 586      =2  #define FLKEY_FLKEY__KEY2     0xF1 ///< Flash writes and erases are enabled by writing 
 587      =2                                     ///< 0xA5 followed by 0xF1 to the FLKEY register.   
 588      =2                                                                                         
 589      =2  //------------------------------------------------------------------------------
 590      =2  // FLSCL Enums (Flash Scale @ 0xB6)
 591      =2  //------------------------------------------------------------------------------
 592      =2  #define FLSCL_FLRT__BMASK               0x10 ///< Flash Read Timing                       
 593      =2  #define FLSCL_FLRT__SHIFT               0x04 ///< Flash Read Timing                       
 594      =2  #define FLSCL_FLRT__SYSCLK_BELOW_25_MHZ 0x00 ///< SYSCLK <= 25 MHz.                       
 595      =2  #define FLSCL_FLRT__SYSCLK_BELOW_48_MHZ 0x10 ///< SYSCLK <= 48 MHz.                       
 596      =2                                                                                            
 597      =2  #define FLSCL_FOSE__BMASK               0x80 ///< Flash One-Shot Enable                   
 598      =2  #define FLSCL_FOSE__SHIFT               0x07 ///< Flash One-Shot Enable                   
 599      =2  #define FLSCL_FOSE__DISABLED            0x00 ///< Disable the flash one-shot.             
 600      =2  #define FLSCL_FOSE__ENABLED             0x80 ///< Enable the flash one-shot (recommended).
 601      =2                                                                                            
 602      =2  //------------------------------------------------------------------------------
 603      =2  // PSCTL Enums (Program Store Control @ 0x8F)
 604      =2  //------------------------------------------------------------------------------
 605      =2  #define PSCTL_PSWE__BMASK          0x01 ///< Program Store Write Enable                      
 606      =2  #define PSCTL_PSWE__SHIFT          0x00 ///< Program Store Write Enable                      
 607      =2  #define PSCTL_PSWE__WRITE_DISABLED 0x00 ///< Writes to flash program memory disabled.        
 608      =2  #define PSCTL_PSWE__WRITE_ENABLED  0x01 ///< Writes to flash program memory enabled; the MOVX
 609      =2                                          ///< write instruction targets flash memory.         
 610      =2                                                                                               
 611      =2  #define PSCTL_PSEE__BMASK          0x02 ///< Program Store Erase Enable                      
 612      =2  #define PSCTL_PSEE__SHIFT          0x01 ///< Program Store Erase Enable                      
 613      =2  #define PSCTL_PSEE__ERASE_DISABLED 0x00 ///< Flash program memory erasure disabled.          
 614      =2  #define PSCTL_PSEE__ERASE_ENABLED  0x02 ///< Flash program memory erasure enabled.           
 615      =2                                                                                               
 616      =2  //------------------------------------------------------------------------------
 617      =2  // HFO0CAL Enums (High Frequency Oscillator Calibration @ 0xB3)
 618      =2  //------------------------------------------------------------------------------
 619      =2  #define HFO0CAL_OSCICL__FMASK 0x7F ///< Internal Oscillator Calibration
 620      =2  #define HFO0CAL_OSCICL__SHIFT 0x00 ///< Internal Oscillator Calibration
 621      =2                                                                         
 622      =2  //------------------------------------------------------------------------------
 623      =2  // HFO0CN Enums (High Frequency Oscillator Control @ 0xB2)
 624      =2  //------------------------------------------------------------------------------
 625      =2  #define HFO0CN_IFCN__FMASK        0x03 ///< Oscillator Frequency Divider Control              
 626      =2  #define HFO0CN_IFCN__SHIFT        0x00 ///< Oscillator Frequency Divider Control              
 627      =2  #define HFO0CN_IFCN__SYSCLK_DIV_8 0x00 ///< SYSCLK can be derived from Internal H-F Oscillator
 628      =2                                         ///< divided by 8 (1.5 MHz).                           
 629      =2  #define HFO0CN_IFCN__SYSCLK_DIV_4 0x01 ///< SYSCLK can be derived from Internal H-F Oscillator
 630      =2                                         ///< divided by 4 (3 MHz).                             
 631      =2  #define HFO0CN_IFCN__SYSCLK_DIV_2 0x02 ///< SYSCLK can be derived from Internal H-F Oscillator
 632      =2                                         ///< divided by 2 (6 MHz).                             
C51 COMPILER V9.56.0.0   UART_0                                                            10/28/2016 17:37:02 PAGE 37  

 633      =2  #define HFO0CN_IFCN__SYSCLK_DIV_1 0x03 ///< SYSCLK can be derived from Internal H-F Oscillator
 634      =2                                         ///< divided by 1 (12 MHz).                            
 635      =2                                                                                                
 636      =2  #define HFO0CN_SUSPEND__BMASK     0x20 ///< Oscillator Suspend Enable                         
 637      =2  #define HFO0CN_SUSPEND__SHIFT     0x05 ///< Oscillator Suspend Enable                         
 638      =2  #define HFO0CN_SUSPEND__DISABLED  0x00 ///< The internal oscillator is not in suspend mode.   
 639      =2  #define HFO0CN_SUSPEND__ENABLED   0x20 ///< Place the internal oscillator in suspend mode.    
 640      =2                                                                                                
 641      =2  #define HFO0CN_IFRDY__BMASK       0x40 ///< Oscillator Frequency Ready Flag                   
 642      =2  #define HFO0CN_IFRDY__SHIFT       0x06 ///< Oscillator Frequency Ready Flag                   
 643      =2  #define HFO0CN_IFRDY__NOT_SET     0x00 ///< The Internal High Frequency Oscillator is not     
 644      =2                                         ///< running at the programmed frequency.              
 645      =2  #define HFO0CN_IFRDY__SET         0x40 ///< The Internal High Frequency Oscillator is running 
 646      =2                                         ///< at the programmed frequency.                      
 647      =2                                                                                                
 648      =2  #define HFO0CN_IOSCEN__BMASK      0x80 ///< Oscillator Enable                                 
 649      =2  #define HFO0CN_IOSCEN__SHIFT      0x07 ///< Oscillator Enable                                 
 650      =2  #define HFO0CN_IOSCEN__DISABLED   0x00 ///< Disable the High Frequency Oscillator.            
 651      =2  #define HFO0CN_IOSCEN__ENABLED    0x80 ///< Enable the High Frequency Oscillator.             
 652      =2                                                                                                
 653      =2  //------------------------------------------------------------------------------
 654      =2  // EIE1 Enums (Extended Interrupt Enable 1 @ 0xE6)
 655      =2  //------------------------------------------------------------------------------
 656      =2  #define EIE1_ESMB0__BMASK     0x01 ///< SMBus (SMB0) Interrupt Enable                     
 657      =2  #define EIE1_ESMB0__SHIFT     0x00 ///< SMBus (SMB0) Interrupt Enable                     
 658      =2  #define EIE1_ESMB0__DISABLED  0x00 ///< Disable all SMB0 interrupts.                      
 659      =2  #define EIE1_ESMB0__ENABLED   0x01 ///< Enable interrupt requests generated by SMB0.      
 660      =2                                                                                            
 661      =2  #define EIE1_EUSB0__BMASK     0x02 ///< USB (USB0) Interrupt Enable                       
 662      =2  #define EIE1_EUSB0__SHIFT     0x01 ///< USB (USB0) Interrupt Enable                       
 663      =2  #define EIE1_EUSB0__DISABLED  0x00 ///< Disable all USB0 interrupts.                      
 664      =2  #define EIE1_EUSB0__ENABLED   0x02 ///< Enable interrupt requests generated by USB0.      
 665      =2                                                                                            
 666      =2  #define EIE1_EWADC0__BMASK    0x04 ///< ADC0 Window Comparison Interrupt Enable           
 667      =2  #define EIE1_EWADC0__SHIFT    0x02 ///< ADC0 Window Comparison Interrupt Enable           
 668      =2  #define EIE1_EWADC0__DISABLED 0x00 ///< Disable ADC0 Window Comparison interrupt.         
 669      =2  #define EIE1_EWADC0__ENABLED  0x04 ///< Enable interrupt requests generated by ADC0 Window
 670      =2                                     ///< Compare flag (ADWINT).                            
 671      =2                                                                                            
 672      =2  #define EIE1_EADC0__BMASK     0x08 ///< ADC0 Conversion Complete Interrupt Enable         
 673      =2  #define EIE1_EADC0__SHIFT     0x03 ///< ADC0 Conversion Complete Interrupt Enable         
 674      =2  #define EIE1_EADC0__DISABLED  0x00 ///< Disable ADC0 Conversion Complete interrupt.       
 675      =2  #define EIE1_EADC0__ENABLED   0x08 ///< Enable interrupt requests generated by the ADINT  
 676      =2                                     ///< flag.                                             
 677      =2                                                                                            
 678      =2  #define EIE1_EPCA0__BMASK     0x10 ///< Programmable Counter Array (PCA0) Interrupt Enable
 679      =2  #define EIE1_EPCA0__SHIFT     0x04 ///< Programmable Counter Array (PCA0) Interrupt Enable
 680      =2  #define EIE1_EPCA0__DISABLED  0x00 ///< Disable all PCA0 interrupts.                      
 681      =2  #define EIE1_EPCA0__ENABLED   0x10 ///< Enable interrupt requests generated by PCA0.      
 682      =2                                                                                            
 683      =2  #define EIE1_ECP0__BMASK      0x20 ///< Comparator0 (CP0) Interrupt Enable                
 684      =2  #define EIE1_ECP0__SHIFT      0x05 ///< Comparator0 (CP0) Interrupt Enable                
 685      =2  #define EIE1_ECP0__DISABLED   0x00 ///< Disable CP0 interrupts.                           
 686      =2  #define EIE1_ECP0__ENABLED    0x20 ///< Enable interrupt requests generated by the        
 687      =2                                     ///< comparator 0 CPRIF or CPFIF flags.                
 688      =2                                                                                            
 689      =2  #define EIE1_ECP1__BMASK      0x40 ///< Comparator1 (CP1) Interrupt Enable                
 690      =2  #define EIE1_ECP1__SHIFT      0x06 ///< Comparator1 (CP1) Interrupt Enable                
 691      =2  #define EIE1_ECP1__DISABLED   0x00 ///< Disable CP1 interrupts.                           
 692      =2  #define EIE1_ECP1__ENABLED    0x40 ///< Enable interrupt requests generated by the        
 693      =2                                     ///< comparator 1 CPRIF or CPFIF flags.                
 694      =2                                                                                            
C51 COMPILER V9.56.0.0   UART_0                                                            10/28/2016 17:37:02 PAGE 38  

 695      =2  #define EIE1_ET3__BMASK       0x80 ///< Timer 3 Interrupt Enable                          
 696      =2  #define EIE1_ET3__SHIFT       0x07 ///< Timer 3 Interrupt Enable                          
 697      =2  #define EIE1_ET3__DISABLED    0x00 ///< Disable Timer 3 interrupts.                       
 698      =2  #define EIE1_ET3__ENABLED     0x80 ///< Enable interrupt requests generated by the TF3L or
 699      =2                                     ///< TF3H flags.                                       
 700      =2                                                                                            
 701      =2  //------------------------------------------------------------------------------
 702      =2  // EIE2 Enums (Extended Interrupt Enable 2 @ 0xE7)
 703      =2  //------------------------------------------------------------------------------
 704      =2  #define EIE2_EVBUS__BMASK    0x01 ///< VBUS Level Interrupt Enable                       
 705      =2  #define EIE2_EVBUS__SHIFT    0x00 ///< VBUS Level Interrupt Enable                       
 706      =2  #define EIE2_EVBUS__DISABLED 0x00 ///< Disable all VBUS interrupts.                      
 707      =2  #define EIE2_EVBUS__ENABLED  0x01 ///< Enable interrupt requests generated by VBUS level 
 708      =2                                    ///< sense.                                            
 709      =2                                                                                           
 710      =2  #define EIE2_ES1__BMASK      0x02 ///< UART1 Interrupt Enable                            
 711      =2  #define EIE2_ES1__SHIFT      0x01 ///< UART1 Interrupt Enable                            
 712      =2  #define EIE2_ES1__DISABLED   0x00 ///< Disable UART1 interrupt.                          
 713      =2  #define EIE2_ES1__ENABLED    0x02 ///< Enable UART1 interrupt.                           
 714      =2                                                                                           
 715      =2  #define EIE2_ESMB1__BMASK    0x08 ///< SMBus1 Interrupt Enable                           
 716      =2  #define EIE2_ESMB1__SHIFT    0x03 ///< SMBus1 Interrupt Enable                           
 717      =2  #define EIE2_ESMB1__DISABLED 0x00 ///< Disable all SMB1 interrupts.                      
 718      =2  #define EIE2_ESMB1__ENABLED  0x08 ///< Enable interrupt requests generated by SMB1.      
 719      =2                                                                                           
 720      =2  #define EIE2_ET4__BMASK      0x10 ///< Timer 4 Interrupt Enable                          
 721      =2  #define EIE2_ET4__SHIFT      0x04 ///< Timer 4 Interrupt Enable                          
 722      =2  #define EIE2_ET4__DISABLED   0x00 ///< Disable Timer 4interrupts.                        
 723      =2  #define EIE2_ET4__ENABLED    0x10 ///< Enable interrupt requests generated by the TF4L or
 724      =2                                    ///< TF4H flags.                                       
 725      =2                                                                                           
 726      =2  #define EIE2_ET5__BMASK      0x20 ///< Timer 5 Interrupt Enable                          
 727      =2  #define EIE2_ET5__SHIFT      0x05 ///< Timer 5 Interrupt Enable                          
 728      =2  #define EIE2_ET5__DISABLED   0x00 ///< Disable Timer 5 interrupts.                       
 729      =2  #define EIE2_ET5__ENABLED    0x20 ///< Enable interrupt requests generated by the TF5L or
 730      =2                                    ///< TF5H flags.                                       
 731      =2                                                                                           
 732      =2  //------------------------------------------------------------------------------
 733      =2  // EIP1 Enums (Extended Interrupt Priority 1 @ 0xF6)
 734      =2  //------------------------------------------------------------------------------
 735      =2  #define EIP1_PSMB0__BMASK  0x01 ///< SMBus (SMB0) Interrupt Priority Control                     
 736      =2  #define EIP1_PSMB0__SHIFT  0x00 ///< SMBus (SMB0) Interrupt Priority Control                     
 737      =2  #define EIP1_PSMB0__LOW    0x00 ///< SMB0 interrupt set to low priority level.                   
 738      =2  #define EIP1_PSMB0__HIGH   0x01 ///< SMB0 interrupt set to high priority level.                  
 739      =2                                                                                                   
 740      =2  #define EIP1_PUSB0__BMASK  0x02 ///< USB (USB0) Interrupt Priority Control                       
 741      =2  #define EIP1_PUSB0__SHIFT  0x01 ///< USB (USB0) Interrupt Priority Control                       
 742      =2  #define EIP1_PUSB0__LOW    0x00 ///< USB0 interrupt set to low priority level.                   
 743      =2  #define EIP1_PUSB0__HIGH   0x02 ///< USB0 interrupt set to high priority level.                  
 744      =2                                                                                                   
 745      =2  #define EIP1_PWADC0__BMASK 0x04 ///< ADC0 Window Comparator Interrupt Priority Control           
 746      =2  #define EIP1_PWADC0__SHIFT 0x02 ///< ADC0 Window Comparator Interrupt Priority Control           
 747      =2  #define EIP1_PWADC0__LOW   0x00 ///< ADC0 Window interrupt set to low priority level.            
 748      =2  #define EIP1_PWADC0__HIGH  0x04 ///< ADC0 Window interrupt set to high priority level.           
 749      =2                                                                                                   
 750      =2  #define EIP1_PADC0__BMASK  0x08 ///< ADC0 Conversion Complete Interrupt Priority Control         
 751      =2  #define EIP1_PADC0__SHIFT  0x03 ///< ADC0 Conversion Complete Interrupt Priority Control         
 752      =2  #define EIP1_PADC0__LOW    0x00 ///< ADC0 Conversion Complete interrupt set to low               
 753      =2                                  ///< priority level.                                             
 754      =2  #define EIP1_PADC0__HIGH   0x08 ///< ADC0 Conversion Complete interrupt set to high              
 755      =2                                  ///< priority level.                                             
 756      =2                                                                                                   
C51 COMPILER V9.56.0.0   UART_0                                                            10/28/2016 17:37:02 PAGE 39  

 757      =2  #define EIP1_PPCA0__BMASK  0x10 ///< Programmable Counter Array (PCA0) Interrupt Priority Control
 758      =2  #define EIP1_PPCA0__SHIFT  0x04 ///< Programmable Counter Array (PCA0) Interrupt Priority Control
 759      =2  #define EIP1_PPCA0__LOW    0x00 ///< PCA0 interrupt set to low priority level.                   
 760      =2  #define EIP1_PPCA0__HIGH   0x10 ///< PCA0 interrupt set to high priority level.                  
 761      =2                                                                                                   
 762      =2  #define EIP1_PCP0__BMASK   0x20 ///< Comparator0 (CP0) Interrupt Priority Control                
 763      =2  #define EIP1_PCP0__SHIFT   0x05 ///< Comparator0 (CP0) Interrupt Priority Control                
 764      =2  #define EIP1_PCP0__LOW     0x00 ///< CP0 interrupt set to low priority level.                    
 765      =2  #define EIP1_PCP0__HIGH    0x20 ///< CP0 interrupt set to high priority level.                   
 766      =2                                                                                                   
 767      =2  #define EIP1_PCP1__BMASK   0x40 ///< Comparator1 (CP1) Interrupt Priority Control                
 768      =2  #define EIP1_PCP1__SHIFT   0x06 ///< Comparator1 (CP1) Interrupt Priority Control                
 769      =2  #define EIP1_PCP1__LOW     0x00 ///< CP1 interrupt set to low priority level.                    
 770      =2  #define EIP1_PCP1__HIGH    0x40 ///< CP1 interrupt set to high priority level.                   
 771      =2                                                                                                   
 772      =2  #define EIP1_PT3__BMASK    0x80 ///< Timer 3 Interrupt Priority Control                          
 773      =2  #define EIP1_PT3__SHIFT    0x07 ///< Timer 3 Interrupt Priority Control                          
 774      =2  #define EIP1_PT3__LOW      0x00 ///< Timer 3 interrupts set to low priority level.               
 775      =2  #define EIP1_PT3__HIGH     0x80 ///< Timer 3 interrupts set to high priority level.              
 776      =2                                                                                                   
 777      =2  //------------------------------------------------------------------------------
 778      =2  // EIP2 Enums (Extended Interrupt Priority 2 @ 0xF7)
 779      =2  //------------------------------------------------------------------------------
 780      =2  #define EIP2_PVBUS__BMASK 0x01 ///< VBUS Level Interrupt Priority Control        
 781      =2  #define EIP2_PVBUS__SHIFT 0x00 ///< VBUS Level Interrupt Priority Control        
 782      =2  #define EIP2_PVBUS__LOW   0x00 ///< VBUS interrupt set to low priority level.    
 783      =2  #define EIP2_PVBUS__HIGH  0x01 ///< VBUS interrupt set to high priority level.   
 784      =2                                                                                   
 785      =2  #define EIP2_PS1__BMASK   0x02 ///< UART1 Interrupt Priority Control             
 786      =2  #define EIP2_PS1__SHIFT   0x01 ///< UART1 Interrupt Priority Control             
 787      =2  #define EIP2_PS1__LOW     0x00 ///< UART1 interrupt set to low priority level.   
 788      =2  #define EIP2_PS1__HIGH    0x02 ///< UART1 interrupt set to high priority level.  
 789      =2                                                                                   
 790      =2  #define EIP2_PSMB1__BMASK 0x08 ///< SMBus1 Interrupt Priority Control            
 791      =2  #define EIP2_PSMB1__SHIFT 0x03 ///< SMBus1 Interrupt Priority Control            
 792      =2  #define EIP2_PSMB1__LOW   0x00 ///< SMB1 interrupt set to low priority level.    
 793      =2  #define EIP2_PSMB1__HIGH  0x08 ///< SMB1 interrupt set to high priority level.   
 794      =2                                                                                   
 795      =2  #define EIP2_PT4__BMASK   0x10 ///< Timer 4 Interrupt Priority Control           
 796      =2  #define EIP2_PT4__SHIFT   0x04 ///< Timer 4 Interrupt Priority Control           
 797      =2  #define EIP2_PT4__LOW     0x00 ///< Timer 4 interrupt set to low priority level. 
 798      =2  #define EIP2_PT4__HIGH    0x10 ///< Timer 4 interrupt set to high priority level.
 799      =2                                                                                   
 800      =2  #define EIP2_PT5__BMASK   0x20 ///< Timer 5 Interrupt Priority Control           
 801      =2  #define EIP2_PT5__SHIFT   0x05 ///< Timer 5 Interrupt Priority Control           
 802      =2  #define EIP2_PT5__LOW     0x00 ///< Timer 5 interrupt set to low priority level. 
 803      =2  #define EIP2_PT5__HIGH    0x20 ///< Timer 5 interrupt set to high priority level.
 804      =2                                                                                   
 805      =2  //------------------------------------------------------------------------------
 806      =2  // IE Enums (Interrupt Enable @ 0xA8)
 807      =2  //------------------------------------------------------------------------------
 808      =2  #define IE_EX0__BMASK      0x01 ///< External Interrupt 0 Enable                       
 809      =2  #define IE_EX0__SHIFT      0x00 ///< External Interrupt 0 Enable                       
 810      =2  #define IE_EX0__DISABLED   0x00 ///< Disable external interrupt 0.                     
 811      =2  #define IE_EX0__ENABLED    0x01 ///< Enable interrupt requests generated by the INT0   
 812      =2                                  ///< input.                                            
 813      =2                                                                                         
 814      =2  #define IE_ET0__BMASK      0x02 ///< Timer 0 Interrupt Enable                          
 815      =2  #define IE_ET0__SHIFT      0x01 ///< Timer 0 Interrupt Enable                          
 816      =2  #define IE_ET0__DISABLED   0x00 ///< Disable all Timer 0 interrupt.                    
 817      =2  #define IE_ET0__ENABLED    0x02 ///< Enable interrupt requests generated by the TF0    
 818      =2                                  ///< flag.                                             
C51 COMPILER V9.56.0.0   UART_0                                                            10/28/2016 17:37:02 PAGE 40  

 819      =2                                                                                         
 820      =2  #define IE_EX1__BMASK      0x04 ///< External Interrupt 1 Enable                       
 821      =2  #define IE_EX1__SHIFT      0x02 ///< External Interrupt 1 Enable                       
 822      =2  #define IE_EX1__DISABLED   0x00 ///< Disable external interrupt 1.                     
 823      =2  #define IE_EX1__ENABLED    0x04 ///< Enable interrupt requests generated by the INT1   
 824      =2                                  ///< input.                                            
 825      =2                                                                                         
 826      =2  #define IE_ET1__BMASK      0x08 ///< Timer 1 Interrupt Enable                          
 827      =2  #define IE_ET1__SHIFT      0x03 ///< Timer 1 Interrupt Enable                          
 828      =2  #define IE_ET1__DISABLED   0x00 ///< Disable all Timer 1 interrupt.                    
 829      =2  #define IE_ET1__ENABLED    0x08 ///< Enable interrupt requests generated by the TF1    
 830      =2                                  ///< flag.                                             
 831      =2                                                                                         
 832      =2  #define IE_ES0__BMASK      0x10 ///< UART0 Interrupt Enable                            
 833      =2  #define IE_ES0__SHIFT      0x04 ///< UART0 Interrupt Enable                            
 834      =2  #define IE_ES0__DISABLED   0x00 ///< Disable UART0 interrupt.                          
 835      =2  #define IE_ES0__ENABLED    0x10 ///< Enable UART0 interrupt.                           
 836      =2                                                                                         
 837      =2  #define IE_ET2__BMASK      0x20 ///< Timer 2 Interrupt Enable                          
 838      =2  #define IE_ET2__SHIFT      0x05 ///< Timer 2 Interrupt Enable                          
 839      =2  #define IE_ET2__DISABLED   0x00 ///< Disable Timer 2 interrupt.                        
 840      =2  #define IE_ET2__ENABLED    0x20 ///< Enable interrupt requests generated by the TF2L or
 841      =2                                  ///< TF2H flags.                                       
 842      =2                                                                                         
 843      =2  #define IE_ESPI0__BMASK    0x40 ///< SPI0 Interrupt Enable                             
 844      =2  #define IE_ESPI0__SHIFT    0x06 ///< SPI0 Interrupt Enable                             
 845      =2  #define IE_ESPI0__DISABLED 0x00 ///< Disable all SPI0 interrupts.                      
 846      =2  #define IE_ESPI0__ENABLED  0x40 ///< Enable interrupt requests generated by SPI0.      
 847      =2                                                                                         
 848      =2  #define IE_EA__BMASK       0x80 ///< All Interrupts Enable                             
 849      =2  #define IE_EA__SHIFT       0x07 ///< All Interrupts Enable                             
 850      =2  #define IE_EA__DISABLED    0x00 ///< Disable all interrupt sources.                    
 851      =2  #define IE_EA__ENABLED     0x80 ///< Enable each interrupt according to its individual 
 852      =2                                  ///< mask setting.                                     
 853      =2                                                                                         
 854      =2  //------------------------------------------------------------------------------
 855      =2  // IP Enums (Interrupt Priority @ 0xB8)
 856      =2  //------------------------------------------------------------------------------
 857      =2  #define IP_PX0__BMASK   0x01 ///< External Interrupt 0 Priority Control                        
 858      =2  #define IP_PX0__SHIFT   0x00 ///< External Interrupt 0 Priority Control                        
 859      =2  #define IP_PX0__LOW     0x00 ///< External Interrupt 0 set to low priority level.              
 860      =2  #define IP_PX0__HIGH    0x01 ///< External Interrupt 0 set to high priority level.             
 861      =2                                                                                                 
 862      =2  #define IP_PT0__BMASK   0x02 ///< Timer 0 Interrupt Priority Control                           
 863      =2  #define IP_PT0__SHIFT   0x01 ///< Timer 0 Interrupt Priority Control                           
 864      =2  #define IP_PT0__LOW     0x00 ///< Timer 0 interrupt set to low priority level.                 
 865      =2  #define IP_PT0__HIGH    0x02 ///< Timer 0 interrupt set to high priority level.                
 866      =2                                                                                                 
 867      =2  #define IP_PX1__BMASK   0x04 ///< External Interrupt 1 Priority Control                        
 868      =2  #define IP_PX1__SHIFT   0x02 ///< External Interrupt 1 Priority Control                        
 869      =2  #define IP_PX1__LOW     0x00 ///< External Interrupt 1 set to low priority level.              
 870      =2  #define IP_PX1__HIGH    0x04 ///< External Interrupt 1 set to high priority level.             
 871      =2                                                                                                 
 872      =2  #define IP_PT1__BMASK   0x08 ///< Timer 1 Interrupt Priority Control                           
 873      =2  #define IP_PT1__SHIFT   0x03 ///< Timer 1 Interrupt Priority Control                           
 874      =2  #define IP_PT1__LOW     0x00 ///< Timer 1 interrupt set to low priority level.                 
 875      =2  #define IP_PT1__HIGH    0x08 ///< Timer 1 interrupt set to high priority level.                
 876      =2                                                                                                 
 877      =2  #define IP_PS0__BMASK   0x10 ///< UART0 Interrupt Priority Control                             
 878      =2  #define IP_PS0__SHIFT   0x04 ///< UART0 Interrupt Priority Control                             
 879      =2  #define IP_PS0__LOW     0x00 ///< UART0 interrupt set to low priority level.                   
 880      =2  #define IP_PS0__HIGH    0x10 ///< UART0 interrupt set to high priority level.                  
C51 COMPILER V9.56.0.0   UART_0                                                            10/28/2016 17:37:02 PAGE 41  

 881      =2                                                                                                 
 882      =2  #define IP_PT2__BMASK   0x20 ///< Timer 2 Interrupt Priority Control                           
 883      =2  #define IP_PT2__SHIFT   0x05 ///< Timer 2 Interrupt Priority Control                           
 884      =2  #define IP_PT2__LOW     0x00 ///< Timer 2 interrupt set to low priority level.                 
 885      =2  #define IP_PT2__HIGH    0x20 ///< Timer 2 interrupt set to high priority level.                
 886      =2                                                                                                 
 887      =2  #define IP_PSPI0__BMASK 0x40 ///< Serial Peripheral Interface (SPI0) Interrupt Priority Control
 888      =2  #define IP_PSPI0__SHIFT 0x06 ///< Serial Peripheral Interface (SPI0) Interrupt Priority Control
 889      =2  #define IP_PSPI0__LOW   0x00 ///< SPI0 interrupt set to low priority level.                    
 890      =2  #define IP_PSPI0__HIGH  0x40 ///< SPI0 interrupt set to high priority level.                   
 891      =2                                                                                                 
 892      =2  //------------------------------------------------------------------------------
 893      =2  // LFO0CN Enums (Low Frequency Oscillator Control @ 0x86)
 894      =2  //------------------------------------------------------------------------------
 895      =2  #define LFO0CN_OSCLD__FMASK       0x03 ///< Internal L-F Oscillator Divider Select           
 896      =2  #define LFO0CN_OSCLD__SHIFT       0x00 ///< Internal L-F Oscillator Divider Select           
 897      =2  #define LFO0CN_OSCLD__DIVIDE_BY_8 0x00 ///< Divide by 8 selected.                            
 898      =2  #define LFO0CN_OSCLD__DIVIDE_BY_4 0x01 ///< Divide by 4 selected.                            
 899      =2  #define LFO0CN_OSCLD__DIVIDE_BY_2 0x02 ///< Divide by 2 selected.                            
 900      =2  #define LFO0CN_OSCLD__DIVIDE_BY_1 0x03 ///< Divide by 1 selected.                            
 901      =2                                                                                               
 902      =2  #define LFO0CN_OSCLF__FMASK       0x3C ///< Internal L-F Oscillator Frequency Control        
 903      =2  #define LFO0CN_OSCLF__SHIFT       0x02 ///< Internal L-F Oscillator Frequency Control        
 904      =2                                                                                               
 905      =2  #define LFO0CN_OSCLRDY__BMASK     0x40 ///< Internal L-F Oscillator Ready                    
 906      =2  #define LFO0CN_OSCLRDY__SHIFT     0x06 ///< Internal L-F Oscillator Ready                    
 907      =2  #define LFO0CN_OSCLRDY__NOT_SET   0x00 ///< Internal L-F Oscillator frequency not stabilized.
 908      =2  #define LFO0CN_OSCLRDY__SET       0x40 ///< Internal L-F Oscillator frequency stabilized.    
 909      =2                                                                                               
 910      =2  #define LFO0CN_OSCLEN__BMASK      0x80 ///< Internal L-F Oscillator Enable                   
 911      =2  #define LFO0CN_OSCLEN__SHIFT      0x07 ///< Internal L-F Oscillator Enable                   
 912      =2  #define LFO0CN_OSCLEN__DISABLED   0x00 ///< Internal L-F Oscillator Disabled.                
 913      =2  #define LFO0CN_OSCLEN__ENABLED    0x80 ///< Internal L-F Oscillator Enabled.                 
 914      =2                                                                                               
 915      =2  //------------------------------------------------------------------------------
 916      =2  // XBR0 Enums (Port I/O Crossbar 0 @ 0xE1)
 917      =2  //------------------------------------------------------------------------------
 918      =2  #define XBR0_URT0E__BMASK     0x01 ///< UART0 I/O Output Enable                        
 919      =2  #define XBR0_URT0E__SHIFT     0x00 ///< UART0 I/O Output Enable                        
 920      =2  #define XBR0_URT0E__DISABLED  0x00 ///< UART0 I/O unavailable at Port pin.             
 921      =2  #define XBR0_URT0E__ENABLED   0x01 ///< UART0 TX, RX routed to Port pins P0.4 and P0.5.
 922      =2                                                                                         
 923      =2  #define XBR0_SPI0E__BMASK     0x02 ///< SPI I/O Enable                                 
 924      =2  #define XBR0_SPI0E__SHIFT     0x01 ///< SPI I/O Enable                                 
 925      =2  #define XBR0_SPI0E__DISABLED  0x00 ///< SPI I/O unavailable at Port pins.              
 926      =2  #define XBR0_SPI0E__ENABLED   0x02 ///< SPI I/O routed to Port pins. The SPI can be    
 927      =2                                     ///< assigned either 3 or 4 GPIO pins.              
 928      =2                                                                                         
 929      =2  #define XBR0_SMB0E__BMASK     0x04 ///< SMB0 I/O Enable                                
 930      =2  #define XBR0_SMB0E__SHIFT     0x02 ///< SMB0 I/O Enable                                
 931      =2  #define XBR0_SMB0E__DISABLED  0x00 ///< SMBus 0 I/O unavailable at Port pins.          
 932      =2  #define XBR0_SMB0E__ENABLED   0x04 ///< SMBus 0 I/O routed to Port pins.               
 933      =2                                                                                         
 934      =2  #define XBR0_SYSCKE__BMASK    0x08 ///< SYSCLK Output Enable                           
 935      =2  #define XBR0_SYSCKE__SHIFT    0x03 ///< SYSCLK Output Enable                           
 936      =2  #define XBR0_SYSCKE__DISABLED 0x00 ///< SYSCLK unavailable at Port pin.                
 937      =2  #define XBR0_SYSCKE__ENABLED  0x08 ///< SYSCLK output routed to Port pin.              
 938      =2                                                                                         
 939      =2  #define XBR0_CP0E__BMASK      0x10 ///< Comparator0 Output Enable                      
 940      =2  #define XBR0_CP0E__SHIFT      0x04 ///< Comparator0 Output Enable                      
 941      =2  #define XBR0_CP0E__DISABLED   0x00 ///< CP0 unavailable at Port pin.                   
 942      =2  #define XBR0_CP0E__ENABLED    0x10 ///< CP0 routed to Port pin.                        
C51 COMPILER V9.56.0.0   UART_0                                                            10/28/2016 17:37:02 PAGE 42  

 943      =2                                                                                         
 944      =2  #define XBR0_CP0AE__BMASK     0x20 ///< Comparator0 Asynchronous Output Enable         
 945      =2  #define XBR0_CP0AE__SHIFT     0x05 ///< Comparator0 Asynchronous Output Enable         
 946      =2  #define XBR0_CP0AE__DISABLED  0x00 ///< Asynchronous CP0 unavailable at Port pin.      
 947      =2  #define XBR0_CP0AE__ENABLED   0x20 ///< Asynchronous CP0 routed to Port pin.           
 948      =2                                                                                         
 949      =2  #define XBR0_CP1E__BMASK      0x40 ///< Comparator1 Output Enable                      
 950      =2  #define XBR0_CP1E__SHIFT      0x06 ///< Comparator1 Output Enable                      
 951      =2  #define XBR0_CP1E__DISABLED   0x00 ///< CP1 unavailable at Port pin.                   
 952      =2  #define XBR0_CP1E__ENABLED    0x40 ///< CP1 routed to Port pin.                        
 953      =2                                                                                         
 954      =2  #define XBR0_CP1AE__BMASK     0x80 ///< Comparator1 Asynchronous Output Enable         
 955      =2  #define XBR0_CP1AE__SHIFT     0x07 ///< Comparator1 Asynchronous Output Enable         
 956      =2  #define XBR0_CP1AE__DISABLED  0x00 ///< Asynchronous CP1 unavailable at Port pin.      
 957      =2  #define XBR0_CP1AE__ENABLED   0x80 ///< Asynchronous CP1 routed to Port pin.           
 958      =2                                                                                         
 959      =2  //------------------------------------------------------------------------------
 960      =2  // XBR1 Enums (Port I/O Crossbar 1 @ 0xE2)
 961      =2  //------------------------------------------------------------------------------
 962      =2  #define XBR1_PCA0ME__FMASK                    0x07 ///< PCA Module I/O Enable                            
 963      =2  #define XBR1_PCA0ME__SHIFT                    0x00 ///< PCA Module I/O Enable                            
 964      =2  #define XBR1_PCA0ME__DISABLED                 0x00 ///< All PCA I/O unavailable at Port pins.            
 965      =2  #define XBR1_PCA0ME__CEX0                     0x01 ///< CEX0 routed to Port pin.                         
 966      =2  #define XBR1_PCA0ME__CEX0_CEX1                0x02 ///< CEX0, CEX1 routed to Port pins.                  
 967      =2  #define XBR1_PCA0ME__CEX0_CEX1_CEX2           0x03 ///< CEX0, CEX1, CEX2 routed to Port pins.            
 968      =2  #define XBR1_PCA0ME__CEX0_CEX1_CEX2_CEX3      0x04 ///< CEX0, CEX1, CEX2, CEX3 routed to Port pins.      
 969      =2  #define XBR1_PCA0ME__CEX0_CEX1_CEX2_CEX3_CEX4 0x05 ///< CEX0, CEX1, CEX2, CEX3, CEX4 routed to Port pins.
 970      =2                                                                                                           
 971      =2  #define XBR1_ECIE__BMASK                      0x08 ///< PCA0 External Counter Input Enable               
 972      =2  #define XBR1_ECIE__SHIFT                      0x03 ///< PCA0 External Counter Input Enable               
 973      =2  #define XBR1_ECIE__DISABLED                   0x00 ///< ECI unavailable at Port pin.                     
 974      =2  #define XBR1_ECIE__ENABLED                    0x08 ///< ECI routed to Port pin.                          
 975      =2                                                                                                           
 976      =2  #define XBR1_T0E__BMASK                       0x10 ///< T0 Enable                                        
 977      =2  #define XBR1_T0E__SHIFT                       0x04 ///< T0 Enable                                        
 978      =2  #define XBR1_T0E__DISABLED                    0x00 ///< T0 unavailable at Port pin.                      
 979      =2  #define XBR1_T0E__ENABLED                     0x10 ///< T0 routed to Port pin.                           
 980      =2                                                                                                           
 981      =2  #define XBR1_T1E__BMASK                       0x20 ///< T1 Enable                                        
 982      =2  #define XBR1_T1E__SHIFT                       0x05 ///< T1 Enable                                        
 983      =2  #define XBR1_T1E__DISABLED                    0x00 ///< T1 unavailable at Port pin.                      
 984      =2  #define XBR1_T1E__ENABLED                     0x20 ///< T1 routed to Port pin.                           
 985      =2                                                                                                           
 986      =2  #define XBR1_XBARE__BMASK                     0x40 ///< Crossbar Enable                                  
 987      =2  #define XBR1_XBARE__SHIFT                     0x06 ///< Crossbar Enable                                  
 988      =2  #define XBR1_XBARE__DISABLED                  0x00 ///< Crossbar disabled.                               
 989      =2  #define XBR1_XBARE__ENABLED                   0x40 ///< Crossbar enabled.                                
 990      =2                                                                                                           
 991      =2  #define XBR1_WEAKPUD__BMASK                   0x80 ///< Port I/O Weak Pullup Disable                     
 992      =2  #define XBR1_WEAKPUD__SHIFT                   0x07 ///< Port I/O Weak Pullup Disable                     
 993      =2  #define XBR1_WEAKPUD__PULL_UPS_ENABLED        0x00 ///< Weak Pullups enabled (except for Ports whose I/O 
 994      =2                                                     ///< are configured for analog mode).                 
 995      =2  #define XBR1_WEAKPUD__PULL_UPS_DISABLED       0x80 ///< Weak Pullups disabled.                           
 996      =2                                                                                                           
 997      =2  //------------------------------------------------------------------------------
 998      =2  // XBR2 Enums (Port I/O Crossbar 2 @ 0xE3)
 999      =2  //------------------------------------------------------------------------------
1000      =2  #define XBR2_URT1E__BMASK    0x01 ///< UART1 I/O Output Enable             
1001      =2  #define XBR2_URT1E__SHIFT    0x00 ///< UART1 I/O Output Enable             
1002      =2  #define XBR2_URT1E__DISABLED 0x00 ///< UART1 I/O unavailable at Port pin.  
1003      =2  #define XBR2_URT1E__ENABLED  0x01 ///< UART1 TX, RX routed to Port pins.   
1004      =2                                                                             
C51 COMPILER V9.56.0.0   UART_0                                                            10/28/2016 17:37:02 PAGE 43  

1005      =2  #define XBR2_SMB1E__BMASK    0x02 ///< SMBus1 I/O Enable                   
1006      =2  #define XBR2_SMB1E__SHIFT    0x01 ///< SMBus1 I/O Enable                   
1007      =2  #define XBR2_SMB1E__DISABLED 0x00 ///< SMBus1 I/O unavailable at Port pins.
1008      =2  #define XBR2_SMB1E__ENABLED  0x02 ///< SMBus1 I/O routed to Port pins.     
1009      =2                                                                             
1010      =2  //------------------------------------------------------------------------------
1011      =2  // PCA0CPH0 Enums (PCA Channel 0 Capture Module High Byte @ 0xFC)
1012      =2  //------------------------------------------------------------------------------
1013      =2  #define PCA0CPH0_PCA0CPH0__FMASK 0xFF ///< PCA Channel 0 Capture Module High Byte
1014      =2  #define PCA0CPH0_PCA0CPH0__SHIFT 0x00 ///< PCA Channel 0 Capture Module High Byte
1015      =2                                                                                   
1016      =2  //------------------------------------------------------------------------------
1017      =2  // PCA0CPL0 Enums (PCA Channel 0 Capture Module Low Byte @ 0xFB)
1018      =2  //------------------------------------------------------------------------------
1019      =2  #define PCA0CPL0_PCA0CPL0__FMASK 0xFF ///< PCA Channel 0 Capture Module Low Byte
1020      =2  #define PCA0CPL0_PCA0CPL0__SHIFT 0x00 ///< PCA Channel 0 Capture Module Low Byte
1021      =2                                                                                  
1022      =2  //------------------------------------------------------------------------------
1023      =2  // PCA0CPM0 Enums (PCA Channel 0 Capture/Compare Mode @ 0xDA)
1024      =2  //------------------------------------------------------------------------------
1025      =2  #define PCA0CPM0_ECCF__BMASK    0x01 ///< Channel 0 Capture/Compare Flag Interrupt Enable
1026      =2  #define PCA0CPM0_ECCF__SHIFT    0x00 ///< Channel 0 Capture/Compare Flag Interrupt Enable
1027      =2  #define PCA0CPM0_ECCF__DISABLED 0x00 ///< Disable CCF0 interrupts.                       
1028      =2  #define PCA0CPM0_ECCF__ENABLED  0x01 ///< Enable a Capture/Compare Flag interrupt request
1029      =2                                       ///< when CCF0 is set.                              
1030      =2                                                                                           
1031      =2  #define PCA0CPM0_PWM__BMASK     0x02 ///< Channel 0 Pulse Width Modulation Mode Enable   
1032      =2  #define PCA0CPM0_PWM__SHIFT     0x01 ///< Channel 0 Pulse Width Modulation Mode Enable   
1033      =2  #define PCA0CPM0_PWM__DISABLED  0x00 ///< Disable PWM function.                          
1034      =2  #define PCA0CPM0_PWM__ENABLED   0x02 ///< Enable PWM function.                           
1035      =2                                                                                           
1036      =2  #define PCA0CPM0_TOG__BMASK     0x04 ///< Channel 0 Toggle Function Enable               
1037      =2  #define PCA0CPM0_TOG__SHIFT     0x02 ///< Channel 0 Toggle Function Enable               
1038      =2  #define PCA0CPM0_TOG__DISABLED  0x00 ///< Disable toggle function.                       
1039      =2  #define PCA0CPM0_TOG__ENABLED   0x04 ///< Enable toggle function.                        
1040      =2                                                                                           
1041      =2  #define PCA0CPM0_MAT__BMASK     0x08 ///< Channel 0 Match Function Enable                
1042      =2  #define PCA0CPM0_MAT__SHIFT     0x03 ///< Channel 0 Match Function Enable                
1043      =2  #define PCA0CPM0_MAT__DISABLED  0x00 ///< Disable match function.                        
1044      =2  #define PCA0CPM0_MAT__ENABLED   0x08 ///< Enable match function.                         
1045      =2                                                                                           
1046      =2  #define PCA0CPM0_CAPN__BMASK    0x10 ///< Channel 0 Capture Negative Function Enable     
1047      =2  #define PCA0CPM0_CAPN__SHIFT    0x04 ///< Channel 0 Capture Negative Function Enable     
1048      =2  #define PCA0CPM0_CAPN__DISABLED 0x00 ///< Disable negative edge capture.                 
1049      =2  #define PCA0CPM0_CAPN__ENABLED  0x10 ///< Enable negative edge capture.                  
1050      =2                                                                                           
1051      =2  #define PCA0CPM0_CAPP__BMASK    0x20 ///< Channel 0 Capture Positive Function Enable     
1052      =2  #define PCA0CPM0_CAPP__SHIFT    0x05 ///< Channel 0 Capture Positive Function Enable     
1053      =2  #define PCA0CPM0_CAPP__DISABLED 0x00 ///< Disable positive edge capture.                 
1054      =2  #define PCA0CPM0_CAPP__ENABLED  0x20 ///< Enable positive edge capture.                  
1055      =2                                                                                           
1056      =2  #define PCA0CPM0_ECOM__BMASK    0x40 ///< Channel 0 Comparator Function Enable           
1057      =2  #define PCA0CPM0_ECOM__SHIFT    0x06 ///< Channel 0 Comparator Function Enable           
1058      =2  #define PCA0CPM0_ECOM__DISABLED 0x00 ///< Disable comparator function.                   
1059      =2  #define PCA0CPM0_ECOM__ENABLED  0x40 ///< Enable comparator function.                    
1060      =2                                                                                           
1061      =2  #define PCA0CPM0_PWM16__BMASK   0x80 ///< Channel 0 16-bit Pulse Width Modulation Enable 
1062      =2  #define PCA0CPM0_PWM16__SHIFT   0x07 ///< Channel 0 16-bit Pulse Width Modulation Enable 
1063      =2  #define PCA0CPM0_PWM16__8_BIT   0x00 ///< 8-bit PWM selected.                            
1064      =2  #define PCA0CPM0_PWM16__16_BIT  0x80 ///< 16-bit PWM selected.                           
1065      =2                                                                                           
1066      =2  //------------------------------------------------------------------------------
C51 COMPILER V9.56.0.0   UART_0                                                            10/28/2016 17:37:02 PAGE 44  

1067      =2  // PCA0CPH1 Enums (PCA Channel 1 Capture Module High Byte @ 0xEA)
1068      =2  //------------------------------------------------------------------------------
1069      =2  #define PCA0CPH1_PCA0CPH1__FMASK 0xFF ///< PCA Channel 1 Capture Module High Byte
1070      =2  #define PCA0CPH1_PCA0CPH1__SHIFT 0x00 ///< PCA Channel 1 Capture Module High Byte
1071      =2                                                                                   
1072      =2  //------------------------------------------------------------------------------
1073      =2  // PCA0CPL1 Enums (PCA Channel 1 Capture Module Low Byte @ 0xE9)
1074      =2  //------------------------------------------------------------------------------
1075      =2  #define PCA0CPL1_PCA0CPL1__FMASK 0xFF ///< PCA Channel 1 Capture Module Low Byte
1076      =2  #define PCA0CPL1_PCA0CPL1__SHIFT 0x00 ///< PCA Channel 1 Capture Module Low Byte
1077      =2                                                                                  
1078      =2  //------------------------------------------------------------------------------
1079      =2  // PCA0CPM1 Enums (PCA Channel 1 Capture/Compare Mode @ 0xDB)
1080      =2  //------------------------------------------------------------------------------
1081      =2  #define PCA0CPM1_ECCF__BMASK    0x01 ///< Channel 1 Capture/Compare Flag Interrupt Enable
1082      =2  #define PCA0CPM1_ECCF__SHIFT    0x00 ///< Channel 1 Capture/Compare Flag Interrupt Enable
1083      =2  #define PCA0CPM1_ECCF__DISABLED 0x00 ///< Disable CCF1 interrupts.                       
1084      =2  #define PCA0CPM1_ECCF__ENABLED  0x01 ///< Enable a Capture/Compare Flag interrupt request
1085      =2                                       ///< when CCF1 is set.                              
1086      =2                                                                                           
1087      =2  #define PCA0CPM1_PWM__BMASK     0x02 ///< Channel 1 Pulse Width Modulation Mode Enable   
1088      =2  #define PCA0CPM1_PWM__SHIFT     0x01 ///< Channel 1 Pulse Width Modulation Mode Enable   
1089      =2  #define PCA0CPM1_PWM__DISABLED  0x00 ///< Disable PWM function.                          
1090      =2  #define PCA0CPM1_PWM__ENABLED   0x02 ///< Enable PWM function.                           
1091      =2                                                                                           
1092      =2  #define PCA0CPM1_TOG__BMASK     0x04 ///< Channel 1 Toggle Function Enable               
1093      =2  #define PCA0CPM1_TOG__SHIFT     0x02 ///< Channel 1 Toggle Function Enable               
1094      =2  #define PCA0CPM1_TOG__DISABLED  0x00 ///< Disable toggle function.                       
1095      =2  #define PCA0CPM1_TOG__ENABLED   0x04 ///< Enable toggle function.                        
1096      =2                                                                                           
1097      =2  #define PCA0CPM1_MAT__BMASK     0x08 ///< Channel 1 Match Function Enable                
1098      =2  #define PCA0CPM1_MAT__SHIFT     0x03 ///< Channel 1 Match Function Enable                
1099      =2  #define PCA0CPM1_MAT__DISABLED  0x00 ///< Disable match function.                        
1100      =2  #define PCA0CPM1_MAT__ENABLED   0x08 ///< Enable match function.                         
1101      =2                                                                                           
1102      =2  #define PCA0CPM1_CAPN__BMASK    0x10 ///< Channel 1 Capture Negative Function Enable     
1103      =2  #define PCA0CPM1_CAPN__SHIFT    0x04 ///< Channel 1 Capture Negative Function Enable     
1104      =2  #define PCA0CPM1_CAPN__DISABLED 0x00 ///< Disable negative edge capture.                 
1105      =2  #define PCA0CPM1_CAPN__ENABLED  0x10 ///< Enable negative edge capture.                  
1106      =2                                                                                           
1107      =2  #define PCA0CPM1_CAPP__BMASK    0x20 ///< Channel 1 Capture Positive Function Enable     
1108      =2  #define PCA0CPM1_CAPP__SHIFT    0x05 ///< Channel 1 Capture Positive Function Enable     
1109      =2  #define PCA0CPM1_CAPP__DISABLED 0x00 ///< Disable positive edge capture.                 
1110      =2  #define PCA0CPM1_CAPP__ENABLED  0x20 ///< Enable positive edge capture.                  
1111      =2                                                                                           
1112      =2  #define PCA0CPM1_ECOM__BMASK    0x40 ///< Channel 1 Comparator Function Enable           
1113      =2  #define PCA0CPM1_ECOM__SHIFT    0x06 ///< Channel 1 Comparator Function Enable           
1114      =2  #define PCA0CPM1_ECOM__DISABLED 0x00 ///< Disable comparator function.                   
1115      =2  #define PCA0CPM1_ECOM__ENABLED  0x40 ///< Enable comparator function.                    
1116      =2                                                                                           
1117      =2  #define PCA0CPM1_PWM16__BMASK   0x80 ///< Channel 1 16-bit Pulse Width Modulation Enable 
1118      =2  #define PCA0CPM1_PWM16__SHIFT   0x07 ///< Channel 1 16-bit Pulse Width Modulation Enable 
1119      =2  #define PCA0CPM1_PWM16__8_BIT   0x00 ///< 8-bit PWM selected.                            
1120      =2  #define PCA0CPM1_PWM16__16_BIT  0x80 ///< 16-bit PWM selected.                           
1121      =2                                                                                           
1122      =2  //------------------------------------------------------------------------------
1123      =2  // PCA0CPH2 Enums (PCA Channel 2 Capture Module High Byte @ 0xEC)
1124      =2  //------------------------------------------------------------------------------
1125      =2  #define PCA0CPH2_PCA0CPH2__FMASK 0xFF ///< PCA Channel 2 Capture Module High Byte
1126      =2  #define PCA0CPH2_PCA0CPH2__SHIFT 0x00 ///< PCA Channel 2 Capture Module High Byte
1127      =2                                                                                   
1128      =2  //------------------------------------------------------------------------------
C51 COMPILER V9.56.0.0   UART_0                                                            10/28/2016 17:37:02 PAGE 45  

1129      =2  // PCA0CPL2 Enums (PCA Channel 2 Capture Module Low Byte @ 0xEB)
1130      =2  //------------------------------------------------------------------------------
1131      =2  #define PCA0CPL2_PCA0CPL2__FMASK 0xFF ///< PCA Channel 2 Capture Module Low Byte
1132      =2  #define PCA0CPL2_PCA0CPL2__SHIFT 0x00 ///< PCA Channel 2 Capture Module Low Byte
1133      =2                                                                                  
1134      =2  //------------------------------------------------------------------------------
1135      =2  // PCA0CPM2 Enums (PCA Channel 2 Capture/Compare Mode @ 0xDC)
1136      =2  //------------------------------------------------------------------------------
1137      =2  #define PCA0CPM2_ECCF__BMASK    0x01 ///< Channel 2 Capture/Compare Flag Interrupt Enable
1138      =2  #define PCA0CPM2_ECCF__SHIFT    0x00 ///< Channel 2 Capture/Compare Flag Interrupt Enable
1139      =2  #define PCA0CPM2_ECCF__DISABLED 0x00 ///< Disable CCF2 interrupts.                       
1140      =2  #define PCA0CPM2_ECCF__ENABLED  0x01 ///< Enable a Capture/Compare Flag interrupt request
1141      =2                                       ///< when CCF2 is set.                              
1142      =2                                                                                           
1143      =2  #define PCA0CPM2_PWM__BMASK     0x02 ///< Channel 2 Pulse Width Modulation Mode Enable   
1144      =2  #define PCA0CPM2_PWM__SHIFT     0x01 ///< Channel 2 Pulse Width Modulation Mode Enable   
1145      =2  #define PCA0CPM2_PWM__DISABLED  0x00 ///< Disable PWM function.                          
1146      =2  #define PCA0CPM2_PWM__ENABLED   0x02 ///< Enable PWM function.                           
1147      =2                                                                                           
1148      =2  #define PCA0CPM2_TOG__BMASK     0x04 ///< Channel 2 Toggle Function Enable               
1149      =2  #define PCA0CPM2_TOG__SHIFT     0x02 ///< Channel 2 Toggle Function Enable               
1150      =2  #define PCA0CPM2_TOG__DISABLED  0x00 ///< Disable toggle function.                       
1151      =2  #define PCA0CPM2_TOG__ENABLED   0x04 ///< Enable toggle function.                        
1152      =2                                                                                           
1153      =2  #define PCA0CPM2_MAT__BMASK     0x08 ///< Channel 2 Match Function Enable                
1154      =2  #define PCA0CPM2_MAT__SHIFT     0x03 ///< Channel 2 Match Function Enable                
1155      =2  #define PCA0CPM2_MAT__DISABLED  0x00 ///< Disable match function.                        
1156      =2  #define PCA0CPM2_MAT__ENABLED   0x08 ///< Enable match function.                         
1157      =2                                                                                           
1158      =2  #define PCA0CPM2_CAPN__BMASK    0x10 ///< Channel 2 Capture Negative Function Enable     
1159      =2  #define PCA0CPM2_CAPN__SHIFT    0x04 ///< Channel 2 Capture Negative Function Enable     
1160      =2  #define PCA0CPM2_CAPN__DISABLED 0x00 ///< Disable negative edge capture.                 
1161      =2  #define PCA0CPM2_CAPN__ENABLED  0x10 ///< Enable negative edge capture.                  
1162      =2                                                                                           
1163      =2  #define PCA0CPM2_CAPP__BMASK    0x20 ///< Channel 2 Capture Positive Function Enable     
1164      =2  #define PCA0CPM2_CAPP__SHIFT    0x05 ///< Channel 2 Capture Positive Function Enable     
1165      =2  #define PCA0CPM2_CAPP__DISABLED 0x00 ///< Disable positive edge capture.                 
1166      =2  #define PCA0CPM2_CAPP__ENABLED  0x20 ///< Enable positive edge capture.                  
1167      =2                                                                                           
1168      =2  #define PCA0CPM2_ECOM__BMASK    0x40 ///< Channel 2 Comparator Function Enable           
1169      =2  #define PCA0CPM2_ECOM__SHIFT    0x06 ///< Channel 2 Comparator Function Enable           
1170      =2  #define PCA0CPM2_ECOM__DISABLED 0x00 ///< Disable comparator function.                   
1171      =2  #define PCA0CPM2_ECOM__ENABLED  0x40 ///< Enable comparator function.                    
1172      =2                                                                                           
1173      =2  #define PCA0CPM2_PWM16__BMASK   0x80 ///< Channel 2 16-bit Pulse Width Modulation Enable 
1174      =2  #define PCA0CPM2_PWM16__SHIFT   0x07 ///< Channel 2 16-bit Pulse Width Modulation Enable 
1175      =2  #define PCA0CPM2_PWM16__8_BIT   0x00 ///< 8-bit PWM selected.                            
1176      =2  #define PCA0CPM2_PWM16__16_BIT  0x80 ///< 16-bit PWM selected.                           
1177      =2                                                                                           
1178      =2  //------------------------------------------------------------------------------
1179      =2  // PCA0CPH3 Enums (PCA Channel 3 Capture Module High Byte @ 0xEE)
1180      =2  //------------------------------------------------------------------------------
1181      =2  #define PCA0CPH3_PCA0CPH3__FMASK 0xFF ///< PCA Channel 3 Capture Module High Byte
1182      =2  #define PCA0CPH3_PCA0CPH3__SHIFT 0x00 ///< PCA Channel 3 Capture Module High Byte
1183      =2                                                                                   
1184      =2  //------------------------------------------------------------------------------
1185      =2  // PCA0CPL3 Enums (PCA Channel 3 Capture Module Low Byte @ 0xED)
1186      =2  //------------------------------------------------------------------------------
1187      =2  #define PCA0CPL3_PCA0CPL3__FMASK 0xFF ///< PCA Channel 3 Capture Module Low Byte
1188      =2  #define PCA0CPL3_PCA0CPL3__SHIFT 0x00 ///< PCA Channel 3 Capture Module Low Byte
1189      =2                                                                                  
1190      =2  //------------------------------------------------------------------------------
C51 COMPILER V9.56.0.0   UART_0                                                            10/28/2016 17:37:02 PAGE 46  

1191      =2  // PCA0CPM3 Enums (PCA Channel 3 Capture/Compare Mode @ 0xDD)
1192      =2  //------------------------------------------------------------------------------
1193      =2  #define PCA0CPM3_ECCF__BMASK    0x01 ///< Channel 3 Capture/Compare Flag Interrupt Enable
1194      =2  #define PCA0CPM3_ECCF__SHIFT    0x00 ///< Channel 3 Capture/Compare Flag Interrupt Enable
1195      =2  #define PCA0CPM3_ECCF__DISABLED 0x00 ///< Disable CCF3 interrupts.                       
1196      =2  #define PCA0CPM3_ECCF__ENABLED  0x01 ///< Enable a Capture/Compare Flag interrupt request
1197      =2                                       ///< when CCF3 is set.                              
1198      =2                                                                                           
1199      =2  #define PCA0CPM3_PWM__BMASK     0x02 ///< Channel 3 Pulse Width Modulation Mode Enable   
1200      =2  #define PCA0CPM3_PWM__SHIFT     0x01 ///< Channel 3 Pulse Width Modulation Mode Enable   
1201      =2  #define PCA0CPM3_PWM__DISABLED  0x00 ///< Disable PWM function.                          
1202      =2  #define PCA0CPM3_PWM__ENABLED   0x02 ///< Enable PWM function.                           
1203      =2                                                                                           
1204      =2  #define PCA0CPM3_TOG__BMASK     0x04 ///< Channel 3 Toggle Function Enable               
1205      =2  #define PCA0CPM3_TOG__SHIFT     0x02 ///< Channel 3 Toggle Function Enable               
1206      =2  #define PCA0CPM3_TOG__DISABLED  0x00 ///< Disable toggle function.                       
1207      =2  #define PCA0CPM3_TOG__ENABLED   0x04 ///< Enable toggle function.                        
1208      =2                                                                                           
1209      =2  #define PCA0CPM3_MAT__BMASK     0x08 ///< Channel 3 Match Function Enable                
1210      =2  #define PCA0CPM3_MAT__SHIFT     0x03 ///< Channel 3 Match Function Enable                
1211      =2  #define PCA0CPM3_MAT__DISABLED  0x00 ///< Disable match function.                        
1212      =2  #define PCA0CPM3_MAT__ENABLED   0x08 ///< Enable match function.                         
1213      =2                                                                                           
1214      =2  #define PCA0CPM3_CAPN__BMASK    0x10 ///< Channel 3 Capture Negative Function Enable     
1215      =2  #define PCA0CPM3_CAPN__SHIFT    0x04 ///< Channel 3 Capture Negative Function Enable     
1216      =2  #define PCA0CPM3_CAPN__DISABLED 0x00 ///< Disable negative edge capture.                 
1217      =2  #define PCA0CPM3_CAPN__ENABLED  0x10 ///< Enable negative edge capture.                  
1218      =2                                                                                           
1219      =2  #define PCA0CPM3_CAPP__BMASK    0x20 ///< Channel 3 Capture Positive Function Enable     
1220      =2  #define PCA0CPM3_CAPP__SHIFT    0x05 ///< Channel 3 Capture Positive Function Enable     
1221      =2  #define PCA0CPM3_CAPP__DISABLED 0x00 ///< Disable positive edge capture.                 
1222      =2  #define PCA0CPM3_CAPP__ENABLED  0x20 ///< Enable positive edge capture.                  
1223      =2                                                                                           
1224      =2  #define PCA0CPM3_ECOM__BMASK    0x40 ///< Channel 3 Comparator Function Enable           
1225      =2  #define PCA0CPM3_ECOM__SHIFT    0x06 ///< Channel 3 Comparator Function Enable           
1226      =2  #define PCA0CPM3_ECOM__DISABLED 0x00 ///< Disable comparator function.                   
1227      =2  #define PCA0CPM3_ECOM__ENABLED  0x40 ///< Enable comparator function.                    
1228      =2                                                                                           
1229      =2  #define PCA0CPM3_PWM16__BMASK   0x80 ///< Channel 3 16-bit Pulse Width Modulation Enable 
1230      =2  #define PCA0CPM3_PWM16__SHIFT   0x07 ///< Channel 3 16-bit Pulse Width Modulation Enable 
1231      =2  #define PCA0CPM3_PWM16__8_BIT   0x00 ///< 8-bit PWM selected.                            
1232      =2  #define PCA0CPM3_PWM16__16_BIT  0x80 ///< 16-bit PWM selected.                           
1233      =2                                                                                           
1234      =2  //------------------------------------------------------------------------------
1235      =2  // PCA0CPH4 Enums (PCA Channel 4 Capture Module High Byte @ 0xFE)
1236      =2  //------------------------------------------------------------------------------
1237      =2  #define PCA0CPH4_PCA0CPH4__FMASK 0xFF ///< PCA Channel 4 Capture Module High Byte
1238      =2  #define PCA0CPH4_PCA0CPH4__SHIFT 0x00 ///< PCA Channel 4 Capture Module High Byte
1239      =2                                                                                   
1240      =2  //------------------------------------------------------------------------------
1241      =2  // PCA0CPL4 Enums (PCA Channel 4 Capture Module Low Byte @ 0xFD)
1242      =2  //------------------------------------------------------------------------------
1243      =2  #define PCA0CPL4_PCA0CPL4__FMASK 0xFF ///< PCA Channel 4 Capture Module Low Byte
1244      =2  #define PCA0CPL4_PCA0CPL4__SHIFT 0x00 ///< PCA Channel 4 Capture Module Low Byte
1245      =2                                                                                  
1246      =2  //------------------------------------------------------------------------------
1247      =2  // PCA0CPM4 Enums (PCA Channel 4 Capture/Compare Mode @ 0xDE)
1248      =2  //------------------------------------------------------------------------------
1249      =2  #define PCA0CPM4_ECCF__BMASK    0x01 ///< Channel 4 Capture/Compare Flag Interrupt Enable
1250      =2  #define PCA0CPM4_ECCF__SHIFT    0x00 ///< Channel 4 Capture/Compare Flag Interrupt Enable
1251      =2  #define PCA0CPM4_ECCF__DISABLED 0x00 ///< Disable CCF4 interrupts.                       
1252      =2  #define PCA0CPM4_ECCF__ENABLED  0x01 ///< Enable a Capture/Compare Flag interrupt request
C51 COMPILER V9.56.0.0   UART_0                                                            10/28/2016 17:37:02 PAGE 47  

1253      =2                                       ///< when CCF4 is set.                              
1254      =2                                                                                           
1255      =2  #define PCA0CPM4_PWM__BMASK     0x02 ///< Channel 4 Pulse Width Modulation Mode Enable   
1256      =2  #define PCA0CPM4_PWM__SHIFT     0x01 ///< Channel 4 Pulse Width Modulation Mode Enable   
1257      =2  #define PCA0CPM4_PWM__DISABLED  0x00 ///< Disable PWM function.                          
1258      =2  #define PCA0CPM4_PWM__ENABLED   0x02 ///< Enable PWM function.                           
1259      =2                                                                                           
1260      =2  #define PCA0CPM4_TOG__BMASK     0x04 ///< Channel 4 Toggle Function Enable               
1261      =2  #define PCA0CPM4_TOG__SHIFT     0x02 ///< Channel 4 Toggle Function Enable               
1262      =2  #define PCA0CPM4_TOG__DISABLED  0x00 ///< Disable toggle function.                       
1263      =2  #define PCA0CPM4_TOG__ENABLED   0x04 ///< Enable toggle function.                        
1264      =2                                                                                           
1265      =2  #define PCA0CPM4_MAT__BMASK     0x08 ///< Channel 4 Match Function Enable                
1266      =2  #define PCA0CPM4_MAT__SHIFT     0x03 ///< Channel 4 Match Function Enable                
1267      =2  #define PCA0CPM4_MAT__DISABLED  0x00 ///< Disable match function.                        
1268      =2  #define PCA0CPM4_MAT__ENABLED   0x08 ///< Enable match function.                         
1269      =2                                                                                           
1270      =2  #define PCA0CPM4_CAPN__BMASK    0x10 ///< Channel 4 Capture Negative Function Enable     
1271      =2  #define PCA0CPM4_CAPN__SHIFT    0x04 ///< Channel 4 Capture Negative Function Enable     
1272      =2  #define PCA0CPM4_CAPN__DISABLED 0x00 ///< Disable negative edge capture.                 
1273      =2  #define PCA0CPM4_CAPN__ENABLED  0x10 ///< Enable negative edge capture.                  
1274      =2                                                                                           
1275      =2  #define PCA0CPM4_CAPP__BMASK    0x20 ///< Channel 4 Capture Positive Function Enable     
1276      =2  #define PCA0CPM4_CAPP__SHIFT    0x05 ///< Channel 4 Capture Positive Function Enable     
1277      =2  #define PCA0CPM4_CAPP__DISABLED 0x00 ///< Disable positive edge capture.                 
1278      =2  #define PCA0CPM4_CAPP__ENABLED  0x20 ///< Enable positive edge capture.                  
1279      =2                                                                                           
1280      =2  #define PCA0CPM4_ECOM__BMASK    0x40 ///< Channel 4 Comparator Function Enable           
1281      =2  #define PCA0CPM4_ECOM__SHIFT    0x06 ///< Channel 4 Comparator Function Enable           
1282      =2  #define PCA0CPM4_ECOM__DISABLED 0x00 ///< Disable comparator function.                   
1283      =2  #define PCA0CPM4_ECOM__ENABLED  0x40 ///< Enable comparator function.                    
1284      =2                                                                                           
1285      =2  #define PCA0CPM4_PWM16__BMASK   0x80 ///< Channel 4 16-bit Pulse Width Modulation Enable 
1286      =2  #define PCA0CPM4_PWM16__SHIFT   0x07 ///< Channel 4 16-bit Pulse Width Modulation Enable 
1287      =2  #define PCA0CPM4_PWM16__8_BIT   0x00 ///< 8-bit PWM selected.                            
1288      =2  #define PCA0CPM4_PWM16__16_BIT  0x80 ///< 16-bit PWM selected.                           
1289      =2                                                                                           
1290      =2  //------------------------------------------------------------------------------
1291      =2  // PCA0CN0 Enums (PCA Control 0 @ 0xD8)
1292      =2  //------------------------------------------------------------------------------
1293      =2  #define PCA0CN0_CCF0__BMASK   0x01 ///< PCA Module 0 Capture/Compare Flag             
1294      =2  #define PCA0CN0_CCF0__SHIFT   0x00 ///< PCA Module 0 Capture/Compare Flag             
1295      =2  #define PCA0CN0_CCF0__NOT_SET 0x00 ///< A match or capture did not occur on channel 0.
1296      =2  #define PCA0CN0_CCF0__SET     0x01 ///< A match or capture occurred on channel 0.     
1297      =2                                                                                        
1298      =2  #define PCA0CN0_CCF1__BMASK   0x02 ///< PCA Module 1 Capture/Compare Flag             
1299      =2  #define PCA0CN0_CCF1__SHIFT   0x01 ///< PCA Module 1 Capture/Compare Flag             
1300      =2  #define PCA0CN0_CCF1__NOT_SET 0x00 ///< A match or capture did not occur on channel 1.
1301      =2  #define PCA0CN0_CCF1__SET     0x02 ///< A match or capture occurred on channel 1.     
1302      =2                                                                                        
1303      =2  #define PCA0CN0_CCF2__BMASK   0x04 ///< PCA Module 2 Capture/Compare Flag             
1304      =2  #define PCA0CN0_CCF2__SHIFT   0x02 ///< PCA Module 2 Capture/Compare Flag             
1305      =2  #define PCA0CN0_CCF2__NOT_SET 0x00 ///< A match or capture did not occur on channel 2.
1306      =2  #define PCA0CN0_CCF2__SET     0x04 ///< A match or capture occurred on channel 2.     
1307      =2                                                                                        
1308      =2  #define PCA0CN0_CCF3__BMASK   0x08 ///< PCA Module 3 Capture/Compare Flag             
1309      =2  #define PCA0CN0_CCF3__SHIFT   0x03 ///< PCA Module 3 Capture/Compare Flag             
1310      =2  #define PCA0CN0_CCF3__NOT_SET 0x00 ///< A match or capture did not occur on channel 3.
1311      =2  #define PCA0CN0_CCF3__SET     0x08 ///< A match or capture occurred on channel 3.     
1312      =2                                                                                        
1313      =2  #define PCA0CN0_CCF4__BMASK   0x10 ///< PCA Module 4 Capture/Compare Flag             
1314      =2  #define PCA0CN0_CCF4__SHIFT   0x04 ///< PCA Module 4 Capture/Compare Flag             
C51 COMPILER V9.56.0.0   UART_0                                                            10/28/2016 17:37:02 PAGE 48  

1315      =2  #define PCA0CN0_CCF4__NOT_SET 0x00 ///< A match or capture did not occur on channel 4.
1316      =2  #define PCA0CN0_CCF4__SET     0x10 ///< A match or capture occurred on channel 4.     
1317      =2                                                                                        
1318      =2  #define PCA0CN0_CR__BMASK     0x40 ///< PCA Counter/Timer Run Control                 
1319      =2  #define PCA0CN0_CR__SHIFT     0x06 ///< PCA Counter/Timer Run Control                 
1320      =2  #define PCA0CN0_CR__STOP      0x00 ///< Stop the PCA Counter/Timer.                   
1321      =2  #define PCA0CN0_CR__RUN       0x40 ///< Start the PCA Counter/Timer running.          
1322      =2                                                                                        
1323      =2  #define PCA0CN0_CF__BMASK     0x80 ///< PCA Counter/Timer Overflow Flag               
1324      =2  #define PCA0CN0_CF__SHIFT     0x07 ///< PCA Counter/Timer Overflow Flag               
1325      =2  #define PCA0CN0_CF__NOT_SET   0x00 ///< The PCA counter/timer did not overflow.       
1326      =2  #define PCA0CN0_CF__SET       0x80 ///< The PCA counter/timer overflowed.             
1327      =2                                                                                        
1328      =2  //------------------------------------------------------------------------------
1329      =2  // PCA0H Enums (PCA Counter/Timer High Byte @ 0xFA)
1330      =2  //------------------------------------------------------------------------------
1331      =2  #define PCA0H_PCA0H__FMASK 0xFF ///< PCA Counter/Timer High Byte
1332      =2  #define PCA0H_PCA0H__SHIFT 0x00 ///< PCA Counter/Timer High Byte
1333      =2                                                                  
1334      =2  //------------------------------------------------------------------------------
1335      =2  // PCA0L Enums (PCA Counter/Timer Low Byte @ 0xF9)
1336      =2  //------------------------------------------------------------------------------
1337      =2  #define PCA0L_PCA0L__FMASK 0xFF ///< PCA Counter/Timer Low Byte
1338      =2  #define PCA0L_PCA0L__SHIFT 0x00 ///< PCA Counter/Timer Low Byte
1339      =2                                                                 
1340      =2  //------------------------------------------------------------------------------
1341      =2  // PCA0MD Enums (PCA Mode @ 0xD9)
1342      =2  //------------------------------------------------------------------------------
1343      =2  #define PCA0MD_ECF__BMASK            0x01 ///< PCA Counter/Timer Overflow Interrupt Enable       
1344      =2  #define PCA0MD_ECF__SHIFT            0x00 ///< PCA Counter/Timer Overflow Interrupt Enable       
1345      =2  #define PCA0MD_ECF__OVF_INT_DISABLED 0x00 ///< Disable the CF interrupt.                         
1346      =2  #define PCA0MD_ECF__OVF_INT_ENABLED  0x01 ///< Enable a PCA Counter/Timer Overflow interrupt     
1347      =2                                            ///< request when CF is set.                           
1348      =2                                                                                                   
1349      =2  #define PCA0MD_CPS__FMASK            0x0E ///< PCA Counter/Timer Pulse Select                    
1350      =2  #define PCA0MD_CPS__SHIFT            0x01 ///< PCA Counter/Timer Pulse Select                    
1351      =2  #define PCA0MD_CPS__SYSCLK_DIV_12    0x00 ///< System clock divided by 12.                       
1352      =2  #define PCA0MD_CPS__SYSCLK_DIV_4     0x02 ///< System clock divided by 4.                        
1353      =2  #define PCA0MD_CPS__T0_OVERFLOW      0x04 ///< Timer 0 overflow.                                 
1354      =2  #define PCA0MD_CPS__ECI              0x06 ///< High-to-low transitions on ECI (max rate = system 
1355      =2                                            ///< clock divided by 4).                              
1356      =2  #define PCA0MD_CPS__SYSCLK           0x08 ///< System clock.                                     
1357      =2  #define PCA0MD_CPS__EXTOSC_DIV_8     0x0A ///< External clock divided by 8 (synchronized with the
1358      =2                                            ///< system clock).                                    
1359      =2                                                                                                   
1360      =2  #define PCA0MD_WDLCK__BMASK          0x20 ///< Watchdog Timer Lock                               
1361      =2  #define PCA0MD_WDLCK__SHIFT          0x05 ///< Watchdog Timer Lock                               
1362      =2  #define PCA0MD_WDLCK__UNLOCKED       0x00 ///< Watchdog Timer Enable unlocked.                   
1363      =2  #define PCA0MD_WDLCK__LOCKED         0x20 ///< Watchdog Timer Enable locked.                     
1364      =2                                                                                                   
1365      =2  #define PCA0MD_WDTE__BMASK           0x40 ///< Watchdog Timer Enable                             
1366      =2  #define PCA0MD_WDTE__SHIFT           0x06 ///< Watchdog Timer Enable                             
1367      =2  #define PCA0MD_WDTE__DISABLED        0x00 ///< Disable Watchdog Timer.                           
1368      =2  #define PCA0MD_WDTE__ENABLED         0x40 ///< Enable PCA Module 4 as the Watchdog Timer.        
1369      =2                                                                                                   
1370      =2  #define PCA0MD_CIDL__BMASK           0x80 ///< PCA Counter/Timer Idle Control                    
1371      =2  #define PCA0MD_CIDL__SHIFT           0x07 ///< PCA Counter/Timer Idle Control                    
1372      =2  #define PCA0MD_CIDL__NORMAL          0x00 ///< PCA continues to function normally while the      
1373      =2                                            ///< system controller is in Idle Mode.                
1374      =2  #define PCA0MD_CIDL__SUSPEND         0x80 ///< PCA operation is suspended while the system       
1375      =2                                            ///< controller is in Idle Mode.                       
1376      =2                                                                                                   
C51 COMPILER V9.56.0.0   UART_0                                                            10/28/2016 17:37:02 PAGE 49  

1377      =2  //------------------------------------------------------------------------------
1378      =2  // PCON0 Enums (Power Control @ 0x87)
1379      =2  //------------------------------------------------------------------------------
1380      =2  #define PCON0_IDLE__BMASK  0x01 ///< Idle Mode Select                                
1381      =2  #define PCON0_IDLE__SHIFT  0x00 ///< Idle Mode Select                                
1382      =2  #define PCON0_IDLE__NORMAL 0x00 ///< Idle mode not activated.                        
1383      =2  #define PCON0_IDLE__IDLE   0x01 ///< CPU goes into Idle mode (shuts off clock to CPU,
1384      =2                                  ///< but clocks to enabled peripherals are still     
1385      =2                                  ///< active).                                        
1386      =2                                                                                       
1387      =2  #define PCON0_STOP__BMASK  0x02 ///< Stop Mode Select                                
1388      =2  #define PCON0_STOP__SHIFT  0x01 ///< Stop Mode Select                                
1389      =2  #define PCON0_STOP__NORMAL 0x00 ///< Stop mode not activated.                        
1390      =2  #define PCON0_STOP__STOP   0x02 ///< CPU goes into Stop mode (internal oscillator    
1391      =2                                  ///< stopped).                                       
1392      =2                                                                                       
1393      =2  #define PCON0_GF0__BMASK   0x04 ///< General Purpose Flag 0                          
1394      =2  #define PCON0_GF0__SHIFT   0x02 ///< General Purpose Flag 0                          
1395      =2  #define PCON0_GF0__NOT_SET 0x00 ///< The GF0 flag is not set. Clear the GF0 flag.    
1396      =2  #define PCON0_GF0__SET     0x04 ///< The GF0 flag is set. Set the GF0 flag.          
1397      =2                                                                                       
1398      =2  #define PCON0_GF1__BMASK   0x08 ///< General Purpose Flag 1                          
1399      =2  #define PCON0_GF1__SHIFT   0x03 ///< General Purpose Flag 1                          
1400      =2  #define PCON0_GF1__NOT_SET 0x00 ///< The GF1 flag is not set. Clear the GF1 flag.    
1401      =2  #define PCON0_GF1__SET     0x08 ///< The GF1 flag is set. Set the GF1 flag.          
1402      =2                                                                                       
1403      =2  #define PCON0_GF2__BMASK   0x10 ///< General Purpose Flag 2                          
1404      =2  #define PCON0_GF2__SHIFT   0x04 ///< General Purpose Flag 2                          
1405      =2  #define PCON0_GF2__NOT_SET 0x00 ///< The GF2 flag is not set. Clear the GF2 flag.    
1406      =2  #define PCON0_GF2__SET     0x10 ///< The GF2 flag is set. Set the GF2 flag.          
1407      =2                                                                                       
1408      =2  #define PCON0_GF3__BMASK   0x20 ///< General Purpose Flag 3                          
1409      =2  #define PCON0_GF3__SHIFT   0x05 ///< General Purpose Flag 3                          
1410      =2  #define PCON0_GF3__NOT_SET 0x00 ///< The GF3 flag is not set. Clear the GF3 flag.    
1411      =2  #define PCON0_GF3__SET     0x20 ///< The GF3 flag is set. Set the GF3 flag.          
1412      =2                                                                                       
1413      =2  #define PCON0_GF4__BMASK   0x40 ///< General Purpose Flag 4                          
1414      =2  #define PCON0_GF4__SHIFT   0x06 ///< General Purpose Flag 4                          
1415      =2  #define PCON0_GF4__NOT_SET 0x00 ///< The GF4 flag is not set. Clear the GF4 flag.    
1416      =2  #define PCON0_GF4__SET     0x40 ///< The GF4 flag is set. Set the GF4 flag.          
1417      =2                                                                                       
1418      =2  #define PCON0_GF5__BMASK   0x80 ///< General Purpose Flag 5                          
1419      =2  #define PCON0_GF5__SHIFT   0x07 ///< General Purpose Flag 5                          
1420      =2  #define PCON0_GF5__NOT_SET 0x00 ///< The GF5 flag is not set. Clear the GF5 flag.    
1421      =2  #define PCON0_GF5__SET     0x80 ///< The GF5 flag is set. Set the GF5 flag.          
1422      =2                                                                                       
1423      =2  //------------------------------------------------------------------------------
1424      =2  // P0 Enums (Port 0 Pin Latch @ 0x80)
1425      =2  //------------------------------------------------------------------------------
1426      =2  #define P0_B0__BMASK 0x01 ///< Port 0 Bit 0 Latch                            
1427      =2  #define P0_B0__SHIFT 0x00 ///< Port 0 Bit 0 Latch                            
1428      =2  #define P0_B0__LOW   0x00 ///< P0.0 is low. Set P0.0 to drive low.           
1429      =2  #define P0_B0__HIGH  0x01 ///< P0.0 is high. Set P0.0 to drive or float high.
1430      =2                                                                               
1431      =2  #define P0_B1__BMASK 0x02 ///< Port 0 Bit 1 Latch                            
1432      =2  #define P0_B1__SHIFT 0x01 ///< Port 0 Bit 1 Latch                            
1433      =2  #define P0_B1__LOW   0x00 ///< P0.1 is low. Set P0.1 to drive low.           
1434      =2  #define P0_B1__HIGH  0x02 ///< P0.1 is high. Set P0.1 to drive or float high.
1435      =2                                                                               
1436      =2  #define P0_B2__BMASK 0x04 ///< Port 0 Bit 2 Latch                            
1437      =2  #define P0_B2__SHIFT 0x02 ///< Port 0 Bit 2 Latch                            
1438      =2  #define P0_B2__LOW   0x00 ///< P0.2 is low. Set P0.2 to drive low.           
C51 COMPILER V9.56.0.0   UART_0                                                            10/28/2016 17:37:02 PAGE 50  

1439      =2  #define P0_B2__HIGH  0x04 ///< P0.2 is high. Set P0.2 to drive or float high.
1440      =2                                                                               
1441      =2  #define P0_B3__BMASK 0x08 ///< Port 0 Bit 3 Latch                            
1442      =2  #define P0_B3__SHIFT 0x03 ///< Port 0 Bit 3 Latch                            
1443      =2  #define P0_B3__LOW   0x00 ///< P0.3 is low. Set P0.3 to drive low.           
1444      =2  #define P0_B3__HIGH  0x08 ///< P0.3 is high. Set P0.3 to drive or float high.
1445      =2                                                                               
1446      =2  #define P0_B4__BMASK 0x10 ///< Port 0 Bit 4 Latch                            
1447      =2  #define P0_B4__SHIFT 0x04 ///< Port 0 Bit 4 Latch                            
1448      =2  #define P0_B4__LOW   0x00 ///< P0.4 is low. Set P0.4 to drive low.           
1449      =2  #define P0_B4__HIGH  0x10 ///< P0.4 is high. Set P0.4 to drive or float high.
1450      =2                                                                               
1451      =2  #define P0_B5__BMASK 0x20 ///< Port 0 Bit 5 Latch                            
1452      =2  #define P0_B5__SHIFT 0x05 ///< Port 0 Bit 5 Latch                            
1453      =2  #define P0_B5__LOW   0x00 ///< P0.5 is low. Set P0.5 to drive low.           
1454      =2  #define P0_B5__HIGH  0x20 ///< P0.5 is high. Set P0.5 to drive or float high.
1455      =2                                                                               
1456      =2  #define P0_B6__BMASK 0x40 ///< Port 0 Bit 6 Latch                            
1457      =2  #define P0_B6__SHIFT 0x06 ///< Port 0 Bit 6 Latch                            
1458      =2  #define P0_B6__LOW   0x00 ///< P0.6 is low. Set P0.6 to drive low.           
1459      =2  #define P0_B6__HIGH  0x40 ///< P0.6 is high. Set P0.6 to drive or float high.
1460      =2                                                                               
1461      =2  #define P0_B7__BMASK 0x80 ///< Port 0 Bit 7 Latch                            
1462      =2  #define P0_B7__SHIFT 0x07 ///< Port 0 Bit 7 Latch                            
1463      =2  #define P0_B7__LOW   0x00 ///< P0.7 is low. Set P0.7 to drive low.           
1464      =2  #define P0_B7__HIGH  0x80 ///< P0.7 is high. Set P0.7 to drive or float high.
1465      =2                                                                               
1466      =2  //------------------------------------------------------------------------------
1467      =2  // P0MDIN Enums (Port 0 Input Mode @ 0xF1)
1468      =2  //------------------------------------------------------------------------------
1469      =2  #define P0MDIN_B0__BMASK   0x01 ///< Port 0 Bit 0 Input Mode                 
1470      =2  #define P0MDIN_B0__SHIFT   0x00 ///< Port 0 Bit 0 Input Mode                 
1471      =2  #define P0MDIN_B0__ANALOG  0x00 ///< P0.0 pin is configured for analog mode. 
1472      =2  #define P0MDIN_B0__DIGITAL 0x01 ///< P0.0 pin is configured for digital mode.
1473      =2                                                                               
1474      =2  #define P0MDIN_B1__BMASK   0x02 ///< Port 0 Bit 1 Input Mode                 
1475      =2  #define P0MDIN_B1__SHIFT   0x01 ///< Port 0 Bit 1 Input Mode                 
1476      =2  #define P0MDIN_B1__ANALOG  0x00 ///< P0.1 pin is configured for analog mode. 
1477      =2  #define P0MDIN_B1__DIGITAL 0x02 ///< P0.1 pin is configured for digital mode.
1478      =2                                                                               
1479      =2  #define P0MDIN_B2__BMASK   0x04 ///< Port 0 Bit 2 Input Mode                 
1480      =2  #define P0MDIN_B2__SHIFT   0x02 ///< Port 0 Bit 2 Input Mode                 
1481      =2  #define P0MDIN_B2__ANALOG  0x00 ///< P0.2 pin is configured for analog mode. 
1482      =2  #define P0MDIN_B2__DIGITAL 0x04 ///< P0.2 pin is configured for digital mode.
1483      =2                                                                               
1484      =2  #define P0MDIN_B3__BMASK   0x08 ///< Port 0 Bit 3 Input Mode                 
1485      =2  #define P0MDIN_B3__SHIFT   0x03 ///< Port 0 Bit 3 Input Mode                 
1486      =2  #define P0MDIN_B3__ANALOG  0x00 ///< P0.3 pin is configured for analog mode. 
1487      =2  #define P0MDIN_B3__DIGITAL 0x08 ///< P0.3 pin is configured for digital mode.
1488      =2                                                                               
1489      =2  #define P0MDIN_B4__BMASK   0x10 ///< Port 0 Bit 4 Input Mode                 
1490      =2  #define P0MDIN_B4__SHIFT   0x04 ///< Port 0 Bit 4 Input Mode                 
1491      =2  #define P0MDIN_B4__ANALOG  0x00 ///< P0.4 pin is configured for analog mode. 
1492      =2  #define P0MDIN_B4__DIGITAL 0x10 ///< P0.4 pin is configured for digital mode.
1493      =2                                                                               
1494      =2  #define P0MDIN_B5__BMASK   0x20 ///< Port 0 Bit 5 Input Mode                 
1495      =2  #define P0MDIN_B5__SHIFT   0x05 ///< Port 0 Bit 5 Input Mode                 
1496      =2  #define P0MDIN_B5__ANALOG  0x00 ///< P0.5 pin is configured for analog mode. 
1497      =2  #define P0MDIN_B5__DIGITAL 0x20 ///< P0.5 pin is configured for digital mode.
1498      =2                                                                               
1499      =2  #define P0MDIN_B6__BMASK   0x40 ///< Port 0 Bit 6 Input Mode                 
1500      =2  #define P0MDIN_B6__SHIFT   0x06 ///< Port 0 Bit 6 Input Mode                 
C51 COMPILER V9.56.0.0   UART_0                                                            10/28/2016 17:37:02 PAGE 51  

1501      =2  #define P0MDIN_B6__ANALOG  0x00 ///< P0.6 pin is configured for analog mode. 
1502      =2  #define P0MDIN_B6__DIGITAL 0x40 ///< P0.6 pin is configured for digital mode.
1503      =2                                                                               
1504      =2  #define P0MDIN_B7__BMASK   0x80 ///< Port 0 Bit 7 Input Mode                 
1505      =2  #define P0MDIN_B7__SHIFT   0x07 ///< Port 0 Bit 7 Input Mode                 
1506      =2  #define P0MDIN_B7__ANALOG  0x00 ///< P0.7 pin is configured for analog mode. 
1507      =2  #define P0MDIN_B7__DIGITAL 0x80 ///< P0.7 pin is configured for digital mode.
1508      =2                                                                               
1509      =2  //------------------------------------------------------------------------------
1510      =2  // P0MDOUT Enums (Port 0 Output Mode @ 0xA4)
1511      =2  //------------------------------------------------------------------------------
1512      =2  #define P0MDOUT_B0__BMASK      0x01 ///< Port 0 Bit 0 Output Mode  
1513      =2  #define P0MDOUT_B0__SHIFT      0x00 ///< Port 0 Bit 0 Output Mode  
1514      =2  #define P0MDOUT_B0__OPEN_DRAIN 0x00 ///< P0.0 output is open-drain.
1515      =2  #define P0MDOUT_B0__PUSH_PULL  0x01 ///< P0.0 output is push-pull. 
1516      =2                                                                     
1517      =2  #define P0MDOUT_B1__BMASK      0x02 ///< Port 0 Bit 1 Output Mode  
1518      =2  #define P0MDOUT_B1__SHIFT      0x01 ///< Port 0 Bit 1 Output Mode  
1519      =2  #define P0MDOUT_B1__OPEN_DRAIN 0x00 ///< P0.1 output is open-drain.
1520      =2  #define P0MDOUT_B1__PUSH_PULL  0x02 ///< P0.1 output is push-pull. 
1521      =2                                                                     
1522      =2  #define P0MDOUT_B2__BMASK      0x04 ///< Port 0 Bit 2 Output Mode  
1523      =2  #define P0MDOUT_B2__SHIFT      0x02 ///< Port 0 Bit 2 Output Mode  
1524      =2  #define P0MDOUT_B2__OPEN_DRAIN 0x00 ///< P0.2 output is open-drain.
1525      =2  #define P0MDOUT_B2__PUSH_PULL  0x04 ///< P0.2 output is push-pull. 
1526      =2                                                                     
1527      =2  #define P0MDOUT_B3__BMASK      0x08 ///< Port 0 Bit 3 Output Mode  
1528      =2  #define P0MDOUT_B3__SHIFT      0x03 ///< Port 0 Bit 3 Output Mode  
1529      =2  #define P0MDOUT_B3__OPEN_DRAIN 0x00 ///< P0.3 output is open-drain.
1530      =2  #define P0MDOUT_B3__PUSH_PULL  0x08 ///< P0.3 output is push-pull. 
1531      =2                                                                     
1532      =2  #define P0MDOUT_B4__BMASK      0x10 ///< Port 0 Bit 4 Output Mode  
1533      =2  #define P0MDOUT_B4__SHIFT      0x04 ///< Port 0 Bit 4 Output Mode  
1534      =2  #define P0MDOUT_B4__OPEN_DRAIN 0x00 ///< P0.4 output is open-drain.
1535      =2  #define P0MDOUT_B4__PUSH_PULL  0x10 ///< P0.4 output is push-pull. 
1536      =2                                                                     
1537      =2  #define P0MDOUT_B5__BMASK      0x20 ///< Port 0 Bit 5 Output Mode  
1538      =2  #define P0MDOUT_B5__SHIFT      0x05 ///< Port 0 Bit 5 Output Mode  
1539      =2  #define P0MDOUT_B5__OPEN_DRAIN 0x00 ///< P0.5 output is open-drain.
1540      =2  #define P0MDOUT_B5__PUSH_PULL  0x20 ///< P0.5 output is push-pull. 
1541      =2                                                                     
1542      =2  #define P0MDOUT_B6__BMASK      0x40 ///< Port 0 Bit 6 Output Mode  
1543      =2  #define P0MDOUT_B6__SHIFT      0x06 ///< Port 0 Bit 6 Output Mode  
1544      =2  #define P0MDOUT_B6__OPEN_DRAIN 0x00 ///< P0.6 output is open-drain.
1545      =2  #define P0MDOUT_B6__PUSH_PULL  0x40 ///< P0.6 output is push-pull. 
1546      =2                                                                     
1547      =2  #define P0MDOUT_B7__BMASK      0x80 ///< Port 0 Bit 7 Output Mode  
1548      =2  #define P0MDOUT_B7__SHIFT      0x07 ///< Port 0 Bit 7 Output Mode  
1549      =2  #define P0MDOUT_B7__OPEN_DRAIN 0x00 ///< P0.7 output is open-drain.
1550      =2  #define P0MDOUT_B7__PUSH_PULL  0x80 ///< P0.7 output is push-pull. 
1551      =2                                                                     
1552      =2  //------------------------------------------------------------------------------
1553      =2  // P0SKIP Enums (Port 0 Skip @ 0xD4)
1554      =2  //------------------------------------------------------------------------------
1555      =2  #define P0SKIP_B0__BMASK       0x01 ///< Port 0 Bit 0 Skip                       
1556      =2  #define P0SKIP_B0__SHIFT       0x00 ///< Port 0 Bit 0 Skip                       
1557      =2  #define P0SKIP_B0__NOT_SKIPPED 0x00 ///< P0.0 pin is not skipped by the crossbar.
1558      =2  #define P0SKIP_B0__SKIPPED     0x01 ///< P0.0 pin is skipped by the crossbar.    
1559      =2                                                                                   
1560      =2  #define P0SKIP_B1__BMASK       0x02 ///< Port 0 Bit 1 Skip                       
1561      =2  #define P0SKIP_B1__SHIFT       0x01 ///< Port 0 Bit 1 Skip                       
1562      =2  #define P0SKIP_B1__NOT_SKIPPED 0x00 ///< P0.1 pin is not skipped by the crossbar.
C51 COMPILER V9.56.0.0   UART_0                                                            10/28/2016 17:37:02 PAGE 52  

1563      =2  #define P0SKIP_B1__SKIPPED     0x02 ///< P0.1 pin is skipped by the crossbar.    
1564      =2                                                                                   
1565      =2  #define P0SKIP_B2__BMASK       0x04 ///< Port 0 Bit 2 Skip                       
1566      =2  #define P0SKIP_B2__SHIFT       0x02 ///< Port 0 Bit 2 Skip                       
1567      =2  #define P0SKIP_B2__NOT_SKIPPED 0x00 ///< P0.2 pin is not skipped by the crossbar.
1568      =2  #define P0SKIP_B2__SKIPPED     0x04 ///< P0.2 pin is skipped by the crossbar.    
1569      =2                                                                                   
1570      =2  #define P0SKIP_B3__BMASK       0x08 ///< Port 0 Bit 3 Skip                       
1571      =2  #define P0SKIP_B3__SHIFT       0x03 ///< Port 0 Bit 3 Skip                       
1572      =2  #define P0SKIP_B3__NOT_SKIPPED 0x00 ///< P0.3 pin is not skipped by the crossbar.
1573      =2  #define P0SKIP_B3__SKIPPED     0x08 ///< P0.3 pin is skipped by the crossbar.    
1574      =2                                                                                   
1575      =2  #define P0SKIP_B4__BMASK       0x10 ///< Port 0 Bit 4 Skip                       
1576      =2  #define P0SKIP_B4__SHIFT       0x04 ///< Port 0 Bit 4 Skip                       
1577      =2  #define P0SKIP_B4__NOT_SKIPPED 0x00 ///< P0.4 pin is not skipped by the crossbar.
1578      =2  #define P0SKIP_B4__SKIPPED     0x10 ///< P0.4 pin is skipped by the crossbar.    
1579      =2                                                                                   
1580      =2  #define P0SKIP_B5__BMASK       0x20 ///< Port 0 Bit 5 Skip                       
1581      =2  #define P0SKIP_B5__SHIFT       0x05 ///< Port 0 Bit 5 Skip                       
1582      =2  #define P0SKIP_B5__NOT_SKIPPED 0x00 ///< P0.5 pin is not skipped by the crossbar.
1583      =2  #define P0SKIP_B5__SKIPPED     0x20 ///< P0.5 pin is skipped by the crossbar.    
1584      =2                                                                                   
1585      =2  #define P0SKIP_B6__BMASK       0x40 ///< Port 0 Bit 6 Skip                       
1586      =2  #define P0SKIP_B6__SHIFT       0x06 ///< Port 0 Bit 6 Skip                       
1587      =2  #define P0SKIP_B6__NOT_SKIPPED 0x00 ///< P0.6 pin is not skipped by the crossbar.
1588      =2  #define P0SKIP_B6__SKIPPED     0x40 ///< P0.6 pin is skipped by the crossbar.    
1589      =2                                                                                   
1590      =2  #define P0SKIP_B7__BMASK       0x80 ///< Port 0 Bit 7 Skip                       
1591      =2  #define P0SKIP_B7__SHIFT       0x07 ///< Port 0 Bit 7 Skip                       
1592      =2  #define P0SKIP_B7__NOT_SKIPPED 0x00 ///< P0.7 pin is not skipped by the crossbar.
1593      =2  #define P0SKIP_B7__SKIPPED     0x80 ///< P0.7 pin is skipped by the crossbar.    
1594      =2                                                                                   
1595      =2  //------------------------------------------------------------------------------
1596      =2  // P1 Enums (Port 1 Pin Latch @ 0x90)
1597      =2  //------------------------------------------------------------------------------
1598      =2  #define P1_B0__BMASK 0x01 ///< Port 1 Bit 0 Latch                            
1599      =2  #define P1_B0__SHIFT 0x00 ///< Port 1 Bit 0 Latch                            
1600      =2  #define P1_B0__LOW   0x00 ///< P1.0 is low. Set P1.0 to drive low.           
1601      =2  #define P1_B0__HIGH  0x01 ///< P1.0 is high. Set P1.0 to drive or float high.
1602      =2                                                                               
1603      =2  #define P1_B1__BMASK 0x02 ///< Port 1 Bit 1 Latch                            
1604      =2  #define P1_B1__SHIFT 0x01 ///< Port 1 Bit 1 Latch                            
1605      =2  #define P1_B1__LOW   0x00 ///< P1.1 is low. Set P1.1 to drive low.           
1606      =2  #define P1_B1__HIGH  0x02 ///< P1.1 is high. Set P1.1 to drive or float high.
1607      =2                                                                               
1608      =2  #define P1_B2__BMASK 0x04 ///< Port 1 Bit 2 Latch                            
1609      =2  #define P1_B2__SHIFT 0x02 ///< Port 1 Bit 2 Latch                            
1610      =2  #define P1_B2__LOW   0x00 ///< P1.2 is low. Set P1.2 to drive low.           
1611      =2  #define P1_B2__HIGH  0x04 ///< P1.2 is high. Set P1.2 to drive or float high.
1612      =2                                                                               
1613      =2  #define P1_B3__BMASK 0x08 ///< Port 1 Bit 3 Latch                            
1614      =2  #define P1_B3__SHIFT 0x03 ///< Port 1 Bit 3 Latch                            
1615      =2  #define P1_B3__LOW   0x00 ///< P1.3 is low. Set P1.3 to drive low.           
1616      =2  #define P1_B3__HIGH  0x08 ///< P1.3 is high. Set P1.3 to drive or float high.
1617      =2                                                                               
1618      =2  #define P1_B4__BMASK 0x10 ///< Port 1 Bit 4 Latch                            
1619      =2  #define P1_B4__SHIFT 0x04 ///< Port 1 Bit 4 Latch                            
1620      =2  #define P1_B4__LOW   0x00 ///< P1.4 is low. Set P1.4 to drive low.           
1621      =2  #define P1_B4__HIGH  0x10 ///< P1.4 is high. Set P1.4 to drive or float high.
1622      =2                                                                               
1623      =2  #define P1_B5__BMASK 0x20 ///< Port 1 Bit 5 Latch                            
1624      =2  #define P1_B5__SHIFT 0x05 ///< Port 1 Bit 5 Latch                            
C51 COMPILER V9.56.0.0   UART_0                                                            10/28/2016 17:37:02 PAGE 53  

1625      =2  #define P1_B5__LOW   0x00 ///< P1.5 is low. Set P1.5 to drive low.           
1626      =2  #define P1_B5__HIGH  0x20 ///< P1.5 is high. Set P1.5 to drive or float high.
1627      =2                                                                               
1628      =2  #define P1_B6__BMASK 0x40 ///< Port 1 Bit 6 Latch                            
1629      =2  #define P1_B6__SHIFT 0x06 ///< Port 1 Bit 6 Latch                            
1630      =2  #define P1_B6__LOW   0x00 ///< P1.6 is low. Set P1.6 to drive low.           
1631      =2  #define P1_B6__HIGH  0x40 ///< P1.6 is high. Set P1.6 to drive or float high.
1632      =2                                                                               
1633      =2  #define P1_B7__BMASK 0x80 ///< Port 1 Bit 7 Latch                            
1634      =2  #define P1_B7__SHIFT 0x07 ///< Port 1 Bit 7 Latch                            
1635      =2  #define P1_B7__LOW   0x00 ///< P1.7 is low. Set P1.7 to drive low.           
1636      =2  #define P1_B7__HIGH  0x80 ///< P1.7 is high. Set P1.7 to drive or float high.
1637      =2                                                                               
1638      =2  //------------------------------------------------------------------------------
1639      =2  // P1MDIN Enums (Port 1 Input Mode @ 0xF2)
1640      =2  //------------------------------------------------------------------------------
1641      =2  #define P1MDIN_B0__BMASK   0x01 ///< Port 1 Bit 0 Input Mode                 
1642      =2  #define P1MDIN_B0__SHIFT   0x00 ///< Port 1 Bit 0 Input Mode                 
1643      =2  #define P1MDIN_B0__ANALOG  0x00 ///< P1.0 pin is configured for analog mode. 
1644      =2  #define P1MDIN_B0__DIGITAL 0x01 ///< P1.0 pin is configured for digital mode.
1645      =2                                                                               
1646      =2  #define P1MDIN_B1__BMASK   0x02 ///< Port 1 Bit 1 Input Mode                 
1647      =2  #define P1MDIN_B1__SHIFT   0x01 ///< Port 1 Bit 1 Input Mode                 
1648      =2  #define P1MDIN_B1__ANALOG  0x00 ///< P1.1 pin is configured for analog mode. 
1649      =2  #define P1MDIN_B1__DIGITAL 0x02 ///< P1.1 pin is configured for digital mode.
1650      =2                                                                               
1651      =2  #define P1MDIN_B2__BMASK   0x04 ///< Port 1 Bit 2 Input Mode                 
1652      =2  #define P1MDIN_B2__SHIFT   0x02 ///< Port 1 Bit 2 Input Mode                 
1653      =2  #define P1MDIN_B2__ANALOG  0x00 ///< P1.2 pin is configured for analog mode. 
1654      =2  #define P1MDIN_B2__DIGITAL 0x04 ///< P1.2 pin is configured for digital mode.
1655      =2                                                                               
1656      =2  #define P1MDIN_B3__BMASK   0x08 ///< Port 1 Bit 3 Input Mode                 
1657      =2  #define P1MDIN_B3__SHIFT   0x03 ///< Port 1 Bit 3 Input Mode                 
1658      =2  #define P1MDIN_B3__ANALOG  0x00 ///< P1.3 pin is configured for analog mode. 
1659      =2  #define P1MDIN_B3__DIGITAL 0x08 ///< P1.3 pin is configured for digital mode.
1660      =2                                                                               
1661      =2  #define P1MDIN_B4__BMASK   0x10 ///< Port 1 Bit 4 Input Mode                 
1662      =2  #define P1MDIN_B4__SHIFT   0x04 ///< Port 1 Bit 4 Input Mode                 
1663      =2  #define P1MDIN_B4__ANALOG  0x00 ///< P1.4 pin is configured for analog mode. 
1664      =2  #define P1MDIN_B4__DIGITAL 0x10 ///< P1.4 pin is configured for digital mode.
1665      =2                                                                               
1666      =2  #define P1MDIN_B5__BMASK   0x20 ///< Port 1 Bit 5 Input Mode                 
1667      =2  #define P1MDIN_B5__SHIFT   0x05 ///< Port 1 Bit 5 Input Mode                 
1668      =2  #define P1MDIN_B5__ANALOG  0x00 ///< P1.5 pin is configured for analog mode. 
1669      =2  #define P1MDIN_B5__DIGITAL 0x20 ///< P1.5 pin is configured for digital mode.
1670      =2                                                                               
1671      =2  #define P1MDIN_B6__BMASK   0x40 ///< Port 1 Bit 6 Input Mode                 
1672      =2  #define P1MDIN_B6__SHIFT   0x06 ///< Port 1 Bit 6 Input Mode                 
1673      =2  #define P1MDIN_B6__ANALOG  0x00 ///< P1.6 pin is configured for analog mode. 
1674      =2  #define P1MDIN_B6__DIGITAL 0x40 ///< P1.6 pin is configured for digital mode.
1675      =2                                                                               
1676      =2  #define P1MDIN_B7__BMASK   0x80 ///< Port 1 Bit 7 Input Mode                 
1677      =2  #define P1MDIN_B7__SHIFT   0x07 ///< Port 1 Bit 7 Input Mode                 
1678      =2  #define P1MDIN_B7__ANALOG  0x00 ///< P1.7 pin is configured for analog mode. 
1679      =2  #define P1MDIN_B7__DIGITAL 0x80 ///< P1.7 pin is configured for digital mode.
1680      =2                                                                               
1681      =2  //------------------------------------------------------------------------------
1682      =2  // P1MDOUT Enums (Port 1 Output Mode @ 0xA5)
1683      =2  //------------------------------------------------------------------------------
1684      =2  #define P1MDOUT_B0__BMASK      0x01 ///< Port 1 Bit 0 Output Mode  
1685      =2  #define P1MDOUT_B0__SHIFT      0x00 ///< Port 1 Bit 0 Output Mode  
1686      =2  #define P1MDOUT_B0__OPEN_DRAIN 0x00 ///< P1.0 output is open-drain.
C51 COMPILER V9.56.0.0   UART_0                                                            10/28/2016 17:37:02 PAGE 54  

1687      =2  #define P1MDOUT_B0__PUSH_PULL  0x01 ///< P1.0 output is push-pull. 
1688      =2                                                                     
1689      =2  #define P1MDOUT_B1__BMASK      0x02 ///< Port 1 Bit 1 Output Mode  
1690      =2  #define P1MDOUT_B1__SHIFT      0x01 ///< Port 1 Bit 1 Output Mode  
1691      =2  #define P1MDOUT_B1__OPEN_DRAIN 0x00 ///< P1.1 output is open-drain.
1692      =2  #define P1MDOUT_B1__PUSH_PULL  0x02 ///< P1.1 output is push-pull. 
1693      =2                                                                     
1694      =2  #define P1MDOUT_B2__BMASK      0x04 ///< Port 1 Bit 2 Output Mode  
1695      =2  #define P1MDOUT_B2__SHIFT      0x02 ///< Port 1 Bit 2 Output Mode  
1696      =2  #define P1MDOUT_B2__OPEN_DRAIN 0x00 ///< P1.2 output is open-drain.
1697      =2  #define P1MDOUT_B2__PUSH_PULL  0x04 ///< P1.2 output is push-pull. 
1698      =2                                                                     
1699      =2  #define P1MDOUT_B3__BMASK      0x08 ///< Port 1 Bit 3 Output Mode  
1700      =2  #define P1MDOUT_B3__SHIFT      0x03 ///< Port 1 Bit 3 Output Mode  
1701      =2  #define P1MDOUT_B3__OPEN_DRAIN 0x00 ///< P1.3 output is open-drain.
1702      =2  #define P1MDOUT_B3__PUSH_PULL  0x08 ///< P1.3 output is push-pull. 
1703      =2                                                                     
1704      =2  #define P1MDOUT_B4__BMASK      0x10 ///< Port 1 Bit 4 Output Mode  
1705      =2  #define P1MDOUT_B4__SHIFT      0x04 ///< Port 1 Bit 4 Output Mode  
1706      =2  #define P1MDOUT_B4__OPEN_DRAIN 0x00 ///< P1.4 output is open-drain.
1707      =2  #define P1MDOUT_B4__PUSH_PULL  0x10 ///< P1.4 output is push-pull. 
1708      =2                                                                     
1709      =2  #define P1MDOUT_B5__BMASK      0x20 ///< Port 1 Bit 5 Output Mode  
1710      =2  #define P1MDOUT_B5__SHIFT      0x05 ///< Port 1 Bit 5 Output Mode  
1711      =2  #define P1MDOUT_B5__OPEN_DRAIN 0x00 ///< P1.5 output is open-drain.
1712      =2  #define P1MDOUT_B5__PUSH_PULL  0x20 ///< P1.5 output is push-pull. 
1713      =2                                                                     
1714      =2  #define P1MDOUT_B6__BMASK      0x40 ///< Port 1 Bit 6 Output Mode  
1715      =2  #define P1MDOUT_B6__SHIFT      0x06 ///< Port 1 Bit 6 Output Mode  
1716      =2  #define P1MDOUT_B6__OPEN_DRAIN 0x00 ///< P1.6 output is open-drain.
1717      =2  #define P1MDOUT_B6__PUSH_PULL  0x40 ///< P1.6 output is push-pull. 
1718      =2                                                                     
1719      =2  #define P1MDOUT_B7__BMASK      0x80 ///< Port 1 Bit 7 Output Mode  
1720      =2  #define P1MDOUT_B7__SHIFT      0x07 ///< Port 1 Bit 7 Output Mode  
1721      =2  #define P1MDOUT_B7__OPEN_DRAIN 0x00 ///< P1.7 output is open-drain.
1722      =2  #define P1MDOUT_B7__PUSH_PULL  0x80 ///< P1.7 output is push-pull. 
1723      =2                                                                     
1724      =2  //------------------------------------------------------------------------------
1725      =2  // P1SKIP Enums (Port 1 Skip @ 0xD5)
1726      =2  //------------------------------------------------------------------------------
1727      =2  #define P1SKIP_B0__BMASK       0x01 ///< Port 1 Bit 0 Skip                       
1728      =2  #define P1SKIP_B0__SHIFT       0x00 ///< Port 1 Bit 0 Skip                       
1729      =2  #define P1SKIP_B0__NOT_SKIPPED 0x00 ///< P1.0 pin is not skipped by the crossbar.
1730      =2  #define P1SKIP_B0__SKIPPED     0x01 ///< P1.0 pin is skipped by the crossbar.    
1731      =2                                                                                   
1732      =2  #define P1SKIP_B1__BMASK       0x02 ///< Port 1 Bit 1 Skip                       
1733      =2  #define P1SKIP_B1__SHIFT       0x01 ///< Port 1 Bit 1 Skip                       
1734      =2  #define P1SKIP_B1__NOT_SKIPPED 0x00 ///< P1.1 pin is not skipped by the crossbar.
1735      =2  #define P1SKIP_B1__SKIPPED     0x02 ///< P1.1 pin is skipped by the crossbar.    
1736      =2                                                                                   
1737      =2  #define P1SKIP_B2__BMASK       0x04 ///< Port 1 Bit 2 Skip                       
1738      =2  #define P1SKIP_B2__SHIFT       0x02 ///< Port 1 Bit 2 Skip                       
1739      =2  #define P1SKIP_B2__NOT_SKIPPED 0x00 ///< P1.2 pin is not skipped by the crossbar.
1740      =2  #define P1SKIP_B2__SKIPPED     0x04 ///< P1.2 pin is skipped by the crossbar.    
1741      =2                                                                                   
1742      =2  #define P1SKIP_B3__BMASK       0x08 ///< Port 1 Bit 3 Skip                       
1743      =2  #define P1SKIP_B3__SHIFT       0x03 ///< Port 1 Bit 3 Skip                       
1744      =2  #define P1SKIP_B3__NOT_SKIPPED 0x00 ///< P1.3 pin is not skipped by the crossbar.
1745      =2  #define P1SKIP_B3__SKIPPED     0x08 ///< P1.3 pin is skipped by the crossbar.    
1746      =2                                                                                   
1747      =2  #define P1SKIP_B4__BMASK       0x10 ///< Port 1 Bit 4 Skip                       
1748      =2  #define P1SKIP_B4__SHIFT       0x04 ///< Port 1 Bit 4 Skip                       
C51 COMPILER V9.56.0.0   UART_0                                                            10/28/2016 17:37:02 PAGE 55  

1749      =2  #define P1SKIP_B4__NOT_SKIPPED 0x00 ///< P1.4 pin is not skipped by the crossbar.
1750      =2  #define P1SKIP_B4__SKIPPED     0x10 ///< P1.4 pin is skipped by the crossbar.    
1751      =2                                                                                   
1752      =2  #define P1SKIP_B5__BMASK       0x20 ///< Port 1 Bit 5 Skip                       
1753      =2  #define P1SKIP_B5__SHIFT       0x05 ///< Port 1 Bit 5 Skip                       
1754      =2  #define P1SKIP_B5__NOT_SKIPPED 0x00 ///< P1.5 pin is not skipped by the crossbar.
1755      =2  #define P1SKIP_B5__SKIPPED     0x20 ///< P1.5 pin is skipped by the crossbar.    
1756      =2                                                                                   
1757      =2  #define P1SKIP_B6__BMASK       0x40 ///< Port 1 Bit 6 Skip                       
1758      =2  #define P1SKIP_B6__SHIFT       0x06 ///< Port 1 Bit 6 Skip                       
1759      =2  #define P1SKIP_B6__NOT_SKIPPED 0x00 ///< P1.6 pin is not skipped by the crossbar.
1760      =2  #define P1SKIP_B6__SKIPPED     0x40 ///< P1.6 pin is skipped by the crossbar.    
1761      =2                                                                                   
1762      =2  #define P1SKIP_B7__BMASK       0x80 ///< Port 1 Bit 7 Skip                       
1763      =2  #define P1SKIP_B7__SHIFT       0x07 ///< Port 1 Bit 7 Skip                       
1764      =2  #define P1SKIP_B7__NOT_SKIPPED 0x00 ///< P1.7 pin is not skipped by the crossbar.
1765      =2  #define P1SKIP_B7__SKIPPED     0x80 ///< P1.7 pin is skipped by the crossbar.    
1766      =2                                                                                   
1767      =2  //------------------------------------------------------------------------------
1768      =2  // P2 Enums (Port 2 Pin Latch @ 0xA0)
1769      =2  //------------------------------------------------------------------------------
1770      =2  #define P2_B0__BMASK 0x01 ///< Port 2 Bit 0 Latch                            
1771      =2  #define P2_B0__SHIFT 0x00 ///< Port 2 Bit 0 Latch                            
1772      =2  #define P2_B0__LOW   0x00 ///< P2.0 is low. Set P2.0 to drive low.           
1773      =2  #define P2_B0__HIGH  0x01 ///< P2.0 is high. Set P2.0 to drive or float high.
1774      =2                                                                               
1775      =2  #define P2_B1__BMASK 0x02 ///< Port 2 Bit 1 Latch                            
1776      =2  #define P2_B1__SHIFT 0x01 ///< Port 2 Bit 1 Latch                            
1777      =2  #define P2_B1__LOW   0x00 ///< P2.1 is low. Set P2.1 to drive low.           
1778      =2  #define P2_B1__HIGH  0x02 ///< P2.1 is high. Set P2.1 to drive or float high.
1779      =2                                                                               
1780      =2  #define P2_B2__BMASK 0x04 ///< Port 2 Bit 2 Latch                            
1781      =2  #define P2_B2__SHIFT 0x02 ///< Port 2 Bit 2 Latch                            
1782      =2  #define P2_B2__LOW   0x00 ///< P2.2 is low. Set P2.2 to drive low.           
1783      =2  #define P2_B2__HIGH  0x04 ///< P2.2 is high. Set P2.2 to drive or float high.
1784      =2                                                                               
1785      =2  #define P2_B3__BMASK 0x08 ///< Port 2 Bit 3 Latch                            
1786      =2  #define P2_B3__SHIFT 0x03 ///< Port 2 Bit 3 Latch                            
1787      =2  #define P2_B3__LOW   0x00 ///< P2.3 is low. Set P2.3 to drive low.           
1788      =2  #define P2_B3__HIGH  0x08 ///< P2.3 is high. Set P2.3 to drive or float high.
1789      =2                                                                               
1790      =2  #define P2_B4__BMASK 0x10 ///< Port 2 Bit 4 Latch                            
1791      =2  #define P2_B4__SHIFT 0x04 ///< Port 2 Bit 4 Latch                            
1792      =2  #define P2_B4__LOW   0x00 ///< P2.4 is low. Set P2.4 to drive low.           
1793      =2  #define P2_B4__HIGH  0x10 ///< P2.4 is high. Set P2.4 to drive or float high.
1794      =2                                                                               
1795      =2  #define P2_B5__BMASK 0x20 ///< Port 2 Bit 5 Latch                            
1796      =2  #define P2_B5__SHIFT 0x05 ///< Port 2 Bit 5 Latch                            
1797      =2  #define P2_B5__LOW   0x00 ///< P2.5 is low. Set P2.5 to drive low.           
1798      =2  #define P2_B5__HIGH  0x20 ///< P2.5 is high. Set P2.5 to drive or float high.
1799      =2                                                                               
1800      =2  #define P2_B6__BMASK 0x40 ///< Port 2 Bit 6 Latch                            
1801      =2  #define P2_B6__SHIFT 0x06 ///< Port 2 Bit 6 Latch                            
1802      =2  #define P2_B6__LOW   0x00 ///< P2.6 is low. Set P2.6 to drive low.           
1803      =2  #define P2_B6__HIGH  0x40 ///< P2.6 is high. Set P2.6 to drive or float high.
1804      =2                                                                               
1805      =2  #define P2_B7__BMASK 0x80 ///< Port 2 Bit 7 Latch                            
1806      =2  #define P2_B7__SHIFT 0x07 ///< Port 2 Bit 7 Latch                            
1807      =2  #define P2_B7__LOW   0x00 ///< P2.7 is low. Set P2.7 to drive low.           
1808      =2  #define P2_B7__HIGH  0x80 ///< P2.7 is high. Set P2.7 to drive or float high.
1809      =2                                                                               
1810      =2  //------------------------------------------------------------------------------
C51 COMPILER V9.56.0.0   UART_0                                                            10/28/2016 17:37:02 PAGE 56  

1811      =2  // P2MDIN Enums (Port 2 Input Mode @ 0xF3)
1812      =2  //------------------------------------------------------------------------------
1813      =2  #define P2MDIN_B0__BMASK   0x01 ///< Port 2 Bit 0 Input Mode                 
1814      =2  #define P2MDIN_B0__SHIFT   0x00 ///< Port 2 Bit 0 Input Mode                 
1815      =2  #define P2MDIN_B0__ANALOG  0x00 ///< P2.0 pin is configured for analog mode. 
1816      =2  #define P2MDIN_B0__DIGITAL 0x01 ///< P2.0 pin is configured for digital mode.
1817      =2                                                                               
1818      =2  #define P2MDIN_B1__BMASK   0x02 ///< Port 2 Bit 1 Input Mode                 
1819      =2  #define P2MDIN_B1__SHIFT   0x01 ///< Port 2 Bit 1 Input Mode                 
1820      =2  #define P2MDIN_B1__ANALOG  0x00 ///< P2.1 pin is configured for analog mode. 
1821      =2  #define P2MDIN_B1__DIGITAL 0x02 ///< P2.1 pin is configured for digital mode.
1822      =2                                                                               
1823      =2  #define P2MDIN_B2__BMASK   0x04 ///< Port 2 Bit 2 Input Mode                 
1824      =2  #define P2MDIN_B2__SHIFT   0x02 ///< Port 2 Bit 2 Input Mode                 
1825      =2  #define P2MDIN_B2__ANALOG  0x00 ///< P2.2 pin is configured for analog mode. 
1826      =2  #define P2MDIN_B2__DIGITAL 0x04 ///< P2.2 pin is configured for digital mode.
1827      =2                                                                               
1828      =2  #define P2MDIN_B3__BMASK   0x08 ///< Port 2 Bit 3 Input Mode                 
1829      =2  #define P2MDIN_B3__SHIFT   0x03 ///< Port 2 Bit 3 Input Mode                 
1830      =2  #define P2MDIN_B3__ANALOG  0x00 ///< P2.3 pin is configured for analog mode. 
1831      =2  #define P2MDIN_B3__DIGITAL 0x08 ///< P2.3 pin is configured for digital mode.
1832      =2                                                                               
1833      =2  #define P2MDIN_B4__BMASK   0x10 ///< Port 2 Bit 4 Input Mode                 
1834      =2  #define P2MDIN_B4__SHIFT   0x04 ///< Port 2 Bit 4 Input Mode                 
1835      =2  #define P2MDIN_B4__ANALOG  0x00 ///< P2.4 pin is configured for analog mode. 
1836      =2  #define P2MDIN_B4__DIGITAL 0x10 ///< P2.4 pin is configured for digital mode.
1837      =2                                                                               
1838      =2  #define P2MDIN_B5__BMASK   0x20 ///< Port 2 Bit 5 Input Mode                 
1839      =2  #define P2MDIN_B5__SHIFT   0x05 ///< Port 2 Bit 5 Input Mode                 
1840      =2  #define P2MDIN_B5__ANALOG  0x00 ///< P2.5 pin is configured for analog mode. 
1841      =2  #define P2MDIN_B5__DIGITAL 0x20 ///< P2.5 pin is configured for digital mode.
1842      =2                                                                               
1843      =2  #define P2MDIN_B6__BMASK   0x40 ///< Port 2 Bit 6 Input Mode                 
1844      =2  #define P2MDIN_B6__SHIFT   0x06 ///< Port 2 Bit 6 Input Mode                 
1845      =2  #define P2MDIN_B6__ANALOG  0x00 ///< P2.6 pin is configured for analog mode. 
1846      =2  #define P2MDIN_B6__DIGITAL 0x40 ///< P2.6 pin is configured for digital mode.
1847      =2                                                                               
1848      =2  #define P2MDIN_B7__BMASK   0x80 ///< Port 2 Bit 7 Input Mode                 
1849      =2  #define P2MDIN_B7__SHIFT   0x07 ///< Port 2 Bit 7 Input Mode                 
1850      =2  #define P2MDIN_B7__ANALOG  0x00 ///< P2.7 pin is configured for analog mode. 
1851      =2  #define P2MDIN_B7__DIGITAL 0x80 ///< P2.7 pin is configured for digital mode.
1852      =2                                                                               
1853      =2  //------------------------------------------------------------------------------
1854      =2  // P2MDOUT Enums (Port 2 Output Mode @ 0xA6)
1855      =2  //------------------------------------------------------------------------------
1856      =2  #define P2MDOUT_B0__BMASK      0x01 ///< Port 2 Bit 0 Output Mode  
1857      =2  #define P2MDOUT_B0__SHIFT      0x00 ///< Port 2 Bit 0 Output Mode  
1858      =2  #define P2MDOUT_B0__OPEN_DRAIN 0x00 ///< P2.0 output is open-drain.
1859      =2  #define P2MDOUT_B0__PUSH_PULL  0x01 ///< P2.0 output is push-pull. 
1860      =2                                                                     
1861      =2  #define P2MDOUT_B1__BMASK      0x02 ///< Port 2 Bit 1 Output Mode  
1862      =2  #define P2MDOUT_B1__SHIFT      0x01 ///< Port 2 Bit 1 Output Mode  
1863      =2  #define P2MDOUT_B1__OPEN_DRAIN 0x00 ///< P2.1 output is open-drain.
1864      =2  #define P2MDOUT_B1__PUSH_PULL  0x02 ///< P2.1 output is push-pull. 
1865      =2                                                                     
1866      =2  #define P2MDOUT_B2__BMASK      0x04 ///< Port 2 Bit 2 Output Mode  
1867      =2  #define P2MDOUT_B2__SHIFT      0x02 ///< Port 2 Bit 2 Output Mode  
1868      =2  #define P2MDOUT_B2__OPEN_DRAIN 0x00 ///< P2.2 output is open-drain.
1869      =2  #define P2MDOUT_B2__PUSH_PULL  0x04 ///< P2.2 output is push-pull. 
1870      =2                                                                     
1871      =2  #define P2MDOUT_B3__BMASK      0x08 ///< Port 2 Bit 3 Output Mode  
1872      =2  #define P2MDOUT_B3__SHIFT      0x03 ///< Port 2 Bit 3 Output Mode  
C51 COMPILER V9.56.0.0   UART_0                                                            10/28/2016 17:37:02 PAGE 57  

1873      =2  #define P2MDOUT_B3__OPEN_DRAIN 0x00 ///< P2.3 output is open-drain.
1874      =2  #define P2MDOUT_B3__PUSH_PULL  0x08 ///< P2.3 output is push-pull. 
1875      =2                                                                     
1876      =2  #define P2MDOUT_B4__BMASK      0x10 ///< Port 2 Bit 4 Output Mode  
1877      =2  #define P2MDOUT_B4__SHIFT      0x04 ///< Port 2 Bit 4 Output Mode  
1878      =2  #define P2MDOUT_B4__OPEN_DRAIN 0x00 ///< P2.4 output is open-drain.
1879      =2  #define P2MDOUT_B4__PUSH_PULL  0x10 ///< P2.4 output is push-pull. 
1880      =2                                                                     
1881      =2  #define P2MDOUT_B5__BMASK      0x20 ///< Port 2 Bit 5 Output Mode  
1882      =2  #define P2MDOUT_B5__SHIFT      0x05 ///< Port 2 Bit 5 Output Mode  
1883      =2  #define P2MDOUT_B5__OPEN_DRAIN 0x00 ///< P2.5 output is open-drain.
1884      =2  #define P2MDOUT_B5__PUSH_PULL  0x20 ///< P2.5 output is push-pull. 
1885      =2                                                                     
1886      =2  #define P2MDOUT_B6__BMASK      0x40 ///< Port 2 Bit 6 Output Mode  
1887      =2  #define P2MDOUT_B6__SHIFT      0x06 ///< Port 2 Bit 6 Output Mode  
1888      =2  #define P2MDOUT_B6__OPEN_DRAIN 0x00 ///< P2.6 output is open-drain.
1889      =2  #define P2MDOUT_B6__PUSH_PULL  0x40 ///< P2.6 output is push-pull. 
1890      =2                                                                     
1891      =2  #define P2MDOUT_B7__BMASK      0x80 ///< Port 2 Bit 7 Output Mode  
1892      =2  #define P2MDOUT_B7__SHIFT      0x07 ///< Port 2 Bit 7 Output Mode  
1893      =2  #define P2MDOUT_B7__OPEN_DRAIN 0x00 ///< P2.7 output is open-drain.
1894      =2  #define P2MDOUT_B7__PUSH_PULL  0x80 ///< P2.7 output is push-pull. 
1895      =2                                                                     
1896      =2  //------------------------------------------------------------------------------
1897      =2  // P2SKIP Enums (Port 2 Skip @ 0xD6)
1898      =2  //------------------------------------------------------------------------------
1899      =2  #define P2SKIP_B0__BMASK       0x01 ///< Port 2 Bit 0 Skip                       
1900      =2  #define P2SKIP_B0__SHIFT       0x00 ///< Port 2 Bit 0 Skip                       
1901      =2  #define P2SKIP_B0__NOT_SKIPPED 0x00 ///< P2.0 pin is not skipped by the crossbar.
1902      =2  #define P2SKIP_B0__SKIPPED     0x01 ///< P2.0 pin is skipped by the crossbar.    
1903      =2                                                                                   
1904      =2  #define P2SKIP_B1__BMASK       0x02 ///< Port 2 Bit 1 Skip                       
1905      =2  #define P2SKIP_B1__SHIFT       0x01 ///< Port 2 Bit 1 Skip                       
1906      =2  #define P2SKIP_B1__NOT_SKIPPED 0x00 ///< P2.1 pin is not skipped by the crossbar.
1907      =2  #define P2SKIP_B1__SKIPPED     0x02 ///< P2.1 pin is skipped by the crossbar.    
1908      =2                                                                                   
1909      =2  #define P2SKIP_B2__BMASK       0x04 ///< Port 2 Bit 2 Skip                       
1910      =2  #define P2SKIP_B2__SHIFT       0x02 ///< Port 2 Bit 2 Skip                       
1911      =2  #define P2SKIP_B2__NOT_SKIPPED 0x00 ///< P2.2 pin is not skipped by the crossbar.
1912      =2  #define P2SKIP_B2__SKIPPED     0x04 ///< P2.2 pin is skipped by the crossbar.    
1913      =2                                                                                   
1914      =2  #define P2SKIP_B3__BMASK       0x08 ///< Port 2 Bit 3 Skip                       
1915      =2  #define P2SKIP_B3__SHIFT       0x03 ///< Port 2 Bit 3 Skip                       
1916      =2  #define P2SKIP_B3__NOT_SKIPPED 0x00 ///< P2.3 pin is not skipped by the crossbar.
1917      =2  #define P2SKIP_B3__SKIPPED     0x08 ///< P2.3 pin is skipped by the crossbar.    
1918      =2                                                                                   
1919      =2  #define P2SKIP_B4__BMASK       0x10 ///< Port 2 Bit 4 Skip                       
1920      =2  #define P2SKIP_B4__SHIFT       0x04 ///< Port 2 Bit 4 Skip                       
1921      =2  #define P2SKIP_B4__NOT_SKIPPED 0x00 ///< P2.4 pin is not skipped by the crossbar.
1922      =2  #define P2SKIP_B4__SKIPPED     0x10 ///< P2.4 pin is skipped by the crossbar.    
1923      =2                                                                                   
1924      =2  #define P2SKIP_B5__BMASK       0x20 ///< Port 2 Bit 5 Skip                       
1925      =2  #define P2SKIP_B5__SHIFT       0x05 ///< Port 2 Bit 5 Skip                       
1926      =2  #define P2SKIP_B5__NOT_SKIPPED 0x00 ///< P2.5 pin is not skipped by the crossbar.
1927      =2  #define P2SKIP_B5__SKIPPED     0x20 ///< P2.5 pin is skipped by the crossbar.    
1928      =2                                                                                   
1929      =2  #define P2SKIP_B6__BMASK       0x40 ///< Port 2 Bit 6 Skip                       
1930      =2  #define P2SKIP_B6__SHIFT       0x06 ///< Port 2 Bit 6 Skip                       
1931      =2  #define P2SKIP_B6__NOT_SKIPPED 0x00 ///< P2.6 pin is not skipped by the crossbar.
1932      =2  #define P2SKIP_B6__SKIPPED     0x40 ///< P2.6 pin is skipped by the crossbar.    
1933      =2                                                                                   
1934      =2  #define P2SKIP_B7__BMASK       0x80 ///< Port 2 Bit 7 Skip                       
C51 COMPILER V9.56.0.0   UART_0                                                            10/28/2016 17:37:02 PAGE 58  

1935      =2  #define P2SKIP_B7__SHIFT       0x07 ///< Port 2 Bit 7 Skip                       
1936      =2  #define P2SKIP_B7__NOT_SKIPPED 0x00 ///< P2.7 pin is not skipped by the crossbar.
1937      =2  #define P2SKIP_B7__SKIPPED     0x80 ///< P2.7 pin is skipped by the crossbar.    
1938      =2                                                                                   
1939      =2  //------------------------------------------------------------------------------
1940      =2  // P3 Enums (Port 3 Pin Latch @ 0xB0)
1941      =2  //------------------------------------------------------------------------------
1942      =2  #define P3_B0__BMASK 0x01 ///< Port 3 Bit 0 Latch                            
1943      =2  #define P3_B0__SHIFT 0x00 ///< Port 3 Bit 0 Latch                            
1944      =2  #define P3_B0__LOW   0x00 ///< P3.0 is low. Set P3.0 to drive low.           
1945      =2  #define P3_B0__HIGH  0x01 ///< P3.0 is high. Set P3.0 to drive or float high.
1946      =2                                                                               
1947      =2  #define P3_B1__BMASK 0x02 ///< Port 3 Bit 1 Latch                            
1948      =2  #define P3_B1__SHIFT 0x01 ///< Port 3 Bit 1 Latch                            
1949      =2  #define P3_B1__LOW   0x00 ///< P3.1 is low. Set P3.1 to drive low.           
1950      =2  #define P3_B1__HIGH  0x02 ///< P3.1 is high. Set P3.1 to drive or float high.
1951      =2                                                                               
1952      =2  #define P3_B2__BMASK 0x04 ///< Port 3 Bit 2 Latch                            
1953      =2  #define P3_B2__SHIFT 0x02 ///< Port 3 Bit 2 Latch                            
1954      =2  #define P3_B2__LOW   0x00 ///< P3.2 is low. Set P3.2 to drive low.           
1955      =2  #define P3_B2__HIGH  0x04 ///< P3.2 is high. Set P3.2 to drive or float high.
1956      =2                                                                               
1957      =2  #define P3_B3__BMASK 0x08 ///< Port 3 Bit 3 Latch                            
1958      =2  #define P3_B3__SHIFT 0x03 ///< Port 3 Bit 3 Latch                            
1959      =2  #define P3_B3__LOW   0x00 ///< P3.3 is low. Set P3.3 to drive low.           
1960      =2  #define P3_B3__HIGH  0x08 ///< P3.3 is high. Set P3.3 to drive or float high.
1961      =2                                                                               
1962      =2  #define P3_B4__BMASK 0x10 ///< Port 3 Bit 4 Latch                            
1963      =2  #define P3_B4__SHIFT 0x04 ///< Port 3 Bit 4 Latch                            
1964      =2  #define P3_B4__LOW   0x00 ///< P3.4 is low. Set P3.4 to drive low.           
1965      =2  #define P3_B4__HIGH  0x10 ///< P3.4 is high. Set P3.4 to drive or float high.
1966      =2                                                                               
1967      =2  #define P3_B5__BMASK 0x20 ///< Port 3 Bit 5 Latch                            
1968      =2  #define P3_B5__SHIFT 0x05 ///< Port 3 Bit 5 Latch                            
1969      =2  #define P3_B5__LOW   0x00 ///< P3.5 is low. Set P3.5 to drive low.           
1970      =2  #define P3_B5__HIGH  0x20 ///< P3.5 is high. Set P3.5 to drive or float high.
1971      =2                                                                               
1972      =2  #define P3_B6__BMASK 0x40 ///< Port 3 Bit 6 Latch                            
1973      =2  #define P3_B6__SHIFT 0x06 ///< Port 3 Bit 6 Latch                            
1974      =2  #define P3_B6__LOW   0x00 ///< P3.6 is low. Set P3.6 to drive low.           
1975      =2  #define P3_B6__HIGH  0x40 ///< P3.6 is high. Set P3.6 to drive or float high.
1976      =2                                                                               
1977      =2  #define P3_B7__BMASK 0x80 ///< Port 3 Bit 7 Latch                            
1978      =2  #define P3_B7__SHIFT 0x07 ///< Port 3 Bit 7 Latch                            
1979      =2  #define P3_B7__LOW   0x00 ///< P3.7 is low. Set P3.7 to drive low.           
1980      =2  #define P3_B7__HIGH  0x80 ///< P3.7 is high. Set P3.7 to drive or float high.
1981      =2                                                                               
1982      =2  //------------------------------------------------------------------------------
1983      =2  // P3MDIN Enums (Port 3 Input Mode @ 0xF4)
1984      =2  //------------------------------------------------------------------------------
1985      =2  #define P3MDIN_B0__BMASK   0x01 ///< Port 3 Bit 0 Input Mode                 
1986      =2  #define P3MDIN_B0__SHIFT   0x00 ///< Port 3 Bit 0 Input Mode                 
1987      =2  #define P3MDIN_B0__ANALOG  0x00 ///< P3.0 pin is configured for analog mode. 
1988      =2  #define P3MDIN_B0__DIGITAL 0x01 ///< P3.0 pin is configured for digital mode.
1989      =2                                                                               
1990      =2  #define P3MDIN_B1__BMASK   0x02 ///< Port 3 Bit 1 Input Mode                 
1991      =2  #define P3MDIN_B1__SHIFT   0x01 ///< Port 3 Bit 1 Input Mode                 
1992      =2  #define P3MDIN_B1__ANALOG  0x00 ///< P3.1 pin is configured for analog mode. 
1993      =2  #define P3MDIN_B1__DIGITAL 0x02 ///< P3.1 pin is configured for digital mode.
1994      =2                                                                               
1995      =2  #define P3MDIN_B2__BMASK   0x04 ///< Port 3 Bit 2 Input Mode                 
1996      =2  #define P3MDIN_B2__SHIFT   0x02 ///< Port 3 Bit 2 Input Mode                 
C51 COMPILER V9.56.0.0   UART_0                                                            10/28/2016 17:37:02 PAGE 59  

1997      =2  #define P3MDIN_B2__ANALOG  0x00 ///< P3.2 pin is configured for analog mode. 
1998      =2  #define P3MDIN_B2__DIGITAL 0x04 ///< P3.2 pin is configured for digital mode.
1999      =2                                                                               
2000      =2  #define P3MDIN_B3__BMASK   0x08 ///< Port 3 Bit 3 Input Mode                 
2001      =2  #define P3MDIN_B3__SHIFT   0x03 ///< Port 3 Bit 3 Input Mode                 
2002      =2  #define P3MDIN_B3__ANALOG  0x00 ///< P3.3 pin is configured for analog mode. 
2003      =2  #define P3MDIN_B3__DIGITAL 0x08 ///< P3.3 pin is configured for digital mode.
2004      =2                                                                               
2005      =2  #define P3MDIN_B4__BMASK   0x10 ///< Port 3 Bit 4 Input Mode                 
2006      =2  #define P3MDIN_B4__SHIFT   0x04 ///< Port 3 Bit 4 Input Mode                 
2007      =2  #define P3MDIN_B4__ANALOG  0x00 ///< P3.4 pin is configured for analog mode. 
2008      =2  #define P3MDIN_B4__DIGITAL 0x10 ///< P3.4 pin is configured for digital mode.
2009      =2                                                                               
2010      =2  #define P3MDIN_B5__BMASK   0x20 ///< Port 3 Bit 5 Input Mode                 
2011      =2  #define P3MDIN_B5__SHIFT   0x05 ///< Port 3 Bit 5 Input Mode                 
2012      =2  #define P3MDIN_B5__ANALOG  0x00 ///< P3.5 pin is configured for analog mode. 
2013      =2  #define P3MDIN_B5__DIGITAL 0x20 ///< P3.5 pin is configured for digital mode.
2014      =2                                                                               
2015      =2  #define P3MDIN_B6__BMASK   0x40 ///< Port 3 Bit 6 Input Mode                 
2016      =2  #define P3MDIN_B6__SHIFT   0x06 ///< Port 3 Bit 6 Input Mode                 
2017      =2  #define P3MDIN_B6__ANALOG  0x00 ///< P3.6 pin is configured for analog mode. 
2018      =2  #define P3MDIN_B6__DIGITAL 0x40 ///< P3.6 pin is configured for digital mode.
2019      =2                                                                               
2020      =2  #define P3MDIN_B7__BMASK   0x80 ///< Port 3 Bit 7 Input Mode                 
2021      =2  #define P3MDIN_B7__SHIFT   0x07 ///< Port 3 Bit 7 Input Mode                 
2022      =2  #define P3MDIN_B7__ANALOG  0x00 ///< P3.7 pin is configured for analog mode. 
2023      =2  #define P3MDIN_B7__DIGITAL 0x80 ///< P3.7 pin is configured for digital mode.
2024      =2                                                                               
2025      =2  //------------------------------------------------------------------------------
2026      =2  // P3MDOUT Enums (Port 3 Output Mode @ 0xA7)
2027      =2  //------------------------------------------------------------------------------
2028      =2  #define P3MDOUT_B0__BMASK      0x01 ///< Port 3 Bit 0 Output Mode  
2029      =2  #define P3MDOUT_B0__SHIFT      0x00 ///< Port 3 Bit 0 Output Mode  
2030      =2  #define P3MDOUT_B0__OPEN_DRAIN 0x00 ///< P3.0 output is open-drain.
2031      =2  #define P3MDOUT_B0__PUSH_PULL  0x01 ///< P3.0 output is push-pull. 
2032      =2                                                                     
2033      =2  #define P3MDOUT_B1__BMASK      0x02 ///< Port 3 Bit 1 Output Mode  
2034      =2  #define P3MDOUT_B1__SHIFT      0x01 ///< Port 3 Bit 1 Output Mode  
2035      =2  #define P3MDOUT_B1__OPEN_DRAIN 0x00 ///< P3.1 output is open-drain.
2036      =2  #define P3MDOUT_B1__PUSH_PULL  0x02 ///< P3.1 output is push-pull. 
2037      =2                                                                     
2038      =2  #define P3MDOUT_B2__BMASK      0x04 ///< Port 3 Bit 2 Output Mode  
2039      =2  #define P3MDOUT_B2__SHIFT      0x02 ///< Port 3 Bit 2 Output Mode  
2040      =2  #define P3MDOUT_B2__OPEN_DRAIN 0x00 ///< P3.2 output is open-drain.
2041      =2  #define P3MDOUT_B2__PUSH_PULL  0x04 ///< P3.2 output is push-pull. 
2042      =2                                                                     
2043      =2  #define P3MDOUT_B3__BMASK      0x08 ///< Port 3 Bit 3 Output Mode  
2044      =2  #define P3MDOUT_B3__SHIFT      0x03 ///< Port 3 Bit 3 Output Mode  
2045      =2  #define P3MDOUT_B3__OPEN_DRAIN 0x00 ///< P3.3 output is open-drain.
2046      =2  #define P3MDOUT_B3__PUSH_PULL  0x08 ///< P3.3 output is push-pull. 
2047      =2                                                                     
2048      =2  #define P3MDOUT_B4__BMASK      0x10 ///< Port 3 Bit 4 Output Mode  
2049      =2  #define P3MDOUT_B4__SHIFT      0x04 ///< Port 3 Bit 4 Output Mode  
2050      =2  #define P3MDOUT_B4__OPEN_DRAIN 0x00 ///< P3.4 output is open-drain.
2051      =2  #define P3MDOUT_B4__PUSH_PULL  0x10 ///< P3.4 output is push-pull. 
2052      =2                                                                     
2053      =2  #define P3MDOUT_B5__BMASK      0x20 ///< Port 3 Bit 5 Output Mode  
2054      =2  #define P3MDOUT_B5__SHIFT      0x05 ///< Port 3 Bit 5 Output Mode  
2055      =2  #define P3MDOUT_B5__OPEN_DRAIN 0x00 ///< P3.5 output is open-drain.
2056      =2  #define P3MDOUT_B5__PUSH_PULL  0x20 ///< P3.5 output is push-pull. 
2057      =2                                                                     
2058      =2  #define P3MDOUT_B6__BMASK      0x40 ///< Port 3 Bit 6 Output Mode  
C51 COMPILER V9.56.0.0   UART_0                                                            10/28/2016 17:37:02 PAGE 60  

2059      =2  #define P3MDOUT_B6__SHIFT      0x06 ///< Port 3 Bit 6 Output Mode  
2060      =2  #define P3MDOUT_B6__OPEN_DRAIN 0x00 ///< P3.6 output is open-drain.
2061      =2  #define P3MDOUT_B6__PUSH_PULL  0x40 ///< P3.6 output is push-pull. 
2062      =2                                                                     
2063      =2  #define P3MDOUT_B7__BMASK      0x80 ///< Port 3 Bit 7 Output Mode  
2064      =2  #define P3MDOUT_B7__SHIFT      0x07 ///< Port 3 Bit 7 Output Mode  
2065      =2  #define P3MDOUT_B7__OPEN_DRAIN 0x00 ///< P3.7 output is open-drain.
2066      =2  #define P3MDOUT_B7__PUSH_PULL  0x80 ///< P3.7 output is push-pull. 
2067      =2                                                                     
2068      =2  //------------------------------------------------------------------------------
2069      =2  // P3SKIP Enums (Port 3 Skip @ 0xDF)
2070      =2  //------------------------------------------------------------------------------
2071      =2  #define P3SKIP_B0__BMASK       0x01 ///< Port 3 Bit 0 Skip                       
2072      =2  #define P3SKIP_B0__SHIFT       0x00 ///< Port 3 Bit 0 Skip                       
2073      =2  #define P3SKIP_B0__NOT_SKIPPED 0x00 ///< P3.0 pin is not skipped by the crossbar.
2074      =2  #define P3SKIP_B0__SKIPPED     0x01 ///< P3.0 pin is skipped by the crossbar.    
2075      =2                                                                                   
2076      =2  #define P3SKIP_B1__BMASK       0x02 ///< Port 3 Bit 1 Skip                       
2077      =2  #define P3SKIP_B1__SHIFT       0x01 ///< Port 3 Bit 1 Skip                       
2078      =2  #define P3SKIP_B1__NOT_SKIPPED 0x00 ///< P3.1 pin is not skipped by the crossbar.
2079      =2  #define P3SKIP_B1__SKIPPED     0x02 ///< P3.1 pin is skipped by the crossbar.    
2080      =2                                                                                   
2081      =2  #define P3SKIP_B2__BMASK       0x04 ///< Port 3 Bit 2 Skip                       
2082      =2  #define P3SKIP_B2__SHIFT       0x02 ///< Port 3 Bit 2 Skip                       
2083      =2  #define P3SKIP_B2__NOT_SKIPPED 0x00 ///< P3.2 pin is not skipped by the crossbar.
2084      =2  #define P3SKIP_B2__SKIPPED     0x04 ///< P3.2 pin is skipped by the crossbar.    
2085      =2                                                                                   
2086      =2  #define P3SKIP_B3__BMASK       0x08 ///< Port 3 Bit 3 Skip                       
2087      =2  #define P3SKIP_B3__SHIFT       0x03 ///< Port 3 Bit 3 Skip                       
2088      =2  #define P3SKIP_B3__NOT_SKIPPED 0x00 ///< P3.3 pin is not skipped by the crossbar.
2089      =2  #define P3SKIP_B3__SKIPPED     0x08 ///< P3.3 pin is skipped by the crossbar.    
2090      =2                                                                                   
2091      =2  #define P3SKIP_B4__BMASK       0x10 ///< Port 3 Bit 4 Skip                       
2092      =2  #define P3SKIP_B4__SHIFT       0x04 ///< Port 3 Bit 4 Skip                       
2093      =2  #define P3SKIP_B4__NOT_SKIPPED 0x00 ///< P3.4 pin is not skipped by the crossbar.
2094      =2  #define P3SKIP_B4__SKIPPED     0x10 ///< P3.4 pin is skipped by the crossbar.    
2095      =2                                                                                   
2096      =2  #define P3SKIP_B5__BMASK       0x20 ///< Port 3 Bit 5 Skip                       
2097      =2  #define P3SKIP_B5__SHIFT       0x05 ///< Port 3 Bit 5 Skip                       
2098      =2  #define P3SKIP_B5__NOT_SKIPPED 0x00 ///< P3.5 pin is not skipped by the crossbar.
2099      =2  #define P3SKIP_B5__SKIPPED     0x20 ///< P3.5 pin is skipped by the crossbar.    
2100      =2                                                                                   
2101      =2  #define P3SKIP_B6__BMASK       0x40 ///< Port 3 Bit 6 Skip                       
2102      =2  #define P3SKIP_B6__SHIFT       0x06 ///< Port 3 Bit 6 Skip                       
2103      =2  #define P3SKIP_B6__NOT_SKIPPED 0x00 ///< P3.6 pin is not skipped by the crossbar.
2104      =2  #define P3SKIP_B6__SKIPPED     0x40 ///< P3.6 pin is skipped by the crossbar.    
2105      =2                                                                                   
2106      =2  #define P3SKIP_B7__BMASK       0x80 ///< Port 3 Bit 7 Skip                       
2107      =2  #define P3SKIP_B7__SHIFT       0x07 ///< Port 3 Bit 7 Skip                       
2108      =2  #define P3SKIP_B7__NOT_SKIPPED 0x00 ///< P3.7 pin is not skipped by the crossbar.
2109      =2  #define P3SKIP_B7__SKIPPED     0x80 ///< P3.7 pin is skipped by the crossbar.    
2110      =2                                                                                   
2111      =2  //------------------------------------------------------------------------------
2112      =2  // P4 Enums (Port 4 Pin Latch @ 0xC7)
2113      =2  //------------------------------------------------------------------------------
2114      =2  #define P4_B0__BMASK 0x01 ///< Port 4 Bit 0 Latch                            
2115      =2  #define P4_B0__SHIFT 0x00 ///< Port 4 Bit 0 Latch                            
2116      =2  #define P4_B0__LOW   0x00 ///< P4.0 is low. Set P4.0 to drive low.           
2117      =2  #define P4_B0__HIGH  0x01 ///< P4.0 is high. Set P4.0 to drive or float high.
2118      =2                                                                               
2119      =2  #define P4_B1__BMASK 0x02 ///< Port 4 Bit 1 Latch                            
2120      =2  #define P4_B1__SHIFT 0x01 ///< Port 4 Bit 1 Latch                            
C51 COMPILER V9.56.0.0   UART_0                                                            10/28/2016 17:37:02 PAGE 61  

2121      =2  #define P4_B1__LOW   0x00 ///< P4.1 is low. Set P4.1 to drive low.           
2122      =2  #define P4_B1__HIGH  0x02 ///< P4.1 is high. Set P4.1 to drive or float high.
2123      =2                                                                               
2124      =2  #define P4_B2__BMASK 0x04 ///< Port 4 Bit 2 Latch                            
2125      =2  #define P4_B2__SHIFT 0x02 ///< Port 4 Bit 2 Latch                            
2126      =2  #define P4_B2__LOW   0x00 ///< P4.2 is low. Set P4.2 to drive low.           
2127      =2  #define P4_B2__HIGH  0x04 ///< P4.2 is high. Set P4.2 to drive or float high.
2128      =2                                                                               
2129      =2  #define P4_B3__BMASK 0x08 ///< Port 4 Bit 3 Latch                            
2130      =2  #define P4_B3__SHIFT 0x03 ///< Port 4 Bit 3 Latch                            
2131      =2  #define P4_B3__LOW   0x00 ///< P4.3 is low. Set P4.3 to drive low.           
2132      =2  #define P4_B3__HIGH  0x08 ///< P4.3 is high. Set P4.3 to drive or float high.
2133      =2                                                                               
2134      =2  #define P4_B4__BMASK 0x10 ///< Port 4 Bit 4 Latch                            
2135      =2  #define P4_B4__SHIFT 0x04 ///< Port 4 Bit 4 Latch                            
2136      =2  #define P4_B4__LOW   0x00 ///< P4.4 is low. Set P4.4 to drive low.           
2137      =2  #define P4_B4__HIGH  0x10 ///< P4.4 is high. Set P4.4 to drive or float high.
2138      =2                                                                               
2139      =2  #define P4_B5__BMASK 0x20 ///< Port 4 Bit 5 Latch                            
2140      =2  #define P4_B5__SHIFT 0x05 ///< Port 4 Bit 5 Latch                            
2141      =2  #define P4_B5__LOW   0x00 ///< P4.5 is low. Set P4.5 to drive low.           
2142      =2  #define P4_B5__HIGH  0x20 ///< P4.5 is high. Set P4.5 to drive or float high.
2143      =2                                                                               
2144      =2  #define P4_B6__BMASK 0x40 ///< Port 4 Bit 6 Latch                            
2145      =2  #define P4_B6__SHIFT 0x06 ///< Port 4 Bit 6 Latch                            
2146      =2  #define P4_B6__LOW   0x00 ///< P4.6 is low. Set P4.6 to drive low.           
2147      =2  #define P4_B6__HIGH  0x40 ///< P4.6 is high. Set P4.6 to drive or float high.
2148      =2                                                                               
2149      =2  #define P4_B7__BMASK 0x80 ///< Port 4 Bit 7 Latch                            
2150      =2  #define P4_B7__SHIFT 0x07 ///< Port 4 Bit 7 Latch                            
2151      =2  #define P4_B7__LOW   0x00 ///< P4.7 is low. Set P4.7 to drive low.           
2152      =2  #define P4_B7__HIGH  0x80 ///< P4.7 is high. Set P4.7 to drive or float high.
2153      =2                                                                               
2154      =2  //------------------------------------------------------------------------------
2155      =2  // P4MDIN Enums (Port 4 Input Mode @ 0xF5)
2156      =2  //------------------------------------------------------------------------------
2157      =2  #define P4MDIN_B0__BMASK   0x01 ///< Port 4 Bit 0 Input Mode                 
2158      =2  #define P4MDIN_B0__SHIFT   0x00 ///< Port 4 Bit 0 Input Mode                 
2159      =2  #define P4MDIN_B0__ANALOG  0x00 ///< P4.0 pin is configured for analog mode. 
2160      =2  #define P4MDIN_B0__DIGITAL 0x01 ///< P4.0 pin is configured for digital mode.
2161      =2                                                                               
2162      =2  #define P4MDIN_B1__BMASK   0x02 ///< Port 4 Bit 1 Input Mode                 
2163      =2  #define P4MDIN_B1__SHIFT   0x01 ///< Port 4 Bit 1 Input Mode                 
2164      =2  #define P4MDIN_B1__ANALOG  0x00 ///< P4.1 pin is configured for analog mode. 
2165      =2  #define P4MDIN_B1__DIGITAL 0x02 ///< P4.1 pin is configured for digital mode.
2166      =2                                                                               
2167      =2  #define P4MDIN_B2__BMASK   0x04 ///< Port 4 Bit 2 Input Mode                 
2168      =2  #define P4MDIN_B2__SHIFT   0x02 ///< Port 4 Bit 2 Input Mode                 
2169      =2  #define P4MDIN_B2__ANALOG  0x00 ///< P4.2 pin is configured for analog mode. 
2170      =2  #define P4MDIN_B2__DIGITAL 0x04 ///< P4.2 pin is configured for digital mode.
2171      =2                                                                               
2172      =2  #define P4MDIN_B3__BMASK   0x08 ///< Port 4 Bit 3 Input Mode                 
2173      =2  #define P4MDIN_B3__SHIFT   0x03 ///< Port 4 Bit 3 Input Mode                 
2174      =2  #define P4MDIN_B3__ANALOG  0x00 ///< P4.3 pin is configured for analog mode. 
2175      =2  #define P4MDIN_B3__DIGITAL 0x08 ///< P4.3 pin is configured for digital mode.
2176      =2                                                                               
2177      =2  #define P4MDIN_B4__BMASK   0x10 ///< Port 4 Bit 4 Input Mode                 
2178      =2  #define P4MDIN_B4__SHIFT   0x04 ///< Port 4 Bit 4 Input Mode                 
2179      =2  #define P4MDIN_B4__ANALOG  0x00 ///< P4.4 pin is configured for analog mode. 
2180      =2  #define P4MDIN_B4__DIGITAL 0x10 ///< P4.4 pin is configured for digital mode.
2181      =2                                                                               
2182      =2  #define P4MDIN_B5__BMASK   0x20 ///< Port 4 Bit 5 Input Mode                 
C51 COMPILER V9.56.0.0   UART_0                                                            10/28/2016 17:37:02 PAGE 62  

2183      =2  #define P4MDIN_B5__SHIFT   0x05 ///< Port 4 Bit 5 Input Mode                 
2184      =2  #define P4MDIN_B5__ANALOG  0x00 ///< P4.5 pin is configured for analog mode. 
2185      =2  #define P4MDIN_B5__DIGITAL 0x20 ///< P4.5 pin is configured for digital mode.
2186      =2                                                                               
2187      =2  #define P4MDIN_B6__BMASK   0x40 ///< Port 4 Bit 6 Input Mode                 
2188      =2  #define P4MDIN_B6__SHIFT   0x06 ///< Port 4 Bit 6 Input Mode                 
2189      =2  #define P4MDIN_B6__ANALOG  0x00 ///< P4.6 pin is configured for analog mode. 
2190      =2  #define P4MDIN_B6__DIGITAL 0x40 ///< P4.6 pin is configured for digital mode.
2191      =2                                                                               
2192      =2  #define P4MDIN_B7__BMASK   0x80 ///< Port 4 Bit 7 Input Mode                 
2193      =2  #define P4MDIN_B7__SHIFT   0x07 ///< Port 4 Bit 7 Input Mode                 
2194      =2  #define P4MDIN_B7__ANALOG  0x00 ///< P4.7 pin is configured for analog mode. 
2195      =2  #define P4MDIN_B7__DIGITAL 0x80 ///< P4.7 pin is configured for digital mode.
2196      =2                                                                               
2197      =2  //------------------------------------------------------------------------------
2198      =2  // P4MDOUT Enums (Port 4 Output Mode @ 0xAE)
2199      =2  //------------------------------------------------------------------------------
2200      =2  #define P4MDOUT_B0__BMASK      0x01 ///< Port 4 Bit 0 Output Mode  
2201      =2  #define P4MDOUT_B0__SHIFT      0x00 ///< Port 4 Bit 0 Output Mode  
2202      =2  #define P4MDOUT_B0__OPEN_DRAIN 0x00 ///< P4.0 output is open-drain.
2203      =2  #define P4MDOUT_B0__PUSH_PULL  0x01 ///< P4.0 output is push-pull. 
2204      =2                                                                     
2205      =2  #define P4MDOUT_B1__BMASK      0x02 ///< Port 4 Bit 1 Output Mode  
2206      =2  #define P4MDOUT_B1__SHIFT      0x01 ///< Port 4 Bit 1 Output Mode  
2207      =2  #define P4MDOUT_B1__OPEN_DRAIN 0x00 ///< P4.1 output is open-drain.
2208      =2  #define P4MDOUT_B1__PUSH_PULL  0x02 ///< P4.1 output is push-pull. 
2209      =2                                                                     
2210      =2  #define P4MDOUT_B2__BMASK      0x04 ///< Port 4 Bit 2 Output Mode  
2211      =2  #define P4MDOUT_B2__SHIFT      0x02 ///< Port 4 Bit 2 Output Mode  
2212      =2  #define P4MDOUT_B2__OPEN_DRAIN 0x00 ///< P4.2 output is open-drain.
2213      =2  #define P4MDOUT_B2__PUSH_PULL  0x04 ///< P4.2 output is push-pull. 
2214      =2                                                                     
2215      =2  #define P4MDOUT_B3__BMASK      0x08 ///< Port 4 Bit 3 Output Mode  
2216      =2  #define P4MDOUT_B3__SHIFT      0x03 ///< Port 4 Bit 3 Output Mode  
2217      =2  #define P4MDOUT_B3__OPEN_DRAIN 0x00 ///< P4.3 output is open-drain.
2218      =2  #define P4MDOUT_B3__PUSH_PULL  0x08 ///< P4.3 output is push-pull. 
2219      =2                                                                     
2220      =2  #define P4MDOUT_B4__BMASK      0x10 ///< Port 4 Bit 4 Output Mode  
2221      =2  #define P4MDOUT_B4__SHIFT      0x04 ///< Port 4 Bit 4 Output Mode  
2222      =2  #define P4MDOUT_B4__OPEN_DRAIN 0x00 ///< P4.4 output is open-drain.
2223      =2  #define P4MDOUT_B4__PUSH_PULL  0x10 ///< P4.4 output is push-pull. 
2224      =2                                                                     
2225      =2  #define P4MDOUT_B5__BMASK      0x20 ///< Port 4 Bit 5 Output Mode  
2226      =2  #define P4MDOUT_B5__SHIFT      0x05 ///< Port 4 Bit 5 Output Mode  
2227      =2  #define P4MDOUT_B5__OPEN_DRAIN 0x00 ///< P4.5 output is open-drain.
2228      =2  #define P4MDOUT_B5__PUSH_PULL  0x20 ///< P4.5 output is push-pull. 
2229      =2                                                                     
2230      =2  #define P4MDOUT_B6__BMASK      0x40 ///< Port 4 Bit 6 Output Mode  
2231      =2  #define P4MDOUT_B6__SHIFT      0x06 ///< Port 4 Bit 6 Output Mode  
2232      =2  #define P4MDOUT_B6__OPEN_DRAIN 0x00 ///< P4.6 output is open-drain.
2233      =2  #define P4MDOUT_B6__PUSH_PULL  0x40 ///< P4.6 output is push-pull. 
2234      =2                                                                     
2235      =2  #define P4MDOUT_B7__BMASK      0x80 ///< Port 4 Bit 7 Output Mode  
2236      =2  #define P4MDOUT_B7__SHIFT      0x07 ///< Port 4 Bit 7 Output Mode  
2237      =2  #define P4MDOUT_B7__OPEN_DRAIN 0x00 ///< P4.7 output is open-drain.
2238      =2  #define P4MDOUT_B7__PUSH_PULL  0x80 ///< P4.7 output is push-pull. 
2239      =2                                                                     
2240      =2  //------------------------------------------------------------------------------
2241      =2  // RSTSRC Enums (Reset Source @ 0xEF)
2242      =2  //------------------------------------------------------------------------------
2243      =2  #define RSTSRC_PINRSF__BMASK   0x01 ///< HW Pin Reset Flag                                                
             -    
C51 COMPILER V9.56.0.0   UART_0                                                            10/28/2016 17:37:02 PAGE 63  

2244      =2  #define RSTSRC_PINRSF__SHIFT   0x00 ///< HW Pin Reset Flag                                                
             -    
2245      =2  #define RSTSRC_PINRSF__NOT_SET 0x00 ///< The RSTb pin did not cause the last reset.                       
             -    
2246      =2  #define RSTSRC_PINRSF__SET     0x01 ///< The RSTb pin caused the last reset.                              
             -    
2247      =2                                                                                                            
             -    
2248      =2  #define RSTSRC_PORSF__BMASK    0x02 ///< Power-On / Supply Monitor Reset Flag, and Supply Monitor Reset En
             -able
2249      =2  #define RSTSRC_PORSF__SHIFT    0x01 ///< Power-On / Supply Monitor Reset Flag, and Supply Monitor Reset En
             -able
2250      =2  #define RSTSRC_PORSF__NOT_SET  0x00 ///< A power-on or supply monitor reset did not occur.                
             -    
2251      =2  #define RSTSRC_PORSF__SET      0x02 ///< A power-on or supply monitor reset occurred.                     
             -    
2252      =2                                                                                                            
             -    
2253      =2  #define RSTSRC_MCDRSF__BMASK   0x04 ///< Missing Clock Detector Enable and Flag                           
             -    
2254      =2  #define RSTSRC_MCDRSF__SHIFT   0x02 ///< Missing Clock Detector Enable and Flag                           
             -    
2255      =2  #define RSTSRC_MCDRSF__NOT_SET 0x00 ///< A missing clock detector reset did not occur.                    
             -    
2256      =2  #define RSTSRC_MCDRSF__SET     0x04 ///< A missing clock detector reset occurred.                         
             -    
2257      =2                                                                                                            
             -    
2258      =2  #define RSTSRC_WDTRSF__BMASK   0x08 ///< Watchdog Timer Reset Flag                                        
             -    
2259      =2  #define RSTSRC_WDTRSF__SHIFT   0x03 ///< Watchdog Timer Reset Flag                                        
             -    
2260      =2  #define RSTSRC_WDTRSF__NOT_SET 0x00 ///< A watchdog timer overflow reset did not occur.                   
             -    
2261      =2  #define RSTSRC_WDTRSF__SET     0x08 ///< A watchdog timer overflow reset occurred.                        
             -    
2262      =2                                                                                                            
             -    
2263      =2  #define RSTSRC_SWRSF__BMASK    0x10 ///< Software Reset Force and Flag                                    
             -    
2264      =2  #define RSTSRC_SWRSF__SHIFT    0x04 ///< Software Reset Force and Flag                                    
             -    
2265      =2  #define RSTSRC_SWRSF__NOT_SET  0x00 ///< A software reset did not occur.                                  
             -    
2266      =2  #define RSTSRC_SWRSF__SET      0x10 ///< A software reset occurred.                                       
             -    
2267      =2                                                                                                            
             -    
2268      =2  #define RSTSRC_C0RSEF__BMASK   0x20 ///< Comparator0 Reset Enable and Flag                                
             -    
2269      =2  #define RSTSRC_C0RSEF__SHIFT   0x05 ///< Comparator0 Reset Enable and Flag                                
             -    
2270      =2  #define RSTSRC_C0RSEF__NOT_SET 0x00 ///< A Comparator 0 reset did not occur.                              
             -    
2271      =2  #define RSTSRC_C0RSEF__SET     0x20 ///< A Comparator 0 reset occurred.                                   
             -    
2272      =2                                                                                                            
             -    
2273      =2  #define RSTSRC_FERROR__BMASK   0x40 ///< Flash Error Reset Flag                                           
             -    
2274      =2  #define RSTSRC_FERROR__SHIFT   0x06 ///< Flash Error Reset Flag                                           
             -    
C51 COMPILER V9.56.0.0   UART_0                                                            10/28/2016 17:37:02 PAGE 64  

2275      =2  #define RSTSRC_FERROR__NOT_SET 0x00 ///< A flash error reset did not occur.                               
             -    
2276      =2  #define RSTSRC_FERROR__SET     0x40 ///< A flash error reset occurred.                                    
             -    
2277      =2                                                                                                            
             -    
2278      =2  #define RSTSRC_USBRSF__BMASK   0x80 ///< USB Reset Enable and Flag                                        
             -    
2279      =2  #define RSTSRC_USBRSF__SHIFT   0x07 ///< USB Reset Enable and Flag                                        
             -    
2280      =2  #define RSTSRC_USBRSF__NOT_SET 0x00 ///< A USB0 reset did not occur.                                      
             -    
2281      =2  #define RSTSRC_USBRSF__SET     0x80 ///< A USB0 reset occurred.                                           
             -    
2282      =2                                                                                                            
             -    
2283      =2  //------------------------------------------------------------------------------
2284      =2  // SFRPAGE Enums (SFR Page @ 0xBF)
2285      =2  //------------------------------------------------------------------------------
2286      =2  #define SFRPAGE_SFRPAGE__FMASK 0xFF ///< SFR Page
2287      =2  #define SFRPAGE_SFRPAGE__SHIFT 0x00 ///< SFR Page
2288      =2                                                   
2289      =2  //------------------------------------------------------------------------------
2290      =2  // SMB0ADM Enums (SMBus 0 Slave Address Mask @ 0xCE)
2291      =2  //------------------------------------------------------------------------------
2292      =2  #define SMB0ADM_EHACK__BMASK             0x01 ///< Hardware Acknowledge Enable                     
2293      =2  #define SMB0ADM_EHACK__SHIFT             0x00 ///< Hardware Acknowledge Enable                     
2294      =2  #define SMB0ADM_EHACK__ADR_ACK_MANUAL    0x00 ///< Firmware must manually acknowledge all incoming 
2295      =2                                                ///< address and data bytes.                         
2296      =2  #define SMB0ADM_EHACK__ADR_ACK_AUTOMATIC 0x01 ///< Automatic slave address recognition and hardware
2297      =2                                                ///< acknowledge is enabled.                         
2298      =2                                                                                                     
2299      =2  #define SMB0ADM_SLVM__FMASK              0xFE ///< SMBus Slave Address Mask                        
2300      =2  #define SMB0ADM_SLVM__SHIFT              0x01 ///< SMBus Slave Address Mask                        
2301      =2                                                                                                     
2302      =2  //------------------------------------------------------------------------------
2303      =2  // SMB0ADR Enums (SMBus 0 Slave Address @ 0xCF)
2304      =2  //------------------------------------------------------------------------------
2305      =2  #define SMB0ADR_GC__BMASK      0x01 ///< General Call Address Enable        
2306      =2  #define SMB0ADR_GC__SHIFT      0x00 ///< General Call Address Enable        
2307      =2  #define SMB0ADR_GC__IGNORED    0x00 ///< General Call Address is ignored.   
2308      =2  #define SMB0ADR_GC__RECOGNIZED 0x01 ///< General Call Address is recognized.
2309      =2                                                                              
2310      =2  #define SMB0ADR_SLV__FMASK     0xFE ///< SMBus Hardware Slave Address       
2311      =2  #define SMB0ADR_SLV__SHIFT     0x01 ///< SMBus Hardware Slave Address       
2312      =2                                                                              
2313      =2  //------------------------------------------------------------------------------
2314      =2  // SMB0CF Enums (SMBus 0 Configuration @ 0xC1)
2315      =2  //------------------------------------------------------------------------------
2316      =2  #define SMB0CF_SMBCS__FMASK             0x03 ///< SMBus Clock Source Selection                     
2317      =2  #define SMB0CF_SMBCS__SHIFT             0x00 ///< SMBus Clock Source Selection                     
2318      =2  #define SMB0CF_SMBCS__TIMER0            0x00 ///< Timer 0 Overflow.                                
2319      =2  #define SMB0CF_SMBCS__TIMER1            0x01 ///< Timer 1 Overflow.                                
2320      =2  #define SMB0CF_SMBCS__TIMER2_HIGH       0x02 ///< Timer 2 High Byte Overflow.                      
2321      =2  #define SMB0CF_SMBCS__TIMER2_LOW        0x03 ///< Timer 2 Low Byte Overflow.                       
2322      =2                                                                                                     
2323      =2  #define SMB0CF_SMBFTE__BMASK            0x04 ///< SMBus Free Timeout Detection Enable              
2324      =2  #define SMB0CF_SMBFTE__SHIFT            0x02 ///< SMBus Free Timeout Detection Enable              
2325      =2  #define SMB0CF_SMBFTE__FREE_TO_DISABLED 0x00 ///< Disable bus free timeouts.                       
2326      =2  #define SMB0CF_SMBFTE__FREE_TO_ENABLED  0x04 ///< Enable bus free timeouts. The bus the bus will be
2327      =2                                               ///< considered free if SCL and SDA remain high for   
2328      =2                                               ///< more than 10 SMBus clock source periods.         
C51 COMPILER V9.56.0.0   UART_0                                                            10/28/2016 17:37:02 PAGE 65  

2329      =2                                                                                                     
2330      =2  #define SMB0CF_SMBTOE__BMASK            0x08 ///< SMBus SCL Timeout Detection Enable               
2331      =2  #define SMB0CF_SMBTOE__SHIFT            0x03 ///< SMBus SCL Timeout Detection Enable               
2332      =2  #define SMB0CF_SMBTOE__SCL_TO_DISABLED  0x00 ///< Disable SCL low timeouts.                        
2333      =2  #define SMB0CF_SMBTOE__SCL_TO_ENABLED   0x08 ///< Enable SCL low timeouts.                         
2334      =2                                                                                                     
2335      =2  #define SMB0CF_EXTHOLD__BMASK           0x10 ///< SMBus Setup and Hold Time Extension Enable       
2336      =2  #define SMB0CF_EXTHOLD__SHIFT           0x04 ///< SMBus Setup and Hold Time Extension Enable       
2337      =2  #define SMB0CF_EXTHOLD__DISABLED        0x00 ///< Disable SDA extended setup and hold times.       
2338      =2  #define SMB0CF_EXTHOLD__ENABLED         0x10 ///< Enable SDA extended setup and hold times.        
2339      =2                                                                                                     
2340      =2  #define SMB0CF_BUSY__BMASK              0x20 ///< SMBus Busy Indicator                             
2341      =2  #define SMB0CF_BUSY__SHIFT              0x05 ///< SMBus Busy Indicator                             
2342      =2  #define SMB0CF_BUSY__NOT_SET            0x00 ///< The bus is not busy.                             
2343      =2  #define SMB0CF_BUSY__SET                0x20 ///< The bus is busy and a transfer is currently in   
2344      =2                                               ///< progress.                                        
2345      =2                                                                                                     
2346      =2  #define SMB0CF_INH__BMASK               0x40 ///< SMBus Slave Inhibit                              
2347      =2  #define SMB0CF_INH__SHIFT               0x06 ///< SMBus Slave Inhibit                              
2348      =2  #define SMB0CF_INH__SLAVE_ENABLED       0x00 ///< Slave states are enabled.                        
2349      =2  #define SMB0CF_INH__SLAVE_DISABLED      0x40 ///< Slave states are inhibited.                      
2350      =2                                                                                                     
2351      =2  #define SMB0CF_ENSMB__BMASK             0x80 ///< SMBus Enable                                     
2352      =2  #define SMB0CF_ENSMB__SHIFT             0x07 ///< SMBus Enable                                     
2353      =2  #define SMB0CF_ENSMB__DISABLED          0x00 ///< Disable the SMBus module.                        
2354      =2  #define SMB0CF_ENSMB__ENABLED           0x80 ///< Enable the SMBus module.                         
2355      =2                                                                                                     
2356      =2  //------------------------------------------------------------------------------
2357      =2  // SMB0CN0 Enums (SMBus 0 Control @ 0xC0)
2358      =2  //------------------------------------------------------------------------------
2359      =2  #define SMB0CN0_SI__BMASK           0x01 ///< SMBus Interrupt Flag                           
2360      =2  #define SMB0CN0_SI__SHIFT           0x00 ///< SMBus Interrupt Flag                           
2361      =2  #define SMB0CN0_SI__NOT_SET         0x00 ///<                                                
2362      =2  #define SMB0CN0_SI__SET             0x01 ///<                                                
2363      =2                                                                                               
2364      =2  #define SMB0CN0_ACK__BMASK          0x02 ///< SMBus Acknowledge                              
2365      =2  #define SMB0CN0_ACK__SHIFT          0x01 ///< SMBus Acknowledge                              
2366      =2  #define SMB0CN0_ACK__NOT_SET        0x00 ///< Generate a NACK, or the response was a NACK.   
2367      =2  #define SMB0CN0_ACK__SET            0x02 ///< Generate an ACK, or the response was an ACK.   
2368      =2                                                                                               
2369      =2  #define SMB0CN0_ARBLOST__BMASK      0x04 ///< SMBus Arbitration Lost Indicator               
2370      =2  #define SMB0CN0_ARBLOST__SHIFT      0x02 ///< SMBus Arbitration Lost Indicator               
2371      =2  #define SMB0CN0_ARBLOST__NOT_SET    0x00 ///< No arbitration error.                          
2372      =2  #define SMB0CN0_ARBLOST__ERROR      0x04 ///< Arbitration error occurred.                    
2373      =2                                                                                               
2374      =2  #define SMB0CN0_ACKRQ__BMASK        0x08 ///< SMBus Acknowledge Request                      
2375      =2  #define SMB0CN0_ACKRQ__SHIFT        0x03 ///< SMBus Acknowledge Request                      
2376      =2  #define SMB0CN0_ACKRQ__NOT_SET      0x00 ///< No ACK requested.                              
2377      =2  #define SMB0CN0_ACKRQ__REQUESTED    0x08 ///< ACK requested.                                 
2378      =2                                                                                               
2379      =2  #define SMB0CN0_STO__BMASK          0x10 ///< SMBus Stop Flag                                
2380      =2  #define SMB0CN0_STO__SHIFT          0x04 ///< SMBus Stop Flag                                
2381      =2  #define SMB0CN0_STO__NOT_SET        0x00 ///< A STOP is not pending.                         
2382      =2  #define SMB0CN0_STO__SET            0x10 ///< Generate a STOP or a STOP is currently pending.
2383      =2                                                                                               
2384      =2  #define SMB0CN0_STA__BMASK          0x20 ///< SMBus Start Flag                               
2385      =2  #define SMB0CN0_STA__SHIFT          0x05 ///< SMBus Start Flag                               
2386      =2  #define SMB0CN0_STA__NOT_SET        0x00 ///< A START was not detected.                      
2387      =2  #define SMB0CN0_STA__SET            0x20 ///< Generate a START, repeated START, or a START is
2388      =2                                           ///< currently pending.                             
2389      =2                                                                                               
2390      =2  #define SMB0CN0_TXMODE__BMASK       0x40 ///< SMBus Transmit Mode Indicator                  
C51 COMPILER V9.56.0.0   UART_0                                                            10/28/2016 17:37:02 PAGE 66  

2391      =2  #define SMB0CN0_TXMODE__SHIFT       0x06 ///< SMBus Transmit Mode Indicator                  
2392      =2  #define SMB0CN0_TXMODE__RECEIVER    0x00 ///< SMBus in Receiver Mode.                        
2393      =2  #define SMB0CN0_TXMODE__TRANSMITTER 0x40 ///< SMBus in Transmitter Mode.                     
2394      =2                                                                                               
2395      =2  #define SMB0CN0_MASTER__BMASK       0x80 ///< SMBus Master/Slave Indicator                   
2396      =2  #define SMB0CN0_MASTER__SHIFT       0x07 ///< SMBus Master/Slave Indicator                   
2397      =2  #define SMB0CN0_MASTER__SLAVE       0x00 ///< SMBus operating in slave mode.                 
2398      =2  #define SMB0CN0_MASTER__MASTER      0x80 ///< SMBus operating in master mode.                
2399      =2                                                                                               
2400      =2  //------------------------------------------------------------------------------
2401      =2  // SMB0DAT Enums (SMBus 0 Data @ 0xC2)
2402      =2  //------------------------------------------------------------------------------
2403      =2  #define SMB0DAT_SMB0DAT__FMASK 0xFF ///< SMBus 0 Data
2404      =2  #define SMB0DAT_SMB0DAT__SHIFT 0x00 ///< SMBus 0 Data
2405      =2                                                       
2406      =2  //------------------------------------------------------------------------------
2407      =2  // SMB1ADM Enums (SMBus 1 Slave Address Mask @ 0xCE)
2408      =2  //------------------------------------------------------------------------------
2409      =2  #define SMB1ADM_EHACK__BMASK             0x01 ///< Hardware Acknowledge Enable                     
2410      =2  #define SMB1ADM_EHACK__SHIFT             0x00 ///< Hardware Acknowledge Enable                     
2411      =2  #define SMB1ADM_EHACK__ADR_ACK_MANUAL    0x00 ///< Firmware must manually acknowledge all incoming 
2412      =2                                                ///< address and data bytes.                         
2413      =2  #define SMB1ADM_EHACK__ADR_ACK_AUTOMATIC 0x01 ///< Automatic slave address recognition and hardware
2414      =2                                                ///< acknowledge is enabled.                         
2415      =2                                                                                                     
2416      =2  #define SMB1ADM_SLVM__FMASK              0xFE ///< SMBus Slave Address Mask                        
2417      =2  #define SMB1ADM_SLVM__SHIFT              0x01 ///< SMBus Slave Address Mask                        
2418      =2                                                                                                     
2419      =2  //------------------------------------------------------------------------------
2420      =2  // SMB1ADR Enums (SMBus 1 Slave Address @ 0xCF)
2421      =2  //------------------------------------------------------------------------------
2422      =2  #define SMB1ADR_GC__BMASK      0x01 ///< General Call Address Enable        
2423      =2  #define SMB1ADR_GC__SHIFT      0x00 ///< General Call Address Enable        
2424      =2  #define SMB1ADR_GC__IGNORED    0x00 ///< General Call Address is ignored.   
2425      =2  #define SMB1ADR_GC__RECOGNIZED 0x01 ///< General Call Address is recognized.
2426      =2                                                                              
2427      =2  #define SMB1ADR_SLV__FMASK     0xFE ///< SMBus Hardware Slave Address       
2428      =2  #define SMB1ADR_SLV__SHIFT     0x01 ///< SMBus Hardware Slave Address       
2429      =2                                                                              
2430      =2  //------------------------------------------------------------------------------
2431      =2  // SMB1CF Enums (SMBus 1 Configuration @ 0xC1)
2432      =2  //------------------------------------------------------------------------------
2433      =2  #define SMB1CF_SMBCS__FMASK             0x03 ///< SMBus Clock Source Selection                     
2434      =2  #define SMB1CF_SMBCS__SHIFT             0x00 ///< SMBus Clock Source Selection                     
2435      =2  #define SMB1CF_SMBCS__TIMER0            0x00 ///< Timer 0 Overflow.                                
2436      =2  #define SMB1CF_SMBCS__TIMER5            0x01 ///< Timer 5 Overflow.                                
2437      =2  #define SMB1CF_SMBCS__TIMER2_HIGH       0x02 ///< Timer 2 High Byte Overflow.                      
2438      =2  #define SMB1CF_SMBCS__TIMER2_LOW        0x03 ///< Timer 2 Low Byte Overflow.                       
2439      =2                                                                                                     
2440      =2  #define SMB1CF_SMBFTE__BMASK            0x04 ///< SMBus Free Timeout Detection Enable              
2441      =2  #define SMB1CF_SMBFTE__SHIFT            0x02 ///< SMBus Free Timeout Detection Enable              
2442      =2  #define SMB1CF_SMBFTE__FREE_TO_DISABLED 0x00 ///< Disable bus free timeouts.                       
2443      =2  #define SMB1CF_SMBFTE__FREE_TO_ENABLED  0x04 ///< Enable bus free timeouts. The bus the bus will be
2444      =2                                               ///< considered free if SCL and SDA remain high for   
2445      =2                                               ///< more than 10 SMBus clock source periods.         
2446      =2                                                                                                     
2447      =2  #define SMB1CF_SMBTOE__BMASK            0x08 ///< SMBus SCL Timeout Detection Enable               
2448      =2  #define SMB1CF_SMBTOE__SHIFT            0x03 ///< SMBus SCL Timeout Detection Enable               
2449      =2  #define SMB1CF_SMBTOE__SCL_TO_DISABLED  0x00 ///< Disable SCL low timeouts.                        
2450      =2  #define SMB1CF_SMBTOE__SCL_TO_ENABLED   0x08 ///< Enable SCL low timeouts.                         
2451      =2                                                                                                     
2452      =2  #define SMB1CF_EXTHOLD__BMASK           0x10 ///< SMBus Setup and Hold Time Extension Enable       
C51 COMPILER V9.56.0.0   UART_0                                                            10/28/2016 17:37:02 PAGE 67  

2453      =2  #define SMB1CF_EXTHOLD__SHIFT           0x04 ///< SMBus Setup and Hold Time Extension Enable       
2454      =2  #define SMB1CF_EXTHOLD__DISABLED        0x00 ///< Disable SDA extended setup and hold times.       
2455      =2  #define SMB1CF_EXTHOLD__ENABLED         0x10 ///< Enable SDA extended setup and hold times.        
2456      =2                                                                                                     
2457      =2  #define SMB1CF_BUSY__BMASK              0x20 ///< SMBus Busy Indicator                             
2458      =2  #define SMB1CF_BUSY__SHIFT              0x05 ///< SMBus Busy Indicator                             
2459      =2  #define SMB1CF_BUSY__NOT_SET            0x00 ///< The bus is not busy.                             
2460      =2  #define SMB1CF_BUSY__SET                0x20 ///< The bus is busy and a transfer is currently in   
2461      =2                                               ///< progress.                                        
2462      =2                                                                                                     
2463      =2  #define SMB1CF_INH__BMASK               0x40 ///< SMBus Slave Inhibit                              
2464      =2  #define SMB1CF_INH__SHIFT               0x06 ///< SMBus Slave Inhibit                              
2465      =2  #define SMB1CF_INH__SLAVE_ENABLED       0x00 ///< Slave states are enabled.                        
2466      =2  #define SMB1CF_INH__SLAVE_DISABLED      0x40 ///< Slave states are inhibited.                      
2467      =2                                                                                                     
2468      =2  #define SMB1CF_ENSMB__BMASK             0x80 ///< SMBus Enable                                     
2469      =2  #define SMB1CF_ENSMB__SHIFT             0x07 ///< SMBus Enable                                     
2470      =2  #define SMB1CF_ENSMB__DISABLED          0x00 ///< Disable the SMBus module.                        
2471      =2  #define SMB1CF_ENSMB__ENABLED           0x80 ///< Enable the SMBus module.                         
2472      =2                                                                                                     
2473      =2  //------------------------------------------------------------------------------
2474      =2  // SMB1CN0 Enums (SMBus 1 Control @ 0xC0)
2475      =2  //------------------------------------------------------------------------------
2476      =2  #define SMB1CN0_SI__BMASK           0x01 ///< SMBus Interrupt Flag                           
2477      =2  #define SMB1CN0_SI__SHIFT           0x00 ///< SMBus Interrupt Flag                           
2478      =2  #define SMB1CN0_SI__NOT_SET         0x00 ///<                                                
2479      =2  #define SMB1CN0_SI__SET             0x01 ///<                                                
2480      =2                                                                                               
2481      =2  #define SMB1CN0_ACK__BMASK          0x02 ///< SMBus Acknowledge                              
2482      =2  #define SMB1CN0_ACK__SHIFT          0x01 ///< SMBus Acknowledge                              
2483      =2  #define SMB1CN0_ACK__NOT_SET        0x00 ///< Generate a NACK, or the response was a NACK.   
2484      =2  #define SMB1CN0_ACK__SET            0x02 ///< Generate an ACK, or the response was an ACK.   
2485      =2                                                                                               
2486      =2  #define SMB1CN0_ARBLOST__BMASK      0x04 ///< SMBus Arbitration Lost Indicator               
2487      =2  #define SMB1CN0_ARBLOST__SHIFT      0x02 ///< SMBus Arbitration Lost Indicator               
2488      =2  #define SMB1CN0_ARBLOST__NOT_SET    0x00 ///< No arbitration error.                          
2489      =2  #define SMB1CN0_ARBLOST__ERROR      0x04 ///< Arbitration error occurred.                    
2490      =2                                                                                               
2491      =2  #define SMB1CN0_ACKRQ__BMASK        0x08 ///< SMBus Acknowledge Request                      
2492      =2  #define SMB1CN0_ACKRQ__SHIFT        0x03 ///< SMBus Acknowledge Request                      
2493      =2  #define SMB1CN0_ACKRQ__NOT_SET      0x00 ///< No ACK requested.                              
2494      =2  #define SMB1CN0_ACKRQ__REQUESTED    0x08 ///< ACK requested.                                 
2495      =2                                                                                               
2496      =2  #define SMB1CN0_STO__BMASK          0x10 ///< SMBus Stop Flag                                
2497      =2  #define SMB1CN0_STO__SHIFT          0x04 ///< SMBus Stop Flag                                
2498      =2  #define SMB1CN0_STO__NOT_SET        0x00 ///< A STOP is not pending.                         
2499      =2  #define SMB1CN0_STO__SET            0x10 ///< Generate a STOP or a STOP is currently pending.
2500      =2                                                                                               
2501      =2  #define SMB1CN0_STA__BMASK          0x20 ///< SMBus Start Flag                               
2502      =2  #define SMB1CN0_STA__SHIFT          0x05 ///< SMBus Start Flag                               
2503      =2  #define SMB1CN0_STA__NOT_SET        0x00 ///< A START was not detected.                      
2504      =2  #define SMB1CN0_STA__SET            0x20 ///< Generate a START, repeated START, or a START is
2505      =2                                           ///< currently pending.                             
2506      =2                                                                                               
2507      =2  #define SMB1CN0_TXMODE__BMASK       0x40 ///< SMBus Transmit Mode Indicator                  
2508      =2  #define SMB1CN0_TXMODE__SHIFT       0x06 ///< SMBus Transmit Mode Indicator                  
2509      =2  #define SMB1CN0_TXMODE__RECEIVER    0x00 ///< SMBus in Receiver Mode.                        
2510      =2  #define SMB1CN0_TXMODE__TRANSMITTER 0x40 ///< SMBus in Transmitter Mode.                     
2511      =2                                                                                               
2512      =2  #define SMB1CN0_MASTER__BMASK       0x80 ///< SMBus Master/Slave Indicator                   
2513      =2  #define SMB1CN0_MASTER__SHIFT       0x07 ///< SMBus Master/Slave Indicator                   
2514      =2  #define SMB1CN0_MASTER__SLAVE       0x00 ///< SMBus operating in slave mode.                 
C51 COMPILER V9.56.0.0   UART_0                                                            10/28/2016 17:37:02 PAGE 68  

2515      =2  #define SMB1CN0_MASTER__MASTER      0x80 ///< SMBus operating in master mode.                
2516      =2                                                                                               
2517      =2  //------------------------------------------------------------------------------
2518      =2  // SMB1DAT Enums (SMBus 1 Data @ 0xC2)
2519      =2  //------------------------------------------------------------------------------
2520      =2  #define SMB1DAT_SMB1DAT__FMASK 0xFF ///< SMBus 1 Data
2521      =2  #define SMB1DAT_SMB1DAT__SHIFT 0x00 ///< SMBus 1 Data
2522      =2                                                       
2523      =2  //------------------------------------------------------------------------------
2524      =2  // SMBTC Enums (SMBus Timing and Pin Control @ 0xB9)
2525      =2  //------------------------------------------------------------------------------
2526      =2  #define SMBTC_SMB0SDD__FMASK         0x03 ///< SMBus 0 Start Detection Window                   
2527      =2  #define SMBTC_SMB0SDD__SHIFT         0x00 ///< SMBus 0 Start Detection Window                   
2528      =2  #define SMBTC_SMB0SDD__NONE          0x00 ///< No additional hold time window (0-1 SYSCLK).     
2529      =2  #define SMBTC_SMB0SDD__ADD_2_SYSCLKS 0x01 ///< Increase hold time window to 2-3 SYSCLKs.        
2530      =2  #define SMBTC_SMB0SDD__ADD_4_SYSCLKS 0x02 ///< Increase hold time window to 4-5 SYSCLKs.        
2531      =2  #define SMBTC_SMB0SDD__ADD_8_SYSCLKS 0x03 ///< Increase hold time window to 8-9 SYSCLKs.        
2532      =2                                                                                                  
2533      =2  #define SMBTC_SMB1SDD__FMASK         0x0C ///< SMBus 1 Start Detection Window                   
2534      =2  #define SMBTC_SMB1SDD__SHIFT         0x02 ///< SMBus 1 Start Detection Window                   
2535      =2  #define SMBTC_SMB1SDD__NONE          0x00 ///< No additional hold time requirement (0-1 SYSCLK).
2536      =2  #define SMBTC_SMB1SDD__ADD_2_SYSCLKS 0x04 ///< Increase hold time window to 2-3 SYSCLKs.        
2537      =2  #define SMBTC_SMB1SDD__ADD_4_SYSCLKS 0x08 ///< Increase hold time window to 4-5 SYSCLKs.        
2538      =2  #define SMBTC_SMB1SDD__ADD_8_SYSCLKS 0x0C ///< Increase hold time window to 8-9 SYSCLKs.        
2539      =2                                                                                                  
2540      =2  //------------------------------------------------------------------------------
2541      =2  // SPI0CFG Enums (SPI0 Configuration @ 0xA1)
2542      =2  //------------------------------------------------------------------------------
2543      =2  #define SPI0CFG_RXBMT__BMASK                0x01 ///< Receive Buffer Empty                              
2544      =2  #define SPI0CFG_RXBMT__SHIFT                0x00 ///< Receive Buffer Empty                              
2545      =2  #define SPI0CFG_RXBMT__NOT_SET              0x00 ///< New data is available in the receive buffer (Slave
2546      =2                                                   ///< mode).                                            
2547      =2  #define SPI0CFG_RXBMT__SET                  0x01 ///< No new data in the receive buffer (Slave mode).   
2548      =2                                                                                                          
2549      =2  #define SPI0CFG_SRMT__BMASK                 0x02 ///< Shift Register Empty                              
2550      =2  #define SPI0CFG_SRMT__SHIFT                 0x01 ///< Shift Register Empty                              
2551      =2  #define SPI0CFG_SRMT__NOT_SET               0x00 ///< The shift register is not empty.                  
2552      =2  #define SPI0CFG_SRMT__SET                   0x02 ///< The shift register is empty.                      
2553      =2                                                                                                          
2554      =2  #define SPI0CFG_NSSIN__BMASK                0x04 ///< NSS Instantaneous Pin Input                       
2555      =2  #define SPI0CFG_NSSIN__SHIFT                0x02 ///< NSS Instantaneous Pin Input                       
2556      =2  #define SPI0CFG_NSSIN__LOW                  0x00 ///< The NSS pin is low.                               
2557      =2  #define SPI0CFG_NSSIN__HIGH                 0x04 ///< The NSS pin is high.                              
2558      =2                                                                                                          
2559      =2  #define SPI0CFG_SLVSEL__BMASK               0x08 ///< Slave Selected Flag                               
2560      =2  #define SPI0CFG_SLVSEL__SHIFT               0x03 ///< Slave Selected Flag                               
2561      =2  #define SPI0CFG_SLVSEL__NOT_SELECTED        0x00 ///< The Slave is not selected (NSS is high).          
2562      =2  #define SPI0CFG_SLVSEL__SELECTED            0x08 ///< The Slave is selected (NSS is low).               
2563      =2                                                                                                          
2564      =2  #define SPI0CFG_CKPOL__BMASK                0x10 ///< SPI0 Clock Polarity                               
2565      =2  #define SPI0CFG_CKPOL__SHIFT                0x04 ///< SPI0 Clock Polarity                               
2566      =2  #define SPI0CFG_CKPOL__IDLE_LOW             0x00 ///< SCK line low in idle state.                       
2567      =2  #define SPI0CFG_CKPOL__IDLE_HIGH            0x10 ///< SCK line high in idle state.                      
2568      =2                                                                                                          
2569      =2  #define SPI0CFG_CKPHA__BMASK                0x20 ///< SPI0 Clock Phase                                  
2570      =2  #define SPI0CFG_CKPHA__SHIFT                0x05 ///< SPI0 Clock Phase                                  
2571      =2  #define SPI0CFG_CKPHA__DATA_CENTERED_FIRST  0x00 ///< Data centered on first edge of SCK period.        
2572      =2  #define SPI0CFG_CKPHA__DATA_CENTERED_SECOND 0x20 ///< Data centered on second edge of SCK period.       
2573      =2                                                                                                          
2574      =2  #define SPI0CFG_MSTEN__BMASK                0x40 ///< Master Mode Enable                                
2575      =2  #define SPI0CFG_MSTEN__SHIFT                0x06 ///< Master Mode Enable                                
2576      =2  #define SPI0CFG_MSTEN__MASTER_DISABLED      0x00 ///< Disable master mode. Operate in slave mode.       
C51 COMPILER V9.56.0.0   UART_0                                                            10/28/2016 17:37:02 PAGE 69  

2577      =2  #define SPI0CFG_MSTEN__MASTER_ENABLED       0x40 ///< Enable master mode. Operate as a master.          
2578      =2                                                                                                          
2579      =2  #define SPI0CFG_SPIBSY__BMASK               0x80 ///< SPI Busy                                          
2580      =2  #define SPI0CFG_SPIBSY__SHIFT               0x07 ///< SPI Busy                                          
2581      =2  #define SPI0CFG_SPIBSY__NOT_SET             0x00 ///< A SPI transfer is not in progress.                
2582      =2  #define SPI0CFG_SPIBSY__SET                 0x80 ///< A SPI transfer is in progress.                    
2583      =2                                                                                                          
2584      =2  //------------------------------------------------------------------------------
2585      =2  // SPI0CKR Enums (SPI0 Clock Rate @ 0xA2)
2586      =2  //------------------------------------------------------------------------------
2587      =2  #define SPI0CKR_SPI0CKR__FMASK 0xFF ///< SPI0 Clock Rate
2588      =2  #define SPI0CKR_SPI0CKR__SHIFT 0x00 ///< SPI0 Clock Rate
2589      =2                                                          
2590      =2  //------------------------------------------------------------------------------
2591      =2  // SPI0CN0 Enums (SPI0 Control @ 0xF8)
2592      =2  //------------------------------------------------------------------------------
2593      =2  #define SPI0CN0_SPIEN__BMASK                  0x01 ///< SPI0 Enable                                       
2594      =2  #define SPI0CN0_SPIEN__SHIFT                  0x00 ///< SPI0 Enable                                       
2595      =2  #define SPI0CN0_SPIEN__DISABLED               0x00 ///< Disable the SPI module.                           
2596      =2  #define SPI0CN0_SPIEN__ENABLED                0x01 ///< Enable the SPI module.                            
2597      =2                                                                                                            
2598      =2  #define SPI0CN0_TXBMT__BMASK                  0x02 ///< Transmit Buffer Empty                             
2599      =2  #define SPI0CN0_TXBMT__SHIFT                  0x01 ///< Transmit Buffer Empty                             
2600      =2  #define SPI0CN0_TXBMT__NOT_SET                0x00 ///< The transmit buffer is not empty.                 
2601      =2  #define SPI0CN0_TXBMT__SET                    0x02 ///< The transmit buffer is empty.                     
2602      =2                                                                                                            
2603      =2  #define SPI0CN0_NSSMD__FMASK                  0x0C ///< Slave Select Mode                                 
2604      =2  #define SPI0CN0_NSSMD__SHIFT                  0x02 ///< Slave Select Mode                                 
2605      =2  #define SPI0CN0_NSSMD__3_WIRE                 0x00 ///< 3-Wire Slave or 3-Wire Master Mode. NSS signal is 
2606      =2                                                     ///< not routed to a port pin.                         
2607      =2  #define SPI0CN0_NSSMD__4_WIRE_SLAVE           0x04 ///< 4-Wire Slave or Multi-Master Mode. NSS is an input
2608      =2                                                     ///< to the device.                                    
2609      =2  #define SPI0CN0_NSSMD__4_WIRE_MASTER_NSS_LOW  0x08 ///< 4-Wire Single-Master Mode. NSS is an output and   
2610      =2                                                     ///< logic low.                                        
2611      =2  #define SPI0CN0_NSSMD__4_WIRE_MASTER_NSS_HIGH 0x0C ///< 4-Wire Single-Master Mode. NSS is an output and   
2612      =2                                                     ///< logic high.                                       
2613      =2                                                                                                            
2614      =2  #define SPI0CN0_RXOVRN__BMASK                 0x10 ///< Receive Overrun Flag                              
2615      =2  #define SPI0CN0_RXOVRN__SHIFT                 0x04 ///< Receive Overrun Flag                              
2616      =2  #define SPI0CN0_RXOVRN__NOT_SET               0x00 ///< A receive overrun did not occur.                  
2617      =2  #define SPI0CN0_RXOVRN__SET                   0x10 ///< A receive overrun occurred.                       
2618      =2                                                                                                            
2619      =2  #define SPI0CN0_MODF__BMASK                   0x20 ///< Mode Fault Flag                                   
2620      =2  #define SPI0CN0_MODF__SHIFT                   0x05 ///< Mode Fault Flag                                   
2621      =2  #define SPI0CN0_MODF__NOT_SET                 0x00 ///< A master collision did not occur.                 
2622      =2  #define SPI0CN0_MODF__SET                     0x20 ///< A master collision occurred.                      
2623      =2                                                                                                            
2624      =2  #define SPI0CN0_WCOL__BMASK                   0x40 ///< Write Collision Flag                              
2625      =2  #define SPI0CN0_WCOL__SHIFT                   0x06 ///< Write Collision Flag                              
2626      =2  #define SPI0CN0_WCOL__NOT_SET                 0x00 ///< A write collision did not occur.                  
2627      =2  #define SPI0CN0_WCOL__SET                     0x40 ///< A write collision occurred.                       
2628      =2                                                                                                            
2629      =2  #define SPI0CN0_SPIF__BMASK                   0x80 ///< SPI0 Interrupt Flag                               
2630      =2  #define SPI0CN0_SPIF__SHIFT                   0x07 ///< SPI0 Interrupt Flag                               
2631      =2  #define SPI0CN0_SPIF__NOT_SET                 0x00 ///< A data transfer has not completed since the last  
2632      =2                                                     ///< time SPIF was cleared.                            
2633      =2  #define SPI0CN0_SPIF__SET                     0x80 ///< A data transfer completed.                        
2634      =2                                                                                                            
2635      =2  //------------------------------------------------------------------------------
2636      =2  // SPI0DAT Enums (SPI0 Data @ 0xA3)
2637      =2  //------------------------------------------------------------------------------
2638      =2  #define SPI0DAT_SPI0DAT__FMASK 0xFF ///< SPI0 Transmit and Receive Data
C51 COMPILER V9.56.0.0   UART_0                                                            10/28/2016 17:37:02 PAGE 70  

2639      =2  #define SPI0DAT_SPI0DAT__SHIFT 0x00 ///< SPI0 Transmit and Receive Data
2640      =2                                                                         
2641      =2  //------------------------------------------------------------------------------
2642      =2  // TH0 Enums (Timer 0 High Byte @ 0x8C)
2643      =2  //------------------------------------------------------------------------------
2644      =2  #define TH0_TH0__FMASK 0xFF ///< Timer 0 High Byte
2645      =2  #define TH0_TH0__SHIFT 0x00 ///< Timer 0 High Byte
2646      =2                                                    
2647      =2  //------------------------------------------------------------------------------
2648      =2  // TH1 Enums (Timer 1 High Byte @ 0x8D)
2649      =2  //------------------------------------------------------------------------------
2650      =2  #define TH1_TH1__FMASK 0xFF ///< Timer 1 High Byte
2651      =2  #define TH1_TH1__SHIFT 0x00 ///< Timer 1 High Byte
2652      =2                                                    
2653      =2  //------------------------------------------------------------------------------
2654      =2  // TL0 Enums (Timer 0 Low Byte @ 0x8A)
2655      =2  //------------------------------------------------------------------------------
2656      =2  #define TL0_TL0__FMASK 0xFF ///< Timer 0 Low Byte
2657      =2  #define TL0_TL0__SHIFT 0x00 ///< Timer 0 Low Byte
2658      =2                                                   
2659      =2  //------------------------------------------------------------------------------
2660      =2  // TL1 Enums (Timer 1 Low Byte @ 0x8B)
2661      =2  //------------------------------------------------------------------------------
2662      =2  #define TL1_TL1__FMASK 0xFF ///< Timer 1 Low Byte
2663      =2  #define TL1_TL1__SHIFT 0x00 ///< Timer 1 Low Byte
2664      =2                                                   
2665      =2  //------------------------------------------------------------------------------
2666      =2  // TMR2CN0 Enums (Timer 2 Control 0 @ 0xC8)
2667      =2  //------------------------------------------------------------------------------
2668      =2  #define TMR2CN0_T2XCLK__BMASK          0x01 ///< Timer 2 External Clock Select                    
2669      =2  #define TMR2CN0_T2XCLK__SHIFT          0x00 ///< Timer 2 External Clock Select                    
2670      =2  #define TMR2CN0_T2XCLK__SYSCLK_DIV_12  0x00 ///< Timer 2 clock is the system clock divided by 12. 
2671      =2  #define TMR2CN0_T2XCLK__EXTOSC_DIV_8   0x01 ///< Timer 2 clock is the external oscillator divided 
2672      =2                                              ///< by 8 (synchronized with SYSCLK).                 
2673      =2                                                                                                    
2674      =2  #define TMR2CN0_T2CSS__BMASK           0x02 ///< Timer 2 Capture Source Select                    
2675      =2  #define TMR2CN0_T2CSS__SHIFT           0x01 ///< Timer 2 Capture Source Select                    
2676      =2  #define TMR2CN0_T2CSS__USB_SOF_CAPTURE 0x00 ///< Capture source is USB SOF event.                 
2677      =2  #define TMR2CN0_T2CSS__LFOSC_CAPTURE   0x02 ///< Capture source is falling edge of Low-Frequency  
2678      =2                                              ///< Oscillator.                                      
2679      =2                                                                                                    
2680      =2  #define TMR2CN0_TR2__BMASK             0x04 ///< Timer 2 Run Control                              
2681      =2  #define TMR2CN0_TR2__SHIFT             0x02 ///< Timer 2 Run Control                              
2682      =2  #define TMR2CN0_TR2__STOP              0x00 ///< Stop Timer 2.                                    
2683      =2  #define TMR2CN0_TR2__RUN               0x04 ///< Start Timer 2 running.                           
2684      =2                                                                                                    
2685      =2  #define TMR2CN0_T2SPLIT__BMASK         0x08 ///< Timer 2 Split Mode Enable                        
2686      =2  #define TMR2CN0_T2SPLIT__SHIFT         0x03 ///< Timer 2 Split Mode Enable                        
2687      =2  #define TMR2CN0_T2SPLIT__16_BIT_RELOAD 0x00 ///< Timer 2 operates in 16-bit auto-reload mode.     
2688      =2  #define TMR2CN0_T2SPLIT__8_BIT_RELOAD  0x08 ///< Timer 2 operates as two 8-bit auto-reload timers.
2689      =2                                                                                                    
2690      =2  #define TMR2CN0_TF2CEN__BMASK          0x10 ///< Timer 2 Capture Enable                           
2691      =2  #define TMR2CN0_TF2CEN__SHIFT          0x04 ///< Timer 2 Capture Enable                           
2692      =2  #define TMR2CN0_TF2CEN__DISABLED       0x00 ///< Disable capture mode.                            
2693      =2  #define TMR2CN0_TF2CEN__ENABLED        0x10 ///< Enable capture mode.                             
2694      =2                                                                                                    
2695      =2  #define TMR2CN0_TF2LEN__BMASK          0x20 ///< Timer 2 Low Byte Interrupt Enable                
2696      =2  #define TMR2CN0_TF2LEN__SHIFT          0x05 ///< Timer 2 Low Byte Interrupt Enable                
2697      =2  #define TMR2CN0_TF2LEN__DISABLED       0x00 ///< Disable low byte interrupts.                     
2698      =2  #define TMR2CN0_TF2LEN__ENABLED        0x20 ///< Enable low byte interrupts.                      
2699      =2                                                                                                    
2700      =2  #define TMR2CN0_TF2L__BMASK            0x40 ///< Timer 2 Low Byte Overflow Flag                   
C51 COMPILER V9.56.0.0   UART_0                                                            10/28/2016 17:37:02 PAGE 71  

2701      =2  #define TMR2CN0_TF2L__SHIFT            0x06 ///< Timer 2 Low Byte Overflow Flag                   
2702      =2  #define TMR2CN0_TF2L__NOT_SET          0x00 ///< Timer 2 low byte did not overflow.               
2703      =2  #define TMR2CN0_TF2L__SET              0x40 ///< Timer 2 low byte overflowed.                     
2704      =2                                                                                                    
2705      =2  #define TMR2CN0_TF2H__BMASK            0x80 ///< Timer 2 High Byte Overflow Flag                  
2706      =2  #define TMR2CN0_TF2H__SHIFT            0x07 ///< Timer 2 High Byte Overflow Flag                  
2707      =2  #define TMR2CN0_TF2H__NOT_SET          0x00 ///< Timer 2 8-bit high byte or 16-bit value did not  
2708      =2                                              ///< overflow.                                        
2709      =2  #define TMR2CN0_TF2H__SET              0x80 ///< Timer 2 8-bit high byte or 16-bit value          
2710      =2                                              ///< overflowed.                                      
2711      =2                                                                                                    
2712      =2  //------------------------------------------------------------------------------
2713      =2  // TMR2H Enums (Timer 2 High Byte @ 0xCD)
2714      =2  //------------------------------------------------------------------------------
2715      =2  #define TMR2H_TMR2H__FMASK 0xFF ///< Timer 2 High Byte
2716      =2  #define TMR2H_TMR2H__SHIFT 0x00 ///< Timer 2 High Byte
2717      =2                                                        
2718      =2  //------------------------------------------------------------------------------
2719      =2  // TMR2L Enums (Timer 2 Low Byte @ 0xCC)
2720      =2  //------------------------------------------------------------------------------
2721      =2  #define TMR2L_TMR2L__FMASK 0xFF ///< Timer 2 Low Byte
2722      =2  #define TMR2L_TMR2L__SHIFT 0x00 ///< Timer 2 Low Byte
2723      =2                                                       
2724      =2  //------------------------------------------------------------------------------
2725      =2  // TMR2RLH Enums (Timer 2 Reload High Byte @ 0xCB)
2726      =2  //------------------------------------------------------------------------------
2727      =2  #define TMR2RLH_TMR2RLH__FMASK 0xFF ///< Timer 2 Reload High Byte
2728      =2  #define TMR2RLH_TMR2RLH__SHIFT 0x00 ///< Timer 2 Reload High Byte
2729      =2                                                                   
2730      =2  //------------------------------------------------------------------------------
2731      =2  // TMR2RLL Enums (Timer 2 Reload Low Byte @ 0xCA)
2732      =2  //------------------------------------------------------------------------------
2733      =2  #define TMR2RLL_TMR2RLL__FMASK 0xFF ///< Timer 2 Reload Low Byte
2734      =2  #define TMR2RLL_TMR2RLL__SHIFT 0x00 ///< Timer 2 Reload Low Byte
2735      =2                                                                  
2736      =2  //------------------------------------------------------------------------------
2737      =2  // TMR3CN0 Enums (Timer 3 Control 0 @ 0x91)
2738      =2  //------------------------------------------------------------------------------
2739      =2  #define TMR3CN0_T3XCLK__BMASK          0x01 ///< Timer 3 External Clock Select                    
2740      =2  #define TMR3CN0_T3XCLK__SHIFT          0x00 ///< Timer 3 External Clock Select                    
2741      =2  #define TMR3CN0_T3XCLK__SYSCLK_DIV_12  0x00 ///< Timer 3 clock is the system clock divided by 12. 
2742      =2  #define TMR3CN0_T3XCLK__EXTOSC_DIV_8   0x01 ///< Timer 3 clock is the external oscillator divided 
2743      =2                                              ///< by 8 (synchronized with SYSCLK).                 
2744      =2                                                                                                    
2745      =2  #define TMR3CN0_T3CSS__BMASK           0x02 ///< Timer 3 Capture Source Select                    
2746      =2  #define TMR3CN0_T3CSS__SHIFT           0x01 ///< Timer 3 Capture Source Select                    
2747      =2  #define TMR3CN0_T3CSS__USB_SOF_CAPTURE 0x00 ///< Capture source is USB SOF event.                 
2748      =2  #define TMR3CN0_T3CSS__LFOSC_CAPTURE   0x02 ///< Capture source is falling edge of Low-Frequency  
2749      =2                                              ///< Oscillator.                                      
2750      =2                                                                                                    
2751      =2  #define TMR3CN0_TR3__BMASK             0x04 ///< Timer 3 Run Control                              
2752      =2  #define TMR3CN0_TR3__SHIFT             0x02 ///< Timer 3 Run Control                              
2753      =2  #define TMR3CN0_TR3__STOP              0x00 ///< Stop Timer 3.                                    
2754      =2  #define TMR3CN0_TR3__RUN               0x04 ///< Start Timer 3 running.                           
2755      =2                                                                                                    
2756      =2  #define TMR3CN0_T3SPLIT__BMASK         0x08 ///< Timer 3 Split Mode Enable                        
2757      =2  #define TMR3CN0_T3SPLIT__SHIFT         0x03 ///< Timer 3 Split Mode Enable                        
2758      =2  #define TMR3CN0_T3SPLIT__16_BIT_RELOAD 0x00 ///< Timer 3 operates in 16-bit auto-reload mode.     
2759      =2  #define TMR3CN0_T3SPLIT__8_BIT_RELOAD  0x08 ///< Timer 3 operates as two 8-bit auto-reload timers.
2760      =2                                                                                                    
2761      =2  #define TMR3CN0_TF3CEN__BMASK          0x10 ///< Timer 3 Capture Enable                           
2762      =2  #define TMR3CN0_TF3CEN__SHIFT          0x04 ///< Timer 3 Capture Enable                           
C51 COMPILER V9.56.0.0   UART_0                                                            10/28/2016 17:37:02 PAGE 72  

2763      =2  #define TMR3CN0_TF3CEN__DISABLED       0x00 ///< Disable capture mode.                            
2764      =2  #define TMR3CN0_TF3CEN__ENABLED        0x10 ///< Enable capture mode.                             
2765      =2                                                                                                    
2766      =2  #define TMR3CN0_TF3LEN__BMASK          0x20 ///< Timer 3 Low Byte Interrupt Enable                
2767      =2  #define TMR3CN0_TF3LEN__SHIFT          0x05 ///< Timer 3 Low Byte Interrupt Enable                
2768      =2  #define TMR3CN0_TF3LEN__DISABLED       0x00 ///< Disable low byte interrupts.                     
2769      =2  #define TMR3CN0_TF3LEN__ENABLED        0x20 ///< Enable low byte interrupts.                      
2770      =2                                                                                                    
2771      =2  #define TMR3CN0_TF3L__BMASK            0x40 ///< Timer 3 Low Byte Overflow Flag                   
2772      =2  #define TMR3CN0_TF3L__SHIFT            0x06 ///< Timer 3 Low Byte Overflow Flag                   
2773      =2  #define TMR3CN0_TF3L__NOT_SET          0x00 ///< Timer 3 low byte did not overflow.               
2774      =2  #define TMR3CN0_TF3L__SET              0x40 ///< Timer 3 low byte overflowed.                     
2775      =2                                                                                                    
2776      =2  #define TMR3CN0_TF3H__BMASK            0x80 ///< Timer 3 High Byte Overflow Flag                  
2777      =2  #define TMR3CN0_TF3H__SHIFT            0x07 ///< Timer 3 High Byte Overflow Flag                  
2778      =2  #define TMR3CN0_TF3H__NOT_SET          0x00 ///< Timer 3 8-bit high byte or 16-bit value did not  
2779      =2                                              ///< overflow.                                        
2780      =2  #define TMR3CN0_TF3H__SET              0x80 ///< Timer 3 8-bit high byte or 16-bit value          
2781      =2                                              ///< overflowed.                                      
2782      =2                                                                                                    
2783      =2  //------------------------------------------------------------------------------
2784      =2  // TMR3H Enums (Timer 3 High Byte @ 0x95)
2785      =2  //------------------------------------------------------------------------------
2786      =2  #define TMR3H_TMR3H__FMASK 0xFF ///< Timer 3 High Byte
2787      =2  #define TMR3H_TMR3H__SHIFT 0x00 ///< Timer 3 High Byte
2788      =2                                                        
2789      =2  //------------------------------------------------------------------------------
2790      =2  // TMR3L Enums (Timer 3 Low Byte @ 0x94)
2791      =2  //------------------------------------------------------------------------------
2792      =2  #define TMR3L_TMR3L__FMASK 0xFF ///< Timer 3 Low Byte
2793      =2  #define TMR3L_TMR3L__SHIFT 0x00 ///< Timer 3 Low Byte
2794      =2                                                       
2795      =2  //------------------------------------------------------------------------------
2796      =2  // TMR3RLH Enums (Timer 3 Reload High Byte @ 0x93)
2797      =2  //------------------------------------------------------------------------------
2798      =2  #define TMR3RLH_TMR3RLH__FMASK 0xFF ///< Timer 3 Reload High Byte
2799      =2  #define TMR3RLH_TMR3RLH__SHIFT 0x00 ///< Timer 3 Reload High Byte
2800      =2                                                                   
2801      =2  //------------------------------------------------------------------------------
2802      =2  // TMR3RLL Enums (Timer 3 Reload Low Byte @ 0x92)
2803      =2  //------------------------------------------------------------------------------
2804      =2  #define TMR3RLL_TMR3RLL__FMASK 0xFF ///< Timer 3 Reload Low Byte
2805      =2  #define TMR3RLL_TMR3RLL__SHIFT 0x00 ///< Timer 3 Reload Low Byte
2806      =2                                                                  
2807      =2  //------------------------------------------------------------------------------
2808      =2  // TMR4CN0 Enums (Timer 4 Control 0 @ 0x91)
2809      =2  //------------------------------------------------------------------------------
2810      =2  #define TMR4CN0_T4XCLK__BMASK          0x01 ///< Timer 4 External Clock Select                    
2811      =2  #define TMR4CN0_T4XCLK__SHIFT          0x00 ///< Timer 4 External Clock Select                    
2812      =2  #define TMR4CN0_T4XCLK__SYSCLK_DIV_12  0x00 ///< Timer 4 clock is the system clock divided by 12. 
2813      =2  #define TMR4CN0_T4XCLK__EXTOSC_DIV_8   0x01 ///< Timer 4 clock is the external oscillator divided 
2814      =2                                              ///< by 8 (synchronized with SYSCLK).                 
2815      =2                                                                                                    
2816      =2  #define TMR4CN0_TR4__BMASK             0x04 ///< Timer 4 Run Control                              
2817      =2  #define TMR4CN0_TR4__SHIFT             0x02 ///< Timer 4 Run Control                              
2818      =2  #define TMR4CN0_TR4__STOP              0x00 ///< Stop Timer 4.                                    
2819      =2  #define TMR4CN0_TR4__RUN               0x04 ///< Start Timer 4 running.                           
2820      =2                                                                                                    
2821      =2  #define TMR4CN0_T4SPLIT__BMASK         0x08 ///< Timer 4 Split Mode Enable                        
2822      =2  #define TMR4CN0_T4SPLIT__SHIFT         0x03 ///< Timer 4 Split Mode Enable                        
2823      =2  #define TMR4CN0_T4SPLIT__16_BIT_RELOAD 0x00 ///< Timer 4 operates in 16-bit auto-reload mode.     
2824      =2  #define TMR4CN0_T4SPLIT__8_BIT_RELOAD  0x08 ///< Timer 4 operates as two 8-bit auto-reload timers.
C51 COMPILER V9.56.0.0   UART_0                                                            10/28/2016 17:37:02 PAGE 73  

2825      =2                                                                                                    
2826      =2  #define TMR4CN0_TF4LEN__BMASK          0x20 ///< Timer 4 Low Byte Interrupt Enable                
2827      =2  #define TMR4CN0_TF4LEN__SHIFT          0x05 ///< Timer 4 Low Byte Interrupt Enable                
2828      =2  #define TMR4CN0_TF4LEN__DISABLED       0x00 ///< Disable low byte interrupts.                     
2829      =2  #define TMR4CN0_TF4LEN__ENABLED        0x20 ///< Enable low byte interrupts.                      
2830      =2                                                                                                    
2831      =2  #define TMR4CN0_TF4L__BMASK            0x40 ///< Timer 4 Low Byte Overflow Flag                   
2832      =2  #define TMR4CN0_TF4L__SHIFT            0x06 ///< Timer 4 Low Byte Overflow Flag                   
2833      =2  #define TMR4CN0_TF4L__NOT_SET          0x00 ///< Timer 4 low byte did not overflow.               
2834      =2  #define TMR4CN0_TF4L__SET              0x40 ///< Timer 4 low byte overflowed.                     
2835      =2                                                                                                    
2836      =2  #define TMR4CN0_TF4H__BMASK            0x80 ///< Timer 4 High Byte Overflow Flag                  
2837      =2  #define TMR4CN0_TF4H__SHIFT            0x07 ///< Timer 4 High Byte Overflow Flag                  
2838      =2  #define TMR4CN0_TF4H__NOT_SET          0x00 ///< Timer 4 8-bit high byte or 16-bit value did not  
2839      =2                                              ///< overflow.                                        
2840      =2  #define TMR4CN0_TF4H__SET              0x80 ///< Timer 4 8-bit high byte or 16-bit value          
2841      =2                                              ///< overflowed.                                      
2842      =2                                                                                                    
2843      =2  //------------------------------------------------------------------------------
2844      =2  // TMR4H Enums (Timer 4 High Byte @ 0x95)
2845      =2  //------------------------------------------------------------------------------
2846      =2  #define TMR4H_TMR4H__FMASK 0xFF ///< Timer 4 High Byte
2847      =2  #define TMR4H_TMR4H__SHIFT 0x00 ///< Timer 4 High Byte
2848      =2                                                        
2849      =2  //------------------------------------------------------------------------------
2850      =2  // TMR4L Enums (Timer 4 Low Byte @ 0x94)
2851      =2  //------------------------------------------------------------------------------
2852      =2  #define TMR4L_TMR4L__FMASK 0xFF ///< Timer 4 Low Byte
2853      =2  #define TMR4L_TMR4L__SHIFT 0x00 ///< Timer 4 Low Byte
2854      =2                                                       
2855      =2  //------------------------------------------------------------------------------
2856      =2  // TMR4RLH Enums (Timer 4 Reload High Byte @ 0x93)
2857      =2  //------------------------------------------------------------------------------
2858      =2  #define TMR4RLH_TMR4RLH__FMASK 0xFF ///< Timer 4 Reload High Byte
2859      =2  #define TMR4RLH_TMR4RLH__SHIFT 0x00 ///< Timer 4 Reload High Byte
2860      =2                                                                   
2861      =2  //------------------------------------------------------------------------------
2862      =2  // TMR4RLL Enums (Timer 4 Reload Low Byte @ 0x92)
2863      =2  //------------------------------------------------------------------------------
2864      =2  #define TMR4RLL_TMR4RLL__FMASK 0xFF ///< Timer 4 Reload Low Byte
2865      =2  #define TMR4RLL_TMR4RLL__SHIFT 0x00 ///< Timer 4 Reload Low Byte
2866      =2                                                                  
2867      =2  //------------------------------------------------------------------------------
2868      =2  // TMR5CN0 Enums (Timer 5 Control 0 @ 0xC8)
2869      =2  //------------------------------------------------------------------------------
2870      =2  #define TMR5CN0_T5XCLK__BMASK          0x01 ///< Timer 5 External Clock Select                    
2871      =2  #define TMR5CN0_T5XCLK__SHIFT          0x00 ///< Timer 5 External Clock Select                    
2872      =2  #define TMR5CN0_T5XCLK__SYSCLK_DIV_12  0x00 ///< Timer 5 clock is the system clock divided by 12. 
2873      =2  #define TMR5CN0_T5XCLK__EXTOSC_DIV_8   0x01 ///< Timer 5 clock is the external oscillator divided 
2874      =2                                              ///< by 8 (synchronized with SYSCLK).                 
2875      =2                                                                                                    
2876      =2  #define TMR5CN0_TR5__BMASK             0x04 ///< Timer 5 Run Control                              
2877      =2  #define TMR5CN0_TR5__SHIFT             0x02 ///< Timer 5 Run Control                              
2878      =2  #define TMR5CN0_TR5__STOP              0x00 ///< Stop Timer 5.                                    
2879      =2  #define TMR5CN0_TR5__RUN               0x04 ///< Start Timer 5 running.                           
2880      =2                                                                                                    
2881      =2  #define TMR5CN0_T5SPLIT__BMASK         0x08 ///< Timer 5 Split Mode Enable                        
2882      =2  #define TMR5CN0_T5SPLIT__SHIFT         0x03 ///< Timer 5 Split Mode Enable                        
2883      =2  #define TMR5CN0_T5SPLIT__16_BIT_RELOAD 0x00 ///< Timer 5 operates in 16-bit auto-reload mode.     
2884      =2  #define TMR5CN0_T5SPLIT__8_BIT_RELOAD  0x08 ///< Timer 5 operates as two 8-bit auto-reload timers.
2885      =2                                                                                                    
2886      =2  #define TMR5CN0_TF5LEN__BMASK          0x20 ///< Timer 5 Low Byte Interrupt Enable                
C51 COMPILER V9.56.0.0   UART_0                                                            10/28/2016 17:37:02 PAGE 74  

2887      =2  #define TMR5CN0_TF5LEN__SHIFT          0x05 ///< Timer 5 Low Byte Interrupt Enable                
2888      =2  #define TMR5CN0_TF5LEN__DISABLED       0x00 ///< Disable low byte interrupts.                     
2889      =2  #define TMR5CN0_TF5LEN__ENABLED        0x20 ///< Enable low byte interrupts.                      
2890      =2                                                                                                    
2891      =2  #define TMR5CN0_TF5L__BMASK            0x40 ///< Timer 5 Low Byte Overflow Flag                   
2892      =2  #define TMR5CN0_TF5L__SHIFT            0x06 ///< Timer 5 Low Byte Overflow Flag                   
2893      =2  #define TMR5CN0_TF5L__NOT_SET          0x00 ///< Timer 5 low byte did not overflow.               
2894      =2  #define TMR5CN0_TF5L__SET              0x40 ///< Timer 5 low byte overflowed.                     
2895      =2                                                                                                    
2896      =2  #define TMR5CN0_TF5H__BMASK            0x80 ///< Timer 5 High Byte Overflow Flag                  
2897      =2  #define TMR5CN0_TF5H__SHIFT            0x07 ///< Timer 5 High Byte Overflow Flag                  
2898      =2  #define TMR5CN0_TF5H__NOT_SET          0x00 ///< Timer 5 8-bit high byte or 16-bit value did not  
2899      =2                                              ///< overflow.                                        
2900      =2  #define TMR5CN0_TF5H__SET              0x80 ///< Timer 5 8-bit high byte or 16-bit value          
2901      =2                                              ///< overflowed.                                      
2902      =2                                                                                                    
2903      =2  //------------------------------------------------------------------------------
2904      =2  // TMR5H Enums (Timer 5 High Byte @ 0xCD)
2905      =2  //------------------------------------------------------------------------------
2906      =2  #define TMR5H_TMR5H__FMASK 0xFF ///< Timer 5 High Byte
2907      =2  #define TMR5H_TMR5H__SHIFT 0x00 ///< Timer 5 High Byte
2908      =2                                                        
2909      =2  //------------------------------------------------------------------------------
2910      =2  // TMR5L Enums (Timer 5 Low Byte @ 0xCC)
2911      =2  //------------------------------------------------------------------------------
2912      =2  #define TMR5L_TMR5L__FMASK 0xFF ///< Timer 5 Low Byte
2913      =2  #define TMR5L_TMR5L__SHIFT 0x00 ///< Timer 5 Low Byte
2914      =2                                                       
2915      =2  //------------------------------------------------------------------------------
2916      =2  // TMR5RLH Enums (Timer 5 Reload High Byte @ 0xCB)
2917      =2  //------------------------------------------------------------------------------
2918      =2  #define TMR5RLH_TMR5RLH__FMASK 0xFF ///< Timer 5 Reload High Byte
2919      =2  #define TMR5RLH_TMR5RLH__SHIFT 0x00 ///< Timer 5 Reload High Byte
2920      =2                                                                   
2921      =2  //------------------------------------------------------------------------------
2922      =2  // TMR5RLL Enums (Timer 5 Reload Low Byte @ 0xCA)
2923      =2  //------------------------------------------------------------------------------
2924      =2  #define TMR5RLL_TMR5RLL__FMASK 0xFF ///< Timer 5 Reload Low Byte
2925      =2  #define TMR5RLL_TMR5RLL__SHIFT 0x00 ///< Timer 5 Reload Low Byte
2926      =2                                                                  
2927      =2  //------------------------------------------------------------------------------
2928      =2  // CKCON0 Enums (Clock Control 0 @ 0x8E)
2929      =2  //------------------------------------------------------------------------------
2930      =2  #define CKCON0_SCA__FMASK           0x03 ///< Timer 0/1 Prescale                                
2931      =2  #define CKCON0_SCA__SHIFT           0x00 ///< Timer 0/1 Prescale                                
2932      =2  #define CKCON0_SCA__SYSCLK_DIV_12   0x00 ///< System clock divided by 12.                       
2933      =2  #define CKCON0_SCA__SYSCLK_DIV_4    0x01 ///< System clock divided by 4.                        
2934      =2  #define CKCON0_SCA__SYSCLK_DIV_48   0x02 ///< System clock divided by 48.                       
2935      =2  #define CKCON0_SCA__EXTOSC_DIV_8    0x03 ///< External oscillator divided by 8 (synchronized    
2936      =2                                           ///< with the system clock).                           
2937      =2                                                                                                  
2938      =2  #define CKCON0_T0M__BMASK           0x04 ///< Timer 0 Clock Select                              
2939      =2  #define CKCON0_T0M__SHIFT           0x02 ///< Timer 0 Clock Select                              
2940      =2  #define CKCON0_T0M__PRESCALE        0x00 ///< Counter/Timer 0 uses the clock defined by the     
2941      =2                                           ///< prescale field, SCA.                              
2942      =2  #define CKCON0_T0M__SYSCLK          0x04 ///< Counter/Timer 0 uses the system clock.            
2943      =2                                                                                                  
2944      =2  #define CKCON0_T1M__BMASK           0x08 ///< Timer 1 Clock Select                              
2945      =2  #define CKCON0_T1M__SHIFT           0x03 ///< Timer 1 Clock Select                              
2946      =2  #define CKCON0_T1M__PRESCALE        0x00 ///< Timer 1 uses the clock defined by the prescale    
2947      =2                                           ///< field, SCA.                                       
2948      =2  #define CKCON0_T1M__SYSCLK          0x08 ///< Timer 1 uses the system clock.                    
C51 COMPILER V9.56.0.0   UART_0                                                            10/28/2016 17:37:02 PAGE 75  

2949      =2                                                                                                  
2950      =2  #define CKCON0_T2ML__BMASK          0x10 ///< Timer 2 Low Byte Clock Select                     
2951      =2  #define CKCON0_T2ML__SHIFT          0x04 ///< Timer 2 Low Byte Clock Select                     
2952      =2  #define CKCON0_T2ML__EXTERNAL_CLOCK 0x00 ///< Timer 2 low byte uses the clock defined by T2XCLK 
2953      =2                                           ///< in TMR2CN0.                                       
2954      =2  #define CKCON0_T2ML__SYSCLK         0x10 ///< Timer 2 low byte uses the system clock.           
2955      =2                                                                                                  
2956      =2  #define CKCON0_T2MH__BMASK          0x20 ///< Timer 2 High Byte Clock Select                    
2957      =2  #define CKCON0_T2MH__SHIFT          0x05 ///< Timer 2 High Byte Clock Select                    
2958      =2  #define CKCON0_T2MH__EXTERNAL_CLOCK 0x00 ///< Timer 2 high byte uses the clock defined by T2XCLK
2959      =2                                           ///< in TMR2CN0.                                       
2960      =2  #define CKCON0_T2MH__SYSCLK         0x20 ///< Timer 2 high byte uses the system clock.          
2961      =2                                                                                                  
2962      =2  #define CKCON0_T3ML__BMASK          0x40 ///< Timer 3 Low Byte Clock Select                     
2963      =2  #define CKCON0_T3ML__SHIFT          0x06 ///< Timer 3 Low Byte Clock Select                     
2964      =2  #define CKCON0_T3ML__EXTERNAL_CLOCK 0x00 ///< Timer 3 low byte uses the clock defined by T3XCLK 
2965      =2                                           ///< in TMR3CN0.                                       
2966      =2  #define CKCON0_T3ML__SYSCLK         0x40 ///< Timer 3 low byte uses the system clock.           
2967      =2                                                                                                  
2968      =2  #define CKCON0_T3MH__BMASK          0x80 ///< Timer 3 High Byte Clock Select                    
2969      =2  #define CKCON0_T3MH__SHIFT          0x07 ///< Timer 3 High Byte Clock Select                    
2970      =2  #define CKCON0_T3MH__EXTERNAL_CLOCK 0x00 ///< Timer 3 high byte uses the clock defined by T3XCLK
2971      =2                                           ///< in TMR3CN0.                                       
2972      =2  #define CKCON0_T3MH__SYSCLK         0x80 ///< Timer 3 high byte uses the system clock.          
2973      =2                                                                                                  
2974      =2  //------------------------------------------------------------------------------
2975      =2  // CKCON1 Enums (Clock Control 1 @ 0xE4)
2976      =2  //------------------------------------------------------------------------------
2977      =2  #define CKCON1_T4ML__BMASK          0x01 ///< Timer 4 Low Byte Clock Select                     
2978      =2  #define CKCON1_T4ML__SHIFT          0x00 ///< Timer 4 Low Byte Clock Select                     
2979      =2  #define CKCON1_T4ML__EXTERNAL_CLOCK 0x00 ///< Timer 4 low byte uses the clock defined by T4XCLK 
2980      =2                                           ///< in TMR4CN0.                                       
2981      =2  #define CKCON1_T4ML__SYSCLK         0x01 ///< Timer 4 low byte uses the system clock.           
2982      =2                                                                                                  
2983      =2  #define CKCON1_T4MH__BMASK          0x02 ///< Timer 4 High Byte Clock Select                    
2984      =2  #define CKCON1_T4MH__SHIFT          0x01 ///< Timer 4 High Byte Clock Select                    
2985      =2  #define CKCON1_T4MH__EXTERNAL_CLOCK 0x00 ///< Timer 4 high byte uses the clock defined by T4XCLK
2986      =2                                           ///< in TMR4CN0.                                       
2987      =2  #define CKCON1_T4MH__SYSCLK         0x02 ///< Timer 4 high byte uses the system clock.          
2988      =2                                                                                                  
2989      =2  #define CKCON1_T5ML__BMASK          0x04 ///< Timer 5 Low Byte Clock Select                     
2990      =2  #define CKCON1_T5ML__SHIFT          0x02 ///< Timer 5 Low Byte Clock Select                     
2991      =2  #define CKCON1_T5ML__EXTERNAL_CLOCK 0x00 ///< Timer 5 low byte uses the clock defined by T5XCLK 
2992      =2                                           ///< in TMR5CN.                                        
2993      =2  #define CKCON1_T5ML__SYSCLK         0x04 ///< Timer 5 low byte uses the system clock.           
2994      =2                                                                                                  
2995      =2  #define CKCON1_T5MH__BMASK          0x08 ///< Timer 5 High Byte Clock Select                    
2996      =2  #define CKCON1_T5MH__SHIFT          0x03 ///< Timer 5 High Byte Clock Select                    
2997      =2  #define CKCON1_T5MH__EXTERNAL_CLOCK 0x00 ///< Timer 5 high byte uses the clock defined by T5XCLK
2998      =2                                           ///< in TMR5CN.                                        
2999      =2  #define CKCON1_T5MH__SYSCLK         0x08 ///< Timer 5 high byte uses the system clock.          
3000      =2                                                                                                  
3001      =2  //------------------------------------------------------------------------------
3002      =2  // TCON Enums (Timer 0/1 Control @ 0x88)
3003      =2  //------------------------------------------------------------------------------
3004      =2  #define TCON_IT0__BMASK   0x01 ///< Interrupt 0 Type Select  
3005      =2  #define TCON_IT0__SHIFT   0x00 ///< Interrupt 0 Type Select  
3006      =2  #define TCON_IT0__LEVEL   0x00 ///< INT0 is level triggered. 
3007      =2  #define TCON_IT0__EDGE    0x01 ///< INT0 is edge triggered.  
3008      =2                                                               
3009      =2  #define TCON_IE0__BMASK   0x02 ///< External Interrupt 0     
3010      =2  #define TCON_IE0__SHIFT   0x01 ///< External Interrupt 0     
C51 COMPILER V9.56.0.0   UART_0                                                            10/28/2016 17:37:02 PAGE 76  

3011      =2  #define TCON_IE0__NOT_SET 0x00 ///< Edge/level not detected. 
3012      =2  #define TCON_IE0__SET     0x02 ///< Edge/level detected      
3013      =2                                                               
3014      =2  #define TCON_IT1__BMASK   0x04 ///< Interrupt 1 Type Select  
3015      =2  #define TCON_IT1__SHIFT   0x02 ///< Interrupt 1 Type Select  
3016      =2  #define TCON_IT1__LEVEL   0x00 ///< INT1 is level triggered. 
3017      =2  #define TCON_IT1__EDGE    0x04 ///< INT1 is edge triggered.  
3018      =2                                                               
3019      =2  #define TCON_IE1__BMASK   0x08 ///< External Interrupt 1     
3020      =2  #define TCON_IE1__SHIFT   0x03 ///< External Interrupt 1     
3021      =2  #define TCON_IE1__NOT_SET 0x00 ///< Edge/level not detected. 
3022      =2  #define TCON_IE1__SET     0x08 ///< Edge/level detected      
3023      =2                                                               
3024      =2  #define TCON_TR0__BMASK   0x10 ///< Timer 0 Run Control      
3025      =2  #define TCON_TR0__SHIFT   0x04 ///< Timer 0 Run Control      
3026      =2  #define TCON_TR0__STOP    0x00 ///< Stop Timer 0.            
3027      =2  #define TCON_TR0__RUN     0x10 ///< Start Timer 0 running.   
3028      =2                                                               
3029      =2  #define TCON_TF0__BMASK   0x20 ///< Timer 0 Overflow Flag    
3030      =2  #define TCON_TF0__SHIFT   0x05 ///< Timer 0 Overflow Flag    
3031      =2  #define TCON_TF0__NOT_SET 0x00 ///< Timer 0 did not overflow.
3032      =2  #define TCON_TF0__SET     0x20 ///< Timer 0 overflowed.      
3033      =2                                                               
3034      =2  #define TCON_TR1__BMASK   0x40 ///< Timer 1 Run Control      
3035      =2  #define TCON_TR1__SHIFT   0x06 ///< Timer 1 Run Control      
3036      =2  #define TCON_TR1__STOP    0x00 ///< Stop Timer 1.            
3037      =2  #define TCON_TR1__RUN     0x40 ///< Start Timer 1 running.   
3038      =2                                                               
3039      =2  #define TCON_TF1__BMASK   0x80 ///< Timer 1 Overflow Flag    
3040      =2  #define TCON_TF1__SHIFT   0x07 ///< Timer 1 Overflow Flag    
3041      =2  #define TCON_TF1__NOT_SET 0x00 ///< Timer 1 did not overflow.
3042      =2  #define TCON_TF1__SET     0x80 ///< Timer 1 overflowed.      
3043      =2                                                               
3044      =2  //------------------------------------------------------------------------------
3045      =2  // TMOD Enums (Timer 0/1 Mode @ 0x89)
3046      =2  //------------------------------------------------------------------------------
3047      =2  #define TMOD_T0M__FMASK      0x03 ///< Timer 0 Mode Select                               
3048      =2  #define TMOD_T0M__SHIFT      0x00 ///< Timer 0 Mode Select                               
3049      =2  #define TMOD_T0M__MODE0      0x00 ///< Mode 0, 13-bit Counter/Timer                      
3050      =2  #define TMOD_T0M__MODE1      0x01 ///< Mode 1, 16-bit Counter/Timer                      
3051      =2  #define TMOD_T0M__MODE2      0x02 ///< Mode 2, 8-bit Counter/Timer with Auto-Reload      
3052      =2  #define TMOD_T0M__MODE3      0x03 ///< Mode 3, Two 8-bit Counter/Timers                  
3053      =2                                                                                           
3054      =2  #define TMOD_CT0__BMASK      0x04 ///< Counter/Timer 0 Select                            
3055      =2  #define TMOD_CT0__SHIFT      0x02 ///< Counter/Timer 0 Select                            
3056      =2  #define TMOD_CT0__TIMER      0x00 ///< Timer Mode. Timer 0 increments on the clock       
3057      =2                                    ///< defined by T0M in the CKCON0 register.            
3058      =2  #define TMOD_CT0__COUNTER    0x04 ///< Counter Mode. Timer 0 increments on high-to-low   
3059      =2                                    ///< transitions of an external pin (T0).              
3060      =2                                                                                           
3061      =2  #define TMOD_GATE0__BMASK    0x08 ///< Timer 0 Gate Control                              
3062      =2  #define TMOD_GATE0__SHIFT    0x03 ///< Timer 0 Gate Control                              
3063      =2  #define TMOD_GATE0__DISABLED 0x00 ///< Timer 0 enabled when TR0 = 1 irrespective of INT0 
3064      =2                                    ///< logic level.                                      
3065      =2  #define TMOD_GATE0__ENABLED  0x08 ///< Timer 0 enabled only when TR0 = 1 and INT0 is     
3066      =2                                    ///< active as defined by bit IN0PL in register IT01CF.
3067      =2                                                                                           
3068      =2  #define TMOD_T1M__FMASK      0x30 ///< Timer 1 Mode Select                               
3069      =2  #define TMOD_T1M__SHIFT      0x04 ///< Timer 1 Mode Select                               
3070      =2  #define TMOD_T1M__MODE0      0x00 ///< Mode 0, 13-bit Counter/Timer                      
3071      =2  #define TMOD_T1M__MODE1      0x10 ///< Mode 1, 16-bit Counter/Timer                      
3072      =2  #define TMOD_T1M__MODE2      0x20 ///< Mode 2, 8-bit Counter/Timer with Auto-Reload      
C51 COMPILER V9.56.0.0   UART_0                                                            10/28/2016 17:37:02 PAGE 77  

3073      =2  #define TMOD_T1M__MODE3      0x30 ///< Mode 3, Timer 1 Inactive                          
3074      =2                                                                                           
3075      =2  #define TMOD_CT1__BMASK      0x40 ///< Counter/Timer 1 Select                            
3076      =2  #define TMOD_CT1__SHIFT      0x06 ///< Counter/Timer 1 Select                            
3077      =2  #define TMOD_CT1__TIMER      0x00 ///< Timer Mode. Timer 1 increments on the clock       
3078      =2                                    ///< defined by T1M in the CKCON0 register.            
3079      =2  #define TMOD_CT1__COUNTER    0x40 ///< Counter Mode. Timer 1 increments on high-to-low   
3080      =2                                    ///< transitions of an external pin (T1).              
3081      =2                                                                                           
3082      =2  #define TMOD_GATE1__BMASK    0x80 ///< Timer 1 Gate Control                              
3083      =2  #define TMOD_GATE1__SHIFT    0x07 ///< Timer 1 Gate Control                              
3084      =2  #define TMOD_GATE1__DISABLED 0x00 ///< Timer 1 enabled when TR1 = 1 irrespective of INT1 
3085      =2                                    ///< logic level.                                      
3086      =2  #define TMOD_GATE1__ENABLED  0x80 ///< Timer 1 enabled only when TR1 = 1 and INT1 is     
3087      =2                                    ///< active as defined by bit IN1PL in register IT01CF.
3088      =2                                                                                           
3089      =2  //------------------------------------------------------------------------------
3090      =2  // SBCON1 Enums (UART1 Baud Rate Generator Control @ 0xAC)
3091      =2  //------------------------------------------------------------------------------
3092      =2  #define SBCON1_BPS__FMASK     0x03 ///< Baud Rate Prescaler Select                     
3093      =2  #define SBCON1_BPS__SHIFT     0x00 ///< Baud Rate Prescaler Select                     
3094      =2  #define SBCON1_BPS__DIV_BY_12 0x00 ///< Prescaler = 12.                                
3095      =2  #define SBCON1_BPS__DIV_BY_4  0x01 ///< Prescaler = 4.                                 
3096      =2  #define SBCON1_BPS__DIV_BY_48 0x02 ///< Prescaler = 48.                                
3097      =2  #define SBCON1_BPS__DIV_BY_1  0x03 ///< Prescaler = 1.                                 
3098      =2                                                                                         
3099      =2  #define SBCON1_BREN__BMASK    0x40 ///< Baud Rate Generator Enable                     
3100      =2  #define SBCON1_BREN__SHIFT    0x06 ///< Baud Rate Generator Enable                     
3101      =2  #define SBCON1_BREN__DISABLED 0x00 ///< Disable the baud rate generator. UART1 will not
3102      =2                                     ///< function.                                      
3103      =2  #define SBCON1_BREN__ENABLED  0x40 ///< Enable the baud rate generator.                
3104      =2                                                                                         
3105      =2  //------------------------------------------------------------------------------
3106      =2  // SBRLH1 Enums (UART1 Baud Rate Generator High Byte @ 0xB5)
3107      =2  //------------------------------------------------------------------------------
3108      =2  #define SBRLH1_BRH__FMASK 0xFF ///< UART1 Baud Rate Reload High
3109      =2  #define SBRLH1_BRH__SHIFT 0x00 ///< UART1 Baud Rate Reload High
3110      =2                                                                 
3111      =2  //------------------------------------------------------------------------------
3112      =2  // SBRLL1 Enums (UART1 Baud Rate Generator Low Byte @ 0xB4)
3113      =2  //------------------------------------------------------------------------------
3114      =2  #define SBRLL1_BRL__FMASK 0xFF ///< UART1 Baud Rate Reload Low
3115      =2  #define SBRLL1_BRL__SHIFT 0x00 ///< UART1 Baud Rate Reload Low
3116      =2                                                                
3117      =2  //------------------------------------------------------------------------------
3118      =2  // SBUF1 Enums (UART1 Serial Port Data Buffer @ 0xD3)
3119      =2  //------------------------------------------------------------------------------
3120      =2  #define SBUF1_SBUF1__FMASK 0xFF ///< Serial Port Data Buffer
3121      =2  #define SBUF1_SBUF1__SHIFT 0x00 ///< Serial Port Data Buffer
3122      =2                                                              
3123      =2  //------------------------------------------------------------------------------
3124      =2  // SCON1 Enums (UART1 Serial Port Control @ 0xD2)
3125      =2  //------------------------------------------------------------------------------
3126      =2  #define SCON1_RI__BMASK             0x01 ///< Receive Interrupt Flag                           
3127      =2  #define SCON1_RI__SHIFT             0x00 ///< Receive Interrupt Flag                           
3128      =2  #define SCON1_RI__NOT_SET           0x00 ///< New data has not been received by UART1.         
3129      =2  #define SCON1_RI__SET               0x01 ///< UART1 received one or more data bytes.           
3130      =2                                                                                                 
3131      =2  #define SCON1_TI__BMASK             0x02 ///< Transmit Interrupt Flag                          
3132      =2  #define SCON1_TI__SHIFT             0x01 ///< Transmit Interrupt Flag                          
3133      =2  #define SCON1_TI__NOT_SET           0x00 ///< A byte of data has not been transmitted by UART1.
3134      =2  #define SCON1_TI__SET               0x02 ///< UART1 transmitted a byte of data.                
C51 COMPILER V9.56.0.0   UART_0                                                            10/28/2016 17:37:02 PAGE 78  

3135      =2                                                                                                 
3136      =2  #define SCON1_RBX__BMASK            0x04 ///< Extra Receive Bit                                
3137      =2  #define SCON1_RBX__SHIFT            0x02 ///< Extra Receive Bit                                
3138      =2  #define SCON1_RBX__LOW              0x00 ///< The extra bit or the first stop bit is 0.        
3139      =2  #define SCON1_RBX__HIGH             0x04 ///< The extra bit or the first stop bit is 1.        
3140      =2                                                                                                 
3141      =2  #define SCON1_TBX__BMASK            0x08 ///< Extra Transmission Bit                           
3142      =2  #define SCON1_TBX__SHIFT            0x03 ///< Extra Transmission Bit                           
3143      =2  #define SCON1_TBX__LOW              0x00 ///< Set extra bit to 0 (low).                        
3144      =2  #define SCON1_TBX__HIGH             0x08 ///< Set extra bit to 1 (high).                       
3145      =2                                                                                                 
3146      =2  #define SCON1_REN__BMASK            0x10 ///< Receive Enable                                   
3147      =2  #define SCON1_REN__SHIFT            0x04 ///< Receive Enable                                   
3148      =2  #define SCON1_REN__RECEIVE_DISABLED 0x00 ///< UART1 reception disabled.                        
3149      =2  #define SCON1_REN__RECEIVE_ENABLED  0x10 ///< UART1 reception enabled.                         
3150      =2                                                                                                 
3151      =2  #define SCON1_PERR__BMASK           0x40 ///< Parity Error Flag                                
3152      =2  #define SCON1_PERR__SHIFT           0x06 ///< Parity Error Flag                                
3153      =2  #define SCON1_PERR__NOT_SET         0x00 ///< Parity error has not occurred.                   
3154      =2  #define SCON1_PERR__SET             0x40 ///< Parity error has occurred.                       
3155      =2                                                                                                 
3156      =2  #define SCON1_OVR__BMASK            0x80 ///< Receive FIFO Overrun Flag                        
3157      =2  #define SCON1_OVR__SHIFT            0x07 ///< Receive FIFO Overrun Flag                        
3158      =2  #define SCON1_OVR__NOT_SET          0x00 ///< Receive FIFO overrun has not occurred.           
3159      =2  #define SCON1_OVR__SET              0x80 ///< Receive FIFO overrun has occurred.               
3160      =2                                                                                                 
3161      =2  //------------------------------------------------------------------------------
3162      =2  // SMOD1 Enums (UART1 Mode @ 0xE5)
3163      =2  //------------------------------------------------------------------------------
3164      =2  #define SMOD1_SBL__BMASK          0x01 ///< Stop Bit Length                                 
3165      =2  #define SMOD1_SBL__SHIFT          0x00 ///< Stop Bit Length                                 
3166      =2  #define SMOD1_SBL__SHORT          0x00 ///< Short: Stop bit is active for one bit time.     
3167      =2  #define SMOD1_SBL__LONG           0x01 ///< Long: Stop bit is active for two bit times (data
3168      =2                                         ///< length = 6, 7, or 8 bits) or 1.5 bit times (data
3169      =2                                         ///< length = 5 bits).                               
3170      =2                                                                                              
3171      =2  #define SMOD1_XBE__BMASK          0x02 ///< Extra Bit Enable                                
3172      =2  #define SMOD1_XBE__SHIFT          0x01 ///< Extra Bit Enable                                
3173      =2  #define SMOD1_XBE__DISABLED       0x00 ///< Disable the extra bit.                          
3174      =2  #define SMOD1_XBE__ENABLED        0x02 ///< Enable the extra bit.                           
3175      =2                                                                                              
3176      =2  #define SMOD1_SDL__FMASK          0x0C ///< Data Length                                     
3177      =2  #define SMOD1_SDL__SHIFT          0x02 ///< Data Length                                     
3178      =2  #define SMOD1_SDL__5_BITS         0x00 ///< 5 bits.                                         
3179      =2  #define SMOD1_SDL__6_BITS         0x04 ///< 6 bits.                                         
3180      =2  #define SMOD1_SDL__7_BITS         0x08 ///< 7 bits.                                         
3181      =2  #define SMOD1_SDL__8_BITS         0x0C ///< 8 bits.                                         
3182      =2                                                                                              
3183      =2  #define SMOD1_PE__BMASK           0x10 ///< Parity Enable                                   
3184      =2  #define SMOD1_PE__SHIFT           0x04 ///< Parity Enable                                   
3185      =2  #define SMOD1_PE__PARITY_DISABLED 0x00 ///< Disable hardware parity.                        
3186      =2  #define SMOD1_PE__PARITY_ENABLED  0x10 ///< Enable hardware parity.                         
3187      =2                                                                                              
3188      =2  #define SMOD1_SPT__FMASK          0x60 ///< Parity Type                                     
3189      =2  #define SMOD1_SPT__SHIFT          0x05 ///< Parity Type                                     
3190      =2  #define SMOD1_SPT__ODD_PARITY     0x00 ///< Odd.                                            
3191      =2  #define SMOD1_SPT__EVEN_PARITY    0x20 ///< Even.                                           
3192      =2  #define SMOD1_SPT__MARK_PARITY    0x40 ///< Mark.                                           
3193      =2  #define SMOD1_SPT__SPACE_PARITY   0x60 ///< Space.                                          
3194      =2                                                                                              
3195      =2  #define SMOD1_MCE__BMASK          0x80 ///< Multiprocessor Communication Enable             
3196      =2  #define SMOD1_MCE__SHIFT          0x07 ///< Multiprocessor Communication Enable             
C51 COMPILER V9.56.0.0   UART_0                                                            10/28/2016 17:37:02 PAGE 79  

3197      =2  #define SMOD1_MCE__MULTI_DISABLED 0x00 ///< RI will be activated if the stop bits are 1.    
3198      =2  #define SMOD1_MCE__MULTI_ENABLED  0x80 ///< RI will be activated if the stop bits and extra 
3199      =2                                         ///< bit are 1. The extra bit must be enabled using  
3200      =2                                         ///< XBE.                                            
3201      =2                                                                                              
3202      =2  //------------------------------------------------------------------------------
3203      =2  // SBUF0 Enums (UART0 Serial Port Data Buffer @ 0x99)
3204      =2  //------------------------------------------------------------------------------
3205      =2  #define SBUF0_SBUF0__FMASK 0xFF ///< Serial Data Buffer
3206      =2  #define SBUF0_SBUF0__SHIFT 0x00 ///< Serial Data Buffer
3207      =2                                                         
3208      =2  //------------------------------------------------------------------------------
3209      =2  // SCON0 Enums (UART0 Serial Port Control @ 0x98)
3210      =2  //------------------------------------------------------------------------------
3211      =2  #define SCON0_RI__BMASK             0x01 ///< Receive Interrupt Flag                           
3212      =2  #define SCON0_RI__SHIFT             0x00 ///< Receive Interrupt Flag                           
3213      =2  #define SCON0_RI__NOT_SET           0x00 ///< A byte of data has not been received by UART0.   
3214      =2  #define SCON0_RI__SET               0x01 ///< UART0 received a byte of data.                   
3215      =2                                                                                                 
3216      =2  #define SCON0_TI__BMASK             0x02 ///< Transmit Interrupt Flag                          
3217      =2  #define SCON0_TI__SHIFT             0x01 ///< Transmit Interrupt Flag                          
3218      =2  #define SCON0_TI__NOT_SET           0x00 ///< A byte of data has not been transmitted by UART0.
3219      =2  #define SCON0_TI__SET               0x02 ///< UART0 transmitted a byte of data.                
3220      =2                                                                                                 
3221      =2  #define SCON0_RB8__BMASK            0x04 ///< Ninth Receive Bit                                
3222      =2  #define SCON0_RB8__SHIFT            0x02 ///< Ninth Receive Bit                                
3223      =2  #define SCON0_RB8__CLEARED_TO_0     0x00 ///< In Mode 0, the STOP bit was 0. In Mode 1, the 9th
3224      =2                                           ///< bit was 0.                                       
3225      =2  #define SCON0_RB8__SET_TO_1         0x04 ///< In Mode 0, the STOP bit was 1. In Mode 1, the 9th
3226      =2                                           ///< bit was 1.                                       
3227      =2                                                                                                 
3228      =2  #define SCON0_TB8__BMASK            0x08 ///< Ninth Transmission Bit                           
3229      =2  #define SCON0_TB8__SHIFT            0x03 ///< Ninth Transmission Bit                           
3230      =2  #define SCON0_TB8__CLEARED_TO_0     0x00 ///< In Mode 1, set the 9th transmission bit to 0.    
3231      =2  #define SCON0_TB8__SET_TO_1         0x08 ///< In Mode 1, set the 9th transmission bit to 1.    
3232      =2                                                                                                 
3233      =2  #define SCON0_REN__BMASK            0x10 ///< Receive Enable                                   
3234      =2  #define SCON0_REN__SHIFT            0x04 ///< Receive Enable                                   
3235      =2  #define SCON0_REN__RECEIVE_DISABLED 0x00 ///< UART0 reception disabled.                        
3236      =2  #define SCON0_REN__RECEIVE_ENABLED  0x10 ///< UART0 reception enabled.                         
3237      =2                                                                                                 
3238      =2  #define SCON0_MCE__BMASK            0x20 ///< Multiprocessor Communication Enable              
3239      =2  #define SCON0_MCE__SHIFT            0x05 ///< Multiprocessor Communication Enable              
3240      =2  #define SCON0_MCE__MULTI_DISABLED   0x00 ///< Ignore level of 9th bit / Stop bit.              
3241      =2  #define SCON0_MCE__MULTI_ENABLED    0x20 ///< RI is set and an interrupt is generated only when
3242      =2                                           ///< the stop bit is logic 1 (Mode 0) or when the 9th 
3243      =2                                           ///< bit is logic 1 (Mode 1).                         
3244      =2                                                                                                 
3245      =2  #define SCON0_SMODE__BMASK          0x80 ///< Serial Port 0 Operation Mode                     
3246      =2  #define SCON0_SMODE__SHIFT          0x07 ///< Serial Port 0 Operation Mode                     
3247      =2  #define SCON0_SMODE__8_BIT          0x00 ///< 8-bit UART with Variable Baud Rate (Mode 0).     
3248      =2  #define SCON0_SMODE__9_BIT          0x80 ///< 9-bit UART with Variable Baud Rate (Mode 1).     
3249      =2                                                                                                 
3250      =2  //------------------------------------------------------------------------------
3251      =2  // CLKREC Enums (USB0 Clock Recovery Control @ 0x0F)
3252      =2  //------------------------------------------------------------------------------
3253      =2  #define CLKREC_CRLOW__BMASK      0x20 ///< Low Speed Clock Recovery Mode               
3254      =2  #define CLKREC_CRLOW__SHIFT      0x05 ///< Low Speed Clock Recovery Mode               
3255      =2  #define CLKREC_CRLOW__FULL_SPEED 0x00 ///< Full Speed Mode.                            
3256      =2  #define CLKREC_CRLOW__LOW_SPEED  0x20 ///< Low Speed Mode.                             
3257      =2                                                                                         
3258      =2  #define CLKREC_CRSSEN__BMASK     0x40 ///< Clock Recovery Single Step                  
C51 COMPILER V9.56.0.0   UART_0                                                            10/28/2016 17:37:02 PAGE 80  

3259      =2  #define CLKREC_CRSSEN__SHIFT     0x06 ///< Clock Recovery Single Step                  
3260      =2  #define CLKREC_CRSSEN__DISABLED  0x00 ///< Disable single-step mode (normal calibration
3261      =2                                        ///< mode).                                      
3262      =2  #define CLKREC_CRSSEN__ENABLED   0x40 ///< Enable single-step mode.                    
3263      =2                                                                                         
3264      =2  #define CLKREC_CRE__BMASK        0x80 ///< Clock Recovery Enable                       
3265      =2  #define CLKREC_CRE__SHIFT        0x07 ///< Clock Recovery Enable                       
3266      =2  #define CLKREC_CRE__DISABLED     0x00 ///< Disable clock recovery.                     
3267      =2  #define CLKREC_CRE__ENABLED      0x80 ///< Enable clock recovery.                      
3268      =2                                                                                         
3269      =2  //------------------------------------------------------------------------------
3270      =2  // CMIE Enums (USB0 Common Interrupt Enable @ 0x0B)
3271      =2  //------------------------------------------------------------------------------
3272      =2  #define CMIE_SUSINTE__BMASK    0x01 ///< Suspend Interrupt Enable       
3273      =2  #define CMIE_SUSINTE__SHIFT    0x00 ///< Suspend Interrupt Enable       
3274      =2  #define CMIE_SUSINTE__DISABLED 0x00 ///< Disable suspend interrupts.    
3275      =2  #define CMIE_SUSINTE__ENABLED  0x01 ///< Enable suspend interrupts.     
3276      =2                                                                          
3277      =2  #define CMIE_RSUINTE__BMASK    0x02 ///< Resume Interrupt Enable        
3278      =2  #define CMIE_RSUINTE__SHIFT    0x01 ///< Resume Interrupt Enable        
3279      =2  #define CMIE_RSUINTE__DISABLED 0x00 ///< Disable resume interrupts.     
3280      =2  #define CMIE_RSUINTE__ENABLED  0x02 ///< Enable resume interrupts.      
3281      =2                                                                          
3282      =2  #define CMIE_RSTINTE__BMASK    0x04 ///< Reset Interrupt Enable         
3283      =2  #define CMIE_RSTINTE__SHIFT    0x02 ///< Reset Interrupt Enable         
3284      =2  #define CMIE_RSTINTE__DISABLED 0x00 ///< Disable reset interrupts.      
3285      =2  #define CMIE_RSTINTE__ENABLED  0x04 ///< Enable reset interrupts.       
3286      =2                                                                          
3287      =2  #define CMIE_SOFE__BMASK       0x08 ///< Start of Frame Interrupt Enable
3288      =2  #define CMIE_SOFE__SHIFT       0x03 ///< Start of Frame Interrupt Enable
3289      =2  #define CMIE_SOFE__DISABLED    0x00 ///< Disable SOF interrupts.        
3290      =2  #define CMIE_SOFE__ENABLED     0x08 ///< Enable SOF interrupts.         
3291      =2                                                                          
3292      =2  //------------------------------------------------------------------------------
3293      =2  // CMINT Enums (USB0 Common Interrupt @ 0x06)
3294      =2  //------------------------------------------------------------------------------
3295      =2  #define CMINT_SUSINT__BMASK   0x01 ///< Suspend Interrupt Flag       
3296      =2  #define CMINT_SUSINT__SHIFT   0x00 ///< Suspend Interrupt Flag       
3297      =2  #define CMINT_SUSINT__NOT_SET 0x00 ///< Suspend interrupt inactive.  
3298      =2  #define CMINT_SUSINT__SET     0x01 ///< Suspend interrupt active.    
3299      =2                                                                       
3300      =2  #define CMINT_RSUINT__BMASK   0x02 ///< Resume Interrupt Flag        
3301      =2  #define CMINT_RSUINT__SHIFT   0x01 ///< Resume Interrupt Flag        
3302      =2  #define CMINT_RSUINT__NOT_SET 0x00 ///< Resume interrupt inactive.   
3303      =2  #define CMINT_RSUINT__SET     0x02 ///< Resume interrupt active.     
3304      =2                                                                       
3305      =2  #define CMINT_RSTINT__BMASK   0x04 ///< Reset Interrupt Flag         
3306      =2  #define CMINT_RSTINT__SHIFT   0x02 ///< Reset Interrupt Flag         
3307      =2  #define CMINT_RSTINT__NOT_SET 0x00 ///< Reset interrupt inactive.    
3308      =2  #define CMINT_RSTINT__SET     0x04 ///< Reset interrupt active.      
3309      =2                                                                       
3310      =2  #define CMINT_SOF__BMASK      0x08 ///< Start of Frame Interrupt Flag
3311      =2  #define CMINT_SOF__SHIFT      0x03 ///< Start of Frame Interrupt Flag
3312      =2  #define CMINT_SOF__NOT_SET    0x00 ///< SOF interrupt inactive.      
3313      =2  #define CMINT_SOF__SET        0x08 ///< SOF interrupt active.        
3314      =2                                                                       
3315      =2  //------------------------------------------------------------------------------
3316      =2  // E0CNT Enums (USB0 Endpoint0 Data Count @ 0x16)
3317      =2  //------------------------------------------------------------------------------
3318      =2  #define E0CNT_E0CNT__FMASK 0x7F ///< Endpoint 0 Data Count
3319      =2  #define E0CNT_E0CNT__SHIFT 0x00 ///< Endpoint 0 Data Count
3320      =2                                                            
C51 COMPILER V9.56.0.0   UART_0                                                            10/28/2016 17:37:02 PAGE 81  

3321      =2  //------------------------------------------------------------------------------
3322      =2  // E0CSR Enums (USB0 Endpoint0 Control @ 0x11)
3323      =2  //------------------------------------------------------------------------------
3324      =2  #define E0CSR_OPRDY__BMASK     0x01 ///< OUT Packet Ready                                  
3325      =2  #define E0CSR_OPRDY__SHIFT     0x00 ///< OUT Packet Ready                                  
3326      =2  #define E0CSR_OPRDY__NOT_SET   0x00 ///< A data packet has not been received.              
3327      =2  #define E0CSR_OPRDY__SET       0x01 ///< A data packet has been received.                  
3328      =2                                                                                             
3329      =2  #define E0CSR_INPRDY__BMASK    0x02 ///< IN Packet Ready                                   
3330      =2  #define E0CSR_INPRDY__SHIFT    0x01 ///< IN Packet Ready                                   
3331      =2  #define E0CSR_INPRDY__NOT_SET  0x00 ///< An IN packet is not ready to transmit.            
3332      =2  #define E0CSR_INPRDY__SET      0x02 ///< An IN packet is ready to transmit.                
3333      =2                                                                                             
3334      =2  #define E0CSR_STSTL__BMASK     0x04 ///< Sent Stall                                        
3335      =2  #define E0CSR_STSTL__SHIFT     0x02 ///< Sent Stall                                        
3336      =2  #define E0CSR_STSTL__NOT_SET   0x00 ///< A STALL handshake signal was not transmitted.     
3337      =2  #define E0CSR_STSTL__SET       0x04 ///< A STALL handshake signal was transmitted.         
3338      =2                                                                                             
3339      =2  #define E0CSR_DATAEND__BMASK   0x08 ///< Data End                                          
3340      =2  #define E0CSR_DATAEND__SHIFT   0x03 ///< Data End                                          
3341      =2  #define E0CSR_DATAEND__NOT_SET 0x00 ///< This is not the last data packet.                 
3342      =2  #define E0CSR_DATAEND__SET     0x08 ///< This is the last data packet.                     
3343      =2                                                                                             
3344      =2  #define E0CSR_SUEND__BMASK     0x10 ///< Setup End                                         
3345      =2  #define E0CSR_SUEND__SHIFT     0x04 ///< Setup End                                         
3346      =2  #define E0CSR_SUEND__NOT_SET   0x00 ///< A control transaction did not end before firmware 
3347      =2                                      ///< wrote a 1 to the DATAEND bit.                     
3348      =2  #define E0CSR_SUEND__SET       0x10 ///< A control transaction ended before firmware wrote 
3349      =2                                      ///< a 1 to the DATAEND bit.                           
3350      =2                                                                                             
3351      =2  #define E0CSR_SDSTL__BMASK     0x20 ///< Send Stall                                        
3352      =2  #define E0CSR_SDSTL__SHIFT     0x05 ///< Send Stall                                        
3353      =2  #define E0CSR_SDSTL__NOT_SET   0x00 ///< Do not send a STALL.                              
3354      =2  #define E0CSR_SDSTL__SET       0x20 ///< Send a STALL.                                     
3355      =2                                                                                             
3356      =2  #define E0CSR_SOPRDY__BMASK    0x40 ///< Serviced OPRDY                                    
3357      =2  #define E0CSR_SOPRDY__SHIFT    0x06 ///< Serviced OPRDY                                    
3358      =2  #define E0CSR_SOPRDY__NOT_SET  0x00 ///< OUT packet has not been serviced.                 
3359      =2  #define E0CSR_SOPRDY__SET      0x40 ///< OUT packet has been serviced.                     
3360      =2                                                                                             
3361      =2  #define E0CSR_SSUEND__BMASK    0x80 ///< Serviced Setup End                                
3362      =2  #define E0CSR_SSUEND__SHIFT    0x07 ///< Serviced Setup End                                
3363      =2  #define E0CSR_SSUEND__NOT_SET  0x00 ///< The setup end (SUEND) event has not been serviced.
3364      =2  #define E0CSR_SSUEND__SET      0x80 ///< The setup end (SUEND) event has been serviced.    
3365      =2                                                                                             
3366      =2  //------------------------------------------------------------------------------
3367      =2  // EENABLE Enums (USB0 Endpoint Enable @ 0x1E)
3368      =2  //------------------------------------------------------------------------------
3369      =2  #define EENABLE_EEN1__BMASK    0x02 ///< Endpoint 1 Enable                                
3370      =2  #define EENABLE_EEN1__SHIFT    0x01 ///< Endpoint 1 Enable                                
3371      =2  #define EENABLE_EEN1__DISABLED 0x00 ///< Disable Endpoint 1 (no NACK, ACK, or STALL on the
3372      =2                                      ///< USB network).                                    
3373      =2  #define EENABLE_EEN1__ENABLED  0x02 ///< Enable Endpoint 1 (normal).                      
3374      =2                                                                                            
3375      =2  #define EENABLE_EEN2__BMASK    0x04 ///< Endpoint 2 Enable                                
3376      =2  #define EENABLE_EEN2__SHIFT    0x02 ///< Endpoint 2 Enable                                
3377      =2  #define EENABLE_EEN2__DISABLED 0x00 ///< Disable Endpoint 2 (no NACK, ACK, or STALL on the
3378      =2                                      ///< USB network).                                    
3379      =2  #define EENABLE_EEN2__ENABLED  0x04 ///< Enable Endpoint 2 (normal).                      
3380      =2                                                                                            
3381      =2  #define EENABLE_EEN3__BMASK    0x08 ///< Endpoint 3 Enable                                
3382      =2  #define EENABLE_EEN3__SHIFT    0x03 ///< Endpoint 3 Enable                                
C51 COMPILER V9.56.0.0   UART_0                                                            10/28/2016 17:37:02 PAGE 82  

3383      =2  #define EENABLE_EEN3__DISABLED 0x00 ///< Disable Endpoint 3 (no NACK, ACK, or STALL on the
3384      =2                                      ///< USB network).                                    
3385      =2  #define EENABLE_EEN3__ENABLED  0x08 ///< Enable Endpoint 3 (normal).                      
3386      =2                                                                                            
3387      =2  //------------------------------------------------------------------------------
3388      =2  // EINCSRH Enums (USB0 IN Endpoint Control High @ 0x12)
3389      =2  //------------------------------------------------------------------------------
3390      =2  #define EINCSRH_SPLIT__BMASK        0x04 ///< FIFO Split Enable                                
3391      =2  #define EINCSRH_SPLIT__SHIFT        0x02 ///< FIFO Split Enable                                
3392      =2  #define EINCSRH_SPLIT__DISABLED     0x00 ///< Disable split mode.                              
3393      =2  #define EINCSRH_SPLIT__ENABLED      0x04 ///< Enable split mode.                               
3394      =2                                                                                                 
3395      =2  #define EINCSRH_FCDT__BMASK         0x08 ///< Force Data Toggle                                
3396      =2  #define EINCSRH_FCDT__SHIFT         0x03 ///< Force Data Toggle                                
3397      =2  #define EINCSRH_FCDT__ACK_TOGGLE    0x00 ///< Endpoint data toggle switches only when an ACK is
3398      =2                                           ///< received following a data packet transmission.   
3399      =2  #define EINCSRH_FCDT__ALWAYS_TOGGLE 0x08 ///< Endpoint data toggle forced to switch after every
3400      =2                                           ///< data packet is transmitted, regardless of ACK    
3401      =2                                           ///< reception.                                       
3402      =2                                                                                                 
3403      =2  #define EINCSRH_DIRSEL__BMASK       0x20 ///< Endpoint Direction Select                        
3404      =2  #define EINCSRH_DIRSEL__SHIFT       0x05 ///< Endpoint Direction Select                        
3405      =2  #define EINCSRH_DIRSEL__OUT         0x00 ///< Endpoint direction selected as OUT.              
3406      =2  #define EINCSRH_DIRSEL__IN          0x20 ///< Endpoint direction selected as IN.               
3407      =2                                                                                                 
3408      =2  #define EINCSRH_ISO__BMASK          0x40 ///< Isochronous Transfer Enable                      
3409      =2  #define EINCSRH_ISO__SHIFT          0x06 ///< Isochronous Transfer Enable                      
3410      =2  #define EINCSRH_ISO__DISABLED       0x00 ///< Endpoint configured for Bulk/Interrupt transfers.
3411      =2  #define EINCSRH_ISO__ENABLED        0x40 ///< Endpoint configured for Isochronous transfers.   
3412      =2                                                                                                 
3413      =2  #define EINCSRH_DBIEN__BMASK        0x80 ///< IN Endpoint Double-Buffer Enable                 
3414      =2  #define EINCSRH_DBIEN__SHIFT        0x07 ///< IN Endpoint Double-Buffer Enable                 
3415      =2  #define EINCSRH_DBIEN__DISABLED     0x00 ///< Disable double-buffering for the selected IN     
3416      =2                                           ///< endpoint.                                        
3417      =2  #define EINCSRH_DBIEN__ENABLED      0x80 ///< Enable double-buffering for the selected IN      
3418      =2                                           ///< endpoint.                                        
3419      =2                                                                                                 
3420      =2  //------------------------------------------------------------------------------
3421      =2  // EINCSRL Enums (USB0 IN Endpoint Control Low @ 0x11)
3422      =2  //------------------------------------------------------------------------------
3423      =2  #define EINCSRL_INPRDY__BMASK     0x01 ///< In Packet Ready                                   
3424      =2  #define EINCSRL_INPRDY__SHIFT     0x00 ///< In Packet Ready                                   
3425      =2  #define EINCSRL_INPRDY__NOT_SET   0x00 ///< A packet is not available in the Endpoint IN FIFO.
3426      =2  #define EINCSRL_INPRDY__SET       0x01 ///< A packet is available in the Endpoint IN FIFO.    
3427      =2                                                                                                
3428      =2  #define EINCSRL_FIFONE__BMASK     0x02 ///< FIFO Not Empty                                    
3429      =2  #define EINCSRL_FIFONE__SHIFT     0x01 ///< FIFO Not Empty                                    
3430      =2  #define EINCSRL_FIFONE__EMPTY     0x00 ///< The IN Endpoint FIFO is empty.                    
3431      =2  #define EINCSRL_FIFONE__NOT_EMPTY 0x02 ///< The IN Endpoint FIFO contains one or more packets.
3432      =2                                                                                                
3433      =2  #define EINCSRL_UNDRUN__BMASK     0x04 ///< Data Underrun Flag                                
3434      =2  #define EINCSRL_UNDRUN__SHIFT     0x02 ///< Data Underrun Flag                                
3435      =2  #define EINCSRL_UNDRUN__NOT_SET   0x00 ///< A data underrun did not occur.                    
3436      =2  #define EINCSRL_UNDRUN__SET       0x04 ///< A data underrun occurred.                         
3437      =2                                                                                                
3438      =2  #define EINCSRL_FLUSH__BMASK      0x08 ///< FIFO Flush                                        
3439      =2  #define EINCSRL_FLUSH__SHIFT      0x03 ///< FIFO Flush                                        
3440      =2  #define EINCSRL_FLUSH__NOT_SET    0x00 ///< Do not flush the next packet.                     
3441      =2  #define EINCSRL_FLUSH__SET        0x08 ///< Flush the next packet to be transmitted from the  
3442      =2                                         ///< IN Endpoint FIFO.                                 
3443      =2                                                                                                
3444      =2  #define EINCSRL_SDSTL__BMASK      0x10 ///< Send Stall                                        
C51 COMPILER V9.56.0.0   UART_0                                                            10/28/2016 17:37:02 PAGE 83  

3445      =2  #define EINCSRL_SDSTL__SHIFT      0x04 ///< Send Stall                                        
3446      =2  #define EINCSRL_SDSTL__NOT_SET    0x00 ///< Terminate the STALL.                              
3447      =2  #define EINCSRL_SDSTL__SET        0x10 ///< Generate a STALL in response to an IN token.      
3448      =2                                                                                                
3449      =2  #define EINCSRL_STSTL__BMASK      0x20 ///< Sent Stall Flag                                   
3450      =2  #define EINCSRL_STSTL__SHIFT      0x05 ///< Sent Stall Flag                                   
3451      =2  #define EINCSRL_STSTL__NOT_SET    0x00 ///< A STALL handshake was not transmitted.            
3452      =2  #define EINCSRL_STSTL__SET        0x20 ///< A STALL handshake was transmitted.                
3453      =2                                                                                                
3454      =2  #define EINCSRL_CLRDT__BMASK      0x40 ///< Clear Data Toggle                                 
3455      =2  #define EINCSRL_CLRDT__SHIFT      0x06 ///< Clear Data Toggle                                 
3456      =2  #define EINCSRL_CLRDT__CLEAR      0x00 ///< Clear the IN Endpoint data toggle.                
3457      =2                                                                                                
3458      =2  //------------------------------------------------------------------------------
3459      =2  // EOUTCNTH Enums (USB0 OUT Endpoint Count High @ 0x17)
3460      =2  //------------------------------------------------------------------------------
3461      =2  #define EOUTCNTH_EOCH__FMASK 0x03 ///< OUT Endpoint Count High
3462      =2  #define EOUTCNTH_EOCH__SHIFT 0x00 ///< OUT Endpoint Count High
3463      =2                                                                
3464      =2  //------------------------------------------------------------------------------
3465      =2  // EOUTCNTL Enums (USB0 OUT Endpoint Count Low @ 0x16)
3466      =2  //------------------------------------------------------------------------------
3467      =2  #define EOUTCNTL_EOCL__FMASK 0xFF ///< OUT Endpoint Count Low
3468      =2  #define EOUTCNTL_EOCL__SHIFT 0x00 ///< OUT Endpoint Count Low
3469      =2                                                               
3470      =2  //------------------------------------------------------------------------------
3471      =2  // EOUTCSRH Enums (USB0 OUT Endpoint Control High @ 0x15)
3472      =2  //------------------------------------------------------------------------------
3473      =2  #define EOUTCSRH_ISO__BMASK      0x40 ///< Isochronous Transfer Enable                      
3474      =2  #define EOUTCSRH_ISO__SHIFT      0x06 ///< Isochronous Transfer Enable                      
3475      =2  #define EOUTCSRH_ISO__DISABLED   0x00 ///< Endpoint configured for Bulk/Interrupt transfers.
3476      =2  #define EOUTCSRH_ISO__ENABLED    0x40 ///< Endpoint configured for Isochronous transfers.   
3477      =2                                                                                              
3478      =2  #define EOUTCSRH_DBOEN__BMASK    0x80 ///< Double-Buffer Enable                             
3479      =2  #define EOUTCSRH_DBOEN__SHIFT    0x07 ///< Double-Buffer Enable                             
3480      =2  #define EOUTCSRH_DBOEN__DISABLED 0x00 ///< Disable double-buffering for the selected OUT    
3481      =2                                        ///< endpoint.                                        
3482      =2  #define EOUTCSRH_DBOEN__ENABLED  0x80 ///< Enable double-buffering for the selected OUT     
3483      =2                                        ///< endpoint.                                        
3484      =2                                                                                              
3485      =2  //------------------------------------------------------------------------------
3486      =2  // EOUTCSRL Enums (USB0 OUT Endpoint Control Low @ 0x14)
3487      =2  //------------------------------------------------------------------------------
3488      =2  #define EOUTCSRL_OPRDY__BMASK      0x01 ///< OUT Packet Ready                                  
3489      =2  #define EOUTCSRL_OPRDY__SHIFT      0x00 ///< OUT Packet Ready                                  
3490      =2  #define EOUTCSRL_OPRDY__NOT_SET    0x00 ///< A data packet is not available in the Endpoint OUT
3491      =2                                          ///< FIFO.                                             
3492      =2  #define EOUTCSRL_OPRDY__SET        0x01 ///< A data packet is available in the Endpoint OUT    
3493      =2                                          ///< FIFO.                                             
3494      =2                                                                                                 
3495      =2  #define EOUTCSRL_FIFOFUL__BMASK    0x02 ///< OUT FIFO Full                                     
3496      =2  #define EOUTCSRL_FIFOFUL__SHIFT    0x01 ///< OUT FIFO Full                                     
3497      =2  #define EOUTCSRL_FIFOFUL__NOT_FULL 0x00 ///< OUT endpoint FIFO is not full.                    
3498      =2  #define EOUTCSRL_FIFOFUL__FULL     0x02 ///< OUT endpoint FIFO is full.                        
3499      =2                                                                                                 
3500      =2  #define EOUTCSRL_OVRUN__BMASK      0x04 ///< Data Overrun Flag                                 
3501      =2  #define EOUTCSRL_OVRUN__SHIFT      0x02 ///< Data Overrun Flag                                 
3502      =2  #define EOUTCSRL_OVRUN__NOT_SET    0x00 ///< No data overrun.                                  
3503      =2  #define EOUTCSRL_OVRUN__SET        0x04 ///< A data packet was lost because of a full FIFO     
3504      =2                                          ///< since this flag was last cleared.                 
3505      =2                                                                                                 
3506      =2  #define EOUTCSRL_DATERR__BMASK     0x08 ///< Data Error Flag                                   
C51 COMPILER V9.56.0.0   UART_0                                                            10/28/2016 17:37:02 PAGE 84  

3507      =2  #define EOUTCSRL_DATERR__SHIFT     0x03 ///< Data Error Flag                                   
3508      =2  #define EOUTCSRL_DATERR__NOT_SET   0x00 ///< A received packet does not have a CRC or bit-     
3509      =2                                          ///< stuffing error.                                   
3510      =2  #define EOUTCSRL_DATERR__SET       0x08 ///< A received packet has a CRC or bit-stuffing error.
3511      =2                                                                                                 
3512      =2  #define EOUTCSRL_FLUSH__BMASK      0x10 ///< FIFO Flush                                        
3513      =2  #define EOUTCSRL_FLUSH__SHIFT      0x04 ///< FIFO Flush                                        
3514      =2  #define EOUTCSRL_FLUSH__NOT_SET    0x00 ///< Do not flush the next packet.                     
3515      =2  #define EOUTCSRL_FLUSH__SET        0x10 ///< Flush the next packet to be read from the OUT     
3516      =2                                          ///< endpoint FIFO.                                    
3517      =2                                                                                                 
3518      =2  #define EOUTCSRL_SDSTL__BMASK      0x20 ///< Send Stall                                        
3519      =2  #define EOUTCSRL_SDSTL__SHIFT      0x05 ///< Send Stall                                        
3520      =2  #define EOUTCSRL_SDSTL__NOT_SET    0x00 ///< Terminate the STALL.                              
3521      =2  #define EOUTCSRL_SDSTL__SET        0x20 ///< Generate a STALL handshake.                       
3522      =2                                                                                                 
3523      =2  #define EOUTCSRL_STSTL__BMASK      0x40 ///< Sent Stall Flag                                   
3524      =2  #define EOUTCSRL_STSTL__SHIFT      0x06 ///< Sent Stall Flag                                   
3525      =2  #define EOUTCSRL_STSTL__NOT_SET    0x00 ///< A STALL handshake was not transmitted.            
3526      =2  #define EOUTCSRL_STSTL__SET        0x40 ///< A STALL handshake was transmitted.                
3527      =2                                                                                                 
3528      =2  #define EOUTCSRL_CLRDT__BMASK      0x80 ///< Clear Data Toggle                                 
3529      =2  #define EOUTCSRL_CLRDT__SHIFT      0x07 ///< Clear Data Toggle                                 
3530      =2  #define EOUTCSRL_CLRDT__CLEAR      0x00 ///< Clear the OUT Endpoint data toggle.               
3531      =2                                                                                                 
3532      =2  //------------------------------------------------------------------------------
3533      =2  // FADDR Enums (USB0 Function Address @ 0x00)
3534      =2  //------------------------------------------------------------------------------
3535      =2  #define FADDR_FADDR__FMASK    0x7F ///< Function Address                               
3536      =2  #define FADDR_FADDR__SHIFT    0x00 ///< Function Address                               
3537      =2                                                                                         
3538      =2  #define FADDR_UPDATE__BMASK   0x80 ///< Function Address Update                        
3539      =2  #define FADDR_UPDATE__SHIFT   0x07 ///< Function Address Update                        
3540      =2  #define FADDR_UPDATE__NOT_SET 0x00 ///< The last address written to FADDR is in effect.
3541      =2  #define FADDR_UPDATE__SET     0x80 ///< The last address written to FADDR is not yet in
3542      =2                                     ///< effect.                                        
3543      =2                                                                                         
3544      =2  //------------------------------------------------------------------------------
3545      =2  // FIFO0 Enums (USB0 Endpoint 0 FIFO Access @ 0x20)
3546      =2  //------------------------------------------------------------------------------
3547      =2  #define FIFO0_FIFODATA__FMASK 0xFF ///< Endpoint 0 FIFO Access
3548      =2  #define FIFO0_FIFODATA__SHIFT 0x00 ///< Endpoint 0 FIFO Access
3549      =2                                                                
3550      =2  //------------------------------------------------------------------------------
3551      =2  // FIFO1 Enums (USB0 Endpoint 1 FIFO Access @ 0x21)
3552      =2  //------------------------------------------------------------------------------
3553      =2  #define FIFO1_FIFODATA__FMASK 0xFF ///< Endpoint 1 FIFO Access
3554      =2  #define FIFO1_FIFODATA__SHIFT 0x00 ///< Endpoint 1 FIFO Access
3555      =2                                                                
3556      =2  //------------------------------------------------------------------------------
3557      =2  // FIFO2 Enums (USB0 Endpoint 2 FIFO Access @ 0x22)
3558      =2  //------------------------------------------------------------------------------
3559      =2  #define FIFO2_FIFODATA__FMASK 0xFF ///< Endpoint 2 FIFO Access
3560      =2  #define FIFO2_FIFODATA__SHIFT 0x00 ///< Endpoint 2 FIFO Access
3561      =2                                                                
3562      =2  //------------------------------------------------------------------------------
3563      =2  // FIFO3 Enums (USB0 Endpoint 3 FIFO Access @ 0x23)
3564      =2  //------------------------------------------------------------------------------
3565      =2  #define FIFO3_FIFODATA__FMASK 0xFF ///< Endpoint 3 FIFO Access
3566      =2  #define FIFO3_FIFODATA__SHIFT 0x00 ///< Endpoint 3 FIFO Access
3567      =2                                                                
3568      =2  //------------------------------------------------------------------------------
C51 COMPILER V9.56.0.0   UART_0                                                            10/28/2016 17:37:02 PAGE 85  

3569      =2  // FRAMEH Enums (USB0 Frame Number High @ 0x0D)
3570      =2  //------------------------------------------------------------------------------
3571      =2  #define FRAMEH_FRMEH__FMASK 0x07 ///< Frame Number High
3572      =2  #define FRAMEH_FRMEH__SHIFT 0x00 ///< Frame Number High
3573      =2                                                         
3574      =2  //------------------------------------------------------------------------------
3575      =2  // FRAMEL Enums (USB0 Frame Number Low @ 0x0C)
3576      =2  //------------------------------------------------------------------------------
3577      =2  #define FRAMEL_FRMEL__FMASK 0xFF ///< Frame Number Low
3578      =2  #define FRAMEL_FRMEL__SHIFT 0x00 ///< Frame Number Low
3579      =2                                                        
3580      =2  //------------------------------------------------------------------------------
3581      =2  // IN1IE Enums (USB0 IN Endpoint Interrupt Enable @ 0x07)
3582      =2  //------------------------------------------------------------------------------
3583      =2  #define IN1IE_EP0E__BMASK    0x01 ///< Endpoint 0 Interrupt Enable      
3584      =2  #define IN1IE_EP0E__SHIFT    0x00 ///< Endpoint 0 Interrupt Enable      
3585      =2  #define IN1IE_EP0E__DISABLED 0x00 ///< Disable Endpoint 0 interrupts.   
3586      =2  #define IN1IE_EP0E__ENABLED  0x01 ///< Enable Endpoint 0 interrupts.    
3587      =2                                                                          
3588      =2  #define IN1IE_IN1E__BMASK    0x02 ///< IN Endpoint 1 Interrupt Enable   
3589      =2  #define IN1IE_IN1E__SHIFT    0x01 ///< IN Endpoint 1 Interrupt Enable   
3590      =2  #define IN1IE_IN1E__DISABLED 0x00 ///< Disable Endpoint 1 IN interrupts.
3591      =2  #define IN1IE_IN1E__ENABLED  0x02 ///< Enable Endpoint 1 IN interrupts. 
3592      =2                                                                          
3593      =2  #define IN1IE_IN2E__BMASK    0x04 ///< IN Endpoint 2 Interrupt Enable   
3594      =2  #define IN1IE_IN2E__SHIFT    0x02 ///< IN Endpoint 2 Interrupt Enable   
3595      =2  #define IN1IE_IN2E__DISABLED 0x00 ///< Disable Endpoint 2 IN interrupts.
3596      =2  #define IN1IE_IN2E__ENABLED  0x04 ///< Enable Endpoint 2 IN interrupts. 
3597      =2                                                                          
3598      =2  #define IN1IE_IN3E__BMASK    0x08 ///< IN Endpoint 3 Interrupt Enable   
3599      =2  #define IN1IE_IN3E__SHIFT    0x03 ///< IN Endpoint 3 Interrupt Enable   
3600      =2  #define IN1IE_IN3E__DISABLED 0x00 ///< Disable Endpoint 3 IN interrupts.
3601      =2  #define IN1IE_IN3E__ENABLED  0x08 ///< Enable Endpoint 3 IN interrupts. 
3602      =2                                                                          
3603      =2  //------------------------------------------------------------------------------
3604      =2  // IN1INT Enums (USB0 IN Endpoint Interrupt @ 0x02)
3605      =2  //------------------------------------------------------------------------------
3606      =2  #define IN1INT_EP0__BMASK   0x01 ///< Endpoint 0 Interrupt Flag        
3607      =2  #define IN1INT_EP0__SHIFT   0x00 ///< Endpoint 0 Interrupt Flag        
3608      =2  #define IN1INT_EP0__NOT_SET 0x00 ///< Endpoint 0 interrupt inactive.   
3609      =2  #define IN1INT_EP0__SET     0x01 ///< Endpoint 0 interrupt active.     
3610      =2                                                                         
3611      =2  #define IN1INT_IN1__BMASK   0x02 ///< IN Endpoint 1 Interrupt Flag     
3612      =2  #define IN1INT_IN1__SHIFT   0x01 ///< IN Endpoint 1 Interrupt Flag     
3613      =2  #define IN1INT_IN1__NOT_SET 0x00 ///< IN Endpoint 1 interrupt inactive.
3614      =2  #define IN1INT_IN1__SET     0x02 ///< IN Endpoint 1 interrupt active.  
3615      =2                                                                         
3616      =2  #define IN1INT_IN2__BMASK   0x04 ///< IN Endpoint 2 Interrupt Flag     
3617      =2  #define IN1INT_IN2__SHIFT   0x02 ///< IN Endpoint 2 Interrupt Flag     
3618      =2  #define IN1INT_IN2__NOT_SET 0x00 ///< IN Endpoint 2 interrupt inactive.
3619      =2  #define IN1INT_IN2__SET     0x04 ///< IN Endpoint 2 interrupt active.  
3620      =2                                                                         
3621      =2  #define IN1INT_IN3__BMASK   0x08 ///< IN Endpoint 3 Interrupt Flag     
3622      =2  #define IN1INT_IN3__SHIFT   0x03 ///< IN Endpoint 3 Interrupt Flag     
3623      =2  #define IN1INT_IN3__NOT_SET 0x00 ///< IN Endpoint 3 interrupt inactive.
3624      =2  #define IN1INT_IN3__SET     0x08 ///< IN Endpoint 3 interrupt active.  
3625      =2                                                                         
3626      =2  //------------------------------------------------------------------------------
3627      =2  // INDEX Enums (USB0 Endpoint Index @ 0x0E)
3628      =2  //------------------------------------------------------------------------------
3629      =2  #define INDEX_EPSEL__FMASK      0x0F ///< Endpoint Select Bits
3630      =2  #define INDEX_EPSEL__SHIFT      0x00 ///< Endpoint Select Bits
C51 COMPILER V9.56.0.0   UART_0                                                            10/28/2016 17:37:02 PAGE 86  

3631      =2  #define INDEX_EPSEL__ENDPOINT_0 0x00 ///< Endpoint 0.         
3632      =2  #define INDEX_EPSEL__ENDPOINT_1 0x01 ///< Endpoint 1.         
3633      =2  #define INDEX_EPSEL__ENDPOINT_2 0x02 ///< Endpoint 2.         
3634      =2  #define INDEX_EPSEL__ENDPOINT_3 0x03 ///< Endpoint 3.         
3635      =2                                                                
3636      =2  //------------------------------------------------------------------------------
3637      =2  // OUT1IE Enums (USB0 OUT Endpoint Interrupt Enable @ 0x09)
3638      =2  //------------------------------------------------------------------------------
3639      =2  #define OUT1IE_OUT1E__BMASK    0x02 ///< OUT Endpoint 1 Interrupt Enable   
3640      =2  #define OUT1IE_OUT1E__SHIFT    0x01 ///< OUT Endpoint 1 Interrupt Enable   
3641      =2  #define OUT1IE_OUT1E__DISABLED 0x00 ///< Disable Endpoint 1 OUT interrupts.
3642      =2  #define OUT1IE_OUT1E__ENABLED  0x02 ///< Enable Endpoint 1 OUT interrupts. 
3643      =2                                                                             
3644      =2  #define OUT1IE_OUT2E__BMASK    0x04 ///< OUT Endpoint 2 Interrupt Enable   
3645      =2  #define OUT1IE_OUT2E__SHIFT    0x02 ///< OUT Endpoint 2 Interrupt Enable   
3646      =2  #define OUT1IE_OUT2E__DISABLED 0x00 ///< Disable Endpoint 2 OUT interrupts.
3647      =2  #define OUT1IE_OUT2E__ENABLED  0x04 ///< Enable Endpoint 2 OUT interrupts. 
3648      =2                                                                             
3649      =2  #define OUT1IE_OUT3E__BMASK    0x08 ///< OUT Endpoint 3 Interrupt Enable   
3650      =2  #define OUT1IE_OUT3E__SHIFT    0x03 ///< OUT Endpoint 3 Interrupt Enable   
3651      =2  #define OUT1IE_OUT3E__DISABLED 0x00 ///< Disable Endpoint 3 OUT interrupts.
3652      =2  #define OUT1IE_OUT3E__ENABLED  0x08 ///< Enable Endpoint 3 OUT interrupts. 
3653      =2                                                                             
3654      =2  //------------------------------------------------------------------------------
3655      =2  // OUT1INT Enums (USB0 OUT Endpoint Interrupt @ 0x04)
3656      =2  //------------------------------------------------------------------------------
3657      =2  #define OUT1INT_OUT1__BMASK   0x02 ///< OUT Endpoint 1 Interrupt Flag     
3658      =2  #define OUT1INT_OUT1__SHIFT   0x01 ///< OUT Endpoint 1 Interrupt Flag     
3659      =2  #define OUT1INT_OUT1__NOT_SET 0x00 ///< OUT Endpoint 1 interrupt inactive.
3660      =2  #define OUT1INT_OUT1__SET     0x02 ///< OUT Endpoint 1 interrupt active.  
3661      =2                                                                            
3662      =2  #define OUT1INT_OUT2__BMASK   0x04 ///< OUT Endpoint 2 Interrupt Flag     
3663      =2  #define OUT1INT_OUT2__SHIFT   0x02 ///< OUT Endpoint 2 Interrupt Flag     
3664      =2  #define OUT1INT_OUT2__NOT_SET 0x00 ///< OUT Endpoint 2 interrupt inactive.
3665      =2  #define OUT1INT_OUT2__SET     0x04 ///< OUT Endpoint 2 interrupt active.  
3666      =2                                                                            
3667      =2  #define OUT1INT_OUT3__BMASK   0x08 ///< OUT Endpoint 3 Interrupt Flag     
3668      =2  #define OUT1INT_OUT3__SHIFT   0x03 ///< OUT Endpoint 3 Interrupt Flag     
3669      =2  #define OUT1INT_OUT3__NOT_SET 0x00 ///< OUT Endpoint 3 interrupt inactive.
3670      =2  #define OUT1INT_OUT3__SET     0x08 ///< OUT Endpoint 3 interrupt active.  
3671      =2                                                                            
3672      =2  //------------------------------------------------------------------------------
3673      =2  // POWER Enums (USB0 Power @ 0x01)
3674      =2  //------------------------------------------------------------------------------
3675      =2  #define POWER_SUSEN__BMASK         0x01 ///< Suspend Detection Enable                          
3676      =2  #define POWER_SUSEN__SHIFT         0x00 ///< Suspend Detection Enable                          
3677      =2  #define POWER_SUSEN__DISABLED      0x00 ///< Disable suspend detection. USB0 will ignore       
3678      =2                                          ///< suspend signaling on the bus.                     
3679      =2  #define POWER_SUSEN__ENABLED       0x01 ///< Enable suspend detection. USB0 will enter suspend 
3680      =2                                          ///< mode if it detects suspend signaling on the bus.  
3681      =2                                                                                                 
3682      =2  #define POWER_SUSMD__BMASK         0x02 ///< Suspend Mode                                      
3683      =2  #define POWER_SUSMD__SHIFT         0x01 ///< Suspend Mode                                      
3684      =2  #define POWER_SUSMD__NOT_SUSPENDED 0x00 ///< USB0 not in suspend mode.                         
3685      =2  #define POWER_SUSMD__SUSPENDED     0x02 ///< USB0 in suspend mode.                             
3686      =2                                                                                                 
3687      =2  #define POWER_RESUME__BMASK        0x04 ///< Force Resume                                      
3688      =2  #define POWER_RESUME__SHIFT        0x02 ///< Force Resume                                      
3689      =2  #define POWER_RESUME__START        0x04 ///< Generate resume signalling to create a remote     
3690      =2                                          ///< wakeup event.                                     
3691      =2                                                                                                 
3692      =2  #define POWER_USBRST__BMASK        0x08 ///< Reset Detect                                      
C51 COMPILER V9.56.0.0   UART_0                                                            10/28/2016 17:37:02 PAGE 87  

3693      =2  #define POWER_USBRST__SHIFT        0x03 ///< Reset Detect                                      
3694      =2  #define POWER_USBRST__NOT_SET      0x00 ///< USB reset signalling not detected.                
3695      =2  #define POWER_USBRST__SET          0x08 ///< USB reset signalling detected.                    
3696      =2                                                                                                 
3697      =2  #define POWER_USBINH__BMASK        0x10 ///< USB0 Inhibit                                      
3698      =2  #define POWER_USBINH__SHIFT        0x04 ///< USB0 Inhibit                                      
3699      =2  #define POWER_USBINH__ENABLED      0x00 ///< USB0 enabled.                                     
3700      =2  #define POWER_USBINH__DISABLED     0x10 ///< USB0 inhibited. All USB traffic is ignored.       
3701      =2                                                                                                 
3702      =2  #define POWER_ISOUD__BMASK         0x80 ///< Isochronous Update Mode                           
3703      =2  #define POWER_ISOUD__SHIFT         0x07 ///< Isochronous Update Mode                           
3704      =2  #define POWER_ISOUD__IN_TOKEN      0x00 ///< When firmware writes INPRDY = 1, USB0 will send   
3705      =2                                          ///< the packet when the next IN token is received.    
3706      =2  #define POWER_ISOUD__SOF_TOKEN     0x80 ///< When firmware writes INPRDY = 1, USB0 will wait   
3707      =2                                          ///< for a SOF token before sending the packet. If an  
3708      =2                                          ///< IN token is received before a SOF token, USB0 will
3709      =2                                          ///< send a zero-length data packet.                   
3710      =2                                                                                                 
3711      =2  //------------------------------------------------------------------------------
3712      =2  // USB0ADR Enums (USB0 Indirect Address @ 0x96)
3713      =2  //------------------------------------------------------------------------------
3714      =2  #define USB0ADR_USB0ADR__FMASK          0x3F ///< USB0 Indirect Register Address                    
3715      =2  #define USB0ADR_USB0ADR__SHIFT          0x00 ///< USB0 Indirect Register Address                    
3716      =2  #define USB0ADR_USB0ADR__FADDR          0x00 ///< Function Address.                                 
3717      =2  #define USB0ADR_USB0ADR__POWER          0x01 ///< Power Management.                                 
3718      =2  #define USB0ADR_USB0ADR__IN1INT         0x02 ///< Endpoint 0 and Endpoints 1-3 IN Interrupt Flags.  
3719      =2  #define USB0ADR_USB0ADR__OUT1INT        0x04 ///< Endpoints 1-3 OUT Interrupt Flags.                
3720      =2  #define USB0ADR_USB0ADR__CMINT          0x06 ///< Common USB Interrupt Flags.                       
3721      =2  #define USB0ADR_USB0ADR__IN1IE          0x07 ///< Endpoint 0 and Endpoints 1-3 IN Interrupt Enables.
3722      =2  #define USB0ADR_USB0ADR__OUT1IE         0x09 ///< Endpoints 1-3 OUT Interrupt Enables.              
3723      =2  #define USB0ADR_USB0ADR__CMIE           0x0B ///< Common USB Interrupt Enables.                     
3724      =2  #define USB0ADR_USB0ADR__FRAMEL         0x0C ///< Frame Number Low Byte.                            
3725      =2  #define USB0ADR_USB0ADR__FRAMEH         0x0D ///< Frame Number High Byte.                           
3726      =2  #define USB0ADR_USB0ADR__INDEX          0x0E ///< Endpoint Index Selection.                         
3727      =2  #define USB0ADR_USB0ADR__CLKREC         0x0F ///< Clock Recovery Control.                           
3728      =2  #define USB0ADR_USB0ADR__E0CSR_EINCSRL  0x11 ///< Endpoint 0 Control / Status, Endpoint IN Control /
3729      =2                                               ///< Status Low Byte.                                  
3730      =2  #define USB0ADR_USB0ADR__EINCSRH        0x12 ///< Endpoint IN Control / Status High Byte.           
3731      =2  #define USB0ADR_USB0ADR__EOUTCSRL       0x14 ///< Endpoint OUT Control / Status Low Byte.           
3732      =2  #define USB0ADR_USB0ADR__EOUTCSRH       0x15 ///< Endpoint OUT Control / Status High Byte.          
3733      =2  #define USB0ADR_USB0ADR__E0CNT_EOUTCNTL 0x16 ///< Number of Received Bytes in Endpoint 0 FIFO,      
3734      =2                                               ///< Endpoint OUT Packet Count Low Byte.               
3735      =2  #define USB0ADR_USB0ADR__EOUTCNTH       0x17 ///< Endpoint OUT Packet Count High Byte.              
3736      =2  #define USB0ADR_USB0ADR__EENABLE        0x1E ///< Endpoint Enable.                                  
3737      =2  #define USB0ADR_USB0ADR__FIFO0          0x20 ///< Endpoint 0 FIFO.                                  
3738      =2  #define USB0ADR_USB0ADR__FIFO1          0x21 ///< Endpoint 1 FIFO.                                  
3739      =2  #define USB0ADR_USB0ADR__FIFO2          0x22 ///< Endpoint 2 FIFO.                                  
3740      =2  #define USB0ADR_USB0ADR__FIFO3          0x23 ///< Endpoint 3 FIFO.                                  
3741      =2                                                                                                      
3742      =2  #define USB0ADR_AUTORD__BMASK           0x40 ///< USB0 Register Auto-Read Flag                      
3743      =2  #define USB0ADR_AUTORD__SHIFT           0x06 ///< USB0 Register Auto-Read Flag                      
3744      =2  #define USB0ADR_AUTORD__DISABLED        0x00 ///< BUSY must be written manually for each USB0       
3745      =2                                               ///< indirect register read.                           
3746      =2  #define USB0ADR_AUTORD__ENABLED         0x40 ///< The next indirect register read will automatically
3747      =2                                               ///< be initiated when firmware reads USB0DAT (USBADDR 
3748      =2                                               ///< bits will not be changed).                        
3749      =2                                                                                                      
3750      =2  #define USB0ADR_BUSY__BMASK             0x80 ///< USB0 Register Read Busy Flag                      
3751      =2  #define USB0ADR_BUSY__SHIFT             0x07 ///< USB0 Register Read Busy Flag                      
3752      =2  #define USB0ADR_BUSY__NOT_SET           0x00 ///< A read is not in progress.                        
3753      =2  #define USB0ADR_BUSY__SET               0x80 ///< Initiate a read or a read is in progress.         
3754      =2                                                                                                      
C51 COMPILER V9.56.0.0   UART_0                                                            10/28/2016 17:37:02 PAGE 88  

3755      =2  //------------------------------------------------------------------------------
3756      =2  // USB0DAT Enums (USB0 Data @ 0x97)
3757      =2  //------------------------------------------------------------------------------
3758      =2  #define USB0DAT_USB0DAT__FMASK 0xFF ///< USB0 Data
3759      =2  #define USB0DAT_USB0DAT__SHIFT 0x00 ///< USB0 Data
3760      =2                                                    
3761      =2  //------------------------------------------------------------------------------
3762      =2  // USB0XCN Enums (USB0 Transceiver Control @ 0xD7)
3763      =2  //------------------------------------------------------------------------------
3764      =2  #define USB0XCN_Dn__BMASK                0x01 ///< D- Signal Status                                 
3765      =2  #define USB0XCN_Dn__SHIFT                0x00 ///< D- Signal Status                                 
3766      =2  #define USB0XCN_Dn__LOW                  0x00 ///< D- signal currently at logic 0.                  
3767      =2  #define USB0XCN_Dn__HIGH                 0x01 ///< D- signal currently at logic 1.                  
3768      =2                                                                                                      
3769      =2  #define USB0XCN_Dp__BMASK                0x02 ///< D+ Signal Status                                 
3770      =2  #define USB0XCN_Dp__SHIFT                0x01 ///< D+ Signal Status                                 
3771      =2  #define USB0XCN_Dp__LOW                  0x00 ///< D+ signal currently at logic 0.                  
3772      =2  #define USB0XCN_Dp__HIGH                 0x02 ///< D+ signal currently at logic 1.                  
3773      =2                                                                                                      
3774      =2  #define USB0XCN_DFREC__BMASK             0x04 ///< Differential Receiver                            
3775      =2  #define USB0XCN_DFREC__SHIFT             0x02 ///< Differential Receiver                            
3776      =2  #define USB0XCN_DFREC__DIFFERENTIAL_ZERO 0x00 ///< Differential 0 signalling on the bus.            
3777      =2  #define USB0XCN_DFREC__DIFFERENTIAL_ONE  0x04 ///< Differential 1 signalling on the bus.            
3778      =2                                                                                                      
3779      =2  #define USB0XCN_PHYTST__FMASK            0x18 ///< Physical Layer Test                              
3780      =2  #define USB0XCN_PHYTST__SHIFT            0x03 ///< Physical Layer Test                              
3781      =2  #define USB0XCN_PHYTST__MODE0            0x00 ///< Mode 0: Normal (non-test mode) (D+ = X, D- = X). 
3782      =2  #define USB0XCN_PHYTST__MODE1            0x08 ///< Mode 1: Differential 1 forced (D+ = 1, D- = 0).  
3783      =2  #define USB0XCN_PHYTST__MODE2            0x10 ///< Mode 2: Differential 0 forced (D+ = 0, D- = 1).  
3784      =2  #define USB0XCN_PHYTST__MODE3            0x18 ///< Mode 3: Single-Ended 0 forced (D+ = 0, D- = 0).  
3785      =2                                                                                                      
3786      =2  #define USB0XCN_SPEED__BMASK             0x20 ///< USB0 Speed Select                                
3787      =2  #define USB0XCN_SPEED__SHIFT             0x05 ///< USB0 Speed Select                                
3788      =2  #define USB0XCN_SPEED__LOW_SPEED         0x00 ///< USB0 operates as a Low Speed device. If enabled, 
3789      =2                                                ///< the internal pull-up resistor appears on the D-  
3790      =2                                                ///< line.                                            
3791      =2  #define USB0XCN_SPEED__FULL_SPEED        0x20 ///< USB0 operates as a Full Speed device. If enabled,
3792      =2                                                ///< the internal pull-up resistor appears on the D+  
3793      =2                                                ///< line.                                            
3794      =2                                                                                                      
3795      =2  #define USB0XCN_PHYEN__BMASK             0x40 ///< Physical Layer Enable                            
3796      =2  #define USB0XCN_PHYEN__SHIFT             0x06 ///< Physical Layer Enable                            
3797      =2  #define USB0XCN_PHYEN__DISABLED          0x00 ///< Disable the USB0 physical layer transceiver      
3798      =2                                                ///< (suspend).                                       
3799      =2  #define USB0XCN_PHYEN__ENABLED           0x40 ///< Enable the USB0 physical layer transceiver       
3800      =2                                                ///< (normal).                                        
3801      =2                                                                                                      
3802      =2  #define USB0XCN_PREN__BMASK              0x80 ///< Internal Pull-up Resistor Enable                 
3803      =2  #define USB0XCN_PREN__SHIFT              0x07 ///< Internal Pull-up Resistor Enable                 
3804      =2  #define USB0XCN_PREN__PULL_UP_DISABLED   0x00 ///< Internal pull-up resistor disabled (device       
3805      =2                                                ///< effectively detached from USB network).          
3806      =2  #define USB0XCN_PREN__PULL_UP_ENABLED    0x80 ///< Internal pull-up resistor enabled when VBUS is   
3807      =2                                                ///< present (device attached to the USB network).    
3808      =2                                                                                                      
3809      =2  //------------------------------------------------------------------------------
3810      =2  // VDM0CN Enums (Supply Monitor Control @ 0xFF)
3811      =2  //------------------------------------------------------------------------------
3812      =2  #define VDM0CN_VDDSTAT__BMASK  0x40 ///< Supply Status                                   
3813      =2  #define VDM0CN_VDDSTAT__SHIFT  0x06 ///< Supply Status                                   
3814      =2  #define VDM0CN_VDDSTAT__BELOW  0x00 ///< VDD is at or below the supply monitor threshold.
3815      =2  #define VDM0CN_VDDSTAT__ABOVE  0x40 ///< VDD is above the supply monitor threshold.      
3816      =2                                                                                           
C51 COMPILER V9.56.0.0   UART_0                                                            10/28/2016 17:37:02 PAGE 89  

3817      =2  #define VDM0CN_VDMEN__BMASK    0x80 ///< Supply Monitor Enable                           
3818      =2  #define VDM0CN_VDMEN__SHIFT    0x07 ///< Supply Monitor Enable                           
3819      =2  #define VDM0CN_VDMEN__DISABLED 0x00 ///< Supply Monitor Disabled.                        
3820      =2  #define VDM0CN_VDMEN__ENABLED  0x80 ///< Supply Monitor Enabled.                         
3821      =2                                                                                           
3822      =2  //------------------------------------------------------------------------------
3823      =2  // REF0CN Enums (Voltage Reference Control @ 0xD1)
3824      =2  //------------------------------------------------------------------------------
3825      =2  #define REF0CN_REFBE__BMASK    0x01 ///< Internal Reference Buffer Enable                  
3826      =2  #define REF0CN_REFBE__SHIFT    0x00 ///< Internal Reference Buffer Enable                  
3827      =2  #define REF0CN_REFBE__DISABLED 0x00 ///< Disable the internal reference buffer.            
3828      =2  #define REF0CN_REFBE__ENABLED  0x01 ///< Enable the internal reference buffer. The internal
3829      =2                                      ///< voltage reference is driven on the VREF pin.      
3830      =2                                                                                             
3831      =2  #define REF0CN_TEMPE__BMASK    0x04 ///< Temperature Sensor Enable                         
3832      =2  #define REF0CN_TEMPE__SHIFT    0x02 ///< Temperature Sensor Enable                         
3833      =2  #define REF0CN_TEMPE__DISABLED 0x00 ///< Disable the internal Temperature Sensor.          
3834      =2  #define REF0CN_TEMPE__ENABLED  0x04 ///< Enable the internal Temperature Sensor.           
3835      =2                                                                                             
3836      =2  #define REF0CN_REFSL__BMASK    0x08 ///< Voltage Reference Select                          
3837      =2  #define REF0CN_REFSL__SHIFT    0x03 ///< Voltage Reference Select                          
3838      =2  #define REF0CN_REFSL__VREF     0x00 ///< Use the VREF pin as the voltage reference.        
3839      =2  #define REF0CN_REFSL__VDD      0x08 ///< Use VDD as the voltage reference.                 
3840      =2                                                                                             
3841      =2  #define REF0CN_REGOVR__BMASK   0x10 ///< Regulator Reference Override                      
3842      =2  #define REF0CN_REGOVR__SHIFT   0x04 ///< Regulator Reference Override                      
3843      =2  #define REF0CN_REGOVR__REFSL   0x00 ///< The REFSL bit selects the voltage reference       
3844      =2                                      ///< source.                                           
3845      =2  #define REF0CN_REGOVR__VREG    0x10 ///< Use the output of the internal regulator as the   
3846      =2                                      ///< voltage reference source.                         
3847      =2                                                                                             
3848      =2  #define REF0CN_REFBGS__BMASK   0x80 ///< Reference Buffer Gain Select                      
3849      =2  #define REF0CN_REFBGS__SHIFT   0x07 ///< Reference Buffer Gain Select                      
3850      =2  #define REF0CN_REFBGS__GAIN_2  0x00 ///< The on-chip voltage reference buffer gain is 2.   
3851      =2  #define REF0CN_REFBGS__GAIN_1  0x80 ///< The on-chip voltage reference buffer gain is 1.   
3852      =2                                                                                             
3853      =2  //------------------------------------------------------------------------------
3854      =2  // REG01CN Enums (Voltage Regulator Control @ 0xC9)
3855      =2  //------------------------------------------------------------------------------
3856      =2  #define REG01CN_REG1MD__BMASK     0x02 ///< VREG1 Voltage Regulator Mode                     
3857      =2  #define REG01CN_REG1MD__SHIFT     0x01 ///< VREG1 Voltage Regulator Mode                     
3858      =2  #define REG01CN_REG1MD__NORMAL    0x00 ///< VREG1 Voltage Regulator in normal mode.          
3859      =2  #define REG01CN_REG1MD__LOW_POWER 0x02 ///< VREG1 Voltage Regulator in low power mode.       
3860      =2                                                                                               
3861      =2  #define REG01CN_STOPCF__BMASK     0x08 ///< VREG1 Stop and Shutdown Mode Configuration       
3862      =2  #define REG01CN_STOPCF__SHIFT     0x03 ///< VREG1 Stop and Shutdown Mode Configuration       
3863      =2  #define REG01CN_STOPCF__ACTIVE    0x00 ///< VREG1 Regulator is still active in stop mode. Any
3864      =2                                         ///< enabled reset source will reset the device.      
3865      =2  #define REG01CN_STOPCF__SHUTDOWN  0x08 ///< VREG1 Regulator is shut down in stop mode (device
3866      =2                                         ///< enters Shutdown mode). Only the RSTb pin or power
3867      =2                                         ///< cycle can reset the device.                      
3868      =2                                                                                               
3869      =2  #define REG01CN_REG0MD__BMASK     0x10 ///< VREG0 Voltage Regulator Mode                     
3870      =2  #define REG01CN_REG0MD__SHIFT     0x04 ///< VREG0 Voltage Regulator Mode                     
3871      =2  #define REG01CN_REG0MD__NORMAL    0x00 ///< VREG0 Voltage Regulator in normal mode.          
3872      =2  #define REG01CN_REG0MD__LOW_POWER 0x10 ///< VREG0 Voltage Regulator in low power mode.       
3873      =2                                                                                               
3874      =2  #define REG01CN_VBSTAT__BMASK     0x40 ///< VBUS Signal Status                               
3875      =2  #define REG01CN_VBSTAT__SHIFT     0x06 ///< VBUS Signal Status                               
3876      =2  #define REG01CN_VBSTAT__NOT_SET   0x00 ///< VBUS signal currently absent (device not attached
3877      =2                                         ///< to USB network).                                 
3878      =2  #define REG01CN_VBSTAT__SET       0x40 ///< VBUS signal currently present (device attached to
C51 COMPILER V9.56.0.0   UART_0                                                            10/28/2016 17:37:02 PAGE 90  

3879      =2                                         ///< USB network).                                    
3880      =2                                                                                               
3881      =2  #define REG01CN_REG0DIS__BMASK    0x80 ///< Voltage Regulator (REG0) Disable                 
3882      =2  #define REG01CN_REG0DIS__SHIFT    0x07 ///< Voltage Regulator (REG0) Disable                 
3883      =2  #define REG01CN_REG0DIS__ENABLED  0x00 ///< Enable the VREG0 Voltage Regulator.              
3884      =2  #define REG01CN_REG0DIS__DISABLED 0x80 ///< Disable the VREG0 Voltage Regulator.             
3885      =2                                                                                               
3886      =2  //------------------------------------------------------------------------------
3887      =2  // EMI0CF Enums (External Memory Configuration @ 0x85)
3888      =2  //------------------------------------------------------------------------------
3889      =2  #define EMI0CF_EALE__FMASK                    0x03 ///< ALE Pulse-Width Select                            
3890      =2  #define EMI0CF_EALE__SHIFT                    0x00 ///< ALE Pulse-Width Select                            
3891      =2  #define EMI0CF_EALE__1_CLOCK                  0x00 ///< ALE high and ALE low pulse width = 1 SYSCLK cycle.
3892      =2  #define EMI0CF_EALE__2_CLOCKS                 0x01 ///< ALE high and ALE low pulse width = 2 SYSCLK       
3893      =2                                                     ///< cycles.                                           
3894      =2  #define EMI0CF_EALE__3_CLOCKS                 0x02 ///< ALE high and ALE low pulse width = 3 SYSCLK       
3895      =2                                                     ///< cycles.                                           
3896      =2  #define EMI0CF_EALE__4_CLOCKS                 0x03 ///< ALE high and ALE low pulse width = 4 SYSCLK       
3897      =2                                                     ///< cycles.                                           
3898      =2                                                                                                            
3899      =2  #define EMI0CF_EMD__FMASK                     0x0C ///< EMIF Operating Mode Select                        
3900      =2  #define EMI0CF_EMD__SHIFT                     0x02 ///< EMIF Operating Mode Select                        
3901      =2  #define EMI0CF_EMD__INTERNAL_ONLY             0x00 ///< Internal Only: MOVX accesses on-chip XRAM only.   
3902      =2                                                     ///< All effective addresses alias to on-chip memory   
3903      =2                                                     ///< space.                                            
3904      =2  #define EMI0CF_EMD__SPLIT_WITHOUT_BANK_SELECT 0x04 ///< Split Mode without Bank Select: Accesses below the
3905      =2                                                     ///< internal XRAM boundary are directed on-chip.      
3906      =2                                                     ///< Accesses above the internal XRAM boundary are     
3907      =2                                                     ///< directed off-chip. 8-bit off-chip MOVX operations 
3908      =2                                                     ///< use the current contents of the Address high port 
3909      =2                                                     ///< latches to resolve the upper address byte. To     
3910      =2                                                     ///< access off chip space, EMI0CN must be set to a    
3911      =2                                                     ///< page that is not contained in the on-chip address 
3912      =2                                                     ///< space.                                            
3913      =2  #define EMI0CF_EMD__SPLIT_WITH_BANK_SELECT    0x08 ///< Split Mode with Bank Select: Accesses below the   
3914      =2                                                     ///< internal XRAM boundary are directed on-chip.      
3915      =2                                                     ///< Accesses above the internal XRAM boundary are     
3916      =2                                                     ///< directed off-chip. 8-bit off-chip MOVX operations 
3917      =2                                                     ///< uses the contents of EMI0CN to determine the high-
3918      =2                                                     ///< byte of the address.                              
3919      =2  #define EMI0CF_EMD__EXTERNAL_ONLY             0x0C ///< External Only: MOVX accesses off-chip XRAM only.  
3920      =2                                                     ///< On-chip XRAM is not visible to the core.          
3921      =2                                                                                                            
3922      =2  #define EMI0CF_MUXMD__BMASK                   0x10 ///< EMIF Multiplex Mode Select                        
3923      =2  #define EMI0CF_MUXMD__SHIFT                   0x04 ///< EMIF Multiplex Mode Select                        
3924      =2  #define EMI0CF_MUXMD__MULTIPLEXED             0x00 ///< EMIF operates in multiplexed address/data mode.   
3925      =2  #define EMI0CF_MUXMD__NON_MULTIPLEXED         0x10 ///< EMIF operates in non-multiplexed mode (separate   
3926      =2                                                     ///< address and data pins).                           
3927      =2                                                                                                            
3928      =2  #define EMI0CF_USBFAE__BMASK                  0x40 ///< USB FIFO Access Enable                            
3929      =2  #define EMI0CF_USBFAE__SHIFT                  0x06 ///< USB FIFO Access Enable                            
3930      =2  #define EMI0CF_USBFAE__FIFO_ACCESS_DISABLED   0x00 ///< USB FIFO RAM not available through MOVX           
3931      =2                                                     ///< instructions.                                     
3932      =2  #define EMI0CF_USBFAE__FIFO_ACCESS_ENABLED    0x40 ///< USB FIFO RAM available using MOVX instructions.   
3933      =2                                                     ///< The 1 KB of USB RAM will be mapped in XRAM space  
3934      =2                                                     ///< at addresses 0x0400 to 0x07FF. The USB clock must 
3935      =2                                                     ///< be active and greater than or equal to twice the  
3936      =2                                                     ///< SYSCLK (USBCLK > 2 x SYSCLK) to access this area  
3937      =2                                                     ///< with MOVX instructions.                           
3938      =2                                                                                                            
3939      =2  //------------------------------------------------------------------------------
3940      =2  // EMI0CN Enums (External Memory Interface Control @ 0xAA)
C51 COMPILER V9.56.0.0   UART_0                                                            10/28/2016 17:37:02 PAGE 91  

3941      =2  //------------------------------------------------------------------------------
3942      =2  #define EMI0CN_PGSEL__FMASK 0xFF ///< XRAM Page Select
3943      =2  #define EMI0CN_PGSEL__SHIFT 0x00 ///< XRAM Page Select
3944      =2                                                        
3945      =2  //------------------------------------------------------------------------------
3946      =2  // EMI0TC Enums (External Memory Timing Control @ 0x84)
3947      =2  //------------------------------------------------------------------------------
3948      =2  #define EMI0TC_AHOLD__FMASK      0x03 ///< EMIF Address Hold Time                      
3949      =2  #define EMI0TC_AHOLD__SHIFT      0x00 ///< EMIF Address Hold Time                      
3950      =2  #define EMI0TC_AHOLD__0_CLOCKS   0x00 ///< Address hold time = 0 SYSCLK cycles.        
3951      =2  #define EMI0TC_AHOLD__1_CLOCK    0x01 ///< Address hold time = 1 SYSCLK cycle.         
3952      =2  #define EMI0TC_AHOLD__2_CLOCKS   0x02 ///< Address hold time = 2 SYSCLK cycles.        
3953      =2  #define EMI0TC_AHOLD__3_CLOCKS   0x03 ///< Address hold time = 3 SYSCLK cycles.        
3954      =2                                                                                         
3955      =2  #define EMI0TC_PWIDTH__FMASK     0x3C ///< EMIF /WR and /RD Pulse-Width Control        
3956      =2  #define EMI0TC_PWIDTH__SHIFT     0x02 ///< EMIF /WR and /RD Pulse-Width Control        
3957      =2  #define EMI0TC_PWIDTH__1_CLOCK   0x00 ///< /WR and /RD pulse width is 1 SYSCLK cycle.  
3958      =2  #define EMI0TC_PWIDTH__2_CLOCKS  0x04 ///< /WR and /RD pulse width is 2 SYSCLK cycles. 
3959      =2  #define EMI0TC_PWIDTH__3_CLOCKS  0x08 ///< /WR and /RD pulse width is 3 SYSCLK cycles. 
3960      =2  #define EMI0TC_PWIDTH__4_CLOCKS  0x0C ///< /WR and /RD pulse width is 4 SYSCLK cycles. 
3961      =2  #define EMI0TC_PWIDTH__5_CLOCKS  0x10 ///< /WR and /RD pulse width is 5 SYSCLK cycles. 
3962      =2  #define EMI0TC_PWIDTH__6_CLOCKS  0x14 ///< /WR and /RD pulse width is 6 SYSCLK cycles. 
3963      =2  #define EMI0TC_PWIDTH__7_CLOCKS  0x18 ///< /WR and /RD pulse width is 7 SYSCLK cycles. 
3964      =2  #define EMI0TC_PWIDTH__8_CLOCKS  0x1C ///< /WR and /RD pulse width is 8 SYSCLK cycles. 
3965      =2  #define EMI0TC_PWIDTH__9_CLOCKS  0x20 ///< /WR and /RD pulse width is 9 SYSCLK cycles. 
3966      =2  #define EMI0TC_PWIDTH__10_CLOCKS 0x24 ///< /WR and /RD pulse width is 10 SYSCLK cycles.
3967      =2  #define EMI0TC_PWIDTH__11_CLOCKS 0x28 ///< /WR and /RD pulse width is 11 SYSCLK cycles.
3968      =2  #define EMI0TC_PWIDTH__12_CLOCKS 0x2C ///< /WR and /RD pulse width is 12 SYSCLK cycles.
3969      =2  #define EMI0TC_PWIDTH__13_CLOCKS 0x30 ///< /WR and /RD pulse width is 13 SYSCLK cycles.
3970      =2  #define EMI0TC_PWIDTH__14_CLOCKS 0x34 ///< /WR and /RD pulse width is 14 SYSCLK cycles.
3971      =2  #define EMI0TC_PWIDTH__15_CLOCKS 0x38 ///< /WR and /RD pulse width is 15 SYSCLK cycles.
3972      =2  #define EMI0TC_PWIDTH__16_CLOCKS 0x3C ///< /WR and /RD pulse width is 16 SYSCLK cycles.
3973      =2                                                                                         
3974      =2  #define EMI0TC_ASETUP__FMASK     0xC0 ///< EMIF Address Setup Time                     
3975      =2  #define EMI0TC_ASETUP__SHIFT     0x06 ///< EMIF Address Setup Time                     
3976      =2  #define EMI0TC_ASETUP__0_CLOCKS  0x00 ///< Address setup time = 0 SYSCLK cycles.       
3977      =2  #define EMI0TC_ASETUP__1_CLOCK   0x40 ///< Address setup time = 1 SYSCLK cycle.        
3978      =2  #define EMI0TC_ASETUP__2_CLOCKS  0x80 ///< Address setup time = 2 SYSCLK cycles.       
3979      =2  #define EMI0TC_ASETUP__3_CLOCKS  0xC0 ///< Address setup time = 3 SYSCLK cycles.       
3980      =2                                                                                         
3981      =2  #endif // SI_EFM8UB2_REGISTER_ENUMS_H
3982      =2  //-eof--------------------------------------------------------------------------
3983      =2  
  12      =1  
  13      =1  /**************************************************************************//**
  14      =1   *@addtogroup uart_0 UART0 Driver
  15      =1   *@{
  16      =1   *
  17      =1   *@brief Peripheral driver for uart0
  18      =1   *
  19      =1   * # Introduction #
  20      =1   *
  21      =1   * This module contains all the driver content for UART0
  22      =1   *
  23      =1   * ### Memory Usage ###
  24      =1   *
  25      =1   * The table below shows the memory consumption of the library with various
  26      =1   * options. The 'default' entry shows the consumption when most or all available
  27      =1   * functions are called. Typical consumption is expected to be less than this
  28      =1   * since there are normally many uncalled functions that will consume no
  29      =1   * resources.
  30      =1   *
C51 COMPILER V9.56.0.0   UART_0                                                            10/28/2016 17:37:02 PAGE 92  

  31      =1   * @note It is possible for memory usage to exceed the listed values in rare cases
  32      =1   *
  33      =1   * | condition          | CODE | XRAM | IRAM | RAM |
  34      =1   * |--------------------|------|------|------|-----|
  35      =1   * |USE                 |  295 |    6 |    0 |   0 |
  36      =1   * |STDIO               |   20 |    0 |    0 |   0 |
  37      =1   *
  38      =1   * # Theory of Operation #
  39      =1   *
  40      =1   * The UART driver provides several levels of functionality. Higher level
  41      =1   * functionality is more user friendly but also less broadly applicable.
  42      =1   *
  43      =1   * ### Buffered Api ###
  44      =1   *
  45      =1   * The driver provides high level functions for transferring a buffer of data.
  46      =1   * This functionality is made available by setting EFM8PDL_UART0_USE_BUFFER
  47      =1   * to 1.
  48      =1   *
  49      =1   * This functionality relies on the UART0 interrupt to function and the
  50      =1   * library provides the ISR for that interrupt.
  51      =1   *
  52      =1   * For data transmission the user provides a data buffer and the length of that
  53      =1   * buffer. The driver will then transmit the entire buffer before issuing an
  54      =1   * end-of-transfer callback.
  55      =1   *
  56      =1   * In the following example we implement a ping-pong transmission.
  57      =1   *
  58      =1   * ~~~~~.c
  59      =1   * SI_SEGMENT_VARIABLE(bufferA[32], uint8_t, SI_SEG_XDATA);
  60      =1   * SI_SEGMENT_VARIABLE(bufferB[32], uint8_t, SI_SEG_XDATA);
  61      =1   * SI_VARIABLE_SEGMENT_POINTER(curBuffer, uint8_t, SI_SEG_XDATA);
  62      =1   * bool targetA;
  63      =1   *
  64      =1   * // Some other code pushes data to curBuffer and handles
  65      =1   * // kicking the transfer with an initial call to writeBuffer
  66      =1   *
  67      =1   * //when current transfer is complete send switch ping-pong
  68      =1   * //  and send all data accumulated in the other buffer.
  69      =1   * //  If no data is ready in other buffer we will write
  70      =1   * void UART0_transmitCompleteCb()
  71      =1   * {
  72      =1   *   if(targetA)
  73      =1   *   {
  74      =1   *     //Don't transmit if no data is available
  75      =1   *     if(curBuffer == bufferA)
  76      =1   *     {
  77      =1   *       //Some code to mark that the transfer is stalled
  78      =1   *       return;
  79      =1   *     }
  80      =1   *
  81      =1   *     // Send all data in A and start accumulating in B
  82      =1   *     UART0_writeBuffer(bufferA, curBuffer - bufferA);
  83      =1   *     curBuffer = bufferB;
  84      =1   *     targetA = false;
  85      =1   *   }
  86      =1   *   else
  87      =1   *   {
  88      =1   *     //Don't transmit if no data is available
  89      =1   *     if(curBuffer == bufferA)
  90      =1   *     {
  91      =1   *       //Some code to mark that the transfer is stalled
  92      =1   *       return;
C51 COMPILER V9.56.0.0   UART_0                                                            10/28/2016 17:37:02 PAGE 93  

  93      =1   *     }
  94      =1   *
  95      =1   *     //send all data in B and start accumulating in A
  96      =1   *     UART0_writeBuffer(bufferA, curBuffer - bufferA);
  97      =1   *     curBuffer = bufferA;
  98      =1   *     targetA = true;
  99      =1   *   }
 100      =1   * }
 101      =1   * ~~~~~
 102      =1   *
 103      =1   * For reception the user provides a buffer and it's size. The library will
 104      =1   * receive data into the buffer until it is full and then call the user
 105      =1   * back. The user may query the number of bytes remaining in the buffer at
 106      =1   * any time if they wish to process data before the buffer is full.
 107      =1   *
 108      =1   * This example provides ping-pong reception.
 109      =1   *
 110      =1   * ~~~~~.c
 111      =1   * SI_SEGMENT_VARIABLE(bufferA[32], uint8_t, SI_SEG_XDATA);
 112      =1   * SI_SEGMENT_VARIABLE(bufferB[32], uint8_t, SI_SEG_XDATA);
 113      =1   * SI_VARIABLE_SEGMENT_POINTER(curBuffer, uint8_t, SI_SEG_XDATA);
 114      =1   * SI_VARIABLE_SEGMENT_POINTER(dataReady, uint8_t, SI_SEG_XDATA);
 115      =1   * bool targetA;
 116      =1   *
 117      =1   * //Here the main loop handles stuff
 118      =1   * void main()
 119      =1   * {
 120      =1   *   //other initialization
 121      =1   *   UART0_readBuffer(bufferA, 32);
 122      =1   *   targetA = true;
 123      =1   *
 124      =1   *    while(1)
 125      =1   *    {
 126      =1   *      if(dataReady != NULL)
 127      =1   *      {
 128      =1   *        //process data
 129      =1   *        dataReady = NULL;
 130      =1   *      }
 131      =1   *    }
 132      =1   *  }
 133      =1   *
 134      =1   *  // When the current buffer is full inform the main loop it's
 135      =1   *  //ready for processing and switch to the other buffer
 136      =1   *  void UART0_receiveCompleteCb()
 137      =1   *  {
 138      =1   *    if(targetA)
 139      =1   *    {
 140      =1   *      datReady = bufferA;
 141      =1   *      UART0_readBuffer(bufferB, 32);
 142      =1   *      targetA = false;
 143      =1   *    }
 144      =1   *    else
 145      =1   *    {
 146      =1   *      datReady = bufferB;
 147      =1   *      UART0_readBuffer(bufferA, 32);
 148      =1   *      targetA = true;
 149      =1   *    }
 150      =1   *  }
 151      =1   * ~~~~~
 152      =1   *
 153      =1   * ### STDIO Api ###
 154      =1   * On of the simplest use cases is using UART 0 to stdio data. The driver
C51 COMPILER V9.56.0.0   UART_0                                                            10/28/2016 17:37:02 PAGE 94  

 155      =1   * provides a standard blocking implementation accessed by setting
 156      =1   * EFM8PDL_UART0_USE_STDIO.
 157      =1   *
 158      =1   * When this is in use no other functions are available.
 159      =1   *
 160      =1   * When this is in use calls to printf will block until the entire string
 161      =1   * has been transmitted on the uart.
 162      =1   *
 163      =1   * ### Runtime & Initialization API ###
 164      =1   *
 165      =1   * The final option is to use the runtime and initialization api to implement
 166      =1   * a custom uart driver.
 167      =1   *
 168      =1   * The reference manual should be consulted for a full understanding of how
 169      =1   * the block operates in order to use the Runtime api correctly.
 170      =1   *
 171      =1   * ### Hardware Configuration ###
 172      =1   *
 173      =1   * This Driver provides a basic level of configuration through the API. However
 174      =1   * use of the Simplicity Hardware Configuration tool is highly recommended.
 175      =1   *
 176      =1   *****************************************************************************/
 177      =1  
 178      =1  //Option macro documentation
 179      =1  /**************************************************************************//**
 180      =1   * @addtogroup uart0_config Driver Configuration
 181      =1   * @{
 182      =1   *  
 183      =1   * @brief
 184      =1   * Driver configuration constants read from SI_EFM8UB2_Defs.h
 185      =1   * 
 186      =1   * This peripheral driver will look for configuration constants in
 187      =1   * **SI_EFM8UB2_Defs.h**. This file is provided/written by the user and should be
 188      =1   * located in a directory that is part of the include path.
 189      =1   *  
 190      =1   ******************************************************************************/
 191      =1  
 192      =1  /**************************************************************************//**
 193      =1   * @def EFM8PDL_UART0_USE_STDIO
 194      =1   * @brief
 195      =1   * Controls the inclusion of putchar and setchar for use with printf/scanf.
 196      =1   *
 197      =1   * When '1' blocking implementations of putchar and set char are defined. This option
 198      =1   * is intended to be use in place of all other options. If EFM8PDL_UART0_USE_STDIO
 199      =1   * is '1' then EFM8PDL_UART0_USE should be 0 and the UART 0 peripheral driver should
 200      =1   * not be called by the user directly accept for the initial setup.
 201      =1   *
 202      =1   * The putchar implementation provides an initialization function to prime the TX transfer
 203      =1   * and configure the UART for receive and transmit. This function should be called immediately
 204      =1   * after device configuration and before any printf or scanf calls.
 205      =1   *
 206      =1   * Default setting is '0' and may be overridden by defining in 'SI_EFM8UB2_Defs.h'.
 207      =1   *
 208      =1   *****************************************************************************/
 209      =1  
 210      =1  /**************************************************************************//**
 211      =1   * @def EFM8PDL_UART0_USE_BUFFER
 212      =1   * @brief
 213      =1   * Controls inclusion of UART0 Buffer Access API.
 214      =1   *
 215      =1   * When '1' the UART0 Buffered Access API is included in the driver.
 216      =1   *
C51 COMPILER V9.56.0.0   UART_0                                                            10/28/2016 17:37:02 PAGE 95  

 217      =1   * Default setting is '1' and may be overridden by defining in 'SI_EFM8UB2_Defs.h'.
 218      =1   *
 219      =1   *****************************************************************************/
 220      =1  
 221      =1  /**************************************************************************//**
 222      =1   * @addtogroup uart0_config_buffered Buffered API Options
 223      =1   * @{
 224      =1   *****************************************************************************/
 225      =1  
 226      =1  /**************************************************************************//**
 227      =1   * @def EFM8PDL_UART0_RX_BUFTYPE
 228      =1   * @brief Controls the type of pointer used for buffered receives.
 229      =1   *
 230      =1   * Sets the memory segment for the rx data buffer pointer when EFM8PDL_UART0_USE_BUFFER is '1'
 231      =1   * valid values are:
 232      =1   *
 233      =1   * - SI_SEG_XDATA (default)
 234      =1   * - SI_SEG_PDATA
 235      =1   * - SI_SEG_IDATA
 236      =1   * - SI_SEG_CODE
 237      =1   * - SI_SEG_GENERIC
 238      =1   *
 239      =1   * @warning:
 240      =1   * Use of generic pointers will adversely effect the size and performance
 241      =1   * of the buffering functions.
 242      =1   *
 243      =1   *****************************************************************************/
 244      =1  
 245      =1  /**************************************************************************//**
 246      =1   * @def EFM8PDL_UART0_TX_BUFTYPE
 247      =1   * @brief Controls the type of pointer used for buffered transmits.
 248      =1   *
 249      =1   * Sets the memory segment for the tx data buffer pointer when EFM8PDL_UART0_USE_BUFFER is '1'
 250      =1   * valid values are:
 251      =1   *
 252      =1   * - SI_SEG_XDATA (default)
 253      =1   * - SI_SEG_PDATA
 254      =1   * - SI_SEG_IDATA
 255      =1   * - SI_SEG_CODE
 256      =1   * - SI_SEG_GENERIC
 257      =1   *
 258      =1   *****************************************************************************/
 259      =1  
 260      =1  /** @} (end addtogroup uart0_config_buffered Buffered API Optionsn) */
 261      =1  /** @} (end addtogroup uart0_config Driver Configuration) */
 262      =1  
 263      =1  // Option macro default values
 264      =1  #ifndef IS_DOXYGEN
 265      =1    #define IS_DOXYGEN 0
 266      =1  #endif
 267      =1  
 268      =1  #ifndef EFM8PDL_UART0_USE_STDIO
 269      =1  #define EFM8PDL_UART0_USE_STDIO 0
 270      =1  #endif
 271      =1  #ifndef EFM8PDL_UART0_USE_BUFFER
 272      =1    #if (!EFM8PDL_UART0_USE_STDIO)
 273      =1      #define EFM8PDL_UART0_USE_BUFFER 1 // buffer mode by default unless user has already selected one of t
             -he others
 274      =1    #else
           =1     #define EFM8PDL_UART0_USE_BUFFER 0 // buffer mode by default unless user has already selected one of t
             -he others
           =1   #endif
C51 COMPILER V9.56.0.0   UART_0                                                            10/28/2016 17:37:02 PAGE 96  

 277      =1  #endif
 278      =1  #ifndef EFM8PDL_UART0_TX_BUFTYPE
 279      =1  #define EFM8PDL_UART0_TX_BUFTYPE SI_SEG_XDATA
 280      =1  #endif
 281      =1  #ifndef EFM8PDL_UART0_RX_BUFTYPE
 282      =1  #define EFM8PDL_UART0_RX_BUFTYPE SI_SEG_XDATA
 283      =1  #endif
 284      =1  
 285      =1  // Runtime API
 286      =1  /**************************************************************************//**
 287      =1   * @addtogroup uart0_runtime UART0 Runtime API
 288      =1   * @{
 289      =1   *****************************************************************************/
 290      =1  
 291      =1  /**************************************************************************//**
 292      =1   * @addtogroup uart0_if Interrupt Flag Enums
 293      =1   * @{
 294      =1   *****************************************************************************/
 295      =1  #define UART0_TX_IF SCON0_TI__BMASK /**< UART0 TX Interrupt */
 296      =1  #define UART0_RX_IF SCON0_RI__BMASK /**< UART0 RX Interrupt  */
 297      =1  /** @} (end addtogroup uart0_if Interrupt Flag Enums) */
 298      =1  
 299      =1  /***************************************************************************//**
 300      =1   * @brief
 301      =1   * Return the value of the specified interrupt flag.
 302      =1   *
 303      =1   * @return
 304      =1   * The state of the flags. This value is the OR of all flags which are set.
 305      =1   *
 306      =1   * ~~~~~.c
 307      =1   * if(UART0_getIntFlags() & UART_TX_IF)
 308      =1   * {
 309      =1   *   //do something
 310      =1   * }
 311      =1   *
 312      =1   * uint8_t value = UART0_getIntFlags();
 313      =1   * if(value)
 314      =1   * {
 315      =1   *   //do some stuff that needs to be done for RX and TX
 316      =1   *   if (value & UART_RX_IF)
 317      =1   *   {
 318      =1   *     //Do stuff that only needs to be done for RX
 319      =1   *   }
 320      =1   * }
 321      =1   * ~~~~~
 322      =1   *
 323      =1   * Valid flags can be found in the Interrupt Flag Enums group.
 324      =1   *
 325      =1   *****************************************************************************/
 326      =1  uint8_t UART0_getIntFlags();
 327      =1  
 328      =1  /***************************************************************************//**
 329      =1   * @brief
 330      =1   * Clear the specified interrupt flag.
 331      =1   *
 332      =1   * @param flag:
 333      =1   * Flag to clear. Multiple flags can be cleared by OR-ing the flags.
 334      =1   *
 335      =1   * Valid flags can be found in the Interrupt Flag Enums group.
 336      =1   *
 337      =1   ******************************************************************************/
 338      =1  void UART0_clearIntFlags(uint8_t flag);
C51 COMPILER V9.56.0.0   UART_0                                                            10/28/2016 17:37:02 PAGE 97  

 339      =1  
 340      =1  /***************************************************************************//**
 341      =1   * @brief
 342      =1   * Sets the TX complete interrupt flag.
 343      =1   *
 344      =1   * It is common to operate the UART in polling mode where the procedure for
 345      =1   * transmitting a byte is to block till TX is complete and then clear the flag
 346      =1   * and write to SBUF. For these cases it is necessary to manually set the TX bit
 347      =1   * to initialize the UART.
 348      =1   *
 349      =1   ******************************************************************************/
 350      =1  void UART0_initTxPolling();
 351      =1  
 352      =1  /***************************************************************************//**
 353      =1   * @brief
 354      =1   * Write 8 bits to the UART to be transmitted.
 355      =1   *
 356      =1   * @param value:
 357      =1   * Data to be transmitted.
 358      =1   *
 359      =1   * If the UART already has data pending transmission it will be overwritten.
 360      =1   *
 361      =1   ******************************************************************************/
 362      =1  void UART0_write(uint8_t value);
 363      =1  
 364      =1  /***************************************************************************//**
 365      =1   * @brief
 366      =1   * Read the last received byte from UART.
 367      =1   *
 368      =1   * @return
 369      =1   * The most recent byte read by the UART.
 370      =1   *
 371      =1   ******************************************************************************/
 372      =1  uint8_t UART0_read(void);
 373      =1  
 374      =1  /***************************************************************************//**
 375      =1   * @brief
 376      =1   * Write the a byte to the UART with an extra bit.
 377      =1   *
 378      =1   * @param value:
 379      =1   * Data to transmit.
 380      =1   *
 381      =1   * Data[9] should contain the value of the extra bit.
 382      =1   *
 383      =1   ******************************************************************************/
 384      =1  void UART0_writeWithExtraBit(uint16_t value);
 385      =1  
 386      =1  /***************************************************************************//**
 387      =1   * @brief
 388      =1   * Read a byte from the UART with an extra bit.
 389      =1   *
 390      =1   * @return
 391      =1   * The last byte received with data[9] set to the value of the extra bit.
 392      =1   *
 393      =1   ******************************************************************************/
 394      =1  uint16_t UART0_readWithExtraBit(void);
 395      =1  /** @} (end addtogroup uart0_runtime UART0 Runtime API) */
 396      =1  
 397      =1  // Initialization API
 398      =1  /***************************************************************************//**
 399      =1   * @addtogroup uart0_init UART0 Initialization API
 400      =1   * @{
C51 COMPILER V9.56.0.0   UART_0                                                            10/28/2016 17:37:02 PAGE 98  

 401      =1   ******************************************************************************/
 402      =1  
 403      =1  /// UART transfer width enums.
 404      =1  typedef enum
 405      =1  {
 406      =1    UART0_WIDTH_8 = SCON0_SMODE__8_BIT, //!< UART in 8-bit mode.
 407      =1    UART0_WIDTH_9 = SCON0_SMODE__9_BIT, //!< UART in 9-bit mode.
 408      =1  } UART0_Width_t;
 409      =1  
 410      =1  /// UART Multiprocessor support enums.
 411      =1  typedef enum
 412      =1  {
 413      =1    UART0_MULTIPROC_DISABLE = SCON0_MCE__MULTI_DISABLED, //!< UART Multiprocessor communication Disabled.
 414      =1    UART0_MULTIPROC_ENABLE  = SCON0_MCE__MULTI_ENABLED,  //!< UART Multiprocessor communication Enabled.
 415      =1  } UART0_Multiproc_t;
 416      =1  
 417      =1  /// UART RX support enums
 418      =1  typedef enum
 419      =1  {
 420      =1    UART0_RX_ENABLE  = SCON0_REN__RECEIVE_ENABLED,   //!< UART Receive Enabled.
 421      =1    UART0_RX_DISABLE = SCON0_REN__RECEIVE_DISABLED,  //!< UART Receive Disabled.
 422      =1  } UART0_RxEnable_t;
 423      =1  
 424      =1  /***************************************************************************//**
 425      =1   * @brief
 426      =1   * Initialize the UART
 427      =1   *
 428      =1   * @param rxen:
 429      =1   * Receive enable status.
 430      =1   * @param width:
 431      =1   * Data word width.
 432      =1   * @param mce:
 433      =1   * Multiprocessor mode status.
 434      =1   *
 435      =1   ******************************************************************************/
 436      =1  void UART0_init(UART0_RxEnable_t rxen, UART0_Width_t width, UART0_Multiproc_t mce);
 437      =1  
 438      =1  /***************************************************************************//**
 439      =1   * @brief
 440      =1   * Restore the UART to it's uninitialized (reset) state.
 441      =1   *
 442      =1   ******************************************************************************/
 443      =1  void UART0_reset();
 444      =1  
 445      =1  /** @} (end uart0_init UART0 Initialization API) */
 446      =1  
 447      =1  // Buffer API
 448      =1  /**************************************************************************//**
 449      =1   * @addtogroup uart0_buffer UART0 Buffer Access API
 450      =1   * @{
 451      =1   *****************************************************************************/
 452      =1  #if (EFM8PDL_UART0_USE_BUFFER == 1) || IS_DOXYGEN
 453      =1  
 454      =1  /***************************************************************************//**
 455      =1   * @brief
 456      =1   * Transmit a buffer of data via UART.
 457      =1   *
 458      =1   * @param[in] buffer:
 459      =1   * Pointer to buffer of data to be transmitted.
 460      =1   * @param length:
 461      =1   * Number of bytes in transfer to be transmitted.
 462      =1   *
C51 COMPILER V9.56.0.0   UART_0                                                            10/28/2016 17:37:02 PAGE 99  

 463      =1   * Buffer transfers support only 8-bit wide transfers.
 464      =1   *
 465      =1   ******************************************************************************/
 466      =1  void UART0_writeBuffer(SI_VARIABLE_SEGMENT_POINTER(buffer,
 468      =1                                                  uint8_t,
 468      =1                                                  EFM8PDL_UART0_TX_BUFTYPE),
 469      =1                                                  uint8_t length);
 470      =1  
 471      =1  /***************************************************************************//**
 472      =1   * @brief
 473      =1   * Receive a buffer of data via UART.
 474      =1   *
 475      =1   * @param[out] buffer:
 476      =1   * Pointer to buffer of data to be transmitted.
 477      =1   * @param length:
 478      =1   * Number of bytes in transfer to be transmitted.
 479      =1   *
 480      =1   * Buffered transfers support only 8-bit words.
 481      =1   *
 482      =1   ******************************************************************************/
 483      =1  void UART0_readBuffer(SI_VARIABLE_SEGMENT_POINTER(buffer,
 485      =1                                                 uint8_t,
 485      =1                                                 EFM8PDL_UART0_RX_BUFTYPE),
 486      =1                                                 uint8_t length);
 487      =1  
 488      =1  /***************************************************************************//**
 489      =1   * @brief
 490      =1   * Abort current buffer transmission.
 491      =1   *
 492      =1   * Data already moved into the UART will finish transmission. No more
 493      =1   * data will be pulled out of the TX buffer.
 494      =1   *
 495      =1   ******************************************************************************/
 496      =1  void UART0_abortWrite();
 497      =1  
 498      =1  /***************************************************************************//**
 499      =1   * @brief
 500      =1   * Abort current buffer reception.
 501      =1   *
 502      =1   * No more data will be written to the RX buffer.
 503      =1   *
 504      =1   ******************************************************************************/
 505      =1  void UART0_abortRead();
 506      =1  
 507      =1  /***************************************************************************//**
 508      =1   * @brief
 509      =1   * Return the number of bytes remaining in the TX buffer.
 510      =1   *
 511      =1   * @return
 512      =1   * number of btyes remaining in TX buffer. 0 if no transfer is in progress.
 513      =1   *
 514      =1   * @retur
 515      =1   * 0 if transfer is not in progress.
 516      =1   *
 517      =1   ******************************************************************************/
 518      =1  uint8_t UART0_txBytesRemaining();
 519      =1  
 520      =1  /***************************************************************************//**
 521      =1   * @brief
 522      =1   * Return the number of bytes remaining in the RX buffer.
 523      =1   *
 524      =1   * @return
C51 COMPILER V9.56.0.0   UART_0                                                            10/28/2016 17:37:02 PAGE 100 

 525      =1   * number of btyes remaining in RX buffer. 0 if no transfer is in progress.
 526      =1   *
 527      =1   ******************************************************************************/
 528      =1  uint8_t UART0_rxBytesRemaining();
 529      =1  /** @} (end uart0_buffer UART0 Buffer Access API) */
 530      =1  
 531      =1  /**************************************************************************//**
 532      =1   * @def void UART0_ISR()
 533      =1   * @brief UART0 Interrupt handler.
 534      =1   *
 535      =1   * This callback is implemented inside the driver if EFM8PDL_UART0_USE_BUFFER is set
 536      =1   * otherwise the user must implement the ISR.
 537      =1   *
 538      =1   *****************************************************************************/
 539      =1  #endif // EFM8PDL_UART0_USE_BUFFER
 540      =1  
 541      =1  // Callbacks
 542      =1  /**************************************************************************//**
 543      =1   * @addtogroup uart0_callbacks User Callbacks
 544      =1   * @{
 545      =1   *****************************************************************************/
 546      =1  
 547      =1  /**************************************************************************//**
 548      =1   * @addtogroup uart0_callbacks_buffer Buffer Access API
 549      =1   * @{
 550      =1   *
 551      =1   * These callbacks will be called by the library when
 552      =1   * EFM8PDL_UART0_USE_BUFFER. If the Buffered Access API is disabled
 553      =1   * the callbacks do not need to be provided by the user.
 554      =1   *
 555      =1   *****************************************************************************/
 556      =1  #if (EFM8PDL_UART0_USE_BUFFER == 1) || IS_DOXYGEN
 557      =1  
 558      =1  /***************************************************************************//**
 559      =1   * @brief
 560      =1   * Callback for reception of byte.
 561      =1   *
 562      =1   * This function is called when all expected bytes have been received.
 563      =1   *
 564      =1   * @warning
 565      =1   * This function is called from an ISR and should be as short as possible.
 566      =1   *
 567      =1   ******************************************************************************/
 568      =1  void UART0_receiveCompleteCb();
 569      =1  
 570      =1  /***************************************************************************//**
 571      =1   * @brief
 572      =1   * Callback for transmission of a byte.
 573      =1   *
 574      =1   * This function is called when all bytes in the buffer have been transferred.
 575      =1   *
 576      =1   * @warning
 577      =1   * This function is called from an ISR and should be as short as possible.
 578      =1   *
 579      =1   ******************************************************************************/
 580      =1  void UART0_transmitCompleteCb();
 581      =1  
 582      =1  #endif //EFM8PDL_UART0_USE_BUFFER
 583      =1  /** @} (end uart0_callbacks_buffer Buffer Access API) */
 584      =1  /** @} (end uart0_callbacks User Callbacks) */
 585      =1  
 586      =1  
C51 COMPILER V9.56.0.0   UART_0                                                            10/28/2016 17:37:02 PAGE 101 

 587      =1  // STIDO API
 588      =1  /**************************************************************************//**
 589      =1   * @addtogroup uart0_stdio UART0 STDIO API
 590      =1   * @{
 591      =1   *
 592      =1   * This API is intended to be used in place of all other uart driver
 593      =1   * API's and will assume control of the uart.
 594      =1   *
 595      =1   * @warning
 596      =1   * This implementation is blocking and may hang the MCU under certain
 597      =1   * conditions.
 598      =1   *
 599      =1   ******************************************************************************/
 600      =1  #if (EFM8PDL_UART0_USE_STDIO == 1) || IS_DOXYGEN
           =1 
           =1 /***************************************************************************//**
           =1  * @brief
           =1  * Initializes uart for STDIO operation.
           =1  *
           =1  * This function sets up the uart for use by printf/scanif. It must be called
           =1  * once durring device initialization **before** using STDIO.
           =1  *
           =1  ******************************************************************************/
           =1 void UART0_initStdio();
           =1 
           =1 #endif //EFM8PDL_UART0_USE_STDIO
 613      =1  /** @} (end uart0_stdio UART0 STDIO API) */
 614      =1  /** @} (end uart_0 UART0 Driver) */
 615      =1  #endif //__UART_0_H__
   8          
   9          uint8_t UART0_getIntFlags()
  10          {
  11   1        return SCON0 & (UART0_TX_IF | UART0_RX_IF);
  12   1      }
  13          
  14          void UART0_clearIntFlags(uint8_t flag)
  15          {
  16   1        SCON0 &= ~(flag);
  17   1      }
  18          
  19          void UART0_initTxPolling()
  20          {
  21   1        SCON0_TI = 1;
  22   1      }
  23          
  24          void UART0_write(uint8_t value)
  25          {
  26   1        SBUF0 = value;
  27   1      }
  28          
  29          uint8_t UART0_read(void)
  30          {
  31   1        return SBUF0;
  32   1      }
  33          void UART0_writeWithExtraBit(uint16_t value)
  34          {
  35   1        SCON0_TB8 = value >> 8;
  36   1        SBUF0 = value;
  37   1      }
  38          
  39          uint16_t UART0_readWithExtraBit(void)
  40          {
C51 COMPILER V9.56.0.0   UART_0                                                            10/28/2016 17:37:02 PAGE 102 

  41   1        return (SBUF0 | ((SCON0 & SCON0_RB8__BMASK) << 6) );
  42   1      }
  43          
  44          void UART0_init(UART0_RxEnable_t rxen, UART0_Width_t width, UART0_Multiproc_t mce)
  45          {
  46   1          SCON0 &= ~(SCON0_SMODE__BMASK
  47   1                     | SCON0_MCE__BMASK
  48   1                     | SCON0_REN__BMASK);
  49   1          SCON0 = mce | rxen | width;
  50   1      }
  51          
  52          void UART0_reset()
  53          {
  54   1        SCON0 = SCON0_SMODE__8_BIT
  55   1            | SCON0_MCE__MULTI_DISABLED
  56   1            | SCON0_REN__RECEIVE_DISABLED
  57   1            | SCON0_TB8__CLEARED_TO_0
  58   1            | SCON0_RB8__CLEARED_TO_0
  59   1            | SCON0_TI__NOT_SET
  60   1            | SCON0_RI__NOT_SET;
  61   1      }
  62          
  63          //=========================================================
  64          // Interrupt API
  65          //=========================================================
  66          #if EFM8PDL_UART0_USE_BUFFER == 1
  67          
  68          /**
  69           * Internal variable fort trackig buffer transfers. transferLenth[UART0_TX_TRANSFER] = bytes remaining in 
             -transfer.
  70           */
  71          SI_SEGMENT_VARIABLE(txRemaining, static uint8_t,  SI_SEG_XDATA)=0;
  72          SI_SEGMENT_VARIABLE(rxRemaining, static uint8_t,  SI_SEG_XDATA)=0;
  73          SI_SEGMENT_VARIABLE_SEGMENT_POINTER(txBuffer,    static uint8_t, EFM8PDL_UART0_TX_BUFTYPE, SI_SEG_XDATA);
  74          SI_SEGMENT_VARIABLE_SEGMENT_POINTER(rxBuffer,    static uint8_t, EFM8PDL_UART0_RX_BUFTYPE, SI_SEG_XDATA);
  75          
  76          
  77          SI_INTERRUPT(UART0_ISR, UART0_IRQn)
  78          {
  79   1        //Buffer and clear flags immediately so we don't miss an interrupt while processing
  80   1        uint8_t flags = SCON0 & (SCON0_RI__BMASK | SCON0_TI__BMASK);
  81   1        SCON0 &= ~flags;
  82   1      
  83   1        if (rxRemaining && (flags &  SCON0_RI__SET))
  84   1        {
  85   2          *rxBuffer = SBUF0;
  86   2          ++rxBuffer;
  87   2          --rxRemaining;
  88   2          if (!rxRemaining)
  89   2          {
  90   3            UART0_receiveCompleteCb();
  91   3          }
  92   2        }
  93   1      
  94   1        if ((flags & SCON0_TI__SET))
  95   1        {
  96   2          if (txRemaining){
  97   3            SBUF0 = *txBuffer;
  98   3            ++txBuffer;
  99   3            --txRemaining;
 100   3          }
 101   2          else
C51 COMPILER V9.56.0.0   UART_0                                                            10/28/2016 17:37:02 PAGE 103 

 102   2          {
 103   3            UART0_transmitCompleteCb();
 104   3          }
 105   2        }
 106   1      }
 107          
 108          void UART0_writeBuffer(SI_VARIABLE_SEGMENT_POINTER(buffer,
 110                                                          uint8_t,
 110                                                          EFM8PDL_UART0_TX_BUFTYPE),
 111                                 uint8_t length)
 112          {
 113   1        //Init internal data
 114   1        txBuffer = buffer+1;
 115   1        txRemaining = length-1;
 116   1      
 117   1        //Send initial byte
 118   1        SBUF0 = *buffer;
 119   1      }
 120          
 121          void UART0_readBuffer(SI_VARIABLE_SEGMENT_POINTER(buffer,
 123                                                     uint8_t,
 123                                                     EFM8PDL_UART0_RX_BUFTYPE),
 124                            uint8_t length)
 125          {
 126   1        //Init internal data
 127   1        rxBuffer = buffer;
 128   1        rxRemaining = length;
 129   1      }
 130          
 131          void UART0_abortWrite()
 132          {
 133   1        txRemaining = 0;
 134   1      }
 135          
 136          void UART0_abortRead()
 137          {
 138   1        rxRemaining = 0;
 139   1      }
 140          
 141          uint8_t UART0_txBytesRemaining()
 142          {
 143   1        return txRemaining;
 144   1      }
 145          
 146          uint8_t UART0_rxBytesRemaining()
 147          {
 148   1        return rxRemaining;
 149   1      }
 150          
 151          #endif //EFM8PDL_UART0_USE_BUFFER
 152          
 153          #if EFM8PDL_UART0_USE_STDIO == 1
              char putchar(char c){
                while(!SCON0_TI);
                SBUF0 = c;
                SCON0_TI = 0;
                return c;
              }
              
              char _getkey(){
                while(!SCON0_RI);
                SCON0_RI = 0;
C51 COMPILER V9.56.0.0   UART_0                                                            10/28/2016 17:37:02 PAGE 104 

                return SBUF0;
              }
              
              void UART0_initStdio()
              {
                SCON0 |= SCON0_REN__RECEIVE_ENABLED | SCON0_TI__SET;
              }
              #endif //EFM8PDL_UART0_USE_STDIO
 172          
 173          
C51 COMPILER V9.56.0.0   UART_0                                                            10/28/2016 17:37:02 PAGE 105 

ASSEMBLY LISTING OF GENERATED OBJECT CODE


             ; FUNCTION UART0_getIntFlags (BEGIN)
                                           ; SOURCE LINE # 9
                                           ; SOURCE LINE # 10
                                           ; SOURCE LINE # 11
0000 E598              MOV     A,SCON0
0002 5403              ANL     A,#03H
0004 FF                MOV     R7,A
                                           ; SOURCE LINE # 12
0005         ?C0001:
0005 22                RET     
             ; FUNCTION UART0_getIntFlags (END)

             ; FUNCTION _UART0_clearIntFlags (BEGIN)
                                           ; SOURCE LINE # 14
0000 900000      R     MOV     DPTR,#flag
0003 EF                MOV     A,R7
0004 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 15
                                           ; SOURCE LINE # 16
0005 900000      R     MOV     DPTR,#flag
0008 E0                MOVX    A,@DPTR
0009 FF                MOV     R7,A
000A EF                MOV     A,R7
000B F4                CPL     A
000C FF                MOV     R7,A
000D EF                MOV     A,R7
000E 5298              ANL     SCON0,A
                                           ; SOURCE LINE # 17
0010         ?C0002:
0010 22                RET     
             ; FUNCTION _UART0_clearIntFlags (END)

             ; FUNCTION UART0_initTxPolling (BEGIN)
                                           ; SOURCE LINE # 19
                                           ; SOURCE LINE # 20
                                           ; SOURCE LINE # 21
0000 D299              SETB    SCON0_TI
                                           ; SOURCE LINE # 22
0002         ?C0003:
0002 22                RET     
             ; FUNCTION UART0_initTxPolling (END)

             ; FUNCTION _UART0_write (BEGIN)
                                           ; SOURCE LINE # 24
0000 900000      R     MOV     DPTR,#value
0003 EF                MOV     A,R7
0004 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 25
                                           ; SOURCE LINE # 26
0005 900000      R     MOV     DPTR,#value
0008 E0                MOVX    A,@DPTR
0009 FF                MOV     R7,A
000A 8F99              MOV     SBUF0,R7
                                           ; SOURCE LINE # 27
000C         ?C0004:
000C 22                RET     
             ; FUNCTION _UART0_write (END)

             ; FUNCTION UART0_read (BEGIN)
C51 COMPILER V9.56.0.0   UART_0                                                            10/28/2016 17:37:02 PAGE 106 

                                           ; SOURCE LINE # 29
                                           ; SOURCE LINE # 30
                                           ; SOURCE LINE # 31
0000 AF99              MOV     R7,SBUF0
                                           ; SOURCE LINE # 32
0002         ?C0005:
0002 22                RET     
             ; FUNCTION UART0_read (END)

             ; FUNCTION _UART0_writeWithExtraBit (BEGIN)
                                           ; SOURCE LINE # 33
0000 900000      R     MOV     DPTR,#value
0003 EE                MOV     A,R6
0004 F0                MOVX    @DPTR,A
0005 A3                INC     DPTR
0006 EF                MOV     A,R7
0007 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 34
                                           ; SOURCE LINE # 35
0008 900000      R     MOV     DPTR,#value
000B E0                MOVX    A,@DPTR
000C FE                MOV     R6,A
000D A3                INC     DPTR
000E E0                MOVX    A,@DPTR
000F FF                MOV     R7,A
0010 EE                MOV     A,R6
0011 FF                MOV     R7,A
0012 7E00              MOV     R6,#00H
0014 EE                MOV     A,R6
0015 4F                ORL     A,R7
0016 24FF              ADD     A,#0FFH
0018 929B              MOV     SCON0_TB8,C
                                           ; SOURCE LINE # 36
001A 900000      R     MOV     DPTR,#value
001D E0                MOVX    A,@DPTR
001E FE                MOV     R6,A
001F A3                INC     DPTR
0020 E0                MOVX    A,@DPTR
0021 FF                MOV     R7,A
0022 8F99              MOV     SBUF0,R7
                                           ; SOURCE LINE # 37
0024         ?C0006:
0024 22                RET     
             ; FUNCTION _UART0_writeWithExtraBit (END)

             ; FUNCTION UART0_readWithExtraBit (BEGIN)
                                           ; SOURCE LINE # 39
                                           ; SOURCE LINE # 40
                                           ; SOURCE LINE # 41
0000 E598              MOV     A,SCON0
0002 5404              ANL     A,#04H
0004 FF                MOV     R7,A
0005 7E00              MOV     R6,#00H
0007 EF                MOV     A,R7
0008 75F040            MOV     B,#040H
000B A4                MUL     AB
000C FF                MOV     R7,A
000D AEF0              MOV     R6,B
000F AD99              MOV     R5,SBUF0
0011 7C00              MOV     R4,#00H
0013 EC                MOV     A,R4
0014 4E                ORL     A,R6
C51 COMPILER V9.56.0.0   UART_0                                                            10/28/2016 17:37:02 PAGE 107 

0015 FE                MOV     R6,A
0016 ED                MOV     A,R5
0017 4F                ORL     A,R7
0018 FF                MOV     R7,A
                                           ; SOURCE LINE # 42
0019         ?C0007:
0019 22                RET     
             ; FUNCTION UART0_readWithExtraBit (END)

             ; FUNCTION _UART0_init (BEGIN)
                                           ; SOURCE LINE # 44
0000 900000      R     MOV     DPTR,#rxen
0003 EF                MOV     A,R7
0004 F0                MOVX    @DPTR,A
0005 900000      R     MOV     DPTR,#width
0008 ED                MOV     A,R5
0009 F0                MOVX    @DPTR,A
000A 900000      R     MOV     DPTR,#mce
000D EB                MOV     A,R3
000E F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 45
                                           ; SOURCE LINE # 46
000F 53984F            ANL     SCON0,#04FH
                                           ; SOURCE LINE # 49
0012 900000      R     MOV     DPTR,#rxen
0015 E0                MOVX    A,@DPTR
0016 FF                MOV     R7,A
0017 900000      R     MOV     DPTR,#mce
001A E0                MOVX    A,@DPTR
001B FE                MOV     R6,A
001C EE                MOV     A,R6
001D 4F                ORL     A,R7
001E FF                MOV     R7,A
001F 900000      R     MOV     DPTR,#width
0022 E0                MOVX    A,@DPTR
0023 FE                MOV     R6,A
0024 EF                MOV     A,R7
0025 4E                ORL     A,R6
0026 F598              MOV     SCON0,A
                                           ; SOURCE LINE # 50
0028         ?C0008:
0028 22                RET     
             ; FUNCTION _UART0_init (END)

             ; FUNCTION UART0_reset (BEGIN)
                                           ; SOURCE LINE # 52
                                           ; SOURCE LINE # 53
                                           ; SOURCE LINE # 54
0000 759800            MOV     SCON0,#00H
                                           ; SOURCE LINE # 61
0003         ?C0009:
0003 22                RET     
             ; FUNCTION UART0_reset (END)

             ; FUNCTION UART0_ISR (BEGIN)
0000 C0E0              PUSH    ACC
0002 C0F0              PUSH    B
0004 C083              PUSH    DPH
0006 C082              PUSH    DPL
0008 C0D0              PUSH    PSW
000A 75D000            MOV     PSW,#00H
000D C000              PUSH    AR0
C51 COMPILER V9.56.0.0   UART_0                                                            10/28/2016 17:37:02 PAGE 108 

000F C001              PUSH    AR1
0011 C002              PUSH    AR2
0013 C003              PUSH    AR3
0015 C004              PUSH    AR4
0017 C005              PUSH    AR5
0019 C006              PUSH    AR6
001B C007              PUSH    AR7
                                           ; SOURCE LINE # 77
                                           ; SOURCE LINE # 80
001D E598              MOV     A,SCON0
001F 5403              ANL     A,#03H
0021 FF                MOV     R7,A
0022 900000      R     MOV     DPTR,#flags
0025 EF                MOV     A,R7
0026 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 81
0027 900000      R     MOV     DPTR,#flags
002A E0                MOVX    A,@DPTR
002B FF                MOV     R7,A
002C EF                MOV     A,R7
002D F4                CPL     A
002E FF                MOV     R7,A
002F EF                MOV     A,R7
0030 5298              ANL     SCON0,A
                                           ; SOURCE LINE # 83
0032 900000      R     MOV     DPTR,#rxRemaining
0035 E0                MOVX    A,@DPTR
0036 FF                MOV     R7,A
0037 EF                MOV     A,R7
0038 6037              JZ      ?C0010
003A 900000      R     MOV     DPTR,#flags
003D E0                MOVX    A,@DPTR
003E FF                MOV     R7,A
003F EF                MOV     A,R7
0040 30E02E            JNB     ACC.0,?C0010
                                           ; SOURCE LINE # 84
                                           ; SOURCE LINE # 85
0043 900000      R     MOV     DPTR,#rxBuffer
0046 E0                MOVX    A,@DPTR
0047 FE                MOV     R6,A
0048 A3                INC     DPTR
0049 E0                MOVX    A,@DPTR
004A FF                MOV     R7,A
004B 8F82              MOV     DPL,R7
004D 8E83              MOV     DPH,R6
004F E599              MOV     A,SBUF0
0051 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 86
0052 900000      R     MOV     DPTR,#rxBuffer+01H
0055 E0                MOVX    A,@DPTR
0056 04                INC     A
0057 F0                MOVX    @DPTR,A
0058 7006              JNZ     ?C0022
005A 900000      R     MOV     DPTR,#rxBuffer
005D E0                MOVX    A,@DPTR
005E 04                INC     A
005F F0                MOVX    @DPTR,A
0060         ?C0022:
                                           ; SOURCE LINE # 87
0060 900000      R     MOV     DPTR,#rxRemaining
0063 E0                MOVX    A,@DPTR
0064 14                DEC     A
C51 COMPILER V9.56.0.0   UART_0                                                            10/28/2016 17:37:02 PAGE 109 

0065 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 88
0066 900000      R     MOV     DPTR,#rxRemaining
0069 E0                MOVX    A,@DPTR
006A FF                MOV     R7,A
006B EF                MOV     A,R7
006C 7003              JNZ     ?C0010
                                           ; SOURCE LINE # 89
                                           ; SOURCE LINE # 90
006E 120000      E     LCALL   UART0_receiveCompleteCb
                                           ; SOURCE LINE # 91
0071         ?C0011:
                                           ; SOURCE LINE # 92
0071         ?C0010:
                                           ; SOURCE LINE # 94
0071 900000      R     MOV     DPTR,#flags
0074 E0                MOVX    A,@DPTR
0075 FF                MOV     R7,A
0076 EF                MOV     A,R7
0077 30E131            JNB     ACC.1,?C0015
                                           ; SOURCE LINE # 95
                                           ; SOURCE LINE # 96
007A 900000      R     MOV     DPTR,#txRemaining
007D E0                MOVX    A,@DPTR
007E FF                MOV     R7,A
007F EF                MOV     A,R7
0080 6026              JZ      ?C0013
                                           ; SOURCE LINE # 97
0082 900000      R     MOV     DPTR,#txBuffer
0085 E0                MOVX    A,@DPTR
0086 FE                MOV     R6,A
0087 A3                INC     DPTR
0088 E0                MOVX    A,@DPTR
0089 FF                MOV     R7,A
008A 8F82              MOV     DPL,R7
008C 8E83              MOV     DPH,R6
008E E0                MOVX    A,@DPTR
008F FF                MOV     R7,A
0090 8F99              MOV     SBUF0,R7
                                           ; SOURCE LINE # 98
0092 900000      R     MOV     DPTR,#txBuffer+01H
0095 E0                MOVX    A,@DPTR
0096 04                INC     A
0097 F0                MOVX    @DPTR,A
0098 7006              JNZ     ?C0023
009A 900000      R     MOV     DPTR,#txBuffer
009D E0                MOVX    A,@DPTR
009E 04                INC     A
009F F0                MOVX    @DPTR,A
00A0         ?C0023:
                                           ; SOURCE LINE # 99
00A0 900000      R     MOV     DPTR,#txRemaining
00A3 E0                MOVX    A,@DPTR
00A4 14                DEC     A
00A5 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 100
00A6 8003              SJMP    ?C0015
00A8         ?C0013:
                                           ; SOURCE LINE # 102
                                           ; SOURCE LINE # 103
00A8 120000      E     LCALL   UART0_transmitCompleteCb
                                           ; SOURCE LINE # 104
C51 COMPILER V9.56.0.0   UART_0                                                            10/28/2016 17:37:02 PAGE 110 

00AB         ?C0014:
                                           ; SOURCE LINE # 105
00AB         ?C0012:
                                           ; SOURCE LINE # 106
00AB         ?C0015:
00AB D007              POP     AR7
00AD D006              POP     AR6
00AF D005              POP     AR5
00B1 D004              POP     AR4
00B3 D003              POP     AR3
00B5 D002              POP     AR2
00B7 D001              POP     AR1
00B9 D000              POP     AR0
00BB D0D0              POP     PSW
00BD D082              POP     DPL
00BF D083              POP     DPH
00C1 D0F0              POP     B
00C3 D0E0              POP     ACC
00C5 32                RETI    
             ; FUNCTION UART0_ISR (END)

             ; FUNCTION _UART0_writeBuffer (BEGIN)
                                           ; SOURCE LINE # 108
0000 900000      R     MOV     DPTR,#buffer
0003 EE                MOV     A,R6
0004 F0                MOVX    @DPTR,A
0005 A3                INC     DPTR
0006 EF                MOV     A,R7
0007 F0                MOVX    @DPTR,A
0008 900000      R     MOV     DPTR,#length
000B ED                MOV     A,R5
000C F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 112
                                           ; SOURCE LINE # 114
000D 900000      R     MOV     DPTR,#buffer
0010 E0                MOVX    A,@DPTR
0011 FE                MOV     R6,A
0012 A3                INC     DPTR
0013 E0                MOVX    A,@DPTR
0014 FF                MOV     R7,A
0015 EF                MOV     A,R7
0016 2401              ADD     A,#01H
0018 FF                MOV     R7,A
0019 EE                MOV     A,R6
001A 3400              ADDC    A,#00H
001C FE                MOV     R6,A
001D 900000      R     MOV     DPTR,#txBuffer
0020 EE                MOV     A,R6
0021 F0                MOVX    @DPTR,A
0022 A3                INC     DPTR
0023 EF                MOV     A,R7
0024 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 115
0025 900000      R     MOV     DPTR,#length
0028 E0                MOVX    A,@DPTR
0029 FF                MOV     R7,A
002A EF                MOV     A,R7
002B 14                DEC     A
002C FF                MOV     R7,A
002D 900000      R     MOV     DPTR,#txRemaining
0030 EF                MOV     A,R7
0031 F0                MOVX    @DPTR,A
C51 COMPILER V9.56.0.0   UART_0                                                            10/28/2016 17:37:02 PAGE 111 

                                           ; SOURCE LINE # 118
0032 900000      R     MOV     DPTR,#buffer
0035 E0                MOVX    A,@DPTR
0036 FE                MOV     R6,A
0037 A3                INC     DPTR
0038 E0                MOVX    A,@DPTR
0039 FF                MOV     R7,A
003A 8F82              MOV     DPL,R7
003C 8E83              MOV     DPH,R6
003E E0                MOVX    A,@DPTR
003F FF                MOV     R7,A
0040 8F99              MOV     SBUF0,R7
                                           ; SOURCE LINE # 119
0042         ?C0016:
0042 22                RET     
             ; FUNCTION _UART0_writeBuffer (END)

             ; FUNCTION _UART0_readBuffer (BEGIN)
                                           ; SOURCE LINE # 121
0000 900000      R     MOV     DPTR,#buffer
0003 EE                MOV     A,R6
0004 F0                MOVX    @DPTR,A
0005 A3                INC     DPTR
0006 EF                MOV     A,R7
0007 F0                MOVX    @DPTR,A
0008 900000      R     MOV     DPTR,#length
000B ED                MOV     A,R5
000C F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 125
                                           ; SOURCE LINE # 127
000D 900000      R     MOV     DPTR,#buffer
0010 E0                MOVX    A,@DPTR
0011 FE                MOV     R6,A
0012 A3                INC     DPTR
0013 E0                MOVX    A,@DPTR
0014 FF                MOV     R7,A
0015 900000      R     MOV     DPTR,#rxBuffer
0018 EE                MOV     A,R6
0019 F0                MOVX    @DPTR,A
001A A3                INC     DPTR
001B EF                MOV     A,R7
001C F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 128
001D 900000      R     MOV     DPTR,#length
0020 E0                MOVX    A,@DPTR
0021 FF                MOV     R7,A
0022 900000      R     MOV     DPTR,#rxRemaining
0025 EF                MOV     A,R7
0026 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 129
0027         ?C0017:
0027 22                RET     
             ; FUNCTION _UART0_readBuffer (END)

             ; FUNCTION UART0_abortWrite (BEGIN)
                                           ; SOURCE LINE # 131
                                           ; SOURCE LINE # 132
                                           ; SOURCE LINE # 133
0000 900000      R     MOV     DPTR,#txRemaining
0003 E4                CLR     A
0004 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 134
C51 COMPILER V9.56.0.0   UART_0                                                            10/28/2016 17:37:02 PAGE 112 

0005         ?C0018:
0005 22                RET     
             ; FUNCTION UART0_abortWrite (END)

             ; FUNCTION UART0_abortRead (BEGIN)
                                           ; SOURCE LINE # 136
                                           ; SOURCE LINE # 137
                                           ; SOURCE LINE # 138
0000 900000      R     MOV     DPTR,#rxRemaining
0003 E4                CLR     A
0004 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 139
0005         ?C0019:
0005 22                RET     
             ; FUNCTION UART0_abortRead (END)

             ; FUNCTION UART0_txBytesRemaining (BEGIN)
                                           ; SOURCE LINE # 141
                                           ; SOURCE LINE # 142
                                           ; SOURCE LINE # 143
0000 900000      R     MOV     DPTR,#txRemaining
0003 E0                MOVX    A,@DPTR
0004 FF                MOV     R7,A
                                           ; SOURCE LINE # 144
0005         ?C0020:
0005 22                RET     
             ; FUNCTION UART0_txBytesRemaining (END)

             ; FUNCTION UART0_rxBytesRemaining (BEGIN)
                                           ; SOURCE LINE # 146
                                           ; SOURCE LINE # 147
                                           ; SOURCE LINE # 148
0000 900000      R     MOV     DPTR,#rxRemaining
0003 E0                MOVX    A,@DPTR
0004 FF                MOV     R7,A
                                           ; SOURCE LINE # 149
0005         ?C0021:
0005 22                RET     
             ; FUNCTION UART0_rxBytesRemaining (END)

C51 COMPILER V9.56.0.0   UART_0                                                            10/28/2016 17:37:02 PAGE 113 

NAME                                    CLASS   MSPACE  TYPE    OFFSET  SIZE
====                                    =====   ======  ====    ======  ====


SPI0CKR. . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00A2H  1
uint16_t . . . . . . . . . . . . . . .  TYPEDEF  -----  U_INT    -----  2
P0 . . . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   0080H  1
PSW_OV . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00D2H  1
XOSC0CN. . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00B1H  1
P1 . . . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   0090H  1
P2 . . . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00A0H  1
uint64_t . . . . . . . . . . . . . . .  TYPEDEF  -----  ARRAY    -----  8
UART0_RX_ENABLE. . . . . . . . . . . .  E_CONST  -----  U_CHAR   -----  1
P3 . . . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00B0H  1
ADC0CF . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00BCH  1
TMR2CN0_T2XCLK . . . . . . . . . . . .  ABSBIT   -----  BIT      00C8H  1
P4 . . . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00C7H  1
SI_GEN_PTR_t . . . . . . . . . . . . .  TYPEDEF  -----  UNION    -----  3
  u8 . . . . . . . . . . . . . . . . .  MEMBER   -----  ARRAY    0000H  3
  gptr . . . . . . . . . . . . . . . .  MEMBER   -----  STRUCT   0000H  3
_UART0_init. . . . . . . . . . . . . .  PUBLIC   CODE   PROC     0000H  -----
  rxen . . . . . . . . . . . . . . . .  AUTO     XDATA  U_CHAR   0000H  1
  width. . . . . . . . . . . . . . . .  AUTO     XDATA  U_CHAR   0001H  1
  mce. . . . . . . . . . . . . . . . .  AUTO     XDATA  U_CHAR   0002H  1
SMB0CN0_MASTER . . . . . . . . . . . .  ABSBIT   -----  BIT      00C7H  1
PCA0 . . . . . . . . . . . . . . . . .  SFR      DATA   U_INT    00F9H  2
EIE1 . . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00E6H  1
SMB1CN0_MASTER . . . . . . . . . . . .  ABSBIT   -----  BIT      00C7H  1
SMB0CN0_ACK. . . . . . . . . . . . . .  ABSBIT   -----  BIT      00C1H  1
USB0XCN. . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00D7H  1
EIE2 . . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00E7H  1
SMB1CN0_ACK. . . . . . . . . . . . . .  ABSBIT   -----  BIT      00C1H  1
int32_t. . . . . . . . . . . . . . . .  TYPEDEF  -----  LONG     -----  4
PSCTL. . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   008FH  1
IT01CF . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00E4H  1
int16_t. . . . . . . . . . . . . . . .  TYPEDEF  -----  INT      -----  2
TMR5CN0_T5XCLK . . . . . . . . . . . .  ABSBIT   -----  BIT      00C8H  1
SMB0CN0_TXMODE . . . . . . . . . . . .  ABSBIT   -----  BIT      00C6H  1
SMB1CN0_TXMODE . . . . . . . . . . . .  ABSBIT   -----  BIT      00C6H  1
SFRPAGE. . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00BFH  1
rxRemaining. . . . . . . . . . . . . .  STATIC   XDATA  U_CHAR   0000H  1
P0MDOUT. . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00A4H  1
int64_t. . . . . . . . . . . . . . . .  TYPEDEF  -----  ARRAY    -----  8
P1MDOUT. . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00A5H  1
SI_UU32. . . . . . . . . . . . . . . .  * TAG *  -----  UNION    -----  4
  u32. . . . . . . . . . . . . . . . .  MEMBER   -----  U_LONG   0000H  4
  s32. . . . . . . . . . . . . . . . .  MEMBER   -----  LONG     0000H  4
  uu16 . . . . . . . . . . . . . . . .  MEMBER   -----  ARRAY    0000H  4
  u16. . . . . . . . . . . . . . . . .  MEMBER   -----  ARRAY    0000H  4
  s16. . . . . . . . . . . . . . . . .  MEMBER   -----  ARRAY    0000H  4
  u8 . . . . . . . . . . . . . . . . .  MEMBER   -----  ARRAY    0000H  4
  s8 . . . . . . . . . . . . . . . . .  MEMBER   -----  ARRAY    0000H  4
txRemaining. . . . . . . . . . . . . .  STATIC   XDATA  U_CHAR   0001H  1
ADC0CN0_ADINT. . . . . . . . . . . . .  ABSBIT   -----  BIT      00EDH  1
TMR2RLH. . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00CBH  1
P2MDOUT. . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00A6H  1
IE . . . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00A8H  1
false. . . . . . . . . . . . . . . . .  E_CONST  -----  U_CHAR   -----  1
TMR3RLH. . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   0093H  1
P3MDOUT. . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00A7H  1
SI_UU16. . . . . . . . . . . . . . . .  * TAG *  -----  UNION    -----  2
C51 COMPILER V9.56.0.0   UART_0                                                            10/28/2016 17:37:02 PAGE 114 

NAME                                    CLASS   MSPACE  TYPE    OFFSET  SIZE
====                                    =====   ======  ====    ======  ====


  u16. . . . . . . . . . . . . . . . .  MEMBER   -----  U_INT    0000H  2
  s16. . . . . . . . . . . . . . . . .  MEMBER   -----  INT      0000H  2
  u8 . . . . . . . . . . . . . . . . .  MEMBER   -----  ARRAY    0000H  2
  s8 . . . . . . . . . . . . . . . . .  MEMBER   -----  ARRAY    0000H  2
TMR4RLH. . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   0093H  1
P4MDOUT. . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00AEH  1
EIP1 . . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00F6H  1
TMR5RLH. . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00CBH  1
EIP2 . . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00F7H  1
SCON0_RB8. . . . . . . . . . . . . . .  ABSBIT   -----  BIT      009AH  1
TMR2RLL. . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00CAH  1
PCA0CPH0 . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00FCH  1
TMR3RLL. . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   0092H  1
PCA0CPH1 . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00EAH  1
GPTR_t . . . . . . . . . . . . . . . .  TYPEDEF  -----  STRUCT   -----  3
  memtype. . . . . . . . . . . . . . .  MEMBER   -----  U_CHAR   0000H  1
  address. . . . . . . . . . . . . . .  MEMBER   -----  UNION    0001H  2
SCON0_TB8. . . . . . . . . . . . . . .  ABSBIT   -----  BIT      009BH  1
B_B0 . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00F0H  1
DP . . . . . . . . . . . . . . . . . .  SFR      DATA   U_INT    0082H  2
TMR4RLL. . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   0092H  1
PCA0CPH2 . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00ECH  1
B_B1 . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00F1H  1
ADC0GT . . . . . . . . . . . . . . . .  SFR      DATA   U_INT    00C3H  2
TMR5RLL. . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00CAH  1
PCA0CPH3 . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00EEH  1
B_B2 . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00F2H  1
PCA0CPL0 . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00FBH  1
PCA0CPH4 . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00FEH  1
EMI0CF . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   0085H  1
B_B3 . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00F3H  1
PCA0MD . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00D9H  1
PCA0CPM0 . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00DAH  1
PCA0CPL1 . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00E9H  1
B_B4 . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00F4H  1
PCA0CPM1 . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00DBH  1
PCA0CPL2 . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00EBH  1
B_B5 . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00F5H  1
PCA0CPM2 . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00DCH  1
PCA0CPL3 . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00EDH  1
IP . . . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00B8H  1
B_B6 . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00F6H  1
ADC0LT . . . . . . . . . . . . . . . .  SFR      DATA   U_INT    00C5H  2
PCA0CPM3 . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00DDH  1
PCA0CPL4 . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00FDH  1
SCON0_MCE. . . . . . . . . . . . . . .  ABSBIT   -----  BIT      009DH  1
B_B7 . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00F7H  1
PCA0CPM4 . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00DEH  1
UART0_receiveCompleteCb. . . . . . . .  EXTERN   CODE   PROC     -----  -----
UART0_MULTIPROC_ENABLE . . . . . . . .  E_CONST  -----  U_CHAR   -----  1
XBR0 . . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00E1H  1
SMB0CF . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00C1H  1
XBR1 . . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00E2H  1
SMB1CF . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00C1H  1
PFE0CN . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00AFH  1
EMI0CN . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00AAH  1
SMB0CN0_STA. . . . . . . . . . . . . .  ABSBIT   -----  BIT      00C5H  1
C51 COMPILER V9.56.0.0   UART_0                                                            10/28/2016 17:37:02 PAGE 115 

NAME                                    CLASS   MSPACE  TYPE    OFFSET  SIZE
====                                    =====   ======  ====    ======  ====


XBR2 . . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00E3H  1
SMB1CN0_STA. . . . . . . . . . . . . .  ABSBIT   -----  BIT      00C5H  1
ACC_ACC0 . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00E0H  1
REF0CN . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00D1H  1
HFO0CN . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00B2H  1
CKCON0 . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   008EH  1
ACC_ACC1 . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00E1H  1
CKCON1 . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00E4H  1
TMR2CN0_TR2. . . . . . . . . . . . . .  ABSBIT   -----  BIT      00CAH  1
ACC_ACC2 . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00E2H  1
ACC_ACC3 . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00E3H  1
SP . . . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   0081H  1
CMP0MD . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   009DH  1
ACC_ACC4 . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00E4H  1
LFO0CN . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   0086H  1
EMI0TC . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   0084H  1
CMP1MD . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   009CH  1
PCA0CN0_CCF0 . . . . . . . . . . . . .  ABSBIT   -----  BIT      00D8H  1
ACC_ACC5 . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00E5H  1
UART0_Width_t. . . . . . . . . . . . .  TYPEDEF  -----  U_CHAR   -----  1
PCA0CN0_CCF1 . . . . . . . . . . . . .  ABSBIT   -----  BIT      00D9H  1
ACC_ACC6 . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00E6H  1
TMR2 . . . . . . . . . . . . . . . . .  SFR      DATA   U_INT    00CCH  2
PCA0CN0_CCF2 . . . . . . . . . . . . .  ABSBIT   -----  BIT      00DAH  1
ACC_ACC7 . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00E7H  1
TMR3 . . . . . . . . . . . . . . . . .  SFR      DATA   U_INT    0094H  2
TMR5CN0_TR5. . . . . . . . . . . . . .  ABSBIT   -----  BIT      00CAH  1
PCA0CN0_CCF3 . . . . . . . . . . . . .  ABSBIT   -----  BIT      00DBH  1
TMR4 . . . . . . . . . . . . . . . . .  SFR      DATA   U_INT    0094H  2
SBCON1 . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00ACH  1
PCA0CN0_CCF4 . . . . . . . . . . . . .  ABSBIT   -----  BIT      00DCH  1
TMR5 . . . . . . . . . . . . . . . . .  SFR      DATA   U_INT    00CCH  2
SMB0CN0_ACKRQ. . . . . . . . . . . . .  ABSBIT   -----  BIT      00C3H  1
VDM0CN . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00FFH  1
P0MDIN . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00F1H  1
SMB1CN0_ACKRQ. . . . . . . . . . . . .  ABSBIT   -----  BIT      00C3H  1
SCON0_REN. . . . . . . . . . . . . . .  ABSBIT   -----  BIT      009CH  1
P1MDIN . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00F2H  1
UART0_transmitCompleteCb . . . . . . .  EXTERN   CODE   PROC     -----  -----
P2MDIN . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00F3H  1
UART0_initTxPolling. . . . . . . . . .  PUBLIC   CODE   PROC     0000H  -----
SMB0CN0_STO. . . . . . . . . . . . . .  ABSBIT   -----  BIT      00C4H  1
P3MDIN . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00F4H  1
UART0_getIntFlags. . . . . . . . . . .  PUBLIC   CODE   PROC     0000H  -----
SMB1CN0_STO. . . . . . . . . . . . . .  ABSBIT   -----  BIT      00C4H  1
SBRLH1 . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00B5H  1
P4MDIN . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00F5H  1
bool . . . . . . . . . . . . . . . . .  TYPEDEF  -----  BIT      -----  1
SI_GEN_PTR . . . . . . . . . . . . . .  * TAG *  -----  UNION    -----  3
  u8 . . . . . . . . . . . . . . . . .  MEMBER   -----  ARRAY    0000H  3
  gptr . . . . . . . . . . . . . . . .  MEMBER   -----  STRUCT   0000H  3
PSW_RS0. . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00D3H  1
PCA0CN0_CF . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00DFH  1
SPI0CN0_RXOVRN . . . . . . . . . . . .  ABSBIT   -----  BIT      00FCH  1
PSW_RS1. . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00D4H  1
SBRLL1 . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00B4H  1
UART0_readWithExtraBit . . . . . . . .  PUBLIC   CODE   PROC     0000H  -----
C51 COMPILER V9.56.0.0   UART_0                                                            10/28/2016 17:37:02 PAGE 116 

NAME                                    CLASS   MSPACE  TYPE    OFFSET  SIZE
====                                    =====   ======  ====    ======  ====


ADC0CN0_ADEN . . . . . . . . . . . . .  ABSBIT   -----  BIT      00EFH  1
TMOD . . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   0089H  1
TCON . . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   0088H  1
PSW_PARITY . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00D0H  1
IE_ES0 . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00ACH  1
CMP0MX . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   009FH  1
IE_ET0 . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00A9H  1
CMP1MX . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   009EH  1
UART0_RxEnable_t . . . . . . . . . . .  TYPEDEF  -----  U_CHAR   -----  1
IE_ET1 . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00ABH  1
P0SKIP . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00D4H  1
TMR2CN0_T2CSS. . . . . . . . . . . . .  ABSBIT   -----  BIT      00C9H  1
IE_ET2 . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00ADH  1
P1SKIP . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00D5H  1
P2SKIP . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00D6H  1
ADC0CN0. . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00E8H  1
IE_EX0 . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00A8H  1
P3SKIP . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00DFH  1
UART0_ISR. . . . . . . . . . . . . . .  PUBLIC   CODE   PROC     0000H  -----
  flags. . . . . . . . . . . . . . . .  AUTO     XDATA  U_CHAR   0000H  1
PCA0CN0_CR . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00DEH  1
IE_EX1 . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00AAH  1
SCON0_SMODE. . . . . . . . . . . . . .  ABSBIT   -----  BIT      009FH  1
CLKSEL . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00A9H  1
SPI0CN0_SPIEN. . . . . . . . . . . . .  ABSBIT   -----  BIT      00F8H  1
B. . . . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00F0H  1
ADC0H. . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00BEH  1
true . . . . . . . . . . . . . . . . .  E_CONST  -----  U_CHAR   -----  1
ADC0CN0_ADTM . . . . . . . . . . . . .  ABSBIT   -----  BIT      00EEH  1
_UART0_writeWithExtraBit . . . . . . .  PUBLIC   CODE   PROC     0000H  -----
  value. . . . . . . . . . . . . . . .  AUTO     XDATA  U_INT    0000H  2
TMR2RL . . . . . . . . . . . . . . . .  SFR      DATA   U_INT    00CAH  2
ADC0L. . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00BDH  1
TMR3RL . . . . . . . . . . . . . . . .  SFR      DATA   U_INT    0092H  2
TMR4RL . . . . . . . . . . . . . . . .  SFR      DATA   U_INT    0092H  2
PCA0CN0. . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00D8H  1
ACC. . . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00E0H  1
TMR5RL . . . . . . . . . . . . . . . .  SFR      DATA   U_INT    00CAH  2
rxBuffer . . . . . . . . . . . . . . .  STATIC   XDATA  PTR      0002H  2
PCA0CP0. . . . . . . . . . . . . . . .  SFR      DATA   U_INT    00FBH  2
PCA0CP1. . . . . . . . . . . . . . . .  SFR      DATA   U_INT    00E9H  2
txBuffer . . . . . . . . . . . . . . .  STATIC   XDATA  PTR      0004H  2
_UART0_readBuffer. . . . . . . . . . .  PUBLIC   CODE   PROC     0000H  -----
  buffer . . . . . . . . . . . . . . .  AUTO     XDATA  PTR      0000H  2
  length . . . . . . . . . . . . . . .  AUTO     XDATA  U_CHAR   0002H  1
PCA0CP2. . . . . . . . . . . . . . . .  SFR      DATA   U_INT    00EBH  2
PCA0CP3. . . . . . . . . . . . . . . .  SFR      DATA   U_INT    00EDH  2
TH0. . . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   008CH  1
IP_PS0 . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00BCH  1
PCA0CP4. . . . . . . . . . . . . . . .  SFR      DATA   U_INT    00FDH  2
TH1. . . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   008DH  1
PCA0H. . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00FAH  1
IP_PT0 . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00B9H  1
IP_PT1 . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00BBH  1
uint8_t. . . . . . . . . . . . . . . .  TYPEDEF  -----  U_CHAR   -----  1
UART0_RX_DISABLE . . . . . . . . . . .  E_CONST  -----  U_CHAR   -----  1
SMB0CN0_ARBLOST. . . . . . . . . . . .  ABSBIT   -----  BIT      00C2H  1
C51 COMPILER V9.56.0.0   UART_0                                                            10/28/2016 17:37:02 PAGE 117 

NAME                                    CLASS   MSPACE  TYPE    OFFSET  SIZE
====                                    =====   ======  ====    ======  ====


IP_PT2 . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00BDH  1
TL0. . . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   008AH  1
SPI0CN0_TXBMT. . . . . . . . . . . . .  ABSBIT   -----  BIT      00F9H  1
SMB1CN0_ARBLOST. . . . . . . . . . . .  ABSBIT   -----  BIT      00C2H  1
PSW_F0 . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00D5H  1
IE_ESPI0 . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00AEH  1
TL1. . . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   008BH  1
PCA0L. . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00F9H  1
SMB0CN0_SI . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00C0H  1
PSW_F1 . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00D1H  1
P0_B0. . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      0080H  1
IP_PX0 . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00B8H  1
REG01CN. . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00C9H  1
SMB1CN0_SI . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00C0H  1
P1_B0. . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      0090H  1
P0_B1. . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      0081H  1
IP_PX1 . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00BAH  1
CMP0CN0. . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   009BH  1
TCON_IE0 . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      0089H  1
P2_B0. . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00A0H  1
P1_B1. . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      0091H  1
P0_B2. . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      0082H  1
CMP1CN0. . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   009AH  1
TCON_IE1 . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      008BH  1
P3_B0. . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00B0H  1
P2_B1. . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00A1H  1
P1_B2. . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      0092H  1
P0_B3. . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      0083H  1
SMB0CN0. . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00C0H  1
P3_B1. . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00B1H  1
P2_B2. . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00A2H  1
P1_B3. . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      0093H  1
P0_B4. . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      0084H  1
SMB1CN0. . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00C0H  1
P3_B2. . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00B2H  1
P2_B3. . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00A3H  1
P1_B4. . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      0094H  1
P0_B5. . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      0085H  1
P3_B3. . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00B3H  1
P2_B4. . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00A4H  1
P1_B5. . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      0095H  1
P0_B6. . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      0086H  1
P3_B4. . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00B4H  1
P2_B5. . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00A5H  1
P1_B6. . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      0096H  1
P0_B7. . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      0087H  1
int8_t . . . . . . . . . . . . . . . .  TYPEDEF  -----  CHAR     -----  1
P3_B5. . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00B5H  1
P2_B6. . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00A6H  1
P1_B7. . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      0097H  1
_UART0_writeBuffer . . . . . . . . . .  PUBLIC   CODE   PROC     0000H  -----
  buffer . . . . . . . . . . . . . . .  AUTO     XDATA  PTR      0000H  2
  length . . . . . . . . . . . . . . .  AUTO     XDATA  U_CHAR   0002H  1
P3_B6. . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00B6H  1
P2_B7. . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00A7H  1
P3_B7. . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00B7H  1
DPH. . . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   0083H  1
C51 COMPILER V9.56.0.0   UART_0                                                            10/28/2016 17:37:02 PAGE 118 

NAME                                    CLASS   MSPACE  TYPE    OFFSET  SIZE
====                                    =====   ======  ====    ======  ====


ADC0GTH. . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00C4H  1
TMR2CN0_TF2H . . . . . . . . . . . . .  ABSBIT   -----  BIT      00CFH  1
TMR2CN0_T2SPLIT. . . . . . . . . . . .  ABSBIT   -----  BIT      00CBH  1
PSW_AC . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00D6H  1
SPI0CN0. . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00F8H  1
HFO0CAL. . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00B3H  1
TCON_TF0 . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      008DH  1
SCON0_RI . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      0098H  1
DPL. . . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   0082H  1
TCON_TF1 . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      008FH  1
SBUF0. . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   0099H  1
PCON0. . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   0087H  1
ADC0GTL. . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00C3H  1
SI_UU32_t. . . . . . . . . . . . . . .  TYPEDEF  -----  UNION    -----  4
  u32. . . . . . . . . . . . . . . . .  MEMBER   -----  U_LONG   0000H  4
  s32. . . . . . . . . . . . . . . . .  MEMBER   -----  LONG     0000H  4
  uu16 . . . . . . . . . . . . . . . .  MEMBER   -----  ARRAY    0000H  4
  u16. . . . . . . . . . . . . . . . .  MEMBER   -----  ARRAY    0000H  4
  s16. . . . . . . . . . . . . . . . .  MEMBER   -----  ARRAY    0000H  4
  u8 . . . . . . . . . . . . . . . . .  MEMBER   -----  ARRAY    0000H  4
  s8 . . . . . . . . . . . . . . . . .  MEMBER   -----  ARRAY    0000H  4
TMR2CN0_TF2L . . . . . . . . . . . . .  ABSBIT   -----  BIT      00CEH  1
SCON0_TI . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      0099H  1
ADC0CN0_ADCM0. . . . . . . . . . . . .  ABSBIT   -----  BIT      00E8H  1
SBUF1. . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00D3H  1
ADC0LTH. . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00C6H  1
TCON_IT0 . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      0088H  1
ADC0CN0_ADCM1. . . . . . . . . . . . .  ABSBIT   -----  BIT      00E9H  1
RSTSRC . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00EFH  1
SI_UU16_t. . . . . . . . . . . . . . .  TYPEDEF  -----  UNION    -----  2
  u16. . . . . . . . . . . . . . . . .  MEMBER   -----  U_INT    0000H  2
  s16. . . . . . . . . . . . . . . . .  MEMBER   -----  INT      0000H  2
  u8 . . . . . . . . . . . . . . . . .  MEMBER   -----  ARRAY    0000H  2
  s8 . . . . . . . . . . . . . . . . .  MEMBER   -----  ARRAY    0000H  2
TMR5CN0_TF5H . . . . . . . . . . . . .  ABSBIT   -----  BIT      00CFH  1
TMR5CN0_T5SPLIT. . . . . . . . . . . .  ABSBIT   -----  BIT      00CBH  1
TCON_IT1 . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      008AH  1
ADC0CN0_ADCM2. . . . . . . . . . . . .  ABSBIT   -----  BIT      00EAH  1
SCON0. . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   0098H  1
UART0_rxBytesRemaining . . . . . . . .  PUBLIC   CODE   PROC     0000H  -----
ADC0CN0_ADWINT . . . . . . . . . . . .  ABSBIT   -----  BIT      00EBH  1
SBRL1. . . . . . . . . . . . . . . . .  SFR      DATA   U_INT    00B4H  2
SMOD1. . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00E5H  1
SCON1. . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00D2H  1
AMX0N. . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00BAH  1
ADC0CN0_ADBUSY . . . . . . . . . . . .  ABSBIT   -----  BIT      00ECH  1
SMB0ADM. . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00CEH  1
ADC0LTL. . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00C5H  1
UART0_txBytesRemaining . . . . . . . .  PUBLIC   CODE   PROC     0000H  -----
SPI0CN0_MODF . . . . . . . . . . . . .  ABSBIT   -----  BIT      00FDH  1
IP_PSPI0 . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00BEH  1
SMB1ADM. . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00CEH  1
AMX0P. . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00BBH  1
UART0_abortRead. . . . . . . . . . . .  PUBLIC   CODE   PROC     0000H  -----
UART0_Multiproc_t. . . . . . . . . . .  TYPEDEF  -----  U_CHAR   -----  1
UART0_WIDTH_8. . . . . . . . . . . . .  E_CONST  -----  U_CHAR   -----  1
TMR5CN0_TF5L . . . . . . . . . . . . .  ABSBIT   -----  BIT      00CEH  1
C51 COMPILER V9.56.0.0   UART_0                                                            10/28/2016 17:37:02 PAGE 119 

NAME                                    CLASS   MSPACE  TYPE    OFFSET  SIZE
====                                    =====   ======  ====    ======  ====


TMR2CN0. . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00C8H  1
UART0_MULTIPROC_DISABLE. . . . . . . .  E_CONST  -----  U_CHAR   -----  1
UART0_WIDTH_9. . . . . . . . . . . . .  E_CONST  -----  U_CHAR   -----  1
TMR3CN0. . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   0091H  1
TMR4CN0. . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   0091H  1
TMR5CN0. . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00C8H  1
SMB0ADR. . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00CFH  1
UART0_read . . . . . . . . . . . . . .  PUBLIC   CODE   PROC     0000H  -----
TCON_TR0 . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      008CH  1
SMB1ADR. . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00CFH  1
TMR2CN0_TF2CEN . . . . . . . . . . . .  ABSBIT   -----  BIT      00CCH  1
TCON_TR1 . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      008EH  1
SMB0DAT. . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00C2H  1
TMR2H. . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00CDH  1
SPI0CFG. . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00A1H  1
SMB1DAT. . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00C2H  1
TMR3H. . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   0095H  1
TMR4H. . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   0095H  1
TMR5H. . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00CDH  1
TMR2L. . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00CCH  1
SPI0CN0_SPIF . . . . . . . . . . . . .  ABSBIT   -----  BIT      00FFH  1
USB0ADR. . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   0096H  1
TMR3L. . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   0094H  1
UART0_reset. . . . . . . . . . . . . .  PUBLIC   CODE   PROC     0000H  -----
IE_EA. . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00AFH  1
TMR4L. . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   0094H  1
USB0DAT. . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   0097H  1
TMR5L. . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00CCH  1
FLSCL. . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00B6H  1
_UART0_clearIntFlags . . . . . . . . .  PUBLIC   CODE   PROC     0000H  -----
  flag . . . . . . . . . . . . . . . .  AUTO     XDATA  U_CHAR   0000H  1
TMR2CN0_TF2LEN . . . . . . . . . . . .  ABSBIT   -----  BIT      00CDH  1
SPI0CN0_WCOL . . . . . . . . . . . . .  ABSBIT   -----  BIT      00FEH  1
SPI0CN0_NSSMD0 . . . . . . . . . . . .  ABSBIT   -----  BIT      00FAH  1
PSW_CY . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00D7H  1
SPI0DAT. . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00A3H  1
UART0_abortWrite . . . . . . . . . . .  PUBLIC   CODE   PROC     0000H  -----
SPI0CN0_NSSMD1 . . . . . . . . . . . .  ABSBIT   -----  BIT      00FBH  1
ADC0 . . . . . . . . . . . . . . . . .  SFR      DATA   U_INT    00BDH  2
SMBTC. . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00B9H  1
PSW. . . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00D0H  1
_UART0_write . . . . . . . . . . . . .  PUBLIC   CODE   PROC     0000H  -----
  value. . . . . . . . . . . . . . . .  AUTO     XDATA  U_CHAR   0000H  1
TMR5CN0_TF5LEN . . . . . . . . . . . .  ABSBIT   -----  BIT      00CDH  1
FLKEY. . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00B7H  1
uint32_t . . . . . . . . . . . . . . .  TYPEDEF  -----  U_LONG   -----  4


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    482    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =     20    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
   EDATA SIZE       =   ----    ----
   HDATA SIZE       =   ----    ----
C51 COMPILER V9.56.0.0   UART_0                                                            10/28/2016 17:37:02 PAGE 120 

   XDATA CONST SIZE =   ----    ----
   FAR CONST SIZE   =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
