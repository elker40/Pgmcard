C51 COMPILER V9.56.0.0   I2C_0                                                             10/28/2016 17:37:02 PAGE 1   


C51 COMPILER V9.56.0.0, COMPILATION OF MODULE I2C_0
OBJECT MODULE PLACED IN .\Objects\i2c_0.obj
COMPILER INVOKED BY: D:\MyProKits\MucKits\Keil_C51_Rev956\C51\BIN\C51.EXE ..\..\SdkTool\EFM8UB2\Perip\Src\i2c_0.c LARGE 
                    -OMF2 OPTIMIZE(0,SPEED) BROWSE INCDIR(..\..\SrcCode\Bsp\Inc;..\..\SrcCode\Logic\Inc;..\..\SrcCode\Middle\Gui\Inc;..\..\Sr
                    -cCode\Middle\Input\Inc;..\..\SdkTool\Si8051Base;..\..\SdkTool\EFM8UB2\Inc;..\..\SdkTool\EFM8UB2\Perip\Inc;..\..\SdkTool\
                    -EFM8UB2\Xpress\Inc) DEBUG CODE LISTINCLUDE SYMBOLS PRINT(.\Listings\i2c_0.lst) TABS(2) PREPRINT(.\Listings\i2c_0.i) OBJE
                    -CT(.\Objects\i2c_0.obj)

line level    source

   1          /**************************************************************************//**
   2           * Copyright (c) 2015 by Silicon Laboratories Inc. All rights reserved.
   3           *
   4           * http://developer.silabs.com/legal/version/v11/Silicon_Labs_Software_License_Agreement.txt
   5           *****************************************************************************/
   6          
   7          #include "i2c_0.h"
   1      =1  /******************************************************************************
   2      =1   * Copyright (c) 2014 by Silicon Laboratories Inc. All rights reserved.
   3      =1   *
   4      =1   * http://developer.silabs.com/legal/version/v11/Silicon_Labs_Software_License_Agreement.txt
   5      =1   *****************************************************************************/
   6      =1  
   7      =1  #ifndef __I2C_0_H__
   8      =1  #define __I2C_0_H__
   9      =1  
  10      =1  
  11      =1  #include "SI_EFM8UB2_Defs.h"
   1      =2  //------------------------------------------------------------------------------
   2      =2  // Copyright 2014 Silicon Laboratories, Inc.
   3      =2  // All rights reserved. This program and the accompanying materials
   4      =2  // are made available under the terms of the Silicon Laboratories End User
   5      =2  // License Agreement which accompanies this distribution, and is available at
   6      =2  // http://developer.silabs.com/legal/version/v11/Silicon_Labs_Software_License_Agreement.txt
   7      =2  // Original content and implementation provided by Silicon Laboratories.
   8      =2  //------------------------------------------------------------------------------
   9      =2  //Supported Devices:
  10      =2  //  EFM8UB20F32G_QFN32
  11      =2  //  EFM8UB20F32G_QFP32
  12      =2  //  EFM8UB20F32G_QFP48
  13      =2  //  EFM8UB20F64G_QFN32
  14      =2  //  EFM8UB20F64G_QFP32
  15      =2  //  EFM8UB20F64G_QFP48
  16      =2  
  17      =2  #ifndef SI_EFM8UB2_DEFS_H
  18      =2  #define SI_EFM8UB2_DEFS_H
  19      =2  
  20      =2  #include <si_toolchain.h>
   1      =3  /******************************************************************************
   2      =3   * Copyright (c) 2015 by Silicon Laboratories Inc. All rights reserved.
   3      =3   *
   4      =3   * http://developer.silabs.com/legal/version/v11/Silicon_Labs_Software_License_Agreement.txt
   5      =3   *****************************************************************************/
   6      =3  
   7      =3  #ifndef __SI_TOOLCHAIN_H__
   8      =3  #define __SI_TOOLCHAIN_H__
   9      =3  
  10      =3  #include <stdint.h>
   1      =4  /**************************************************************************//**
   2      =4   * Copyright (c) 2015 by Silicon Laboratories Inc. All rights reserved.
   3      =4   *
C51 COMPILER V9.56.0.0   I2C_0                                                             10/28/2016 17:37:02 PAGE 2   

   4      =4   * http://developer.silabs.com/legal/version/v11/Silicon_Labs_Software_License_Agreement.txt
   5      =4   *****************************************************************************/
   6      =4  
   7      =4  #ifndef STDINT_H
   8      =4  #define STDINT_H
   9      =4  
  10      =4  #if defined __C51__
  11      =4  
  12      =4  typedef unsigned char     uint8_t;
  13      =4  typedef unsigned short    uint16_t;
  14      =4  typedef unsigned long     uint32_t;
  15      =4  typedef uint32_t          uint64_t[2];
  16      =4  
  17      =4  typedef signed char       int8_t;
  18      =4  typedef short             int16_t;
  19      =4  typedef long              int32_t;
  20      =4  typedef int32_t           int64_t[2];
  21      =4  
  22      =4  #endif
  23      =4  
  24      =4  #endif
  11      =3  #include <stdbool.h>
   1      =4  /**************************************************************************//**
   2      =4   * Copyright (c) 2015 by Silicon Laboratories Inc. All rights reserved.
   3      =4   *
   4      =4   * http://developer.silabs.com/legal/version/v11/Silicon_Labs_Software_License_Agreement.txt
   5      =4   *****************************************************************************/
   6      =4  
   7      =4  #ifndef STDBOOL_H
   8      =4  #define STDBOOL_H
   9      =4  
  10      =4  #if defined __C51__
  11      =4  
  12      =4  typedef bit bool;
  13      =4  enum{
  14      =4    false = 0,
  15      =4    true = 1,
  16      =4  };
  17      =4  
  18      =4  #endif //__C51__
  19      =4  #endif //STDBOOL_H
  20      =4  
  12      =3  
  13      =3  /**************************************************************************//**
  14      =3   *
  15      =3   * @addtogroup toolchain_group Toolchain Abstraction
  16      =3   *
  17      =3   * @brief Macros for toolchain abstraction.
  18      =3   *
  19      =3   * # Introduction #
  20      =3   *
  21      =3   * This header file contains macros that are used to provide an abstraction
  22      =3   * for toolchain use in source code.  The 8051 compiler requires C-language
  23      =3   * extensions in order to fully use features of the 8051 architecture.  All
  24      =3   * compilers for 8051 implement a set of extensions but use different names
  25      =3   * and ways of implementing those extensions.  This header file provides
  26      =3   * macros that are defined for each supported toolchain and can be used in
  27      =3   * the source code.  This allows the source code to use 8051 extensions and
  28      =3   * remain independent of which toolchain is used for compilation.
  29      =3   *
  30      =3   * ## Variable and Pointer Declarations ##
  31      =3   *
C51 COMPILER V9.56.0.0   I2C_0                                                             10/28/2016 17:37:02 PAGE 3   

  32      =3   * It is often useful to specify the memory area (or segment) of a variable,
  33      =3   * pointer, or pointer target.  For example, you may wish to place all
  34      =3   * variables in XDATA by default, but for variables used in time-sensitive
  35      =3   * code you use DATA for efficient access.  In this case you declare the
  36      =3   * XDATA variable in the normal C way, but declare the variables to be located
  37      =3   * in the DATA segment using @ref SI_SEGMENT_VARIABLE.
  38      =3   *
  39      =3   * Pointers are more complicated because there are two memory spaces
  40      =3   * associated with a pointer, the pointer target, and the pointer variable
  41      =3   * itself.  When using default memory segment for the pointer location and
  42      =3   * target, then no special macro is needed.  But if you wish to specify the
  43      =3   * pointer variable location, or target memory segment, then you can use one
  44      =3   * of the following macros to do this in a toolchain-independent way.
  45      =3   *
  46      =3   * |Pointer segment|Target segment|Macro                                   |
  47      =3   * |---------------|--------------|----------------------------------------|
  48      =3   * |default        |generic       |None                                    |
  49      =3   * |default        |specific      |@ref SI_VARIABLE_SEGMENT_POINTER        |
  50      =3   * |specific       |generic       |@ref SI_SEGMENT_POINTER                 |
  51      =3   * |specific       |specific      |@ref SI_SEGMENT_VARIABLE_SEGMENT_POINTER|
  52      =3   *
  53      =3   * ## Prior Toolchain Abstraction Header File ##
  54      =3   *
  55      =3   * This file supercedes an earlier header file named `compiler_defs.h`.  We
  56      =3   * are deprecating the use of compiler_defs.h, however it will remain for
  57      =3   * backwards compatibility.  This file was created to normalize macro names,
  58      =3   * remove unused macros, and to provide documentation.
  59      =3   *
  60      =3   * ## Supported Toolchains ##
  61      =3   *
  62      =3   * - Keil/ARM C51
  63      =3   *
  64      =3   * @{
  65      =3   *
  66      =3   *****************************************************************************/
  67      =3  
  68      =3  // Make sure there is a NULL defined if the toolchain does not provide it.
  69      =3  #ifndef NULL
  70      =3  #define NULL ((void *)0)
  71      =3  #endif
  72      =3  
  73      =3  // -------------------------------
  74      =3  // Keil/ARM C51
  75      =3  //
  76      =3  #if defined(__C51__)
  77      =3  
  78      =3  /// Used with pointers, declares a generic pointer.  Generic pointers
  79      =3  /// work with any memory space but are inefficient.
  80      =3  #define SI_SEG_GENERIC
  81      =3  
  82      =3  /// Declares a variable to be located in 8051 DATA space.
  83      =3  #define SI_SEG_DATA data
  84      =3  
  85      =3  /// Declares a variable to be located in 8051 IDATA space.
  86      =3  #define SI_SEG_IDATA idata
  87      =3  
  88      =3  /// Declares a variable to be located in 8051 XDATA space.
  89      =3  #define SI_SEG_XDATA xdata
  90      =3  
  91      =3  /// Declares a variable to be located in 8051 PDATA space.
  92      =3  #define SI_SEG_PDATA pdata
  93      =3  
C51 COMPILER V9.56.0.0   I2C_0                                                             10/28/2016 17:37:02 PAGE 4   

  94      =3  /// Declares a variable to be located in 8051 BDATA (bit-addressable) space.
  95      =3  #define SI_SEG_BDATA bdata
  96      =3  
  97      =3  /// Declares a variable to be located in 8051 CODE space.
  98      =3  #define SI_SEG_CODE code
  99      =3  
 100      =3  /**************************************************************************//**
 101      =3   * Declares a bit variable in a bit-addressable SFR or memory space.
 102      =3   *
 103      =3   * @param name The name of the bit variable.
 104      =3   * @param address The address of the byte containing the bit.
 105      =3   * @param bitnum The bit number (0-7) within the byte.
 106      =3   *
 107      =3   * This cannot be used to make any arbitrary SFR or variable into
 108      =3   * a bit variable.  The underlying memory must support bit-addressability.
 109      =3   *****************************************************************************/
 110      =3  #define SI_SBIT(name, address, bitnum) sbit name = address^bitnum
 111      =3  
 112      =3  /**************************************************************************//**
 113      =3   * Declares an 8-bit special function register (SFR) variable.
 114      =3   *
 115      =3   * @param name The name of the SFR variable.
 116      =3   * @param address The address of the SFR.
 117      =3   *
 118      =3   * This creates a C variable (8-bit) that maps to a physical special function
 119      =3   * register of the 8051.  This cannot be used to make any arbitrary memory
 120      =3   * location into an SFR.  The _address_ must map to a real SFR in the memory
 121      =3   * map.
 122      =3   *****************************************************************************/
 123      =3  #define SI_SFR(name, address) sfr name = address
 124      =3  
 125      =3  /**************************************************************************//**
 126      =3   * Declares a 16-bit special function register (SFR) variable.
 127      =3   *
 128      =3   * @param name The name of the SFR variable.
 129      =3   * @param address The address of the 16-bit SFR.
 130      =3   *
 131      =3   * This creates a C variable (16-bit) that maps to a physical special function
 132      =3   * register of the 8051.  This cannot be used to make any arbitrary memory
 133      =3   * location into an SFR.  The _address_ must map to a real 16-bit SFR in the
 134      =3   * memory map.
 135      =3   *****************************************************************************/
 136      =3  #define SI_SFR16(name, address) sfr16 name = address
 137      =3  
 138      =3  #ifndef __SLS_IDE__
 139      =3  /**************************************************************************//**
 140      =3   * Define an interrupt handler function for an interrupt vector.
 141      =3   *
 142      =3   * @param name The name of the interrupt handler function.
 143      =3   * @param vector The interrupt vector number.
 144      =3   *
 145      =3   * This macro defines a function to be an interrupt handler.  The _vector_
 146      =3   * parameter is the 8051 interrupt vector number, not the address.  This
 147      =3   * will cause the compiler to treat the function as the interrupt handler
 148      =3   * and generate the appropriate prolog/epilog code.
 149      =3   *
 150      =3   * @note This macro is used to define the function implementation.  To declare
 151      =3   * the interrupt function prototype, use @ref SI_INTERRUPT_PROTO.
 152      =3   *****************************************************************************/
 153      =3  #define SI_INTERRUPT(name, vector) void name (void) interrupt vector
 154      =3  
 155      =3  /**************************************************************************//**
C51 COMPILER V9.56.0.0   I2C_0                                                             10/28/2016 17:37:02 PAGE 5   

 156      =3   * Define an interrupt handler function using a specific register bank.
 157      =3   *
 158      =3   * @param name The name of the interrupt handler function.
 159      =3   * @param vector The interrupt vector number.
 160      =3   * @param regnum The register bank number (0-3).
 161      =3   *
 162      =3   * This macro defines a function to be an interrupt handler, using a specific
 163      =3   * register bank for the interrupt code.  The _vector_ parameter is the 8051
 164      =3   * interrupt vector number, not the address.  The _regnum_ parameter is the
 165      =3   * register bank number (0-3) that will be used as general purpose registers
 166      =3   * for the instructions in the compiled code.  Using dedicated register banks
 167      =3   * for interrupt handlers allows the prolog code to just switch banks instead
 168      =3   * of saving and restoring all the general purpose registers.  This can make
 169      =3   * interrupt entry/exit faster but requires dedicating a register bank for
 170      =3   * the interrupt handler.
 171      =3   *
 172      =3   * @note This macro is used to define the function implementation.  To declare
 173      =3   * the interrupt function prototype, use @ref SI_INTERRUPT_PROTO_USING.
 174      =3   *****************************************************************************/
 175      =3  #define SI_INTERRUPT_USING(name, vector, regnum)                             \
 176      =3               void name (void) interrupt vector using regnum
 177      =3  
 178      =3  /**************************************************************************//**
 179      =3   * Declare an interrupt handler prototype for an interrupt vector.
 180      =3   *
 181      =3   * @param name The name of the interrupt handler function.
 182      =3   * @param vector The interrupt vector number.
 183      =3   *
 184      =3   * This macro declares a function prototype for an interrupt handler.  The
 185      =3   * _vector_ parameter is the 8051 interrupt vector number, not the address.
 186      =3   * Declaring the function prototype this way will cause the compiler to
 187      =3   * recognize that the function is an interrupt handler and not a normal C
 188      =3   * function.
 189      =3   *
 190      =3   * @note This macro is used to declare a prototype for the interrupt function.
 191      =3   * To define the interrupt function implementation, use @ref SI_INTERRUPT.
 192      =3   *****************************************************************************/
 193      =3  #define SI_INTERRUPT_PROTO(name, vector) void name (void)
 194      =3  
 195      =3  /**************************************************************************//**
 196      =3   * Declare an interrupt handler prototype using a specific register bank.
 197      =3   *
 198      =3   * @param name The name of the interrupt handler function.
 199      =3   * @param vector The interrupt vector number.
 200      =3   * @param regnum The register bank number (0-3).
 201      =3   *
 202      =3   * This macro declares a function prototype for an interrupt handler, for a
 203      =3   * function that uses a specific register bank for the interrupt code.  The
 204      =3   * _vector_ parameter is the 8051 interrupt vector number, not the address.
 205      =3   * The _regnum_ parameter is the register bank number (0-3) that will be used
 206      =3   * as general purpose registers in the function.  Declaring the function
 207      =3   * prototype this way will cause the compiler to recognize that the function
 208      =3   * is an interrupt handler and is not a normal C function.
 209      =3   *
 210      =3   * @note This macro is used to declare a prototype for the interrupt function.
 211      =3   * To define the interrupt function implementation,
 212      =3   * use @ref SI_INTERRUPT_USING.
 213      =3   *****************************************************************************/
 214      =3  #define SI_INTERRUPT_PROTO_USING(name, vector, regnum) void name (void)
 215      =3  
 216      =3  /**************************************************************************//**
 217      =3   * Define a function to use a specific register bank.
C51 COMPILER V9.56.0.0   I2C_0                                                             10/28/2016 17:37:02 PAGE 6   

 218      =3   *
 219      =3   * @param name The name of the function.
 220      =3   * @param return_value The data type of the function return value
 221      =3   * (void, int, etc).
 222      =3   * @param parameter One C function parameter (or "void") (type and name).
 223      =3   * @param regnum The register bank number (0-3).
 224      =3   *
 225      =3   * This macro defines a function that uses a specific register bank.  The
 226      =3   * _regnum_ parameter is the register bank number (0-3) that will be used as
 227      =3   * general purpose registers for the instructions in the compiled function
 228      =3   * code.  Using dedicated register banks for a function can reduce the amount
 229      =3   * of registers saving and restoring needed on entry and exit to the
 230      =3   * function.  However, this is an advanced feature and you should not use it
 231      =3   * unless you fully understand how and when to use register banking.
 232      =3   *
 233      =3   * You must specify the _return_value_ which is the type of the function.  It
 234      =3   * can be `void` or any other C type or typedef.  The _parameters_ argument
 235      =3   * is the list of function parameters.  It can be `void` or else it must be
 236      =3   * a parameter data type and name.  It can also be multiple parameters but
 237      =3   * they must be enclosed in parentheses and separated by commas.
 238      =3   *
 239      =3   * __Example__
 240      =3   *
 241      =3   * ~~~~~~~~.c
 242      =3   * // The following is used to implement a function with the following
 243      =3   * // signature, and that uses register bank 3 ...
 244      =3   * uint16_t myFunction(uint8_t parm1, uint8_t parm2);
 245      =3   *
 246      =3   * SI_FUNCTION_USING(myFunction, uint16_t, (uint8_t parm1, uint8_t parm2), 3)
 247      =3   * {
 248      =3   *   // Function implementation body
 249      =3   * }
 250      =3   * ~~~~~~~~
 251      =3   *
 252      =3   * @note This macro is used to define the function implementation.  To declare
 253      =3   * the function prototype, use @ref SI_FUNCTION_PROTO_USING.
 254      =3   *****************************************************************************/
 255      =3  #define SI_FUNCTION_USING(name, return_value, parameter, regnum)              \
 256      =3               return_value name (parameter) using regnum
 257      =3  
 258      =3  /**************************************************************************//**
 259      =3   * Declare a function that uses a specific register bank.
 260      =3   *
 261      =3   * @param name The name of the function.
 262      =3   * @param return_value The data type of the function return value
 263      =3   * (void, int, etc).
 264      =3   * @param parameter One C function parameter (or "void") (type and name).
 265      =3   * @param regnum The register bank number (0-3).
 266      =3   *
 267      =3   * This macro declares a function prototype for a C function that uses a
 268      =3   * specific register its working registers.  See the documentation for
 269      =3   * @ref SI_FUNCTION_USING for an explanation of the macro arguments.  This is
 270      =3   * an advanced feature.
 271      =3   *
 272      =3   * @note This macro is used to declare a prototype for the function.  To
 273      =3   * define the function implementation, use @ref SI_FUNCTION_USING.
 274      =3   *****************************************************************************/
 275      =3  #define SI_FUNCTION_PROTO_USING(name, return_value, parameter, regnum)        \
 276      =3               return_value name (parameter)
 277      =3  
 278      =3  /**************************************************************************//**
 279      =3   * Declare a variable to be located in a specific memory segment.
C51 COMPILER V9.56.0.0   I2C_0                                                             10/28/2016 17:37:02 PAGE 7   

 280      =3   *
 281      =3   * @param name The variable name.
 282      =3   * @param vartype The variable data type.
 283      =3   * @param memseg The memory segment to use for the variable.
 284      =3   *
 285      =3   * This macro declares a variable to be located in a specific memory area
 286      =3   * (or segment) of the 8051 memory space.  It is only necessary to use this
 287      =3   * macro if you want to force the variable into a specific memory space instead
 288      =3   * of the default memory space used by the compiler.  The segment can be
 289      =3   * one of the following:
 290      =3   *
 291      =3   * - @ref SI_SEG_DATA
 292      =3   * - @ref SI_SEG_IDATA
 293      =3   * - @ref SI_SEG_BDATA
 294      =3   * - @ref SI_SEG_PDATA
 295      =3   * - @ref SI_SEG_XDATA
 296      =3   * - @ref SI_SEG_CODE
 297      =3   *
 298      =3   * __Example__
 299      =3   *
 300      =3   * ~~~~~~~~.c
 301      =3   * // The following macro can be used to create a variable located in
 302      =3   * // XDATA with the following signature:
 303      =3   * uint8_t myVar;
 304      =3   *
 305      =3   * SI_SEGMENT_VARIABLE(myVar, uint8_t, SEG_XDATA);
 306      =3   * ~~~~~~~~
 307      =3   *****************************************************************************/
 308      =3  #define SI_SEGMENT_VARIABLE(name, vartype, memseg) vartype memseg name
 309      =3  
 310      =3  /**************************************************************************//**
 311      =3   * Declare a memory segment specific pointer variable.
 312      =3   *
 313      =3   * @param name The pointer variable name.
 314      =3   * @param vartype The pointer data type.
 315      =3   * @param targseg The target memory segment for the pointer.
 316      =3   *
 317      =3   * This macro declares a pointer that points at a specific memory area
 318      =3   * (or segment).  The memory segment of the pointer variable itself is not
 319      =3   * specified and the default is used.  The segment can be one of the following:
 320      =3   *
 321      =3   * - @ref SI_SEG_DATA
 322      =3   * - @ref SI_SEG_IDATA
 323      =3   * - @ref SI_SEG_BDATA
 324      =3   * - @ref SI_SEG_PDATA
 325      =3   * - @ref SI_SEG_XDATA
 326      =3   * - @ref SI_SEG_CODE
 327      =3   *
 328      =3   * __Example__
 329      =3   *
 330      =3   * ~~~~~~~~.c
 331      =3   * // The following macro can be used to create a pointer that points to
 332      =3   * // a location in XDATA with the following signature:
 333      =3   * uint8_t *pVar; // where pVar is pointing at XDATA
 334      =3   *
 335      =3   * SI_VARIABLE_SEGMENT_POINTER(pVar, uint8_t, SEG_XDATA);
 336      =3   * ~~~~~~~~
 337      =3   *****************************************************************************/
 338      =3  #define SI_VARIABLE_SEGMENT_POINTER(name, vartype, targseg)                  \
 339      =3               vartype targseg * name
 340      =3  
 341      =3  /**************************************************************************//**
C51 COMPILER V9.56.0.0   I2C_0                                                             10/28/2016 17:37:02 PAGE 8   

 342      =3   * Declare a memory segment specific pointer variable, in a specific segment.
 343      =3   *
 344      =3   * @param name The pointer variable name.
 345      =3   * @param vartype The pointer data type.
 346      =3   * @param targseg The target memory segment for the pointer.
 347      =3   * @param memseg The memory segment to use for the pointer variable.
 348      =3   *
 349      =3   * This macro declares a pointer that points at a specific memory area
 350      =3   * (or segment).  The pointer variable itself is also located in a specified
 351      =3   * memory segment by _memseg_.  The arguments _targseg_ and _memseg_ can be
 352      =3   * one of the following:
 353      =3   *
 354      =3   * - @ref SI_SEG_DATA
 355      =3   * - @ref SI_SEG_IDATA
 356      =3   * - @ref SI_SEG_BDATA
 357      =3   * - @ref SI_SEG_PDATA
 358      =3   * - @ref SI_SEG_XDATA
 359      =3   * - @ref SI_SEG_CODE
 360      =3   *
 361      =3   * __Example__
 362      =3   *
 363      =3   * ~~~~~~~~.c
 364      =3   * // The following macro can be used to create a pointer that points to
 365      =3   * // a location in XDATA while the pointer itself is located in DATA, with
 366      =3   * // the following signature:
 367      =3   * uint8_t *pVar; // where pVar is located in DATA and is pointing at XDATA
 368      =3   *
 369      =3   * SI_SEGMENT_VARIABLE_SEGMENT_POINTER(pVar, uint8_t, SEG_XDATA, SEG_DATA);
 370      =3   * ~~~~~~~~
 371      =3   *****************************************************************************/
 372      =3  #define SI_SEGMENT_VARIABLE_SEGMENT_POINTER(name, vartype, targseg, memseg)  \
 373      =3               vartype targseg * memseg name
 374      =3  
 375      =3  /**************************************************************************//**
 376      =3   * Declare a generic pointer variable that is located in a specific segment.
 377      =3   *
 378      =3   * @param name The pointer variable name.
 379      =3   * @param vartype The pointer data type.
 380      =3   * @param memseg The memory segment to use for the pointer variable.
 381      =3   *
 382      =3   * This macro declares a pointer that is a generic pointer.  This means it can
 383      =3   * point at any kind of memory location.  However the pointer variable itself
 384      =3   * is located in a specific memory segment by _memseg_, which can be one of
 385      =3   * the following:
 386      =3   *
 387      =3   * - @ref SI_SEG_DATA
 388      =3   * - @ref SI_SEG_IDATA
 389      =3   * - @ref SI_SEG_BDATA
 390      =3   * - @ref SI_SEG_PDATA
 391      =3   * - @ref SI_SEG_XDATA
 392      =3   * - @ref SI_SEG_CODE
 393      =3   *
 394      =3   * __Example__
 395      =3   *
 396      =3   * ~~~~~~~~.c
 397      =3   * // The following macro can be used to create a generic pointer that
 398      =3   * // is located in DATA and points at any memory type, with the
 399      =3   * // following signature:
 400      =3   * uint8_t *pVar; // where pVar is located in DATA and is a generic pointer
 401      =3   *
 402      =3   * SI_SEGMENT_POINTER(pVar, uint8_t, SEG_DATA);
 403      =3   * ~~~~~~~~
C51 COMPILER V9.56.0.0   I2C_0                                                             10/28/2016 17:37:02 PAGE 9   

 404      =3   *****************************************************************************/
 405      =3  #define SI_SEGMENT_POINTER(name, vartype, memseg) vartype * memseg name
 406      =3  
 407      =3  /**************************************************************************//**
 408      =3   * Declare an uninitialized variable that is located at a specific address.
 409      =3   *
 410      =3   * @param name The variable name.
 411      =3   * @param vartype The variable data type.
 412      =3   * @param memseg The memory segment to use for the variable.
 413      =3   * @param address The memory address of the variable.
 414      =3   *
 415      =3   * This macro allows declaring a variable that can be placed at a specific
 416      =3   * location in memory.  This can only be used for variables that do not need
 417      =3   * initializers.  The _address_ is the memory address within the specified
 418      =3   * segment.  The memory segment, _memseg_, can be one of the following:
 419      =3   *
 420      =3   * - @ref SI_SEG_DATA
 421      =3   * - @ref SI_SEG_IDATA
 422      =3   * - @ref SI_SEG_BDATA
 423      =3   * - @ref SI_SEG_PDATA
 424      =3   * - @ref SI_SEG_XDATA
 425      =3   * - @ref SI_SEG_CODE
 426      =3   *
 427      =3   * __Example__
 428      =3   *
 429      =3   * ~~~~~~~~.c
 430      =3   * // The following declares a variable located at 0x4000 in XDATA with
 431      =3   * // the following signature:
 432      =3   * uint8_t myMemVar;
 433      =3   *
 434      =3   * SI_LOCATED_VARIABLE_NO_INIT(myMemVar, uint8_t, SEG_DATA, 0x4000);
 435      =3   * ~~~~~~~~
 436      =3   *****************************************************************************/
 437      =3  #define SI_LOCATED_VARIABLE_NO_INIT(name, vartype, memseg, address)          \
 438      =3               vartype memseg name _at_ address
 439      =3  
 440      =3  
 441      =3  #else  // __SLS_IDE__ : Macros defined to remove syntax errors within Simplicity Studio
           =3 #define SI_INTERRUPT(name, vector) void name (void)
           =3 #define SI_INTERRUPT_USING(name, vector, regnum) void name (void)
           =3 #define SI_INTERRUPT_PROTO(name, vector) void name (void)
           =3 #define SI_INTERRUPT_PROTO_USING(name, vector, regnum) void name (void)
           =3 
           =3 #define SI_FUNCTION_USING(name, return_value, parameter, regnum) return_value name (parameter)
           =3 #define SI_FUNCTION_PROTO_USING(name, return_value, parameter, regnum) return_value name (parameter)
           =3 // Note: Parameter must be either 'void' or include a variable type and name. (Ex: char temp_variable)
           =3 
           =3 #define SI_SEGMENT_VARIABLE(name, vartype, locsegment) vartype name
           =3 #define SI_VARIABLE_SEGMENT_POINTER(name, vartype, targsegment) vartype * name
           =3 #define SI_SEGMENT_VARIABLE_SEGMENT_POINTER(name, vartype, targsegment, locsegment) vartype * name
           =3 #define SI_SEGMENT_POINTER(name, vartype, locsegment) vartype * name
           =3 #define SI_LOCATED_VARIABLE_NO_INIT(name, vartype, locsegment, addr) vartype name
           =3 #endif // __SLS_IDE__
 457      =3  
 458      =3  // The following are used for byte ordering when referring to individual
 459      =3  // bytes within a SI_UU32_t.  B0 is the least significant byte.
 460      =3  #define B0 3 ///< Least significant byte of a 4 byte word
 461      =3  #define B1 2 ///< Byte 1 of a 4-byte word, where byte 0 is LSB
 462      =3  #define B2 1 ///< Byte 2 of a 4-byte word, where byte 0 is LSB
 463      =3  #define B3 0 ///< Most significant byte of a 4-byte word
 464      =3  
 465      =3  #define LSB 1 ///< Index to least significant bit of a 2 byte word
C51 COMPILER V9.56.0.0   I2C_0                                                             10/28/2016 17:37:02 PAGE 10  

 466      =3  #define MSB 0 ///< Index to most significant bit of a 2 byte word
 467      =3  
 468      =3  /// A union type to make it easier to access individual bytes of a 16-bit
 469      =3  /// word, and to use as signed or unsigned type.
 470      =3  typedef union SI_UU16
 471      =3  {
 472      =3    uint16_t u16;   ///< The two byte value as a 16-bit unsigned integer.
 473      =3    int16_t s16;    ///< The two byte value as a 16-bit signed integer.
 474      =3    uint8_t u8[2];  ///< The two byte value as two unsigned 8-bit integers.
 475      =3    int8_t s8[2];   ///< The two byte value as two signed 8-bit integers.
 476      =3  } SI_UU16_t;
 477      =3  
 478      =3  /// A union type to make it easier to access individual bytes within a
 479      =3  /// 32-bit word, or to access it as variations of 16-bit words, or to
 480      =3  /// use as signed or unsigned type.
 481      =3  typedef union SI_UU32
 482      =3  {
 483      =3    uint32_t u32;       ///< The 4-byte value as a 32-bit unsigned integer.
 484      =3    int32_t s32;        ///< The 4-byte value as a 32-bit signed integer.
 485      =3    SI_UU16_t uu16[2];  ///< The 4-byte value as a SI_UU16_t.
 486      =3    uint16_t u16[2];    ///< The 4-byte value as two unsigned 16-bit integers.
 487      =3    int16_t s16[2];     ///< The 4-byte value as two signed 16-bit integers.
 488      =3    uint8_t u8[4];      ///< The 4-byte value as 4 unsigned 8-bit integers.
 489      =3    int8_t s8[4];       ///< The 4-byte value as 4 signed 8-bit integers.
 490      =3  } SI_UU32_t;
 491      =3  
 492      =3  // Generic pointer memory segment constants.
 493      =3  #define SI_GPTR                   ///< Generic pointer indeterminate type.
 494      =3  #define SI_GPTR_MTYPE_DATA  0x00  ///< Generic pointer for DATA segment.
 495      =3  #define SI_GPTR_MTYPE_IDATA 0x00  ///< Generic pointer for IDATA segment.
 496      =3  #define SI_GPTR_MTYPE_BDATA 0x00  ///< Generic pointer for BDATA segment.
 497      =3  #define SI_GPTR_MTYPE_PDATA 0xFE  ///< Generic pointer for PDATA segment.
 498      =3  #define SI_GPTR_MTYPE_XDATA 0x01  ///< Generic pointer for XDATA segment.
 499      =3  #define SI_GPTR_MTYPE_CODE  0xFF  ///< Generic pointer for CODE segment.
 500      =3  
 501      =3  /// Generic pointer structure containing the type and address.
 502      =3  typedef struct
 503      =3  {
 504      =3    uint8_t memtype;    ///< The type of memory of the generic pointer.
 505      =3    SI_UU16_t address;  ///< The address of the generic pointer.
 506      =3  } GPTR_t;
 507      =3  
 508      =3  /// A union type to allow access to the fields of a generic pointer.
 509      =3  /// A generic pointer has a field indicating the type of memory and an
 510      =3  /// address within the memory.
 511      =3  typedef union SI_GEN_PTR
 512      =3  {
 513      =3    uint8_t u8[3];    ///< 3-byte generic pointer as 3 unsigned 8-bit integers.
 514      =3    GPTR_t gptr;      ///< 3-byte generic pointer as pointer structure
 515      =3  } SI_GEN_PTR_t;
 516      =3  
 517      =3  // Declaration of Keil intrinisc
 518      =3  extern void _nop_(void);
 519      =3  /// Macro to insert a no-operation (NOP) instruction.
 520      =3  #define NOP() _nop_()
 521      =3  
 522      =3  // -------------------------------
 523      =3  // GCC for ARM Cortex-M
 524      =3  // Provides support for code that can be compiled for 8 or 32-bit
 525      =3  //
 526      =3  #elif defined (__GNUC__)
           =3 #if defined(__ARMEL__) && ((__ARMEL__ == 1) && ((__ARM_ARCH == 6) || (__ARM_ARCH == 7)))
C51 COMPILER V9.56.0.0   I2C_0                                                             10/28/2016 17:37:02 PAGE 11  

           =3 
           =3 // these ignore any memory segment directives
           =3 #define SI_SEG_GENERIC
           =3 #define SI_SEG_DATA
           =3 #define SI_SEG_IDATA
           =3 #define SI_SEG_XDATA
           =3 #define SI_SEG_PDATA
           =3 #define SI_SEG_BDATA
           =3 #define SI_SEG_CODE
           =3 
           =3 // the following create a variable of the specified name but ignore the
           =3 // address and bit number.  If the using-code cares about the actual
           =3 // address or bit number, this probably will break it
           =3 #define SI_SBIT(name, address, bitnum) uint8_t name
           =3 #define SI_SFR(name, address) uint8_t name
           =3 #define SI_SFR16(name, address) uint16_t name
           =3 
           =3 // the following create function and variable names of the specified types
           =3 // but the 8051-specific aspects (like memory segment) are ignored
           =3 #define SI_INTERRUPT(name, vector) void name (void)
           =3 #define SI_INTERRUPT_USING(name, vector, regnum) void name (void)
           =3 #define SI_INTERRUPT_PROTO(name, vector) void name (void)
           =3 #define SI_INTERRUPT_PROTO_USING(name, vector, regnum) void name (void)
           =3 #define SI_FUNCTION_USING(name, return_value, parameter, regnum)              \
           =3              return_value name (parameter)
           =3 #define SI_FUNCTION_PROTO_USING(name, return_value, parameter, regnum)        \
           =3              return_value name (parameter)
           =3 #define SI_SEGMENT_VARIABLE(name, vartype, memseg) vartype name
           =3 #define SI_VARIABLE_SEGMENT_POINTER(name, vartype, targseg)                  \
           =3              vartype * name
           =3 #define SI_SEGMENT_VARIABLE_SEGMENT_POINTER(name, vartype, targseg, memseg)  \
           =3              vartype * name
           =3 #define SI_SEGMENT_POINTER(name, vartype, memseg) vartype * name
           =3 #define SI_LOCATED_VARIABLE_NO_INIT(name, vartype, memseg, address)          \
           =3              vartype name
           =3 
           =3 #define B0 0
           =3 #define B1 1
           =3 #define B2 2
           =3 #define B3 3
           =3 #define LSB 0
           =3 #define MSB 1
           =3 typedef union SI_UU16
           =3 {
           =3   uint16_t u16;
           =3   int16_t s16;
           =3   uint8_t u8[2];
           =3   int8_t s8[2];
           =3 } SI_UU16_t;
           =3 
           =3 typedef union SI_UU32
           =3 {
           =3   uint32_t u32;
           =3   int32_t s32;
           =3   SI_UU16_t uu16[2];
           =3   uint16_t u16[2];
           =3   int16_t s16[2];
           =3   uint8_t u8[4];
           =3   int8_t s8[4];
           =3 } SI_UU32_t;
           =3 
           =3 // Generic pointer stuff is left out because if you are accessing
C51 COMPILER V9.56.0.0   I2C_0                                                             10/28/2016 17:37:02 PAGE 12  

           =3 // generic pointer fields then it will need to be rewritten for 32-bit
           =3 
           =3 // __NOP should be declared in cmsis header core_cmInstr.h
           =3 extern void __NOP(void);
           =3 /// Macro to insert a no-operation (NOP) instruction.
           =3 #define NOP() __NOP()
           =3 
           =3 #else // ARM_ARCH 6 | 7
           =3 #error unsupported ARM arch
           =3 #endif
           =3 
           =3 #else // unknown toolchain
           =3 #error Unrecognized toolchain in si_toolchain.h
           =3 #endif
 604      =3  
 605      =3  /** @} */
 606      =3  
 607      =3  #endif
  21      =2  
  22      =2  //-----------------------------------------------------------------------------
  23      =2  // Register Definitions
  24      =2  //-----------------------------------------------------------------------------
  25      =2  SI_SFR (ACC,      0xE0); ///< Accumulator                           
  26      =2  SI_SFR (ADC0CF,   0xBC); ///< ADC0 Configuration                    
  27      =2  SI_SFR (ADC0CN0,  0xE8); ///< ADC0 Control                          
  28      =2  SI_SFR (ADC0GTH,  0xC4); ///< ADC0 Greater-Than High Byte           
  29      =2  SI_SFR (ADC0GTL,  0xC3); ///< ADC0 Greater-Than Low Byte            
  30      =2  SI_SFR (ADC0H,    0xBE); ///< ADC0 Data Word High Byte              
  31      =2  SI_SFR (ADC0L,    0xBD); ///< ADC0 Data Word Low Byte               
  32      =2  SI_SFR (ADC0LTH,  0xC6); ///< ADC0 Less-Than High Byte              
  33      =2  SI_SFR (ADC0LTL,  0xC5); ///< ADC0 Less-Than Low Byte               
  34      =2  SI_SFR (AMX0N,    0xBA); ///< AMUX0 Negative Multiplexer Selection  
  35      =2  SI_SFR (AMX0P,    0xBB); ///< AMUX0 Positive Multiplexer Selection  
  36      =2  SI_SFR (B,        0xF0); ///< B Register                            
  37      =2  SI_SFR (CKCON0,   0x8E); ///< Clock Control 0                       
  38      =2  SI_SFR (CKCON1,   0xE4); ///< Clock Control 1                       
  39      =2  SI_SFR (CLKSEL,   0xA9); ///< Clock Select                          
  40      =2  SI_SFR (CMP0CN0,  0x9B); ///< Comparator 0 Control 0                
  41      =2  SI_SFR (CMP0MD,   0x9D); ///< Comparator 0 Mode                     
  42      =2  SI_SFR (CMP0MX,   0x9F); ///< Comparator 0 Multiplexer Selection    
  43      =2  SI_SFR (CMP1CN0,  0x9A); ///< Comparator 1 Control 0                
  44      =2  SI_SFR (CMP1MD,   0x9C); ///< Comparator 1 Mode                     
  45      =2  SI_SFR (CMP1MX,   0x9E); ///< Comparator 1 Multiplexer Selection    
  46      =2  SI_SFR (DPH,      0x83); ///< Data Pointer High                     
  47      =2  SI_SFR (DPL,      0x82); ///< Data Pointer Low                      
  48      =2  SI_SFR (EIE1,     0xE6); ///< Extended Interrupt Enable 1           
  49      =2  SI_SFR (EIE2,     0xE7); ///< Extended Interrupt Enable 2           
  50      =2  SI_SFR (EIP1,     0xF6); ///< Extended Interrupt Priority 1         
  51      =2  SI_SFR (EIP2,     0xF7); ///< Extended Interrupt Priority 2         
  52      =2  SI_SFR (EMI0CF,   0x85); ///< External Memory Configuration         
  53      =2  SI_SFR (EMI0CN,   0xAA); ///< External Memory Interface Control     
  54      =2  SI_SFR (EMI0TC,   0x84); ///< External Memory Timing Control        
  55      =2  SI_SFR (FLKEY,    0xB7); ///< Flash Lock and Key                    
  56      =2  SI_SFR (FLSCL,    0xB6); ///< Flash Scale                           
  57      =2  SI_SFR (HFO0CAL,  0xB3); ///< High Frequency Oscillator Calibration 
  58      =2  SI_SFR (HFO0CN,   0xB2); ///< High Frequency Oscillator Control     
  59      =2  SI_SFR (IE,       0xA8); ///< Interrupt Enable                      
  60      =2  SI_SFR (IP,       0xB8); ///< Interrupt Priority                    
  61      =2  SI_SFR (IT01CF,   0xE4); ///< INT0/INT1 Configuration               
  62      =2  SI_SFR (LFO0CN,   0x86); ///< Low Frequency Oscillator Control      
  63      =2  SI_SFR (P0,       0x80); ///< Port 0 Pin Latch                      
  64      =2  SI_SFR (P0MDIN,   0xF1); ///< Port 0 Input Mode                     
C51 COMPILER V9.56.0.0   I2C_0                                                             10/28/2016 17:37:02 PAGE 13  

  65      =2  SI_SFR (P0MDOUT,  0xA4); ///< Port 0 Output Mode                    
  66      =2  SI_SFR (P0SKIP,   0xD4); ///< Port 0 Skip                           
  67      =2  SI_SFR (P1,       0x90); ///< Port 1 Pin Latch                      
  68      =2  SI_SFR (P1MDIN,   0xF2); ///< Port 1 Input Mode                     
  69      =2  SI_SFR (P1MDOUT,  0xA5); ///< Port 1 Output Mode                    
  70      =2  SI_SFR (P1SKIP,   0xD5); ///< Port 1 Skip                           
  71      =2  SI_SFR (P2,       0xA0); ///< Port 2 Pin Latch                      
  72      =2  SI_SFR (P2MDIN,   0xF3); ///< Port 2 Input Mode                     
  73      =2  SI_SFR (P2MDOUT,  0xA6); ///< Port 2 Output Mode                    
  74      =2  SI_SFR (P2SKIP,   0xD6); ///< Port 2 Skip                           
  75      =2  SI_SFR (P3,       0xB0); ///< Port 3 Pin Latch                      
  76      =2  SI_SFR (P3MDIN,   0xF4); ///< Port 3 Input Mode                     
  77      =2  SI_SFR (P3MDOUT,  0xA7); ///< Port 3 Output Mode                    
  78      =2  SI_SFR (P3SKIP,   0xDF); ///< Port 3 Skip                           
  79      =2  SI_SFR (P4,       0xC7); ///< Port 4 Pin Latch                      
  80      =2  SI_SFR (P4MDIN,   0xF5); ///< Port 4 Input Mode                     
  81      =2  SI_SFR (P4MDOUT,  0xAE); ///< Port 4 Output Mode                    
  82      =2  SI_SFR (PCA0CN0,  0xD8); ///< PCA Control 0                         
  83      =2  SI_SFR (PCA0CPH0, 0xFC); ///< PCA Channel 0 Capture Module High Byte
  84      =2  SI_SFR (PCA0CPH1, 0xEA); ///< PCA Channel 1 Capture Module High Byte
  85      =2  SI_SFR (PCA0CPH2, 0xEC); ///< PCA Channel 2 Capture Module High Byte
  86      =2  SI_SFR (PCA0CPH3, 0xEE); ///< PCA Channel 3 Capture Module High Byte
  87      =2  SI_SFR (PCA0CPH4, 0xFE); ///< PCA Channel 4 Capture Module High Byte
  88      =2  SI_SFR (PCA0CPL0, 0xFB); ///< PCA Channel 0 Capture Module Low Byte 
  89      =2  SI_SFR (PCA0CPL1, 0xE9); ///< PCA Channel 1 Capture Module Low Byte 
  90      =2  SI_SFR (PCA0CPL2, 0xEB); ///< PCA Channel 2 Capture Module Low Byte 
  91      =2  SI_SFR (PCA0CPL3, 0xED); ///< PCA Channel 3 Capture Module Low Byte 
  92      =2  SI_SFR (PCA0CPL4, 0xFD); ///< PCA Channel 4 Capture Module Low Byte 
  93      =2  SI_SFR (PCA0CPM0, 0xDA); ///< PCA Channel 0 Capture/Compare Mode    
  94      =2  SI_SFR (PCA0CPM1, 0xDB); ///< PCA Channel 1 Capture/Compare Mode    
  95      =2  SI_SFR (PCA0CPM2, 0xDC); ///< PCA Channel 2 Capture/Compare Mode    
  96      =2  SI_SFR (PCA0CPM3, 0xDD); ///< PCA Channel 3 Capture/Compare Mode    
  97      =2  SI_SFR (PCA0CPM4, 0xDE); ///< PCA Channel 4 Capture/Compare Mode    
  98      =2  SI_SFR (PCA0H,    0xFA); ///< PCA Counter/Timer High Byte           
  99      =2  SI_SFR (PCA0L,    0xF9); ///< PCA Counter/Timer Low Byte            
 100      =2  SI_SFR (PCA0MD,   0xD9); ///< PCA Mode                              
 101      =2  SI_SFR (PCON0,    0x87); ///< Power Control                         
 102      =2  SI_SFR (PFE0CN,   0xAF); ///< Prefetch Engine Control               
 103      =2  SI_SFR (PSCTL,    0x8F); ///< Program Store Control                 
 104      =2  SI_SFR (PSW,      0xD0); ///< Program Status Word                   
 105      =2  SI_SFR (REF0CN,   0xD1); ///< Voltage Reference Control             
 106      =2  SI_SFR (REG01CN,  0xC9); ///< Voltage Regulator Control             
 107      =2  SI_SFR (RSTSRC,   0xEF); ///< Reset Source                          
 108      =2  SI_SFR (SBCON1,   0xAC); ///< UART1 Baud Rate Generator Control     
 109      =2  SI_SFR (SBRLH1,   0xB5); ///< UART1 Baud Rate Generator High Byte   
 110      =2  SI_SFR (SBRLL1,   0xB4); ///< UART1 Baud Rate Generator Low Byte    
 111      =2  SI_SFR (SBUF0,    0x99); ///< UART0 Serial Port Data Buffer         
 112      =2  SI_SFR (SBUF1,    0xD3); ///< UART1 Serial Port Data Buffer         
 113      =2  SI_SFR (SCON0,    0x98); ///< UART0 Serial Port Control             
 114      =2  SI_SFR (SCON1,    0xD2); ///< UART1 Serial Port Control             
 115      =2  SI_SFR (SFRPAGE,  0xBF); ///< SFR Page                              
 116      =2  SI_SFR (SMB0ADM,  0xCE); ///< SMBus 0 Slave Address Mask            
 117      =2  SI_SFR (SMB0ADR,  0xCF); ///< SMBus 0 Slave Address                 
 118      =2  SI_SFR (SMB0CF,   0xC1); ///< SMBus 0 Configuration                 
 119      =2  SI_SFR (SMB0CN0,  0xC0); ///< SMBus 0 Control                       
 120      =2  SI_SFR (SMB0DAT,  0xC2); ///< SMBus 0 Data                          
 121      =2  SI_SFR (SMB1ADM,  0xCE); ///< SMBus 1 Slave Address Mask            
 122      =2  SI_SFR (SMB1ADR,  0xCF); ///< SMBus 1 Slave Address                 
 123      =2  SI_SFR (SMB1CF,   0xC1); ///< SMBus 1 Configuration                 
 124      =2  SI_SFR (SMB1CN0,  0xC0); ///< SMBus 1 Control                       
 125      =2  SI_SFR (SMB1DAT,  0xC2); ///< SMBus 1 Data                          
 126      =2  SI_SFR (SMBTC,    0xB9); ///< SMBus Timing and Pin Control          
C51 COMPILER V9.56.0.0   I2C_0                                                             10/28/2016 17:37:02 PAGE 14  

 127      =2  SI_SFR (SMOD1,    0xE5); ///< UART1 Mode                            
 128      =2  SI_SFR (SP,       0x81); ///< Stack Pointer                         
 129      =2  SI_SFR (SPI0CFG,  0xA1); ///< SPI0 Configuration                    
 130      =2  SI_SFR (SPI0CKR,  0xA2); ///< SPI0 Clock Rate                       
 131      =2  SI_SFR (SPI0CN0,  0xF8); ///< SPI0 Control                          
 132      =2  SI_SFR (SPI0DAT,  0xA3); ///< SPI0 Data                             
 133      =2  SI_SFR (TCON,     0x88); ///< Timer 0/1 Control                     
 134      =2  SI_SFR (TH0,      0x8C); ///< Timer 0 High Byte                     
 135      =2  SI_SFR (TH1,      0x8D); ///< Timer 1 High Byte                     
 136      =2  SI_SFR (TL0,      0x8A); ///< Timer 0 Low Byte                      
 137      =2  SI_SFR (TL1,      0x8B); ///< Timer 1 Low Byte                      
 138      =2  SI_SFR (TMOD,     0x89); ///< Timer 0/1 Mode                        
 139      =2  SI_SFR (TMR2CN0,  0xC8); ///< Timer 2 Control 0                     
 140      =2  SI_SFR (TMR2H,    0xCD); ///< Timer 2 High Byte                     
 141      =2  SI_SFR (TMR2L,    0xCC); ///< Timer 2 Low Byte                      
 142      =2  SI_SFR (TMR2RLH,  0xCB); ///< Timer 2 Reload High Byte              
 143      =2  SI_SFR (TMR2RLL,  0xCA); ///< Timer 2 Reload Low Byte               
 144      =2  SI_SFR (TMR3CN0,  0x91); ///< Timer 3 Control 0                     
 145      =2  SI_SFR (TMR3H,    0x95); ///< Timer 3 High Byte                     
 146      =2  SI_SFR (TMR3L,    0x94); ///< Timer 3 Low Byte                      
 147      =2  SI_SFR (TMR3RLH,  0x93); ///< Timer 3 Reload High Byte              
 148      =2  SI_SFR (TMR3RLL,  0x92); ///< Timer 3 Reload Low Byte               
 149      =2  SI_SFR (TMR4CN0,  0x91); ///< Timer 4 Control 0                     
 150      =2  SI_SFR (TMR4H,    0x95); ///< Timer 4 High Byte                     
 151      =2  SI_SFR (TMR4L,    0x94); ///< Timer 4 Low Byte                      
 152      =2  SI_SFR (TMR4RLH,  0x93); ///< Timer 4 Reload High Byte              
 153      =2  SI_SFR (TMR4RLL,  0x92); ///< Timer 4 Reload Low Byte               
 154      =2  SI_SFR (TMR5CN0,  0xC8); ///< Timer 5 Control 0                     
 155      =2  SI_SFR (TMR5H,    0xCD); ///< Timer 5 High Byte                     
 156      =2  SI_SFR (TMR5L,    0xCC); ///< Timer 5 Low Byte                      
 157      =2  SI_SFR (TMR5RLH,  0xCB); ///< Timer 5 Reload High Byte              
 158      =2  SI_SFR (TMR5RLL,  0xCA); ///< Timer 5 Reload Low Byte               
 159      =2  SI_SFR (USB0ADR,  0x96); ///< USB0 Indirect Address                 
 160      =2  SI_SFR (USB0DAT,  0x97); ///< USB0 Data                             
 161      =2  SI_SFR (USB0XCN,  0xD7); ///< USB0 Transceiver Control              
 162      =2  SI_SFR (VDM0CN,   0xFF); ///< Supply Monitor Control                
 163      =2  SI_SFR (XBR0,     0xE1); ///< Port I/O Crossbar 0                   
 164      =2  SI_SFR (XBR1,     0xE2); ///< Port I/O Crossbar 1                   
 165      =2  SI_SFR (XBR2,     0xE3); ///< Port I/O Crossbar 2                   
 166      =2  SI_SFR (XOSC0CN,  0xB1); ///< External Oscillator Control           
 167      =2  
 168      =2  //------------------------------------------------------------------------------
 169      =2  // 16-bit Register Definitions (may not work on all compilers)
 170      =2  //------------------------------------------------------------------------------
 171      =2  SI_SFR16 (ADC0GT,  0xC3); ///< ADC0 Greater-Than            
 172      =2  SI_SFR16 (ADC0,    0xBD); ///< ADC0 Data Word               
 173      =2  SI_SFR16 (ADC0LT,  0xC5); ///< ADC0 Less-Than               
 174      =2  SI_SFR16 (DP,      0x82); ///< Data Pointer                 
 175      =2  SI_SFR16 (PCA0CP0, 0xFB); ///< PCA Channel 0 Capture Module 
 176      =2  SI_SFR16 (PCA0CP1, 0xE9); ///< PCA Channel 1 Capture Module 
 177      =2  SI_SFR16 (PCA0CP2, 0xEB); ///< PCA Channel 2 Capture Module 
 178      =2  SI_SFR16 (PCA0CP3, 0xED); ///< PCA Channel 3 Capture Module 
 179      =2  SI_SFR16 (PCA0CP4, 0xFD); ///< PCA Channel 4 Capture Module 
 180      =2  SI_SFR16 (PCA0,    0xF9); ///< PCA Counter/Timer            
 181      =2  SI_SFR16 (SBRL1,   0xB4); ///< UART1 Baud Rate Generator    
 182      =2  SI_SFR16 (TMR2,    0xCC); ///< Timer 2                      
 183      =2  SI_SFR16 (TMR2RL,  0xCA); ///< Timer 2 Reload               
 184      =2  SI_SFR16 (TMR3,    0x94); ///< Timer 3                      
 185      =2  SI_SFR16 (TMR3RL,  0x92); ///< Timer 3 Reload               
 186      =2  SI_SFR16 (TMR4,    0x94); ///< Timer 4                      
 187      =2  SI_SFR16 (TMR4RL,  0x92); ///< Timer 4 Reload               
 188      =2  SI_SFR16 (TMR5,    0xCC); ///< Timer 5                      
C51 COMPILER V9.56.0.0   I2C_0                                                             10/28/2016 17:37:02 PAGE 15  

 189      =2  SI_SFR16 (TMR5RL,  0xCA); ///< Timer 5 Reload               
 190      =2  
 191      =2  //------------------------------------------------------------------------------
 192      =2  // Indirect Register Definitions
 193      =2  //------------------------------------------------------------------------------
 194      =2  #define CLKREC   0x0F ///< USB0 Clock Recovery Control       
 195      =2  #define CMIE     0x0B ///< USB0 Common Interrupt Enable      
 196      =2  #define CMINT    0x06 ///< USB0 Common Interrupt             
 197      =2  #define E0CNT    0x16 ///< USB0 Endpoint0 Data Count         
 198      =2  #define E0CSR    0x11 ///< USB0 Endpoint0 Control            
 199      =2  #define EENABLE  0x1E ///< USB0 Endpoint Enable              
 200      =2  #define EINCSRH  0x12 ///< USB0 IN Endpoint Control High     
 201      =2  #define EINCSRL  0x11 ///< USB0 IN Endpoint Control          
 202      =2  #define EOUTCNTH 0x17 ///< USB0 OUT Endpoint Count High      
 203      =2  #define EOUTCNTL 0x16 ///< USB0 OUT Endpoint Count           
 204      =2  #define EOUTCSRH 0x15 ///< USB0 OUT Endpoint Control High    
 205      =2  #define EOUTCSRL 0x14 ///< USB0 OUT Endpoint Control         
 206      =2  #define FADDR    0x00 ///< USB0 Function Address             
 207      =2  #define FIFO0    0x20 ///< USB0 Endpoint 0 FIFO Access       
 208      =2  #define FIFO1    0x21 ///< USB0 Endpoint 1 FIFO Access       
 209      =2  #define FIFO2    0x22 ///< USB0 Endpoint 2 FIFO Access       
 210      =2  #define FIFO3    0x23 ///< USB0 Endpoint 3 FIFO Access       
 211      =2  #define FRAMEH   0x0D ///< USB0 Frame Number High            
 212      =2  #define FRAMEL   0x0C ///< USB0 Frame Number                 
 213      =2  #define IN1IE    0x07 ///< USB0 IN Endpoint Interrupt Enable 
 214      =2  #define IN1INT   0x02 ///< USB0 IN Endpoint Interrupt        
 215      =2  #define INDEX    0x0E ///< USB0 Endpoint Index               
 216      =2  #define OUT1IE   0x09 ///< USB0 OUT Endpoint Interrupt Enable
 217      =2  #define OUT1INT  0x04 ///< USB0 OUT Endpoint Interrupt       
 218      =2  #define POWER    0x01 ///< USB0 Power                        
 219      =2  
 220      =2  //------------------------------------------------------------------------------
 221      =2  // Bit Definitions
 222      =2  //------------------------------------------------------------------------------
 223      =2  
 224      =2  // ACC (Accumulator)
 225      =2  #define SFR_ACC 0xE0
 226      =2  SI_SBIT (ACC_ACC0, SFR_ACC, 0); ///< Accumulator Bit 0
 227      =2  SI_SBIT (ACC_ACC1, SFR_ACC, 1); ///< Accumulator Bit 1
 228      =2  SI_SBIT (ACC_ACC2, SFR_ACC, 2); ///< Accumulator Bit 2
 229      =2  SI_SBIT (ACC_ACC3, SFR_ACC, 3); ///< Accumulator Bit 3
 230      =2  SI_SBIT (ACC_ACC4, SFR_ACC, 4); ///< Accumulator Bit 4
 231      =2  SI_SBIT (ACC_ACC5, SFR_ACC, 5); ///< Accumulator Bit 5
 232      =2  SI_SBIT (ACC_ACC6, SFR_ACC, 6); ///< Accumulator Bit 6
 233      =2  SI_SBIT (ACC_ACC7, SFR_ACC, 7); ///< Accumulator Bit 7
 234      =2  
 235      =2  // ADC0CN0 (ADC0 Control)
 236      =2  #define SFR_ADC0CN0 0xE8
 237      =2  SI_SBIT (ADC0CN0_ADCM0,  SFR_ADC0CN0, 0); ///< Start of Conversion Mode Select Bit 0
 238      =2  SI_SBIT (ADC0CN0_ADCM1,  SFR_ADC0CN0, 1); ///< Start of Conversion Mode Select Bit 1
 239      =2  SI_SBIT (ADC0CN0_ADCM2,  SFR_ADC0CN0, 2); ///< Start of Conversion Mode Select Bit 2
 240      =2  SI_SBIT (ADC0CN0_ADWINT, SFR_ADC0CN0, 3); ///< Window Compare Interrupt Flag        
 241      =2  SI_SBIT (ADC0CN0_ADBUSY, SFR_ADC0CN0, 4); ///< ADC Busy                             
 242      =2  SI_SBIT (ADC0CN0_ADINT,  SFR_ADC0CN0, 5); ///< Conversion Complete Interrupt Flag   
 243      =2  SI_SBIT (ADC0CN0_ADTM,   SFR_ADC0CN0, 6); ///< Track Mode                           
 244      =2  SI_SBIT (ADC0CN0_ADEN,   SFR_ADC0CN0, 7); ///< ADC Enable                           
 245      =2  
 246      =2  // B (B Register)
 247      =2  #define SFR_B 0xF0
 248      =2  SI_SBIT (B_B0, SFR_B, 0); ///< B Register Bit 0
 249      =2  SI_SBIT (B_B1, SFR_B, 1); ///< B Register Bit 1
 250      =2  SI_SBIT (B_B2, SFR_B, 2); ///< B Register Bit 2
C51 COMPILER V9.56.0.0   I2C_0                                                             10/28/2016 17:37:02 PAGE 16  

 251      =2  SI_SBIT (B_B3, SFR_B, 3); ///< B Register Bit 3
 252      =2  SI_SBIT (B_B4, SFR_B, 4); ///< B Register Bit 4
 253      =2  SI_SBIT (B_B5, SFR_B, 5); ///< B Register Bit 5
 254      =2  SI_SBIT (B_B6, SFR_B, 6); ///< B Register Bit 6
 255      =2  SI_SBIT (B_B7, SFR_B, 7); ///< B Register Bit 7
 256      =2  
 257      =2  // IE (Interrupt Enable)
 258      =2  #define SFR_IE 0xA8
 259      =2  SI_SBIT (IE_EX0,   SFR_IE, 0); ///< External Interrupt 0 Enable
 260      =2  SI_SBIT (IE_ET0,   SFR_IE, 1); ///< Timer 0 Interrupt Enable   
 261      =2  SI_SBIT (IE_EX1,   SFR_IE, 2); ///< External Interrupt 1 Enable
 262      =2  SI_SBIT (IE_ET1,   SFR_IE, 3); ///< Timer 1 Interrupt Enable   
 263      =2  SI_SBIT (IE_ES0,   SFR_IE, 4); ///< UART0 Interrupt Enable     
 264      =2  SI_SBIT (IE_ET2,   SFR_IE, 5); ///< Timer 2 Interrupt Enable   
 265      =2  SI_SBIT (IE_ESPI0, SFR_IE, 6); ///< SPI0 Interrupt Enable      
 266      =2  SI_SBIT (IE_EA,    SFR_IE, 7); ///< All Interrupts Enable      
 267      =2  
 268      =2  // IP (Interrupt Priority)
 269      =2  #define SFR_IP 0xB8
 270      =2  SI_SBIT (IP_PX0,   SFR_IP, 0); ///< External Interrupt 0 Priority Control                        
 271      =2  SI_SBIT (IP_PT0,   SFR_IP, 1); ///< Timer 0 Interrupt Priority Control                           
 272      =2  SI_SBIT (IP_PX1,   SFR_IP, 2); ///< External Interrupt 1 Priority Control                        
 273      =2  SI_SBIT (IP_PT1,   SFR_IP, 3); ///< Timer 1 Interrupt Priority Control                           
 274      =2  SI_SBIT (IP_PS0,   SFR_IP, 4); ///< UART0 Interrupt Priority Control                             
 275      =2  SI_SBIT (IP_PT2,   SFR_IP, 5); ///< Timer 2 Interrupt Priority Control                           
 276      =2  SI_SBIT (IP_PSPI0, SFR_IP, 6); ///< Serial Peripheral Interface (SPI0) Interrupt Priority Control
 277      =2  
 278      =2  // P0 (Port 0 Pin Latch)
 279      =2  #define SFR_P0 0x80
 280      =2  SI_SBIT (P0_B0, SFR_P0, 0); ///< Port 0 Bit 0 Latch
 281      =2  SI_SBIT (P0_B1, SFR_P0, 1); ///< Port 0 Bit 1 Latch
 282      =2  SI_SBIT (P0_B2, SFR_P0, 2); ///< Port 0 Bit 2 Latch
 283      =2  SI_SBIT (P0_B3, SFR_P0, 3); ///< Port 0 Bit 3 Latch
 284      =2  SI_SBIT (P0_B4, SFR_P0, 4); ///< Port 0 Bit 4 Latch
 285      =2  SI_SBIT (P0_B5, SFR_P0, 5); ///< Port 0 Bit 5 Latch
 286      =2  SI_SBIT (P0_B6, SFR_P0, 6); ///< Port 0 Bit 6 Latch
 287      =2  SI_SBIT (P0_B7, SFR_P0, 7); ///< Port 0 Bit 7 Latch
 288      =2  
 289      =2  // P1 (Port 1 Pin Latch)
 290      =2  #define SFR_P1 0x90
 291      =2  SI_SBIT (P1_B0, SFR_P1, 0); ///< Port 1 Bit 0 Latch
 292      =2  SI_SBIT (P1_B1, SFR_P1, 1); ///< Port 1 Bit 1 Latch
 293      =2  SI_SBIT (P1_B2, SFR_P1, 2); ///< Port 1 Bit 2 Latch
 294      =2  SI_SBIT (P1_B3, SFR_P1, 3); ///< Port 1 Bit 3 Latch
 295      =2  SI_SBIT (P1_B4, SFR_P1, 4); ///< Port 1 Bit 4 Latch
 296      =2  SI_SBIT (P1_B5, SFR_P1, 5); ///< Port 1 Bit 5 Latch
 297      =2  SI_SBIT (P1_B6, SFR_P1, 6); ///< Port 1 Bit 6 Latch
 298      =2  SI_SBIT (P1_B7, SFR_P1, 7); ///< Port 1 Bit 7 Latch
 299      =2  
 300      =2  // P2 (Port 2 Pin Latch)
 301      =2  #define SFR_P2 0xA0
 302      =2  SI_SBIT (P2_B0, SFR_P2, 0); ///< Port 2 Bit 0 Latch
 303      =2  SI_SBIT (P2_B1, SFR_P2, 1); ///< Port 2 Bit 1 Latch
 304      =2  SI_SBIT (P2_B2, SFR_P2, 2); ///< Port 2 Bit 2 Latch
 305      =2  SI_SBIT (P2_B3, SFR_P2, 3); ///< Port 2 Bit 3 Latch
 306      =2  SI_SBIT (P2_B4, SFR_P2, 4); ///< Port 2 Bit 4 Latch
 307      =2  SI_SBIT (P2_B5, SFR_P2, 5); ///< Port 2 Bit 5 Latch
 308      =2  SI_SBIT (P2_B6, SFR_P2, 6); ///< Port 2 Bit 6 Latch
 309      =2  SI_SBIT (P2_B7, SFR_P2, 7); ///< Port 2 Bit 7 Latch
 310      =2  
 311      =2  // P3 (Port 3 Pin Latch)
 312      =2  #define SFR_P3 0xB0
C51 COMPILER V9.56.0.0   I2C_0                                                             10/28/2016 17:37:02 PAGE 17  

 313      =2  SI_SBIT (P3_B0, SFR_P3, 0); ///< Port 3 Bit 0 Latch
 314      =2  SI_SBIT (P3_B1, SFR_P3, 1); ///< Port 3 Bit 1 Latch
 315      =2  SI_SBIT (P3_B2, SFR_P3, 2); ///< Port 3 Bit 2 Latch
 316      =2  SI_SBIT (P3_B3, SFR_P3, 3); ///< Port 3 Bit 3 Latch
 317      =2  SI_SBIT (P3_B4, SFR_P3, 4); ///< Port 3 Bit 4 Latch
 318      =2  SI_SBIT (P3_B5, SFR_P3, 5); ///< Port 3 Bit 5 Latch
 319      =2  SI_SBIT (P3_B6, SFR_P3, 6); ///< Port 3 Bit 6 Latch
 320      =2  SI_SBIT (P3_B7, SFR_P3, 7); ///< Port 3 Bit 7 Latch
 321      =2  
 322      =2  // PCA0CN0 (PCA Control 0)
 323      =2  #define SFR_PCA0CN0 0xD8
 324      =2  SI_SBIT (PCA0CN0_CCF0, SFR_PCA0CN0, 0); ///< PCA Module 0 Capture/Compare Flag
 325      =2  SI_SBIT (PCA0CN0_CCF1, SFR_PCA0CN0, 1); ///< PCA Module 1 Capture/Compare Flag
 326      =2  SI_SBIT (PCA0CN0_CCF2, SFR_PCA0CN0, 2); ///< PCA Module 2 Capture/Compare Flag
 327      =2  SI_SBIT (PCA0CN0_CCF3, SFR_PCA0CN0, 3); ///< PCA Module 3 Capture/Compare Flag
 328      =2  SI_SBIT (PCA0CN0_CCF4, SFR_PCA0CN0, 4); ///< PCA Module 4 Capture/Compare Flag
 329      =2  SI_SBIT (PCA0CN0_CR,   SFR_PCA0CN0, 6); ///< PCA Counter/Timer Run Control    
 330      =2  SI_SBIT (PCA0CN0_CF,   SFR_PCA0CN0, 7); ///< PCA Counter/Timer Overflow Flag  
 331      =2  
 332      =2  // PSW (Program Status Word)
 333      =2  #define SFR_PSW 0xD0
 334      =2  SI_SBIT (PSW_PARITY, SFR_PSW, 0); ///< Parity Flag               
 335      =2  SI_SBIT (PSW_F1,     SFR_PSW, 1); ///< User Flag 1               
 336      =2  SI_SBIT (PSW_OV,     SFR_PSW, 2); ///< Overflow Flag             
 337      =2  SI_SBIT (PSW_RS0,    SFR_PSW, 3); ///< Register Bank Select Bit 0
 338      =2  SI_SBIT (PSW_RS1,    SFR_PSW, 4); ///< Register Bank Select Bit 1
 339      =2  SI_SBIT (PSW_F0,     SFR_PSW, 5); ///< User Flag 0               
 340      =2  SI_SBIT (PSW_AC,     SFR_PSW, 6); ///< Auxiliary Carry Flag      
 341      =2  SI_SBIT (PSW_CY,     SFR_PSW, 7); ///< Carry Flag                
 342      =2  
 343      =2  // SCON0 (UART0 Serial Port Control)
 344      =2  #define SFR_SCON0 0x98
 345      =2  SI_SBIT (SCON0_RI,    SFR_SCON0, 0); ///< Receive Interrupt Flag             
 346      =2  SI_SBIT (SCON0_TI,    SFR_SCON0, 1); ///< Transmit Interrupt Flag            
 347      =2  SI_SBIT (SCON0_RB8,   SFR_SCON0, 2); ///< Ninth Receive Bit                  
 348      =2  SI_SBIT (SCON0_TB8,   SFR_SCON0, 3); ///< Ninth Transmission Bit             
 349      =2  SI_SBIT (SCON0_REN,   SFR_SCON0, 4); ///< Receive Enable                     
 350      =2  SI_SBIT (SCON0_MCE,   SFR_SCON0, 5); ///< Multiprocessor Communication Enable
 351      =2  SI_SBIT (SCON0_SMODE, SFR_SCON0, 7); ///< Serial Port 0 Operation Mode       
 352      =2  
 353      =2  // SMB0CN0 (SMBus 0 Control)
 354      =2  #define SFR_SMB0CN0 0xC0
 355      =2  SI_SBIT (SMB0CN0_SI,      SFR_SMB0CN0, 0); ///< SMBus Interrupt Flag            
 356      =2  SI_SBIT (SMB0CN0_ACK,     SFR_SMB0CN0, 1); ///< SMBus Acknowledge               
 357      =2  SI_SBIT (SMB0CN0_ARBLOST, SFR_SMB0CN0, 2); ///< SMBus Arbitration Lost Indicator
 358      =2  SI_SBIT (SMB0CN0_ACKRQ,   SFR_SMB0CN0, 3); ///< SMBus Acknowledge Request       
 359      =2  SI_SBIT (SMB0CN0_STO,     SFR_SMB0CN0, 4); ///< SMBus Stop Flag                 
 360      =2  SI_SBIT (SMB0CN0_STA,     SFR_SMB0CN0, 5); ///< SMBus Start Flag                
 361      =2  SI_SBIT (SMB0CN0_TXMODE,  SFR_SMB0CN0, 6); ///< SMBus Transmit Mode Indicator   
 362      =2  SI_SBIT (SMB0CN0_MASTER,  SFR_SMB0CN0, 7); ///< SMBus Master/Slave Indicator    
 363      =2  
 364      =2  // SMB1CN0 (SMBus 1 Control)
 365      =2  #define SFR_SMB1CN0 0xC0
 366      =2  SI_SBIT (SMB1CN0_SI,      SFR_SMB1CN0, 0); ///< SMBus Interrupt Flag            
 367      =2  SI_SBIT (SMB1CN0_ACK,     SFR_SMB1CN0, 1); ///< SMBus Acknowledge               
 368      =2  SI_SBIT (SMB1CN0_ARBLOST, SFR_SMB1CN0, 2); ///< SMBus Arbitration Lost Indicator
 369      =2  SI_SBIT (SMB1CN0_ACKRQ,   SFR_SMB1CN0, 3); ///< SMBus Acknowledge Request       
 370      =2  SI_SBIT (SMB1CN0_STO,     SFR_SMB1CN0, 4); ///< SMBus Stop Flag                 
 371      =2  SI_SBIT (SMB1CN0_STA,     SFR_SMB1CN0, 5); ///< SMBus Start Flag                
 372      =2  SI_SBIT (SMB1CN0_TXMODE,  SFR_SMB1CN0, 6); ///< SMBus Transmit Mode Indicator   
 373      =2  SI_SBIT (SMB1CN0_MASTER,  SFR_SMB1CN0, 7); ///< SMBus Master/Slave Indicator    
 374      =2  
C51 COMPILER V9.56.0.0   I2C_0                                                             10/28/2016 17:37:02 PAGE 18  

 375      =2  // SPI0CN0 (SPI0 Control)
 376      =2  #define SFR_SPI0CN0 0xF8
 377      =2  SI_SBIT (SPI0CN0_SPIEN,  SFR_SPI0CN0, 0); ///< SPI0 Enable            
 378      =2  SI_SBIT (SPI0CN0_TXBMT,  SFR_SPI0CN0, 1); ///< Transmit Buffer Empty  
 379      =2  SI_SBIT (SPI0CN0_NSSMD0, SFR_SPI0CN0, 2); ///< Slave Select Mode Bit 0
 380      =2  SI_SBIT (SPI0CN0_NSSMD1, SFR_SPI0CN0, 3); ///< Slave Select Mode Bit 1
 381      =2  SI_SBIT (SPI0CN0_RXOVRN, SFR_SPI0CN0, 4); ///< Receive Overrun Flag   
 382      =2  SI_SBIT (SPI0CN0_MODF,   SFR_SPI0CN0, 5); ///< Mode Fault Flag        
 383      =2  SI_SBIT (SPI0CN0_WCOL,   SFR_SPI0CN0, 6); ///< Write Collision Flag   
 384      =2  SI_SBIT (SPI0CN0_SPIF,   SFR_SPI0CN0, 7); ///< SPI0 Interrupt Flag    
 385      =2  
 386      =2  // TCON (Timer 0/1 Control)
 387      =2  #define SFR_TCON 0x88
 388      =2  SI_SBIT (TCON_IT0, SFR_TCON, 0); ///< Interrupt 0 Type Select
 389      =2  SI_SBIT (TCON_IE0, SFR_TCON, 1); ///< External Interrupt 0   
 390      =2  SI_SBIT (TCON_IT1, SFR_TCON, 2); ///< Interrupt 1 Type Select
 391      =2  SI_SBIT (TCON_IE1, SFR_TCON, 3); ///< External Interrupt 1   
 392      =2  SI_SBIT (TCON_TR0, SFR_TCON, 4); ///< Timer 0 Run Control    
 393      =2  SI_SBIT (TCON_TF0, SFR_TCON, 5); ///< Timer 0 Overflow Flag  
 394      =2  SI_SBIT (TCON_TR1, SFR_TCON, 6); ///< Timer 1 Run Control    
 395      =2  SI_SBIT (TCON_TF1, SFR_TCON, 7); ///< Timer 1 Overflow Flag  
 396      =2  
 397      =2  // TMR2CN0 (Timer 2 Control 0)
 398      =2  #define SFR_TMR2CN0 0xC8
 399      =2  SI_SBIT (TMR2CN0_T2XCLK,  SFR_TMR2CN0, 0); ///< Timer 2 External Clock Select    
 400      =2  SI_SBIT (TMR2CN0_T2CSS,   SFR_TMR2CN0, 1); ///< Timer 2 Capture Source Select    
 401      =2  SI_SBIT (TMR2CN0_TR2,     SFR_TMR2CN0, 2); ///< Timer 2 Run Control              
 402      =2  SI_SBIT (TMR2CN0_T2SPLIT, SFR_TMR2CN0, 3); ///< Timer 2 Split Mode Enable        
 403      =2  SI_SBIT (TMR2CN0_TF2CEN,  SFR_TMR2CN0, 4); ///< Timer 2 Capture Enable           
 404      =2  SI_SBIT (TMR2CN0_TF2LEN,  SFR_TMR2CN0, 5); ///< Timer 2 Low Byte Interrupt Enable
 405      =2  SI_SBIT (TMR2CN0_TF2L,    SFR_TMR2CN0, 6); ///< Timer 2 Low Byte Overflow Flag   
 406      =2  SI_SBIT (TMR2CN0_TF2H,    SFR_TMR2CN0, 7); ///< Timer 2 High Byte Overflow Flag  
 407      =2  
 408      =2  // TMR5CN0 (Timer 5 Control 0)
 409      =2  #define SFR_TMR5CN0 0xC8
 410      =2  SI_SBIT (TMR5CN0_T5XCLK,  SFR_TMR5CN0, 0); ///< Timer 5 External Clock Select    
 411      =2  SI_SBIT (TMR5CN0_TR5,     SFR_TMR5CN0, 2); ///< Timer 5 Run Control              
 412      =2  SI_SBIT (TMR5CN0_T5SPLIT, SFR_TMR5CN0, 3); ///< Timer 5 Split Mode Enable        
 413      =2  SI_SBIT (TMR5CN0_TF5LEN,  SFR_TMR5CN0, 5); ///< Timer 5 Low Byte Interrupt Enable
 414      =2  SI_SBIT (TMR5CN0_TF5L,    SFR_TMR5CN0, 6); ///< Timer 5 Low Byte Overflow Flag   
 415      =2  SI_SBIT (TMR5CN0_TF5H,    SFR_TMR5CN0, 7); ///< Timer 5 High Byte Overflow Flag  
 416      =2  
 417      =2  //------------------------------------------------------------------------------
 418      =2  // Interrupt Definitions
 419      =2  //------------------------------------------------------------------------------
 420      =2  #define INT0_IRQn    0  ///< External Interrupt 0  
 421      =2  #define TIMER0_IRQn  1  ///< Timer 0 Overflow      
 422      =2  #define INT1_IRQn    2  ///< External Interrupt 1  
 423      =2  #define TIMER1_IRQn  3  ///< Timer 1 Overflow      
 424      =2  #define UART0_IRQn   4  ///< UART 0                
 425      =2  #define TIMER2_IRQn  5  ///< Timer 2 Overflow      
 426      =2  #define SPI0_IRQn    6  ///< SPI0                  
 427      =2  #define SMBUS0_IRQn  7  ///< SMBus 0               
 428      =2  #define USB0_IRQn    8  ///< USB0                  
 429      =2  #define ADC0WC_IRQn  9  ///< ADC0 Window Compare   
 430      =2  #define ADC0EOC_IRQn 10 ///< ADC0 End of Conversion
 431      =2  #define PCA0_IRQn    11 ///< PCA0                  
 432      =2  #define CMP0_IRQn    12 ///< Comparator 0          
 433      =2  #define CMP1_IRQn    13 ///< Comparator 1          
 434      =2  #define TIMER3_IRQn  14 ///< Timer 3 Overflow      
 435      =2  #define VBUSLVL_IRQn 15 ///< VBUS Level            
 436      =2  #define UART1_IRQn   16 ///< UART 1                
C51 COMPILER V9.56.0.0   I2C_0                                                             10/28/2016 17:37:02 PAGE 19  

 437      =2  #define SMBUS1_IRQn  18 ///< SMBus 1               
 438      =2  #define TIMER4_IRQn  19 ///< Timer 4 Overflow      
 439      =2  #define TIMER5_IRQn  20 ///< Timer 5 Overflow      
 440      =2  
 441      =2  //------------------------------------------------------------------------------
 442      =2  // SFR Page Definitions
 443      =2  //------------------------------------------------------------------------------
 444      =2  #define LEGACY_PAGE 0x00 ///< Legacy SFR Page                   
 445      =2  #define CONFIG_PAGE 0x0F ///< System and Port Configuration Page
 446      =2  #define SMB1_PAGE   0x0F ///< SMBus 1 Page                      
 447      =2  
 448      =2  //-----------------------------------------------------------------------------
 449      =2  // SDCC PDATA External Memory Paging Support
 450      =2  //-----------------------------------------------------------------------------
 451      =2  
 452      =2  #if defined SDCC
           =2 
           =2 SI_SFR(_XPAGE, 0xAA); // Point to the EMI0CN register
           =2 
           =2 #endif
 457      =2  
 458      =2  #endif // SI_EFM8UB2_DEFS_H
 459      =2  //-eof--------------------------------------------------------------------------
 460      =2  
  12      =1  #include "SI_EFM8UB2_Register_Enums.h"
   1      =2  //------------------------------------------------------------------------------
   2      =2  // Copyright 2014 Silicon Laboratories, Inc.
   3      =2  // All rights reserved. This program and the accompanying materials
   4      =2  // are made available under the terms of the Silicon Laboratories End User
   5      =2  // License Agreement which accompanies this distribution, and is available at
   6      =2  // http://developer.silabs.com/legal/version/v11/Silicon_Labs_Software_License_Agreement.txt
   7      =2  // Original content and implementation provided by Silicon Laboratories.
   8      =2  //------------------------------------------------------------------------------
   9      =2  //Supported Devices:
  10      =2  //  EFM8UB20F32G_QFN32
  11      =2  //  EFM8UB20F32G_QFP32
  12      =2  //  EFM8UB20F32G_QFP48
  13      =2  //  EFM8UB20F64G_QFN32
  14      =2  //  EFM8UB20F64G_QFP32
  15      =2  //  EFM8UB20F64G_QFP48
  16      =2  
  17      =2  #ifndef SI_EFM8UB2_REGISTER_ENUMS_H
  18      =2  #define SI_EFM8UB2_REGISTER_ENUMS_H
  19      =2  
  20      =2  //Standard device includes
  21      =2  #include "SI_EFM8UB2_Defs.h"
   1      =3  //------------------------------------------------------------------------------
   2      =3  // Copyright 2014 Silicon Laboratories, Inc.
   3      =3  // All rights reserved. This program and the accompanying materials
   4      =3  // are made available under the terms of the Silicon Laboratories End User
   5      =3  // License Agreement which accompanies this distribution, and is available at
   6      =3  // http://developer.silabs.com/legal/version/v11/Silicon_Labs_Software_License_Agreement.txt
   7      =3  // Original content and implementation provided by Silicon Laboratories.
   8      =3  //------------------------------------------------------------------------------
   9      =3  //Supported Devices:
  10      =3  //  EFM8UB20F32G_QFN32
  11      =3  //  EFM8UB20F32G_QFP32
  12      =3  //  EFM8UB20F32G_QFP48
  13      =3  //  EFM8UB20F64G_QFN32
  14      =3  //  EFM8UB20F64G_QFP32
  15      =3  //  EFM8UB20F64G_QFP48
  16      =3  
C51 COMPILER V9.56.0.0   I2C_0                                                             10/28/2016 17:37:02 PAGE 20  

  17      =3  #ifndef SI_EFM8UB2_DEFS_H
           =3 #define SI_EFM8UB2_DEFS_H
           =3 
           =3 #include <si_toolchain.h>
           =3 
           =3 //-----------------------------------------------------------------------------
           =3 // Register Definitions
           =3 //-----------------------------------------------------------------------------
           =3 SI_SFR (ACC,      0xE0); ///< Accumulator                           
           =3 SI_SFR (ADC0CF,   0xBC); ///< ADC0 Configuration                    
           =3 SI_SFR (ADC0CN0,  0xE8); ///< ADC0 Control                          
           =3 SI_SFR (ADC0GTH,  0xC4); ///< ADC0 Greater-Than High Byte           
           =3 SI_SFR (ADC0GTL,  0xC3); ///< ADC0 Greater-Than Low Byte            
           =3 SI_SFR (ADC0H,    0xBE); ///< ADC0 Data Word High Byte              
           =3 SI_SFR (ADC0L,    0xBD); ///< ADC0 Data Word Low Byte               
           =3 SI_SFR (ADC0LTH,  0xC6); ///< ADC0 Less-Than High Byte              
           =3 SI_SFR (ADC0LTL,  0xC5); ///< ADC0 Less-Than Low Byte               
           =3 SI_SFR (AMX0N,    0xBA); ///< AMUX0 Negative Multiplexer Selection  
           =3 SI_SFR (AMX0P,    0xBB); ///< AMUX0 Positive Multiplexer Selection  
           =3 SI_SFR (B,        0xF0); ///< B Register                            
           =3 SI_SFR (CKCON0,   0x8E); ///< Clock Control 0                       
           =3 SI_SFR (CKCON1,   0xE4); ///< Clock Control 1                       
           =3 SI_SFR (CLKSEL,   0xA9); ///< Clock Select                          
           =3 SI_SFR (CMP0CN0,  0x9B); ///< Comparator 0 Control 0                
           =3 SI_SFR (CMP0MD,   0x9D); ///< Comparator 0 Mode                     
           =3 SI_SFR (CMP0MX,   0x9F); ///< Comparator 0 Multiplexer Selection    
           =3 SI_SFR (CMP1CN0,  0x9A); ///< Comparator 1 Control 0                
           =3 SI_SFR (CMP1MD,   0x9C); ///< Comparator 1 Mode                     
           =3 SI_SFR (CMP1MX,   0x9E); ///< Comparator 1 Multiplexer Selection    
           =3 SI_SFR (DPH,      0x83); ///< Data Pointer High                     
           =3 SI_SFR (DPL,      0x82); ///< Data Pointer Low                      
           =3 SI_SFR (EIE1,     0xE6); ///< Extended Interrupt Enable 1           
           =3 SI_SFR (EIE2,     0xE7); ///< Extended Interrupt Enable 2           
           =3 SI_SFR (EIP1,     0xF6); ///< Extended Interrupt Priority 1         
           =3 SI_SFR (EIP2,     0xF7); ///< Extended Interrupt Priority 2         
           =3 SI_SFR (EMI0CF,   0x85); ///< External Memory Configuration         
           =3 SI_SFR (EMI0CN,   0xAA); ///< External Memory Interface Control     
           =3 SI_SFR (EMI0TC,   0x84); ///< External Memory Timing Control        
           =3 SI_SFR (FLKEY,    0xB7); ///< Flash Lock and Key                    
           =3 SI_SFR (FLSCL,    0xB6); ///< Flash Scale                           
           =3 SI_SFR (HFO0CAL,  0xB3); ///< High Frequency Oscillator Calibration 
           =3 SI_SFR (HFO0CN,   0xB2); ///< High Frequency Oscillator Control     
           =3 SI_SFR (IE,       0xA8); ///< Interrupt Enable                      
           =3 SI_SFR (IP,       0xB8); ///< Interrupt Priority                    
           =3 SI_SFR (IT01CF,   0xE4); ///< INT0/INT1 Configuration               
           =3 SI_SFR (LFO0CN,   0x86); ///< Low Frequency Oscillator Control      
           =3 SI_SFR (P0,       0x80); ///< Port 0 Pin Latch                      
           =3 SI_SFR (P0MDIN,   0xF1); ///< Port 0 Input Mode                     
           =3 SI_SFR (P0MDOUT,  0xA4); ///< Port 0 Output Mode                    
           =3 SI_SFR (P0SKIP,   0xD4); ///< Port 0 Skip                           
           =3 SI_SFR (P1,       0x90); ///< Port 1 Pin Latch                      
           =3 SI_SFR (P1MDIN,   0xF2); ///< Port 1 Input Mode                     
           =3 SI_SFR (P1MDOUT,  0xA5); ///< Port 1 Output Mode                    
           =3 SI_SFR (P1SKIP,   0xD5); ///< Port 1 Skip                           
           =3 SI_SFR (P2,       0xA0); ///< Port 2 Pin Latch                      
           =3 SI_SFR (P2MDIN,   0xF3); ///< Port 2 Input Mode                     
           =3 SI_SFR (P2MDOUT,  0xA6); ///< Port 2 Output Mode                    
           =3 SI_SFR (P2SKIP,   0xD6); ///< Port 2 Skip                           
           =3 SI_SFR (P3,       0xB0); ///< Port 3 Pin Latch                      
           =3 SI_SFR (P3MDIN,   0xF4); ///< Port 3 Input Mode                     
           =3 SI_SFR (P3MDOUT,  0xA7); ///< Port 3 Output Mode                    
           =3 SI_SFR (P3SKIP,   0xDF); ///< Port 3 Skip                           
C51 COMPILER V9.56.0.0   I2C_0                                                             10/28/2016 17:37:02 PAGE 21  

           =3 SI_SFR (P4,       0xC7); ///< Port 4 Pin Latch                      
           =3 SI_SFR (P4MDIN,   0xF5); ///< Port 4 Input Mode                     
           =3 SI_SFR (P4MDOUT,  0xAE); ///< Port 4 Output Mode                    
           =3 SI_SFR (PCA0CN0,  0xD8); ///< PCA Control 0                         
           =3 SI_SFR (PCA0CPH0, 0xFC); ///< PCA Channel 0 Capture Module High Byte
           =3 SI_SFR (PCA0CPH1, 0xEA); ///< PCA Channel 1 Capture Module High Byte
           =3 SI_SFR (PCA0CPH2, 0xEC); ///< PCA Channel 2 Capture Module High Byte
           =3 SI_SFR (PCA0CPH3, 0xEE); ///< PCA Channel 3 Capture Module High Byte
           =3 SI_SFR (PCA0CPH4, 0xFE); ///< PCA Channel 4 Capture Module High Byte
           =3 SI_SFR (PCA0CPL0, 0xFB); ///< PCA Channel 0 Capture Module Low Byte 
           =3 SI_SFR (PCA0CPL1, 0xE9); ///< PCA Channel 1 Capture Module Low Byte 
           =3 SI_SFR (PCA0CPL2, 0xEB); ///< PCA Channel 2 Capture Module Low Byte 
           =3 SI_SFR (PCA0CPL3, 0xED); ///< PCA Channel 3 Capture Module Low Byte 
           =3 SI_SFR (PCA0CPL4, 0xFD); ///< PCA Channel 4 Capture Module Low Byte 
           =3 SI_SFR (PCA0CPM0, 0xDA); ///< PCA Channel 0 Capture/Compare Mode    
           =3 SI_SFR (PCA0CPM1, 0xDB); ///< PCA Channel 1 Capture/Compare Mode    
           =3 SI_SFR (PCA0CPM2, 0xDC); ///< PCA Channel 2 Capture/Compare Mode    
           =3 SI_SFR (PCA0CPM3, 0xDD); ///< PCA Channel 3 Capture/Compare Mode    
           =3 SI_SFR (PCA0CPM4, 0xDE); ///< PCA Channel 4 Capture/Compare Mode    
           =3 SI_SFR (PCA0H,    0xFA); ///< PCA Counter/Timer High Byte           
           =3 SI_SFR (PCA0L,    0xF9); ///< PCA Counter/Timer Low Byte            
           =3 SI_SFR (PCA0MD,   0xD9); ///< PCA Mode                              
           =3 SI_SFR (PCON0,    0x87); ///< Power Control                         
           =3 SI_SFR (PFE0CN,   0xAF); ///< Prefetch Engine Control               
           =3 SI_SFR (PSCTL,    0x8F); ///< Program Store Control                 
           =3 SI_SFR (PSW,      0xD0); ///< Program Status Word                   
           =3 SI_SFR (REF0CN,   0xD1); ///< Voltage Reference Control             
           =3 SI_SFR (REG01CN,  0xC9); ///< Voltage Regulator Control             
           =3 SI_SFR (RSTSRC,   0xEF); ///< Reset Source                          
           =3 SI_SFR (SBCON1,   0xAC); ///< UART1 Baud Rate Generator Control     
           =3 SI_SFR (SBRLH1,   0xB5); ///< UART1 Baud Rate Generator High Byte   
           =3 SI_SFR (SBRLL1,   0xB4); ///< UART1 Baud Rate Generator Low Byte    
           =3 SI_SFR (SBUF0,    0x99); ///< UART0 Serial Port Data Buffer         
           =3 SI_SFR (SBUF1,    0xD3); ///< UART1 Serial Port Data Buffer         
           =3 SI_SFR (SCON0,    0x98); ///< UART0 Serial Port Control             
           =3 SI_SFR (SCON1,    0xD2); ///< UART1 Serial Port Control             
           =3 SI_SFR (SFRPAGE,  0xBF); ///< SFR Page                              
           =3 SI_SFR (SMB0ADM,  0xCE); ///< SMBus 0 Slave Address Mask            
           =3 SI_SFR (SMB0ADR,  0xCF); ///< SMBus 0 Slave Address                 
           =3 SI_SFR (SMB0CF,   0xC1); ///< SMBus 0 Configuration                 
           =3 SI_SFR (SMB0CN0,  0xC0); ///< SMBus 0 Control                       
           =3 SI_SFR (SMB0DAT,  0xC2); ///< SMBus 0 Data                          
           =3 SI_SFR (SMB1ADM,  0xCE); ///< SMBus 1 Slave Address Mask            
           =3 SI_SFR (SMB1ADR,  0xCF); ///< SMBus 1 Slave Address                 
           =3 SI_SFR (SMB1CF,   0xC1); ///< SMBus 1 Configuration                 
           =3 SI_SFR (SMB1CN0,  0xC0); ///< SMBus 1 Control                       
           =3 SI_SFR (SMB1DAT,  0xC2); ///< SMBus 1 Data                          
           =3 SI_SFR (SMBTC,    0xB9); ///< SMBus Timing and Pin Control          
           =3 SI_SFR (SMOD1,    0xE5); ///< UART1 Mode                            
           =3 SI_SFR (SP,       0x81); ///< Stack Pointer                         
           =3 SI_SFR (SPI0CFG,  0xA1); ///< SPI0 Configuration                    
           =3 SI_SFR (SPI0CKR,  0xA2); ///< SPI0 Clock Rate                       
           =3 SI_SFR (SPI0CN0,  0xF8); ///< SPI0 Control                          
           =3 SI_SFR (SPI0DAT,  0xA3); ///< SPI0 Data                             
           =3 SI_SFR (TCON,     0x88); ///< Timer 0/1 Control                     
           =3 SI_SFR (TH0,      0x8C); ///< Timer 0 High Byte                     
           =3 SI_SFR (TH1,      0x8D); ///< Timer 1 High Byte                     
           =3 SI_SFR (TL0,      0x8A); ///< Timer 0 Low Byte                      
           =3 SI_SFR (TL1,      0x8B); ///< Timer 1 Low Byte                      
           =3 SI_SFR (TMOD,     0x89); ///< Timer 0/1 Mode                        
           =3 SI_SFR (TMR2CN0,  0xC8); ///< Timer 2 Control 0                     
           =3 SI_SFR (TMR2H,    0xCD); ///< Timer 2 High Byte                     
C51 COMPILER V9.56.0.0   I2C_0                                                             10/28/2016 17:37:02 PAGE 22  

           =3 SI_SFR (TMR2L,    0xCC); ///< Timer 2 Low Byte                      
           =3 SI_SFR (TMR2RLH,  0xCB); ///< Timer 2 Reload High Byte              
           =3 SI_SFR (TMR2RLL,  0xCA); ///< Timer 2 Reload Low Byte               
           =3 SI_SFR (TMR3CN0,  0x91); ///< Timer 3 Control 0                     
           =3 SI_SFR (TMR3H,    0x95); ///< Timer 3 High Byte                     
           =3 SI_SFR (TMR3L,    0x94); ///< Timer 3 Low Byte                      
           =3 SI_SFR (TMR3RLH,  0x93); ///< Timer 3 Reload High Byte              
           =3 SI_SFR (TMR3RLL,  0x92); ///< Timer 3 Reload Low Byte               
           =3 SI_SFR (TMR4CN0,  0x91); ///< Timer 4 Control 0                     
           =3 SI_SFR (TMR4H,    0x95); ///< Timer 4 High Byte                     
           =3 SI_SFR (TMR4L,    0x94); ///< Timer 4 Low Byte                      
           =3 SI_SFR (TMR4RLH,  0x93); ///< Timer 4 Reload High Byte              
           =3 SI_SFR (TMR4RLL,  0x92); ///< Timer 4 Reload Low Byte               
           =3 SI_SFR (TMR5CN0,  0xC8); ///< Timer 5 Control 0                     
           =3 SI_SFR (TMR5H,    0xCD); ///< Timer 5 High Byte                     
           =3 SI_SFR (TMR5L,    0xCC); ///< Timer 5 Low Byte                      
           =3 SI_SFR (TMR5RLH,  0xCB); ///< Timer 5 Reload High Byte              
           =3 SI_SFR (TMR5RLL,  0xCA); ///< Timer 5 Reload Low Byte               
           =3 SI_SFR (USB0ADR,  0x96); ///< USB0 Indirect Address                 
           =3 SI_SFR (USB0DAT,  0x97); ///< USB0 Data                             
           =3 SI_SFR (USB0XCN,  0xD7); ///< USB0 Transceiver Control              
           =3 SI_SFR (VDM0CN,   0xFF); ///< Supply Monitor Control                
           =3 SI_SFR (XBR0,     0xE1); ///< Port I/O Crossbar 0                   
           =3 SI_SFR (XBR1,     0xE2); ///< Port I/O Crossbar 1                   
           =3 SI_SFR (XBR2,     0xE3); ///< Port I/O Crossbar 2                   
           =3 SI_SFR (XOSC0CN,  0xB1); ///< External Oscillator Control           
           =3 
           =3 //------------------------------------------------------------------------------
           =3 // 16-bit Register Definitions (may not work on all compilers)
           =3 //------------------------------------------------------------------------------
           =3 SI_SFR16 (ADC0GT,  0xC3); ///< ADC0 Greater-Than            
           =3 SI_SFR16 (ADC0,    0xBD); ///< ADC0 Data Word               
           =3 SI_SFR16 (ADC0LT,  0xC5); ///< ADC0 Less-Than               
           =3 SI_SFR16 (DP,      0x82); ///< Data Pointer                 
           =3 SI_SFR16 (PCA0CP0, 0xFB); ///< PCA Channel 0 Capture Module 
           =3 SI_SFR16 (PCA0CP1, 0xE9); ///< PCA Channel 1 Capture Module 
           =3 SI_SFR16 (PCA0CP2, 0xEB); ///< PCA Channel 2 Capture Module 
           =3 SI_SFR16 (PCA0CP3, 0xED); ///< PCA Channel 3 Capture Module 
           =3 SI_SFR16 (PCA0CP4, 0xFD); ///< PCA Channel 4 Capture Module 
           =3 SI_SFR16 (PCA0,    0xF9); ///< PCA Counter/Timer            
           =3 SI_SFR16 (SBRL1,   0xB4); ///< UART1 Baud Rate Generator    
           =3 SI_SFR16 (TMR2,    0xCC); ///< Timer 2                      
           =3 SI_SFR16 (TMR2RL,  0xCA); ///< Timer 2 Reload               
           =3 SI_SFR16 (TMR3,    0x94); ///< Timer 3                      
           =3 SI_SFR16 (TMR3RL,  0x92); ///< Timer 3 Reload               
           =3 SI_SFR16 (TMR4,    0x94); ///< Timer 4                      
           =3 SI_SFR16 (TMR4RL,  0x92); ///< Timer 4 Reload               
           =3 SI_SFR16 (TMR5,    0xCC); ///< Timer 5                      
           =3 SI_SFR16 (TMR5RL,  0xCA); ///< Timer 5 Reload               
           =3 
           =3 //------------------------------------------------------------------------------
           =3 // Indirect Register Definitions
           =3 //------------------------------------------------------------------------------
           =3 #define CLKREC   0x0F ///< USB0 Clock Recovery Control       
           =3 #define CMIE     0x0B ///< USB0 Common Interrupt Enable      
           =3 #define CMINT    0x06 ///< USB0 Common Interrupt             
           =3 #define E0CNT    0x16 ///< USB0 Endpoint0 Data Count         
           =3 #define E0CSR    0x11 ///< USB0 Endpoint0 Control            
           =3 #define EENABLE  0x1E ///< USB0 Endpoint Enable              
           =3 #define EINCSRH  0x12 ///< USB0 IN Endpoint Control High     
           =3 #define EINCSRL  0x11 ///< USB0 IN Endpoint Control          
           =3 #define EOUTCNTH 0x17 ///< USB0 OUT Endpoint Count High      
C51 COMPILER V9.56.0.0   I2C_0                                                             10/28/2016 17:37:02 PAGE 23  

           =3 #define EOUTCNTL 0x16 ///< USB0 OUT Endpoint Count           
           =3 #define EOUTCSRH 0x15 ///< USB0 OUT Endpoint Control High    
           =3 #define EOUTCSRL 0x14 ///< USB0 OUT Endpoint Control         
           =3 #define FADDR    0x00 ///< USB0 Function Address             
           =3 #define FIFO0    0x20 ///< USB0 Endpoint 0 FIFO Access       
           =3 #define FIFO1    0x21 ///< USB0 Endpoint 1 FIFO Access       
           =3 #define FIFO2    0x22 ///< USB0 Endpoint 2 FIFO Access       
           =3 #define FIFO3    0x23 ///< USB0 Endpoint 3 FIFO Access       
           =3 #define FRAMEH   0x0D ///< USB0 Frame Number High            
           =3 #define FRAMEL   0x0C ///< USB0 Frame Number                 
           =3 #define IN1IE    0x07 ///< USB0 IN Endpoint Interrupt Enable 
           =3 #define IN1INT   0x02 ///< USB0 IN Endpoint Interrupt        
           =3 #define INDEX    0x0E ///< USB0 Endpoint Index               
           =3 #define OUT1IE   0x09 ///< USB0 OUT Endpoint Interrupt Enable
           =3 #define OUT1INT  0x04 ///< USB0 OUT Endpoint Interrupt       
           =3 #define POWER    0x01 ///< USB0 Power                        
           =3 
           =3 //------------------------------------------------------------------------------
           =3 // Bit Definitions
           =3 //------------------------------------------------------------------------------
           =3 
           =3 // ACC (Accumulator)
           =3 #define SFR_ACC 0xE0
           =3 SI_SBIT (ACC_ACC0, SFR_ACC, 0); ///< Accumulator Bit 0
           =3 SI_SBIT (ACC_ACC1, SFR_ACC, 1); ///< Accumulator Bit 1
           =3 SI_SBIT (ACC_ACC2, SFR_ACC, 2); ///< Accumulator Bit 2
           =3 SI_SBIT (ACC_ACC3, SFR_ACC, 3); ///< Accumulator Bit 3
           =3 SI_SBIT (ACC_ACC4, SFR_ACC, 4); ///< Accumulator Bit 4
           =3 SI_SBIT (ACC_ACC5, SFR_ACC, 5); ///< Accumulator Bit 5
           =3 SI_SBIT (ACC_ACC6, SFR_ACC, 6); ///< Accumulator Bit 6
           =3 SI_SBIT (ACC_ACC7, SFR_ACC, 7); ///< Accumulator Bit 7
           =3 
           =3 // ADC0CN0 (ADC0 Control)
           =3 #define SFR_ADC0CN0 0xE8
           =3 SI_SBIT (ADC0CN0_ADCM0,  SFR_ADC0CN0, 0); ///< Start of Conversion Mode Select Bit 0
           =3 SI_SBIT (ADC0CN0_ADCM1,  SFR_ADC0CN0, 1); ///< Start of Conversion Mode Select Bit 1
           =3 SI_SBIT (ADC0CN0_ADCM2,  SFR_ADC0CN0, 2); ///< Start of Conversion Mode Select Bit 2
           =3 SI_SBIT (ADC0CN0_ADWINT, SFR_ADC0CN0, 3); ///< Window Compare Interrupt Flag        
           =3 SI_SBIT (ADC0CN0_ADBUSY, SFR_ADC0CN0, 4); ///< ADC Busy                             
           =3 SI_SBIT (ADC0CN0_ADINT,  SFR_ADC0CN0, 5); ///< Conversion Complete Interrupt Flag   
           =3 SI_SBIT (ADC0CN0_ADTM,   SFR_ADC0CN0, 6); ///< Track Mode                           
           =3 SI_SBIT (ADC0CN0_ADEN,   SFR_ADC0CN0, 7); ///< ADC Enable                           
           =3 
           =3 // B (B Register)
           =3 #define SFR_B 0xF0
           =3 SI_SBIT (B_B0, SFR_B, 0); ///< B Register Bit 0
           =3 SI_SBIT (B_B1, SFR_B, 1); ///< B Register Bit 1
           =3 SI_SBIT (B_B2, SFR_B, 2); ///< B Register Bit 2
           =3 SI_SBIT (B_B3, SFR_B, 3); ///< B Register Bit 3
           =3 SI_SBIT (B_B4, SFR_B, 4); ///< B Register Bit 4
           =3 SI_SBIT (B_B5, SFR_B, 5); ///< B Register Bit 5
           =3 SI_SBIT (B_B6, SFR_B, 6); ///< B Register Bit 6
           =3 SI_SBIT (B_B7, SFR_B, 7); ///< B Register Bit 7
           =3 
           =3 // IE (Interrupt Enable)
           =3 #define SFR_IE 0xA8
           =3 SI_SBIT (IE_EX0,   SFR_IE, 0); ///< External Interrupt 0 Enable
           =3 SI_SBIT (IE_ET0,   SFR_IE, 1); ///< Timer 0 Interrupt Enable   
           =3 SI_SBIT (IE_EX1,   SFR_IE, 2); ///< External Interrupt 1 Enable
           =3 SI_SBIT (IE_ET1,   SFR_IE, 3); ///< Timer 1 Interrupt Enable   
           =3 SI_SBIT (IE_ES0,   SFR_IE, 4); ///< UART0 Interrupt Enable     
           =3 SI_SBIT (IE_ET2,   SFR_IE, 5); ///< Timer 2 Interrupt Enable   
C51 COMPILER V9.56.0.0   I2C_0                                                             10/28/2016 17:37:02 PAGE 24  

           =3 SI_SBIT (IE_ESPI0, SFR_IE, 6); ///< SPI0 Interrupt Enable      
           =3 SI_SBIT (IE_EA,    SFR_IE, 7); ///< All Interrupts Enable      
           =3 
           =3 // IP (Interrupt Priority)
           =3 #define SFR_IP 0xB8
           =3 SI_SBIT (IP_PX0,   SFR_IP, 0); ///< External Interrupt 0 Priority Control                        
           =3 SI_SBIT (IP_PT0,   SFR_IP, 1); ///< Timer 0 Interrupt Priority Control                           
           =3 SI_SBIT (IP_PX1,   SFR_IP, 2); ///< External Interrupt 1 Priority Control                        
           =3 SI_SBIT (IP_PT1,   SFR_IP, 3); ///< Timer 1 Interrupt Priority Control                           
           =3 SI_SBIT (IP_PS0,   SFR_IP, 4); ///< UART0 Interrupt Priority Control                             
           =3 SI_SBIT (IP_PT2,   SFR_IP, 5); ///< Timer 2 Interrupt Priority Control                           
           =3 SI_SBIT (IP_PSPI0, SFR_IP, 6); ///< Serial Peripheral Interface (SPI0) Interrupt Priority Control
           =3 
           =3 // P0 (Port 0 Pin Latch)
           =3 #define SFR_P0 0x80
           =3 SI_SBIT (P0_B0, SFR_P0, 0); ///< Port 0 Bit 0 Latch
           =3 SI_SBIT (P0_B1, SFR_P0, 1); ///< Port 0 Bit 1 Latch
           =3 SI_SBIT (P0_B2, SFR_P0, 2); ///< Port 0 Bit 2 Latch
           =3 SI_SBIT (P0_B3, SFR_P0, 3); ///< Port 0 Bit 3 Latch
           =3 SI_SBIT (P0_B4, SFR_P0, 4); ///< Port 0 Bit 4 Latch
           =3 SI_SBIT (P0_B5, SFR_P0, 5); ///< Port 0 Bit 5 Latch
           =3 SI_SBIT (P0_B6, SFR_P0, 6); ///< Port 0 Bit 6 Latch
           =3 SI_SBIT (P0_B7, SFR_P0, 7); ///< Port 0 Bit 7 Latch
           =3 
           =3 // P1 (Port 1 Pin Latch)
           =3 #define SFR_P1 0x90
           =3 SI_SBIT (P1_B0, SFR_P1, 0); ///< Port 1 Bit 0 Latch
           =3 SI_SBIT (P1_B1, SFR_P1, 1); ///< Port 1 Bit 1 Latch
           =3 SI_SBIT (P1_B2, SFR_P1, 2); ///< Port 1 Bit 2 Latch
           =3 SI_SBIT (P1_B3, SFR_P1, 3); ///< Port 1 Bit 3 Latch
           =3 SI_SBIT (P1_B4, SFR_P1, 4); ///< Port 1 Bit 4 Latch
           =3 SI_SBIT (P1_B5, SFR_P1, 5); ///< Port 1 Bit 5 Latch
           =3 SI_SBIT (P1_B6, SFR_P1, 6); ///< Port 1 Bit 6 Latch
           =3 SI_SBIT (P1_B7, SFR_P1, 7); ///< Port 1 Bit 7 Latch
           =3 
           =3 // P2 (Port 2 Pin Latch)
           =3 #define SFR_P2 0xA0
           =3 SI_SBIT (P2_B0, SFR_P2, 0); ///< Port 2 Bit 0 Latch
           =3 SI_SBIT (P2_B1, SFR_P2, 1); ///< Port 2 Bit 1 Latch
           =3 SI_SBIT (P2_B2, SFR_P2, 2); ///< Port 2 Bit 2 Latch
           =3 SI_SBIT (P2_B3, SFR_P2, 3); ///< Port 2 Bit 3 Latch
           =3 SI_SBIT (P2_B4, SFR_P2, 4); ///< Port 2 Bit 4 Latch
           =3 SI_SBIT (P2_B5, SFR_P2, 5); ///< Port 2 Bit 5 Latch
           =3 SI_SBIT (P2_B6, SFR_P2, 6); ///< Port 2 Bit 6 Latch
           =3 SI_SBIT (P2_B7, SFR_P2, 7); ///< Port 2 Bit 7 Latch
           =3 
           =3 // P3 (Port 3 Pin Latch)
           =3 #define SFR_P3 0xB0
           =3 SI_SBIT (P3_B0, SFR_P3, 0); ///< Port 3 Bit 0 Latch
           =3 SI_SBIT (P3_B1, SFR_P3, 1); ///< Port 3 Bit 1 Latch
           =3 SI_SBIT (P3_B2, SFR_P3, 2); ///< Port 3 Bit 2 Latch
           =3 SI_SBIT (P3_B3, SFR_P3, 3); ///< Port 3 Bit 3 Latch
           =3 SI_SBIT (P3_B4, SFR_P3, 4); ///< Port 3 Bit 4 Latch
           =3 SI_SBIT (P3_B5, SFR_P3, 5); ///< Port 3 Bit 5 Latch
           =3 SI_SBIT (P3_B6, SFR_P3, 6); ///< Port 3 Bit 6 Latch
           =3 SI_SBIT (P3_B7, SFR_P3, 7); ///< Port 3 Bit 7 Latch
           =3 
           =3 // PCA0CN0 (PCA Control 0)
           =3 #define SFR_PCA0CN0 0xD8
           =3 SI_SBIT (PCA0CN0_CCF0, SFR_PCA0CN0, 0); ///< PCA Module 0 Capture/Compare Flag
           =3 SI_SBIT (PCA0CN0_CCF1, SFR_PCA0CN0, 1); ///< PCA Module 1 Capture/Compare Flag
           =3 SI_SBIT (PCA0CN0_CCF2, SFR_PCA0CN0, 2); ///< PCA Module 2 Capture/Compare Flag
C51 COMPILER V9.56.0.0   I2C_0                                                             10/28/2016 17:37:02 PAGE 25  

           =3 SI_SBIT (PCA0CN0_CCF3, SFR_PCA0CN0, 3); ///< PCA Module 3 Capture/Compare Flag
           =3 SI_SBIT (PCA0CN0_CCF4, SFR_PCA0CN0, 4); ///< PCA Module 4 Capture/Compare Flag
           =3 SI_SBIT (PCA0CN0_CR,   SFR_PCA0CN0, 6); ///< PCA Counter/Timer Run Control    
           =3 SI_SBIT (PCA0CN0_CF,   SFR_PCA0CN0, 7); ///< PCA Counter/Timer Overflow Flag  
           =3 
           =3 // PSW (Program Status Word)
           =3 #define SFR_PSW 0xD0
           =3 SI_SBIT (PSW_PARITY, SFR_PSW, 0); ///< Parity Flag               
           =3 SI_SBIT (PSW_F1,     SFR_PSW, 1); ///< User Flag 1               
           =3 SI_SBIT (PSW_OV,     SFR_PSW, 2); ///< Overflow Flag             
           =3 SI_SBIT (PSW_RS0,    SFR_PSW, 3); ///< Register Bank Select Bit 0
           =3 SI_SBIT (PSW_RS1,    SFR_PSW, 4); ///< Register Bank Select Bit 1
           =3 SI_SBIT (PSW_F0,     SFR_PSW, 5); ///< User Flag 0               
           =3 SI_SBIT (PSW_AC,     SFR_PSW, 6); ///< Auxiliary Carry Flag      
           =3 SI_SBIT (PSW_CY,     SFR_PSW, 7); ///< Carry Flag                
           =3 
           =3 // SCON0 (UART0 Serial Port Control)
           =3 #define SFR_SCON0 0x98
           =3 SI_SBIT (SCON0_RI,    SFR_SCON0, 0); ///< Receive Interrupt Flag             
           =3 SI_SBIT (SCON0_TI,    SFR_SCON0, 1); ///< Transmit Interrupt Flag            
           =3 SI_SBIT (SCON0_RB8,   SFR_SCON0, 2); ///< Ninth Receive Bit                  
           =3 SI_SBIT (SCON0_TB8,   SFR_SCON0, 3); ///< Ninth Transmission Bit             
           =3 SI_SBIT (SCON0_REN,   SFR_SCON0, 4); ///< Receive Enable                     
           =3 SI_SBIT (SCON0_MCE,   SFR_SCON0, 5); ///< Multiprocessor Communication Enable
           =3 SI_SBIT (SCON0_SMODE, SFR_SCON0, 7); ///< Serial Port 0 Operation Mode       
           =3 
           =3 // SMB0CN0 (SMBus 0 Control)
           =3 #define SFR_SMB0CN0 0xC0
           =3 SI_SBIT (SMB0CN0_SI,      SFR_SMB0CN0, 0); ///< SMBus Interrupt Flag            
           =3 SI_SBIT (SMB0CN0_ACK,     SFR_SMB0CN0, 1); ///< SMBus Acknowledge               
           =3 SI_SBIT (SMB0CN0_ARBLOST, SFR_SMB0CN0, 2); ///< SMBus Arbitration Lost Indicator
           =3 SI_SBIT (SMB0CN0_ACKRQ,   SFR_SMB0CN0, 3); ///< SMBus Acknowledge Request       
           =3 SI_SBIT (SMB0CN0_STO,     SFR_SMB0CN0, 4); ///< SMBus Stop Flag                 
           =3 SI_SBIT (SMB0CN0_STA,     SFR_SMB0CN0, 5); ///< SMBus Start Flag                
           =3 SI_SBIT (SMB0CN0_TXMODE,  SFR_SMB0CN0, 6); ///< SMBus Transmit Mode Indicator   
           =3 SI_SBIT (SMB0CN0_MASTER,  SFR_SMB0CN0, 7); ///< SMBus Master/Slave Indicator    
           =3 
           =3 // SMB1CN0 (SMBus 1 Control)
           =3 #define SFR_SMB1CN0 0xC0
           =3 SI_SBIT (SMB1CN0_SI,      SFR_SMB1CN0, 0); ///< SMBus Interrupt Flag            
           =3 SI_SBIT (SMB1CN0_ACK,     SFR_SMB1CN0, 1); ///< SMBus Acknowledge               
           =3 SI_SBIT (SMB1CN0_ARBLOST, SFR_SMB1CN0, 2); ///< SMBus Arbitration Lost Indicator
           =3 SI_SBIT (SMB1CN0_ACKRQ,   SFR_SMB1CN0, 3); ///< SMBus Acknowledge Request       
           =3 SI_SBIT (SMB1CN0_STO,     SFR_SMB1CN0, 4); ///< SMBus Stop Flag                 
           =3 SI_SBIT (SMB1CN0_STA,     SFR_SMB1CN0, 5); ///< SMBus Start Flag                
           =3 SI_SBIT (SMB1CN0_TXMODE,  SFR_SMB1CN0, 6); ///< SMBus Transmit Mode Indicator   
           =3 SI_SBIT (SMB1CN0_MASTER,  SFR_SMB1CN0, 7); ///< SMBus Master/Slave Indicator    
           =3 
           =3 // SPI0CN0 (SPI0 Control)
           =3 #define SFR_SPI0CN0 0xF8
           =3 SI_SBIT (SPI0CN0_SPIEN,  SFR_SPI0CN0, 0); ///< SPI0 Enable            
           =3 SI_SBIT (SPI0CN0_TXBMT,  SFR_SPI0CN0, 1); ///< Transmit Buffer Empty  
           =3 SI_SBIT (SPI0CN0_NSSMD0, SFR_SPI0CN0, 2); ///< Slave Select Mode Bit 0
           =3 SI_SBIT (SPI0CN0_NSSMD1, SFR_SPI0CN0, 3); ///< Slave Select Mode Bit 1
           =3 SI_SBIT (SPI0CN0_RXOVRN, SFR_SPI0CN0, 4); ///< Receive Overrun Flag   
           =3 SI_SBIT (SPI0CN0_MODF,   SFR_SPI0CN0, 5); ///< Mode Fault Flag        
           =3 SI_SBIT (SPI0CN0_WCOL,   SFR_SPI0CN0, 6); ///< Write Collision Flag   
           =3 SI_SBIT (SPI0CN0_SPIF,   SFR_SPI0CN0, 7); ///< SPI0 Interrupt Flag    
           =3 
           =3 // TCON (Timer 0/1 Control)
           =3 #define SFR_TCON 0x88
           =3 SI_SBIT (TCON_IT0, SFR_TCON, 0); ///< Interrupt 0 Type Select
C51 COMPILER V9.56.0.0   I2C_0                                                             10/28/2016 17:37:02 PAGE 26  

           =3 SI_SBIT (TCON_IE0, SFR_TCON, 1); ///< External Interrupt 0   
           =3 SI_SBIT (TCON_IT1, SFR_TCON, 2); ///< Interrupt 1 Type Select
           =3 SI_SBIT (TCON_IE1, SFR_TCON, 3); ///< External Interrupt 1   
           =3 SI_SBIT (TCON_TR0, SFR_TCON, 4); ///< Timer 0 Run Control    
           =3 SI_SBIT (TCON_TF0, SFR_TCON, 5); ///< Timer 0 Overflow Flag  
           =3 SI_SBIT (TCON_TR1, SFR_TCON, 6); ///< Timer 1 Run Control    
           =3 SI_SBIT (TCON_TF1, SFR_TCON, 7); ///< Timer 1 Overflow Flag  
           =3 
           =3 // TMR2CN0 (Timer 2 Control 0)
           =3 #define SFR_TMR2CN0 0xC8
           =3 SI_SBIT (TMR2CN0_T2XCLK,  SFR_TMR2CN0, 0); ///< Timer 2 External Clock Select    
           =3 SI_SBIT (TMR2CN0_T2CSS,   SFR_TMR2CN0, 1); ///< Timer 2 Capture Source Select    
           =3 SI_SBIT (TMR2CN0_TR2,     SFR_TMR2CN0, 2); ///< Timer 2 Run Control              
           =3 SI_SBIT (TMR2CN0_T2SPLIT, SFR_TMR2CN0, 3); ///< Timer 2 Split Mode Enable        
           =3 SI_SBIT (TMR2CN0_TF2CEN,  SFR_TMR2CN0, 4); ///< Timer 2 Capture Enable           
           =3 SI_SBIT (TMR2CN0_TF2LEN,  SFR_TMR2CN0, 5); ///< Timer 2 Low Byte Interrupt Enable
           =3 SI_SBIT (TMR2CN0_TF2L,    SFR_TMR2CN0, 6); ///< Timer 2 Low Byte Overflow Flag   
           =3 SI_SBIT (TMR2CN0_TF2H,    SFR_TMR2CN0, 7); ///< Timer 2 High Byte Overflow Flag  
           =3 
           =3 // TMR5CN0 (Timer 5 Control 0)
           =3 #define SFR_TMR5CN0 0xC8
           =3 SI_SBIT (TMR5CN0_T5XCLK,  SFR_TMR5CN0, 0); ///< Timer 5 External Clock Select    
           =3 SI_SBIT (TMR5CN0_TR5,     SFR_TMR5CN0, 2); ///< Timer 5 Run Control              
           =3 SI_SBIT (TMR5CN0_T5SPLIT, SFR_TMR5CN0, 3); ///< Timer 5 Split Mode Enable        
           =3 SI_SBIT (TMR5CN0_TF5LEN,  SFR_TMR5CN0, 5); ///< Timer 5 Low Byte Interrupt Enable
           =3 SI_SBIT (TMR5CN0_TF5L,    SFR_TMR5CN0, 6); ///< Timer 5 Low Byte Overflow Flag   
           =3 SI_SBIT (TMR5CN0_TF5H,    SFR_TMR5CN0, 7); ///< Timer 5 High Byte Overflow Flag  
           =3 
           =3 //------------------------------------------------------------------------------
           =3 // Interrupt Definitions
           =3 //------------------------------------------------------------------------------
           =3 #define INT0_IRQn    0  ///< External Interrupt 0  
           =3 #define TIMER0_IRQn  1  ///< Timer 0 Overflow      
           =3 #define INT1_IRQn    2  ///< External Interrupt 1  
           =3 #define TIMER1_IRQn  3  ///< Timer 1 Overflow      
           =3 #define UART0_IRQn   4  ///< UART 0                
           =3 #define TIMER2_IRQn  5  ///< Timer 2 Overflow      
           =3 #define SPI0_IRQn    6  ///< SPI0                  
           =3 #define SMBUS0_IRQn  7  ///< SMBus 0               
           =3 #define USB0_IRQn    8  ///< USB0                  
           =3 #define ADC0WC_IRQn  9  ///< ADC0 Window Compare   
           =3 #define ADC0EOC_IRQn 10 ///< ADC0 End of Conversion
           =3 #define PCA0_IRQn    11 ///< PCA0                  
           =3 #define CMP0_IRQn    12 ///< Comparator 0          
           =3 #define CMP1_IRQn    13 ///< Comparator 1          
           =3 #define TIMER3_IRQn  14 ///< Timer 3 Overflow      
           =3 #define VBUSLVL_IRQn 15 ///< VBUS Level            
           =3 #define UART1_IRQn   16 ///< UART 1                
           =3 #define SMBUS1_IRQn  18 ///< SMBus 1               
           =3 #define TIMER4_IRQn  19 ///< Timer 4 Overflow      
           =3 #define TIMER5_IRQn  20 ///< Timer 5 Overflow      
           =3 
           =3 //------------------------------------------------------------------------------
           =3 // SFR Page Definitions
           =3 //------------------------------------------------------------------------------
           =3 #define LEGACY_PAGE 0x00 ///< Legacy SFR Page                   
           =3 #define CONFIG_PAGE 0x0F ///< System and Port Configuration Page
           =3 #define SMB1_PAGE   0x0F ///< SMBus 1 Page                      
           =3 
           =3 //-----------------------------------------------------------------------------
           =3 // SDCC PDATA External Memory Paging Support
           =3 //-----------------------------------------------------------------------------
C51 COMPILER V9.56.0.0   I2C_0                                                             10/28/2016 17:37:02 PAGE 27  

           =3 
           =3 #if defined SDCC
           =3 
           =3 SI_SFR(_XPAGE, 0xAA); // Point to the EMI0CN register
           =3 
           =3 #endif
           =3 
           =3 #endif // SI_EFM8UB2_DEFS_H
 459      =3  //-eof--------------------------------------------------------------------------
 460      =3  
  22      =2  //------------------------------------------------------------------------------
  23      =2  // ADC0CF Enums (ADC0 Configuration @ 0xBC)
  24      =2  //------------------------------------------------------------------------------
  25      =2  #define ADC0CF_ADLJST__BMASK           0x04 ///< ADC0 Left Justify Select                   
  26      =2  #define ADC0CF_ADLJST__SHIFT           0x02 ///< ADC0 Left Justify Select                   
  27      =2  #define ADC0CF_ADLJST__RIGHT_JUSTIFIED 0x00 ///< Data in the ADC0H:ADC0L registers is right-
  28      =2                                              ///< justified.                                 
  29      =2  #define ADC0CF_ADLJST__LEFT_JUSTIFIED  0x04 ///< Data in the ADC0H:ADC0L registers is left- 
  30      =2                                              ///< justified.                                 
  31      =2                                                                                              
  32      =2  #define ADC0CF_ADSC__FMASK             0xF8 ///< SAR Clock Divider                          
  33      =2  #define ADC0CF_ADSC__SHIFT             0x03 ///< SAR Clock Divider                          
  34      =2                                                                                              
  35      =2  //------------------------------------------------------------------------------
  36      =2  // ADC0CN0 Enums (ADC0 Control @ 0xE8)
  37      =2  //------------------------------------------------------------------------------
  38      =2  #define ADC0CN0_ADCM__FMASK         0x07 ///< Start of Conversion Mode Select                   
  39      =2  #define ADC0CN0_ADCM__SHIFT         0x00 ///< Start of Conversion Mode Select                   
  40      =2  #define ADC0CN0_ADCM__ADBUSY        0x00 ///< ADC0 conversion initiated on write of 1 to ADBUSY.
  41      =2  #define ADC0CN0_ADCM__TIMER0        0x01 ///< ADC0 conversion initiated on overflow of Timer 0. 
  42      =2  #define ADC0CN0_ADCM__TIMER2        0x02 ///< ADC0 conversion initiated on overflow of Timer 2. 
  43      =2  #define ADC0CN0_ADCM__TIMER1        0x03 ///< ADC0 conversion initiated on overflow of Timer 1. 
  44      =2  #define ADC0CN0_ADCM__CNVSTR        0x04 ///< ADC0 conversion initiated on rising edge of       
  45      =2                                           ///< CNVSTR.                                           
  46      =2  #define ADC0CN0_ADCM__TIMER3        0x05 ///< ADC0 conversion initiated on overflow of Timer 3. 
  47      =2  #define ADC0CN0_ADCM__TIMER4        0x06 ///< ADC0 conversion initiated on overflow of Timer 4. 
  48      =2  #define ADC0CN0_ADCM__TIMER5        0x07 ///< ADC0 conversion initiated on overflow of Timer 5. 
  49      =2                                                                                                  
  50      =2  #define ADC0CN0_ADWINT__BMASK       0x08 ///< Window Compare Interrupt Flag                     
  51      =2  #define ADC0CN0_ADWINT__SHIFT       0x03 ///< Window Compare Interrupt Flag                     
  52      =2  #define ADC0CN0_ADWINT__NOT_SET     0x00 ///< An ADC window compare event did not occur.        
  53      =2  #define ADC0CN0_ADWINT__SET         0x08 ///< An ADC window compare event occurred.             
  54      =2                                                                                                  
  55      =2  #define ADC0CN0_ADBUSY__BMASK       0x10 ///< ADC Busy                                          
  56      =2  #define ADC0CN0_ADBUSY__SHIFT       0x04 ///< ADC Busy                                          
  57      =2  #define ADC0CN0_ADBUSY__NOT_SET     0x00 ///< An ADC0 conversion is not currently in progress.  
  58      =2  #define ADC0CN0_ADBUSY__SET         0x10 ///< ADC0 conversion is in progress or start an ADC0   
  59      =2                                           ///< conversion.                                       
  60      =2                                                                                                  
  61      =2  #define ADC0CN0_ADINT__BMASK        0x20 ///< Conversion Complete Interrupt Flag                
  62      =2  #define ADC0CN0_ADINT__SHIFT        0x05 ///< Conversion Complete Interrupt Flag                
  63      =2  #define ADC0CN0_ADINT__NOT_SET      0x00 ///< ADC0 has not completed a conversion since the last
  64      =2                                           ///< time ADINT was cleared.                           
  65      =2  #define ADC0CN0_ADINT__SET          0x20 ///< ADC0 completed a data conversion.                 
  66      =2                                                                                                  
  67      =2  #define ADC0CN0_ADTM__BMASK         0x40 ///< Track Mode                                        
  68      =2  #define ADC0CN0_ADTM__SHIFT         0x06 ///< Track Mode                                        
  69      =2  #define ADC0CN0_ADTM__TRACK_NORMAL  0x00 ///< Normal Track Mode. When ADC0 is enabled,          
  70      =2                                           ///< conversion begins immediately following the start-
  71      =2                                           ///< of-conversion signal.                             
  72      =2  #define ADC0CN0_ADTM__TRACK_DELAYED 0x40 ///< Delayed Track Mode. When ADC0 is enabled,         
  73      =2                                           ///< conversion begins 3 SAR clock cycles following the
C51 COMPILER V9.56.0.0   I2C_0                                                             10/28/2016 17:37:02 PAGE 28  

  74      =2                                           ///< start-of-conversion signal. The ADC is allowed to 
  75      =2                                           ///< track during this time. Note that there is not a  
  76      =2                                           ///< tracking delay when the external conversion start 
  77      =2                                           ///< (CNVSTR) is used as the start-of-conversion       
  78      =2                                           ///< source.                                           
  79      =2                                                                                                  
  80      =2  #define ADC0CN0_ADEN__BMASK         0x80 ///< ADC Enable                                        
  81      =2  #define ADC0CN0_ADEN__SHIFT         0x07 ///< ADC Enable                                        
  82      =2  #define ADC0CN0_ADEN__DISABLED      0x00 ///< ADC0 Disabled (low-power shutdown).               
  83      =2  #define ADC0CN0_ADEN__ENABLED       0x80 ///< ADC0 Enabled (active and ready for data           
  84      =2                                           ///< conversions).                                     
  85      =2                                                                                                  
  86      =2  //------------------------------------------------------------------------------
  87      =2  // ADC0GTH Enums (ADC0 Greater-Than High Byte @ 0xC4)
  88      =2  //------------------------------------------------------------------------------
  89      =2  #define ADC0GTH_ADC0GTH__FMASK 0xFF ///< Greater-Than High Byte
  90      =2  #define ADC0GTH_ADC0GTH__SHIFT 0x00 ///< Greater-Than High Byte
  91      =2                                                                 
  92      =2  //------------------------------------------------------------------------------
  93      =2  // ADC0GTL Enums (ADC0 Greater-Than Low Byte @ 0xC3)
  94      =2  //------------------------------------------------------------------------------
  95      =2  #define ADC0GTL_ADC0GTL__FMASK 0xFF ///< Greater-Than Low Byte
  96      =2  #define ADC0GTL_ADC0GTL__SHIFT 0x00 ///< Greater-Than Low Byte
  97      =2                                                                
  98      =2  //------------------------------------------------------------------------------
  99      =2  // ADC0H Enums (ADC0 Data Word High Byte @ 0xBE)
 100      =2  //------------------------------------------------------------------------------
 101      =2  #define ADC0H_ADC0H__FMASK 0xFF ///< Data Word High Byte
 102      =2  #define ADC0H_ADC0H__SHIFT 0x00 ///< Data Word High Byte
 103      =2                                                          
 104      =2  //------------------------------------------------------------------------------
 105      =2  // ADC0L Enums (ADC0 Data Word Low Byte @ 0xBD)
 106      =2  //------------------------------------------------------------------------------
 107      =2  #define ADC0L_ADC0L__FMASK 0xFF ///< Data Word Low Byte
 108      =2  #define ADC0L_ADC0L__SHIFT 0x00 ///< Data Word Low Byte
 109      =2                                                         
 110      =2  //------------------------------------------------------------------------------
 111      =2  // ADC0LTH Enums (ADC0 Less-Than High Byte @ 0xC6)
 112      =2  //------------------------------------------------------------------------------
 113      =2  #define ADC0LTH_ADC0LTH__FMASK 0xFF ///< Less-Than High Byte
 114      =2  #define ADC0LTH_ADC0LTH__SHIFT 0x00 ///< Less-Than High Byte
 115      =2                                                              
 116      =2  //------------------------------------------------------------------------------
 117      =2  // ADC0LTL Enums (ADC0 Less-Than Low Byte @ 0xC5)
 118      =2  //------------------------------------------------------------------------------
 119      =2  #define ADC0LTL_ADC0LTL__FMASK 0xFF ///< Less-Than Low Byte
 120      =2  #define ADC0LTL_ADC0LTL__SHIFT 0x00 ///< Less-Than Low Byte
 121      =2                                                             
 122      =2  //------------------------------------------------------------------------------
 123      =2  // AMX0N Enums (AMUX0 Negative Multiplexer Selection @ 0xBA)
 124      =2  //------------------------------------------------------------------------------
 125      =2  #define AMX0N_AMX0N__FMASK   0x3F ///< AMUX0 Negative Input Selection
 126      =2  #define AMX0N_AMX0N__SHIFT   0x00 ///< AMUX0 Negative Input Selection
 127      =2  #define AMX0N_AMX0N__ADC0N0  0x00 ///< Select ADC0N.0.               
 128      =2  #define AMX0N_AMX0N__ADC0N1  0x01 ///< Select ADC0N.1.               
 129      =2  #define AMX0N_AMX0N__ADC0N2  0x02 ///< Select ADC0N.2.               
 130      =2  #define AMX0N_AMX0N__ADC0N3  0x03 ///< Select ADC0N.3.               
 131      =2  #define AMX0N_AMX0N__ADC0N4  0x04 ///< Select ADC0N.4.               
 132      =2  #define AMX0N_AMX0N__ADC0N5  0x05 ///< Select ADC0N.5.               
 133      =2  #define AMX0N_AMX0N__ADC0N6  0x06 ///< Select ADC0N.6.               
 134      =2  #define AMX0N_AMX0N__ADC0N7  0x07 ///< Select ADC0N.7.               
 135      =2  #define AMX0N_AMX0N__ADC0N8  0x08 ///< Select ADC0N.8.               
C51 COMPILER V9.56.0.0   I2C_0                                                             10/28/2016 17:37:02 PAGE 29  

 136      =2  #define AMX0N_AMX0N__ADC0N9  0x09 ///< Select ADC0N.9.               
 137      =2  #define AMX0N_AMX0N__ADC0N10 0x0A ///< Select ADC0N.10.              
 138      =2  #define AMX0N_AMX0N__ADC0N11 0x0B ///< Select ADC0N.11.              
 139      =2  #define AMX0N_AMX0N__ADC0N12 0x0C ///< Select ADC0N.12.              
 140      =2  #define AMX0N_AMX0N__ADC0N13 0x0D ///< Select ADC0N.13.              
 141      =2  #define AMX0N_AMX0N__ADC0N14 0x0E ///< Select ADC0N.14.              
 142      =2  #define AMX0N_AMX0N__ADC0N15 0x0F ///< Select ADC0N.15.              
 143      =2  #define AMX0N_AMX0N__ADC0N16 0x10 ///< Select ADC0N.16.              
 144      =2  #define AMX0N_AMX0N__ADC0N17 0x11 ///< Select ADC0N.17.              
 145      =2  #define AMX0N_AMX0N__ADC0N18 0x12 ///< Select ADC0N.18.              
 146      =2  #define AMX0N_AMX0N__ADC0N19 0x13 ///< Select ADC0N.19.              
 147      =2  #define AMX0N_AMX0N__ADC0N20 0x14 ///< Select ADC0N.20.              
 148      =2  #define AMX0N_AMX0N__ADC0N21 0x15 ///< Select ADC0N.21.              
 149      =2  #define AMX0N_AMX0N__ADC0N22 0x16 ///< Select ADC0N.22.              
 150      =2  #define AMX0N_AMX0N__ADC0N23 0x17 ///< Select ADC0N.23.              
 151      =2  #define AMX0N_AMX0N__ADC0N24 0x18 ///< Select ADC0N.24.              
 152      =2  #define AMX0N_AMX0N__ADC0N25 0x19 ///< Select ADC0N.25.              
 153      =2  #define AMX0N_AMX0N__ADC0N26 0x1A ///< Select ADC0N.26.              
 154      =2  #define AMX0N_AMX0N__ADC0N27 0x1B ///< Select ADC0N.27.              
 155      =2  #define AMX0N_AMX0N__ADC0N28 0x1C ///< Select ADC0N.28.              
 156      =2  #define AMX0N_AMX0N__ADC0N29 0x1D ///< Select ADC0N.29.              
 157      =2  #define AMX0N_AMX0N__VREF    0x1E ///< Internal Voltage Reference.   
 158      =2  #define AMX0N_AMX0N__GND     0x1F ///< Ground (single-ended mode).   
 159      =2  #define AMX0N_AMX0N__ADC0N32 0x20 ///< Select ADC0N.32.              
 160      =2  #define AMX0N_AMX0N__ADC0N33 0x21 ///< Select ADC0N.33.              
 161      =2  #define AMX0N_AMX0N__ADC0N34 0x22 ///< Select ADC0N.34.              
 162      =2                                                                       
 163      =2  //------------------------------------------------------------------------------
 164      =2  // AMX0P Enums (AMUX0 Positive Multiplexer Selection @ 0xBB)
 165      =2  //------------------------------------------------------------------------------
 166      =2  #define AMX0P_AMX0P__FMASK   0x3F ///< AMUX0 Positive Input Selection
 167      =2  #define AMX0P_AMX0P__SHIFT   0x00 ///< AMUX0 Positive Input Selection
 168      =2  #define AMX0P_AMX0P__ADC0P0  0x00 ///< Select ADC0P.0.               
 169      =2  #define AMX0P_AMX0P__ADC0P1  0x01 ///< Select ADC0P.1.               
 170      =2  #define AMX0P_AMX0P__ADC0P2  0x02 ///< Select ADC0P.2.               
 171      =2  #define AMX0P_AMX0P__ADC0P3  0x03 ///< Select ADC0P.3.               
 172      =2  #define AMX0P_AMX0P__ADC0P4  0x04 ///< Select ADC0P.4.               
 173      =2  #define AMX0P_AMX0P__ADC0P5  0x05 ///< Select ADC0P.5.               
 174      =2  #define AMX0P_AMX0P__ADC0P6  0x06 ///< Select ADC0P.6.               
 175      =2  #define AMX0P_AMX0P__ADC0P7  0x07 ///< Select ADC0P.7.               
 176      =2  #define AMX0P_AMX0P__ADC0P8  0x08 ///< Select ADC0P.8.               
 177      =2  #define AMX0P_AMX0P__ADC0P9  0x09 ///< Select ADC0P.9.               
 178      =2  #define AMX0P_AMX0P__ADC0P10 0x0A ///< Select ADC0P.10.              
 179      =2  #define AMX0P_AMX0P__ADC0P11 0x0B ///< Select ADC0P.11.              
 180      =2  #define AMX0P_AMX0P__ADC0P12 0x0C ///< Select ADC0P.12.              
 181      =2  #define AMX0P_AMX0P__ADC0P13 0x0D ///< Select ADC0P.13.              
 182      =2  #define AMX0P_AMX0P__ADC0P14 0x0E ///< Select ADC0P.14.              
 183      =2  #define AMX0P_AMX0P__ADC0P15 0x0F ///< Select ADC0P.15.              
 184      =2  #define AMX0P_AMX0P__ADC0P16 0x10 ///< Select ADC0P.16.              
 185      =2  #define AMX0P_AMX0P__ADC0P17 0x11 ///< Select ADC0P.17.              
 186      =2  #define AMX0P_AMX0P__ADC0P18 0x12 ///< Select ADC0P.18.              
 187      =2  #define AMX0P_AMX0P__ADC0P19 0x13 ///< Select ADC0P.19.              
 188      =2  #define AMX0P_AMX0P__ADC0P20 0x14 ///< Select ADC0P.20.              
 189      =2  #define AMX0P_AMX0P__ADC0P21 0x15 ///< Select ADC0P.21.              
 190      =2  #define AMX0P_AMX0P__ADC0P22 0x16 ///< Select ADC0P.22.              
 191      =2  #define AMX0P_AMX0P__ADC0P23 0x17 ///< Select ADC0P.23.              
 192      =2  #define AMX0P_AMX0P__ADC0P24 0x18 ///< Select ADC0P.24.              
 193      =2  #define AMX0P_AMX0P__ADC0P25 0x19 ///< Select ADC0P.25.              
 194      =2  #define AMX0P_AMX0P__ADC0P26 0x1A ///< Select ADC0P.26.              
 195      =2  #define AMX0P_AMX0P__ADC0P27 0x1B ///< Select ADC0P.27.              
 196      =2  #define AMX0P_AMX0P__ADC0P28 0x1C ///< Select ADC0P.28.              
 197      =2  #define AMX0P_AMX0P__ADC0P29 0x1D ///< Select ADC0P.29.              
C51 COMPILER V9.56.0.0   I2C_0                                                             10/28/2016 17:37:02 PAGE 30  

 198      =2  #define AMX0P_AMX0P__TEMP    0x1E ///< Temperature sensor.           
 199      =2  #define AMX0P_AMX0P__VDD     0x1F ///< VDD Supply Voltage.           
 200      =2  #define AMX0P_AMX0P__ADC0P32 0x20 ///< Select ADC0P.32.              
 201      =2  #define AMX0P_AMX0P__ADC0P33 0x21 ///< Select ADC0P.33.              
 202      =2  #define AMX0P_AMX0P__ADC0P34 0x22 ///< Select ADC0P.34.              
 203      =2                                                                       
 204      =2  //------------------------------------------------------------------------------
 205      =2  // ACC Enums (Accumulator @ 0xE0)
 206      =2  //------------------------------------------------------------------------------
 207      =2  #define ACC_ACC__FMASK 0xFF ///< Accumulator
 208      =2  #define ACC_ACC__SHIFT 0x00 ///< Accumulator
 209      =2                                              
 210      =2  //------------------------------------------------------------------------------
 211      =2  // B Enums (B Register @ 0xF0)
 212      =2  //------------------------------------------------------------------------------
 213      =2  #define B_B__FMASK 0xFF ///< B Register
 214      =2  #define B_B__SHIFT 0x00 ///< B Register
 215      =2                                         
 216      =2  //------------------------------------------------------------------------------
 217      =2  // DPH Enums (Data Pointer High @ 0x83)
 218      =2  //------------------------------------------------------------------------------
 219      =2  #define DPH_DPH__FMASK 0xFF ///< Data Pointer High
 220      =2  #define DPH_DPH__SHIFT 0x00 ///< Data Pointer High
 221      =2                                                    
 222      =2  //------------------------------------------------------------------------------
 223      =2  // DPL Enums (Data Pointer Low @ 0x82)
 224      =2  //------------------------------------------------------------------------------
 225      =2  #define DPL_DPL__FMASK 0xFF ///< Data Pointer Low
 226      =2  #define DPL_DPL__SHIFT 0x00 ///< Data Pointer Low
 227      =2                                                   
 228      =2  //------------------------------------------------------------------------------
 229      =2  // PFE0CN Enums (Prefetch Engine Control @ 0xAF)
 230      =2  //------------------------------------------------------------------------------
 231      =2  #define PFE0CN_FLBWE__BMASK                0x01 ///< Flash Block Write Enable                      
 232      =2  #define PFE0CN_FLBWE__SHIFT                0x00 ///< Flash Block Write Enable                      
 233      =2  #define PFE0CN_FLBWE__BLOCK_WRITE_DISABLED 0x00 ///< Each byte of a firmware flash write is written
 234      =2                                                  ///< individually.                                 
 235      =2  #define PFE0CN_FLBWE__BLOCK_WRITE_ENABLED  0x01 ///< Flash bytes are written in groups of two.     
 236      =2                                                                                                     
 237      =2  #define PFE0CN_PFEN__BMASK                 0x20 ///< Prefetch Enable                               
 238      =2  #define PFE0CN_PFEN__SHIFT                 0x05 ///< Prefetch Enable                               
 239      =2  #define PFE0CN_PFEN__DISABLED              0x00 ///< Disable the prefetch engine (SYSCLK < 25 MHz).
 240      =2  #define PFE0CN_PFEN__ENABLED               0x20 ///< Enable the prefetch engine (SYSCLK > 25 MHz). 
 241      =2                                                                                                     
 242      =2  //------------------------------------------------------------------------------
 243      =2  // PSW Enums (Program Status Word @ 0xD0)
 244      =2  //------------------------------------------------------------------------------
 245      =2  #define PSW_PARITY__BMASK   0x01 ///< Parity Flag                                       
 246      =2  #define PSW_PARITY__SHIFT   0x00 ///< Parity Flag                                       
 247      =2  #define PSW_PARITY__NOT_SET 0x00 ///< The sum of the 8 bits in the accumulator is even. 
 248      =2  #define PSW_PARITY__SET     0x01 ///< The sum of the 8 bits in the accumulator is odd.  
 249      =2                                                                                          
 250      =2  #define PSW_F1__BMASK       0x02 ///< User Flag 1                                       
 251      =2  #define PSW_F1__SHIFT       0x01 ///< User Flag 1                                       
 252      =2  #define PSW_F1__NOT_SET     0x00 ///< Flag is not set.                                  
 253      =2  #define PSW_F1__SET         0x02 ///< Flag is set.                                      
 254      =2                                                                                          
 255      =2  #define PSW_OV__BMASK       0x04 ///< Overflow Flag                                     
 256      =2  #define PSW_OV__SHIFT       0x02 ///< Overflow Flag                                     
 257      =2  #define PSW_OV__NOT_SET     0x00 ///< An overflow did not occur.                        
 258      =2  #define PSW_OV__SET         0x04 ///< An overflow occurred.                             
 259      =2                                                                                          
C51 COMPILER V9.56.0.0   I2C_0                                                             10/28/2016 17:37:02 PAGE 31  

 260      =2  #define PSW_RS__FMASK       0x18 ///< Register Bank Select                              
 261      =2  #define PSW_RS__SHIFT       0x03 ///< Register Bank Select                              
 262      =2  #define PSW_RS__BANK0       0x00 ///< Bank 0, Addresses 0x00-0x07                       
 263      =2  #define PSW_RS__BANK1       0x08 ///< Bank 1, Addresses 0x08-0x0F                       
 264      =2  #define PSW_RS__BANK2       0x10 ///< Bank 2, Addresses 0x10-0x17                       
 265      =2  #define PSW_RS__BANK3       0x18 ///< Bank 3, Addresses 0x18-0x1F                       
 266      =2                                                                                          
 267      =2  #define PSW_F0__BMASK       0x20 ///< User Flag 0                                       
 268      =2  #define PSW_F0__SHIFT       0x05 ///< User Flag 0                                       
 269      =2  #define PSW_F0__NOT_SET     0x00 ///< Flag is not set.                                  
 270      =2  #define PSW_F0__SET         0x20 ///< Flag is set.                                      
 271      =2                                                                                          
 272      =2  #define PSW_AC__BMASK       0x40 ///< Auxiliary Carry Flag                              
 273      =2  #define PSW_AC__SHIFT       0x06 ///< Auxiliary Carry Flag                              
 274      =2  #define PSW_AC__NOT_SET     0x00 ///< A carry into (addition) or borrow from            
 275      =2                                   ///< (subtraction) the high order nibble did not occur.
 276      =2  #define PSW_AC__SET         0x40 ///< A carry into (addition) or borrow from            
 277      =2                                   ///< (subtraction) the high order nibble occurred.     
 278      =2                                                                                          
 279      =2  #define PSW_CY__BMASK       0x80 ///< Carry Flag                                        
 280      =2  #define PSW_CY__SHIFT       0x07 ///< Carry Flag                                        
 281      =2  #define PSW_CY__NOT_SET     0x00 ///< A carry (addition) or borrow (subtraction) did not
 282      =2                                   ///< occur.                                            
 283      =2  #define PSW_CY__SET         0x80 ///< A carry (addition) or borrow (subtraction)        
 284      =2                                   ///< occurred.                                         
 285      =2                                                                                          
 286      =2  //------------------------------------------------------------------------------
 287      =2  // SP Enums (Stack Pointer @ 0x81)
 288      =2  //------------------------------------------------------------------------------
 289      =2  #define SP_SP__FMASK 0xFF ///< Stack Pointer
 290      =2  #define SP_SP__SHIFT 0x00 ///< Stack Pointer
 291      =2                                              
 292      =2  //------------------------------------------------------------------------------
 293      =2  // CLKSEL Enums (Clock Select @ 0xA9)
 294      =2  //------------------------------------------------------------------------------
 295      =2  #define CLKSEL_CLKSL__FMASK               0x07 ///< System Clock Source Select Bits                   
 296      =2  #define CLKSEL_CLKSL__SHIFT               0x00 ///< System Clock Source Select Bits                   
 297      =2  #define CLKSEL_CLKSL__DIVIDED_HFOSC_DIV_4 0x00 ///< Clock (SYSCLK) derived from the Internal High-    
 298      =2                                                 ///< Frequency Oscillator / 4 and scaled per the IFCN  
 299      =2                                                 ///< bits in register OSCICN.                          
 300      =2  #define CLKSEL_CLKSL__EXTOSC              0x01 ///< Clock (SYSCLK) derived from the External          
 301      =2                                                 ///< Oscillator circuit.                               
 302      =2  #define CLKSEL_CLKSL__HFOSC_DIV_2         0x02 ///< Clock (SYSCLK) derived from the Internal High-    
 303      =2                                                 ///< Frequency Oscillator / 2.                         
 304      =2  #define CLKSEL_CLKSL__HFOSC               0x03 ///< Clock (SYSCLK) derived from the Internal High-    
 305      =2                                                 ///< Frequency Oscillator.                             
 306      =2  #define CLKSEL_CLKSL__LFOSC               0x04 ///< Clock (SYSCLK) derived from the Internal Low-     
 307      =2                                                 ///< Frequency Oscillator and scaled per the OSCLD bits
 308      =2                                                 ///< in register OSCLCN.                               
 309      =2                                                                                                        
 310      =2  #define CLKSEL_OUTCLK__BMASK              0x08 ///< Crossbar Clock Out Select                         
 311      =2  #define CLKSEL_OUTCLK__SHIFT              0x03 ///< Crossbar Clock Out Select                         
 312      =2  #define CLKSEL_OUTCLK__SYSCLK             0x00 ///< Enabling the Crossbar SYSCLK signal outputs       
 313      =2                                                 ///< SYSCLK.                                           
 314      =2  #define CLKSEL_OUTCLK__SYSCLK_SYNC_IO     0x08 ///< Enabling the Crossbar SYSCLK signal outputs SYSCLK
 315      =2                                                 ///< synchronized with the Port I/O.                   
 316      =2                                                                                                        
 317      =2  #define CLKSEL_USBCLK__FMASK              0x70 ///< USB Clock Source Select Bits                      
 318      =2  #define CLKSEL_USBCLK__SHIFT              0x04 ///< USB Clock Source Select Bits                      
 319      =2  #define CLKSEL_USBCLK__HFOSC              0x00 ///< USB clock (USBCLK) derived from the Internal High-
 320      =2                                                 ///< Frequency Oscillator.                             
 321      =2  #define CLKSEL_USBCLK__HFOSC_DIV_8        0x10 ///< USB clock (USBCLK) derived from the Internal High-
C51 COMPILER V9.56.0.0   I2C_0                                                             10/28/2016 17:37:02 PAGE 32  

 322      =2                                                 ///< Frequency Oscillator / 8.                         
 323      =2  #define CLKSEL_USBCLK__EXTOSC             0x20 ///< USB clock (USBCLK) derived from the External      
 324      =2                                                 ///< Oscillator.                                       
 325      =2  #define CLKSEL_USBCLK__EXTOSC_DIV_2       0x30 ///< USB clock (USBCLK) derived from the External      
 326      =2                                                 ///< Oscillator / 2.                                   
 327      =2  #define CLKSEL_USBCLK__EXTOSC_DIV_3       0x40 ///< USB clock (USBCLK) derived from the External      
 328      =2                                                 ///< Oscillator / 3.                                   
 329      =2  #define CLKSEL_USBCLK__EXTOSC_DIV_4       0x50 ///< USB clock (USBCLK) derived from the External      
 330      =2                                                 ///< Oscillator / 4.                                   
 331      =2  #define CLKSEL_USBCLK__LFOSC              0x60 ///< USB clock (USBCLK) derived from the Internal Low- 
 332      =2                                                 ///< Frequency Oscillator.                             
 333      =2                                                                                                        
 334      =2  //------------------------------------------------------------------------------
 335      =2  // CMP0CN0 Enums (Comparator 0 Control 0 @ 0x9B)
 336      =2  //------------------------------------------------------------------------------
 337      =2  #define CMP0CN0_CPHYN__FMASK                0x03 ///< Comparator Negative Hysteresis Control            
 338      =2  #define CMP0CN0_CPHYN__SHIFT                0x00 ///< Comparator Negative Hysteresis Control            
 339      =2  #define CMP0CN0_CPHYN__DISABLED             0x00 ///< Negative Hysteresis disabled.                     
 340      =2  #define CMP0CN0_CPHYN__ENABLED_MODE1        0x01 ///< Negative Hysteresis = Hysteresis 1.               
 341      =2  #define CMP0CN0_CPHYN__ENABLED_MODE2        0x02 ///< Negative Hysteresis = Hysteresis 2.               
 342      =2  #define CMP0CN0_CPHYN__ENABLED_MODE3        0x03 ///< Negative Hysteresis = Hysteresis 3 (Maximum).     
 343      =2                                                                                                          
 344      =2  #define CMP0CN0_CPHYP__FMASK                0x0C ///< Comparator Positive Hysteresis Control            
 345      =2  #define CMP0CN0_CPHYP__SHIFT                0x02 ///< Comparator Positive Hysteresis Control            
 346      =2  #define CMP0CN0_CPHYP__DISABLED             0x00 ///< Positive Hysteresis disabled.                     
 347      =2  #define CMP0CN0_CPHYP__ENABLED_MODE1        0x04 ///< Positive Hysteresis = Hysteresis 1.               
 348      =2  #define CMP0CN0_CPHYP__ENABLED_MODE2        0x08 ///< Positive Hysteresis = Hysteresis 2.               
 349      =2  #define CMP0CN0_CPHYP__ENABLED_MODE3        0x0C ///< Positive Hysteresis = Hysteresis 3 (Maximum).     
 350      =2                                                                                                          
 351      =2  #define CMP0CN0_CPFIF__BMASK                0x10 ///< Comparator Falling-Edge Flag                      
 352      =2  #define CMP0CN0_CPFIF__SHIFT                0x04 ///< Comparator Falling-Edge Flag                      
 353      =2  #define CMP0CN0_CPFIF__NOT_SET              0x00 ///< No comparator falling edge has occurred since this
 354      =2                                                   ///< flag was last cleared.                            
 355      =2  #define CMP0CN0_CPFIF__FALLING_EDGE         0x10 ///< Comparator falling edge has occurred.             
 356      =2                                                                                                          
 357      =2  #define CMP0CN0_CPRIF__BMASK                0x20 ///< Comparator Rising-Edge Flag                       
 358      =2  #define CMP0CN0_CPRIF__SHIFT                0x05 ///< Comparator Rising-Edge Flag                       
 359      =2  #define CMP0CN0_CPRIF__NOT_SET              0x00 ///< No comparator rising edge has occurred since this 
 360      =2                                                   ///< flag was last cleared.                            
 361      =2  #define CMP0CN0_CPRIF__RISING_EDGE          0x20 ///< Comparator rising edge has occurred.              
 362      =2                                                                                                          
 363      =2  #define CMP0CN0_CPOUT__BMASK                0x40 ///< Comparator Output State Flag                      
 364      =2  #define CMP0CN0_CPOUT__SHIFT                0x06 ///< Comparator Output State Flag                      
 365      =2  #define CMP0CN0_CPOUT__POS_LESS_THAN_NEG    0x00 ///< Voltage on CP0P < CP0N.                           
 366      =2  #define CMP0CN0_CPOUT__POS_GREATER_THAN_NEG 0x40 ///< Voltage on CP0P > CP0N.                           
 367      =2                                                                                                          
 368      =2  #define CMP0CN0_CPEN__BMASK                 0x80 ///< Comparator Enable                                 
 369      =2  #define CMP0CN0_CPEN__SHIFT                 0x07 ///< Comparator Enable                                 
 370      =2  #define CMP0CN0_CPEN__DISABLED              0x00 ///< Comparator disabled.                              
 371      =2  #define CMP0CN0_CPEN__ENABLED               0x80 ///< Comparator enabled.                               
 372      =2                                                                                                          
 373      =2  //------------------------------------------------------------------------------
 374      =2  // CMP0MD Enums (Comparator 0 Mode @ 0x9D)
 375      =2  //------------------------------------------------------------------------------
 376      =2  #define CMP0MD_CPMD__FMASK              0x03 ///< Comparator Mode Select                      
 377      =2  #define CMP0MD_CPMD__SHIFT              0x00 ///< Comparator Mode Select                      
 378      =2  #define CMP0MD_CPMD__MODE0              0x00 ///< Mode 0 (Fastest Response Time, Highest Power
 379      =2                                               ///< Consumption)                                
 380      =2  #define CMP0MD_CPMD__MODE1              0x01 ///< Mode 1                                      
 381      =2  #define CMP0MD_CPMD__MODE2              0x02 ///< Mode 2                                      
 382      =2  #define CMP0MD_CPMD__MODE3              0x03 ///< Mode 3 (Slowest Response Time, Lowest Power 
 383      =2                                               ///< Consumption)                                
C51 COMPILER V9.56.0.0   I2C_0                                                             10/28/2016 17:37:02 PAGE 33  

 384      =2                                                                                                
 385      =2  #define CMP0MD_CPFIE__BMASK             0x10 ///< Comparator Falling-Edge Interrupt Enable    
 386      =2  #define CMP0MD_CPFIE__SHIFT             0x04 ///< Comparator Falling-Edge Interrupt Enable    
 387      =2  #define CMP0MD_CPFIE__FALL_INT_DISABLED 0x00 ///< Comparator falling-edge interrupt disabled. 
 388      =2  #define CMP0MD_CPFIE__FALL_INT_ENABLED  0x10 ///< Comparator falling-edge interrupt enabled.  
 389      =2                                                                                                
 390      =2  #define CMP0MD_CPRIE__BMASK             0x20 ///< Comparator Rising-Edge Interrupt Enable     
 391      =2  #define CMP0MD_CPRIE__SHIFT             0x05 ///< Comparator Rising-Edge Interrupt Enable     
 392      =2  #define CMP0MD_CPRIE__RISE_INT_DISABLED 0x00 ///< Comparator rising-edge interrupt disabled.  
 393      =2  #define CMP0MD_CPRIE__RISE_INT_ENABLED  0x20 ///< Comparator rising-edge interrupt enabled.   
 394      =2                                                                                                
 395      =2  //------------------------------------------------------------------------------
 396      =2  // CMP0MX Enums (Comparator 0 Multiplexer Selection @ 0x9F)
 397      =2  //------------------------------------------------------------------------------
 398      =2  #define CMP0MX_CMXP__FMASK  0x07 ///< Comparator Positive Input MUX Selection
 399      =2  #define CMP0MX_CMXP__SHIFT  0x00 ///< Comparator Positive Input MUX Selection
 400      =2  #define CMP0MX_CMXP__CMP0P0 0x00 ///< External pin CMP0P.0.                  
 401      =2  #define CMP0MX_CMXP__CMP0P1 0x01 ///< External pin CMP0P.1.                  
 402      =2  #define CMP0MX_CMXP__CMP0P2 0x02 ///< External pin CMP0P.2.                  
 403      =2  #define CMP0MX_CMXP__CMP0P3 0x03 ///< External pin CMP0P.3.                  
 404      =2  #define CMP0MX_CMXP__CMP0P4 0x04 ///< External pin CMP0P.4.                  
 405      =2                                                                               
 406      =2  #define CMP0MX_CMXN__FMASK  0x70 ///< Comparator Negative Input MUX Selection
 407      =2  #define CMP0MX_CMXN__SHIFT  0x04 ///< Comparator Negative Input MUX Selection
 408      =2  #define CMP0MX_CMXN__CMP0N0 0x00 ///< External pin CMP0N.0.                  
 409      =2  #define CMP0MX_CMXN__CMP0N1 0x10 ///< External pin CMP0N.1.                  
 410      =2  #define CMP0MX_CMXN__CMP0N2 0x20 ///< External pin CMP0N.2.                  
 411      =2  #define CMP0MX_CMXN__CMP0N3 0x30 ///< External pin CMP0N.3.                  
 412      =2  #define CMP0MX_CMXN__CMP0N4 0x40 ///< External pin CMP0N.4.                  
 413      =2                                                                               
 414      =2  //------------------------------------------------------------------------------
 415      =2  // CMP1CN0 Enums (Comparator 1 Control 0 @ 0x9A)
 416      =2  //------------------------------------------------------------------------------
 417      =2  #define CMP1CN0_CPHYN__FMASK                0x03 ///< Comparator Negative Hysteresis Control            
 418      =2  #define CMP1CN0_CPHYN__SHIFT                0x00 ///< Comparator Negative Hysteresis Control            
 419      =2  #define CMP1CN0_CPHYN__DISABLED             0x00 ///< Negative Hysteresis disabled.                     
 420      =2  #define CMP1CN0_CPHYN__ENABLED_MODE1        0x01 ///< Negative Hysteresis = Hysteresis 1.               
 421      =2  #define CMP1CN0_CPHYN__ENABLED_MODE2        0x02 ///< Negative Hysteresis = Hysteresis 2.               
 422      =2  #define CMP1CN0_CPHYN__ENABLED_MODE3        0x03 ///< Negative Hysteresis = Hysteresis 3 (Maximum).     
 423      =2                                                                                                          
 424      =2  #define CMP1CN0_CPHYP__FMASK                0x0C ///< Comparator Positive Hysteresis Control            
 425      =2  #define CMP1CN0_CPHYP__SHIFT                0x02 ///< Comparator Positive Hysteresis Control            
 426      =2  #define CMP1CN0_CPHYP__DISABLED             0x00 ///< Positive Hysteresis disabled.                     
 427      =2  #define CMP1CN0_CPHYP__ENABLED_MODE1        0x04 ///< Positive Hysteresis = Hysteresis 1.               
 428      =2  #define CMP1CN0_CPHYP__ENABLED_MODE2        0x08 ///< Positive Hysteresis = Hysteresis 2.               
 429      =2  #define CMP1CN0_CPHYP__ENABLED_MODE3        0x0C ///< Positive Hysteresis = Hysteresis 3 (Maximum).     
 430      =2                                                                                                          
 431      =2  #define CMP1CN0_CPFIF__BMASK                0x10 ///< Comparator Falling-Edge Flag                      
 432      =2  #define CMP1CN0_CPFIF__SHIFT                0x04 ///< Comparator Falling-Edge Flag                      
 433      =2  #define CMP1CN0_CPFIF__NOT_SET              0x00 ///< No comparator falling edge has occurred since this
 434      =2                                                   ///< flag was last cleared.                            
 435      =2  #define CMP1CN0_CPFIF__FALLING_EDGE         0x10 ///< Comparator falling edge has occurred.             
 436      =2                                                                                                          
 437      =2  #define CMP1CN0_CPRIF__BMASK                0x20 ///< Comparator Rising-Edge Flag                       
 438      =2  #define CMP1CN0_CPRIF__SHIFT                0x05 ///< Comparator Rising-Edge Flag                       
 439      =2  #define CMP1CN0_CPRIF__NOT_SET              0x00 ///< No comparator rising edge has occurred since this 
 440      =2                                                   ///< flag was last cleared.                            
 441      =2  #define CMP1CN0_CPRIF__RISING_EDGE          0x20 ///< Comparator rising edge has occurred.              
 442      =2                                                                                                          
 443      =2  #define CMP1CN0_CPOUT__BMASK                0x40 ///< Comparator Output State Flag                      
 444      =2  #define CMP1CN0_CPOUT__SHIFT                0x06 ///< Comparator Output State Flag                      
 445      =2  #define CMP1CN0_CPOUT__POS_LESS_THAN_NEG    0x00 ///< Voltage on CP1P < CP1N.                           
C51 COMPILER V9.56.0.0   I2C_0                                                             10/28/2016 17:37:02 PAGE 34  

 446      =2  #define CMP1CN0_CPOUT__POS_GREATER_THAN_NEG 0x40 ///< Voltage on CP1P > CP1N.                           
 447      =2                                                                                                          
 448      =2  #define CMP1CN0_CPEN__BMASK                 0x80 ///< Comparator Enable                                 
 449      =2  #define CMP1CN0_CPEN__SHIFT                 0x07 ///< Comparator Enable                                 
 450      =2  #define CMP1CN0_CPEN__DISABLED              0x00 ///< Comparator disabled.                              
 451      =2  #define CMP1CN0_CPEN__ENABLED               0x80 ///< Comparator enabled.                               
 452      =2                                                                                                          
 453      =2  //------------------------------------------------------------------------------
 454      =2  // CMP1MD Enums (Comparator 1 Mode @ 0x9C)
 455      =2  //------------------------------------------------------------------------------
 456      =2  #define CMP1MD_CPMD__FMASK              0x03 ///< Comparator Mode Select                      
 457      =2  #define CMP1MD_CPMD__SHIFT              0x00 ///< Comparator Mode Select                      
 458      =2  #define CMP1MD_CPMD__MODE0              0x00 ///< Mode 0 (Fastest Response Time, Highest Power
 459      =2                                               ///< Consumption)                                
 460      =2  #define CMP1MD_CPMD__MODE1              0x01 ///< Mode 1                                      
 461      =2  #define CMP1MD_CPMD__MODE2              0x02 ///< Mode 2                                      
 462      =2  #define CMP1MD_CPMD__MODE3              0x03 ///< Mode 3 (Slowest Response Time, Lowest Power 
 463      =2                                               ///< Consumption)                                
 464      =2                                                                                                
 465      =2  #define CMP1MD_CPFIE__BMASK             0x10 ///< Comparator Falling-Edge Interrupt Enable    
 466      =2  #define CMP1MD_CPFIE__SHIFT             0x04 ///< Comparator Falling-Edge Interrupt Enable    
 467      =2  #define CMP1MD_CPFIE__FALL_INT_DISABLED 0x00 ///< Comparator falling-edge interrupt disabled. 
 468      =2  #define CMP1MD_CPFIE__FALL_INT_ENABLED  0x10 ///< Comparator falling-edge interrupt enabled.  
 469      =2                                                                                                
 470      =2  #define CMP1MD_CPRIE__BMASK             0x20 ///< Comparator Rising-Edge Interrupt Enable     
 471      =2  #define CMP1MD_CPRIE__SHIFT             0x05 ///< Comparator Rising-Edge Interrupt Enable     
 472      =2  #define CMP1MD_CPRIE__RISE_INT_DISABLED 0x00 ///< Comparator rising-edge interrupt disabled.  
 473      =2  #define CMP1MD_CPRIE__RISE_INT_ENABLED  0x20 ///< Comparator rising-edge interrupt enabled.   
 474      =2                                                                                                
 475      =2  //------------------------------------------------------------------------------
 476      =2  // CMP1MX Enums (Comparator 1 Multiplexer Selection @ 0x9E)
 477      =2  //------------------------------------------------------------------------------
 478      =2  #define CMP1MX_CMXP__FMASK  0x07 ///< Comparator Positive Input MUX Selection
 479      =2  #define CMP1MX_CMXP__SHIFT  0x00 ///< Comparator Positive Input MUX Selection
 480      =2  #define CMP1MX_CMXP__CMP1P0 0x00 ///< External pin CMP1P.0.                  
 481      =2  #define CMP1MX_CMXP__CMP1P1 0x01 ///< External pin CMP1P.1.                  
 482      =2  #define CMP1MX_CMXP__CMP1P2 0x02 ///< External pin CMP1P.2.                  
 483      =2  #define CMP1MX_CMXP__CMP1P3 0x03 ///< External pin CMP1P.3.                  
 484      =2  #define CMP1MX_CMXP__CMP1P4 0x04 ///< External pin CMP1P.4.                  
 485      =2                                                                               
 486      =2  #define CMP1MX_CMXN__FMASK  0x70 ///< Comparator Negative Input MUX Selection
 487      =2  #define CMP1MX_CMXN__SHIFT  0x04 ///< Comparator Negative Input MUX Selection
 488      =2  #define CMP1MX_CMXN__CMP1N0 0x00 ///< External pin CMP1N.0.                  
 489      =2  #define CMP1MX_CMXN__CMP1N1 0x10 ///< External pin CMP1N.1.                  
 490      =2  #define CMP1MX_CMXN__CMP1N2 0x20 ///< External pin CMP1N.2.                  
 491      =2  #define CMP1MX_CMXN__CMP1N3 0x30 ///< External pin CMP1N.3.                  
 492      =2  #define CMP1MX_CMXN__CMP1N4 0x40 ///< External pin CMP1N.4.                  
 493      =2                                                                               
 494      =2  //------------------------------------------------------------------------------
 495      =2  // IT01CF Enums (INT0/INT1 Configuration @ 0xE4)
 496      =2  //------------------------------------------------------------------------------
 497      =2  #define IT01CF_IN0SL__FMASK       0x07 ///< INT0 Port Pin Selection   
 498      =2  #define IT01CF_IN0SL__SHIFT       0x00 ///< INT0 Port Pin Selection   
 499      =2  #define IT01CF_IN0SL__P0_0        0x00 ///< Select P0.0.              
 500      =2  #define IT01CF_IN0SL__P0_1        0x01 ///< Select P0.1.              
 501      =2  #define IT01CF_IN0SL__P0_2        0x02 ///< Select P0.2.              
 502      =2  #define IT01CF_IN0SL__P0_3        0x03 ///< Select P0.3.              
 503      =2  #define IT01CF_IN0SL__P0_4        0x04 ///< Select P0.4.              
 504      =2  #define IT01CF_IN0SL__P0_5        0x05 ///< Select P0.5.              
 505      =2  #define IT01CF_IN0SL__P0_6        0x06 ///< Select P0.6.              
 506      =2  #define IT01CF_IN0SL__P0_7        0x07 ///< Select P0.7.              
 507      =2                                                                        
C51 COMPILER V9.56.0.0   I2C_0                                                             10/28/2016 17:37:02 PAGE 35  

 508      =2  #define IT01CF_IN0PL__BMASK       0x08 ///< INT0 Polarity             
 509      =2  #define IT01CF_IN0PL__SHIFT       0x03 ///< INT0 Polarity             
 510      =2  #define IT01CF_IN0PL__ACTIVE_LOW  0x00 ///< INT0 input is active low. 
 511      =2  #define IT01CF_IN0PL__ACTIVE_HIGH 0x08 ///< INT0 input is active high.
 512      =2                                                                        
 513      =2  #define IT01CF_IN1SL__FMASK       0x70 ///< INT1 Port Pin Selection   
 514      =2  #define IT01CF_IN1SL__SHIFT       0x04 ///< INT1 Port Pin Selection   
 515      =2  #define IT01CF_IN1SL__P0_0        0x00 ///< Select P0.0.              
 516      =2  #define IT01CF_IN1SL__P0_1        0x10 ///< Select P0.1.              
 517      =2  #define IT01CF_IN1SL__P0_2        0x20 ///< Select P0.2.              
 518      =2  #define IT01CF_IN1SL__P0_3        0x30 ///< Select P0.3.              
 519      =2  #define IT01CF_IN1SL__P0_4        0x40 ///< Select P0.4.              
 520      =2  #define IT01CF_IN1SL__P0_5        0x50 ///< Select P0.5.              
 521      =2  #define IT01CF_IN1SL__P0_6        0x60 ///< Select P0.6.              
 522      =2  #define IT01CF_IN1SL__P0_7        0x70 ///< Select P0.7.              
 523      =2                                                                        
 524      =2  #define IT01CF_IN1PL__BMASK       0x80 ///< INT1 Polarity             
 525      =2  #define IT01CF_IN1PL__SHIFT       0x07 ///< INT1 Polarity             
 526      =2  #define IT01CF_IN1PL__ACTIVE_LOW  0x00 ///< INT1 input is active low. 
 527      =2  #define IT01CF_IN1PL__ACTIVE_HIGH 0x80 ///< INT1 input is active high.
 528      =2                                                                        
 529      =2  //------------------------------------------------------------------------------
 530      =2  // XOSC0CN Enums (External Oscillator Control @ 0xB1)
 531      =2  //------------------------------------------------------------------------------
 532      =2  #define XOSC0CN_XFCN__FMASK           0x07 ///< External Oscillator Frequency Control            
 533      =2  #define XOSC0CN_XFCN__SHIFT           0x00 ///< External Oscillator Frequency Control            
 534      =2  #define XOSC0CN_XFCN__MODE0           0x00 ///< Select external oscillator mode 0: Crystal       
 535      =2                                             ///< frequency <= 20 kHz, RC/C frequency <= 25 kHz, C 
 536      =2                                             ///< mode K factor = 0.87.                            
 537      =2  #define XOSC0CN_XFCN__MODE1           0x01 ///< Select external oscillator mode 1: 20 kHz <      
 538      =2                                             ///< Crystal frequency <= 58 kHz, 25 kHz < RC/C       
 539      =2                                             ///< frequency <= 50 kHz, C mode K factor = 2.6.      
 540      =2  #define XOSC0CN_XFCN__MODE2           0x02 ///< Select external oscillator mode 2: 58 kHz <      
 541      =2                                             ///< Crystal frequency <= 155 kHz, 50 kHz < RC/C      
 542      =2                                             ///< frequency <= 100 kHz, C mode K factor = 7.7.     
 543      =2  #define XOSC0CN_XFCN__MODE3           0x03 ///< Select external oscillator mode 3: 155 kHz <     
 544      =2                                             ///< Crystal frequency <= 415 kHz, 100 kHz < RC/C     
 545      =2                                             ///< frequency <= 200 kHz, C mode K factor = 22.      
 546      =2  #define XOSC0CN_XFCN__MODE4           0x04 ///< Select external oscillator mode 4: 415 kHz <     
 547      =2                                             ///< Crystal frequency <= 1.1 MHz, 200 kHz < RC/C     
 548      =2                                             ///< frequency <= 400 kHz, C mode K factor = 65.      
 549      =2  #define XOSC0CN_XFCN__MODE5           0x05 ///< Select external oscillator mode 5: 1.1 MHz <     
 550      =2                                             ///< Crystal frequency <= 3.1 MHz, 400 kHz < RC/C     
 551      =2                                             ///< frequency <= 800 kHz, C mode K factor = 180.     
 552      =2  #define XOSC0CN_XFCN__MODE6           0x06 ///< Select external oscillator mode 6: 3.1 MHz <     
 553      =2                                             ///< Crystal frequency <= 8.2 kHz, 800 kHz < RC/C     
 554      =2                                             ///< frequency <= 1.6 MHz, C mode K factor = 664.     
 555      =2  #define XOSC0CN_XFCN__MODE7           0x07 ///< Select external oscillator mode 7: 8.2 MHz <     
 556      =2                                             ///< Crystal frequency <= 25 MHz, 1.6 MHz < RC/C      
 557      =2                                             ///< frequency <= 3.2 MHz, C mode K factor = 1590.    
 558      =2                                                                                                   
 559      =2  #define XOSC0CN_XOSCMD__FMASK         0x70 ///< External Oscillator Mode                         
 560      =2  #define XOSC0CN_XOSCMD__SHIFT         0x04 ///< External Oscillator Mode                         
 561      =2  #define XOSC0CN_XOSCMD__DISABLED      0x00 ///< External Oscillator circuit disabled.            
 562      =2  #define XOSC0CN_XOSCMD__CMOS          0x20 ///< External CMOS Clock Mode.                        
 563      =2  #define XOSC0CN_XOSCMD__CMOS_DIV_2    0x30 ///< External CMOS Clock Mode with divide by 2 stage. 
 564      =2  #define XOSC0CN_XOSCMD__RC_DIV_2      0x40 ///< RC Oscillator Mode with divide by 2 stage.       
 565      =2  #define XOSC0CN_XOSCMD__C_DIV_2       0x50 ///< Capacitor Oscillator Mode with divide by 2 stage.
 566      =2  #define XOSC0CN_XOSCMD__CRYSTAL       0x60 ///< Crystal Oscillator Mode.                         
 567      =2  #define XOSC0CN_XOSCMD__CRYSTAL_DIV_2 0x70 ///< Crystal Oscillator Mode with divide by 2 stage.  
 568      =2                                                                                                   
 569      =2  #define XOSC0CN_XCLKVLD__BMASK        0x80 ///< External Oscillator Valid Flag                   
C51 COMPILER V9.56.0.0   I2C_0                                                             10/28/2016 17:37:02 PAGE 36  

 570      =2  #define XOSC0CN_XCLKVLD__SHIFT        0x07 ///< External Oscillator Valid Flag                   
 571      =2  #define XOSC0CN_XCLKVLD__NOT_SET      0x00 ///< External Oscillator is unused or not yet stable. 
 572      =2  #define XOSC0CN_XCLKVLD__SET          0x80 ///< External Oscillator is running and stable.       
 573      =2                                                                                                   
 574      =2  //------------------------------------------------------------------------------
 575      =2  // FLKEY Enums (Flash Lock and Key @ 0xB7)
 576      =2  //------------------------------------------------------------------------------
 577      =2  #define FLKEY_FLKEY__FMASK    0xFF ///< Flash Lock and Key                             
 578      =2  #define FLKEY_FLKEY__SHIFT    0x00 ///< Flash Lock and Key                             
 579      =2  #define FLKEY_FLKEY__LOCKED   0x00 ///< Flash is write/erase locked.                   
 580      =2  #define FLKEY_FLKEY__FIRST    0x01 ///< The first key code has been written (0xA5).    
 581      =2  #define FLKEY_FLKEY__UNLOCKED 0x02 ///< Flash is unlocked (writes/erases allowed).     
 582      =2  #define FLKEY_FLKEY__DISABLED 0x03 ///< Flash writes/erases are disabled until the next
 583      =2                                     ///< reset.                                         
 584      =2  #define FLKEY_FLKEY__KEY1     0xA5 ///< Flash writes and erases are enabled by writing 
 585      =2                                     ///< 0xA5 followed by 0xF1 to the FLKEY register.   
 586      =2  #define FLKEY_FLKEY__KEY2     0xF1 ///< Flash writes and erases are enabled by writing 
 587      =2                                     ///< 0xA5 followed by 0xF1 to the FLKEY register.   
 588      =2                                                                                         
 589      =2  //------------------------------------------------------------------------------
 590      =2  // FLSCL Enums (Flash Scale @ 0xB6)
 591      =2  //------------------------------------------------------------------------------
 592      =2  #define FLSCL_FLRT__BMASK               0x10 ///< Flash Read Timing                       
 593      =2  #define FLSCL_FLRT__SHIFT               0x04 ///< Flash Read Timing                       
 594      =2  #define FLSCL_FLRT__SYSCLK_BELOW_25_MHZ 0x00 ///< SYSCLK <= 25 MHz.                       
 595      =2  #define FLSCL_FLRT__SYSCLK_BELOW_48_MHZ 0x10 ///< SYSCLK <= 48 MHz.                       
 596      =2                                                                                            
 597      =2  #define FLSCL_FOSE__BMASK               0x80 ///< Flash One-Shot Enable                   
 598      =2  #define FLSCL_FOSE__SHIFT               0x07 ///< Flash One-Shot Enable                   
 599      =2  #define FLSCL_FOSE__DISABLED            0x00 ///< Disable the flash one-shot.             
 600      =2  #define FLSCL_FOSE__ENABLED             0x80 ///< Enable the flash one-shot (recommended).
 601      =2                                                                                            
 602      =2  //------------------------------------------------------------------------------
 603      =2  // PSCTL Enums (Program Store Control @ 0x8F)
 604      =2  //------------------------------------------------------------------------------
 605      =2  #define PSCTL_PSWE__BMASK          0x01 ///< Program Store Write Enable                      
 606      =2  #define PSCTL_PSWE__SHIFT          0x00 ///< Program Store Write Enable                      
 607      =2  #define PSCTL_PSWE__WRITE_DISABLED 0x00 ///< Writes to flash program memory disabled.        
 608      =2  #define PSCTL_PSWE__WRITE_ENABLED  0x01 ///< Writes to flash program memory enabled; the MOVX
 609      =2                                          ///< write instruction targets flash memory.         
 610      =2                                                                                               
 611      =2  #define PSCTL_PSEE__BMASK          0x02 ///< Program Store Erase Enable                      
 612      =2  #define PSCTL_PSEE__SHIFT          0x01 ///< Program Store Erase Enable                      
 613      =2  #define PSCTL_PSEE__ERASE_DISABLED 0x00 ///< Flash program memory erasure disabled.          
 614      =2  #define PSCTL_PSEE__ERASE_ENABLED  0x02 ///< Flash program memory erasure enabled.           
 615      =2                                                                                               
 616      =2  //------------------------------------------------------------------------------
 617      =2  // HFO0CAL Enums (High Frequency Oscillator Calibration @ 0xB3)
 618      =2  //------------------------------------------------------------------------------
 619      =2  #define HFO0CAL_OSCICL__FMASK 0x7F ///< Internal Oscillator Calibration
 620      =2  #define HFO0CAL_OSCICL__SHIFT 0x00 ///< Internal Oscillator Calibration
 621      =2                                                                         
 622      =2  //------------------------------------------------------------------------------
 623      =2  // HFO0CN Enums (High Frequency Oscillator Control @ 0xB2)
 624      =2  //------------------------------------------------------------------------------
 625      =2  #define HFO0CN_IFCN__FMASK        0x03 ///< Oscillator Frequency Divider Control              
 626      =2  #define HFO0CN_IFCN__SHIFT        0x00 ///< Oscillator Frequency Divider Control              
 627      =2  #define HFO0CN_IFCN__SYSCLK_DIV_8 0x00 ///< SYSCLK can be derived from Internal H-F Oscillator
 628      =2                                         ///< divided by 8 (1.5 MHz).                           
 629      =2  #define HFO0CN_IFCN__SYSCLK_DIV_4 0x01 ///< SYSCLK can be derived from Internal H-F Oscillator
 630      =2                                         ///< divided by 4 (3 MHz).                             
 631      =2  #define HFO0CN_IFCN__SYSCLK_DIV_2 0x02 ///< SYSCLK can be derived from Internal H-F Oscillator
C51 COMPILER V9.56.0.0   I2C_0                                                             10/28/2016 17:37:02 PAGE 37  

 632      =2                                         ///< divided by 2 (6 MHz).                             
 633      =2  #define HFO0CN_IFCN__SYSCLK_DIV_1 0x03 ///< SYSCLK can be derived from Internal H-F Oscillator
 634      =2                                         ///< divided by 1 (12 MHz).                            
 635      =2                                                                                                
 636      =2  #define HFO0CN_SUSPEND__BMASK     0x20 ///< Oscillator Suspend Enable                         
 637      =2  #define HFO0CN_SUSPEND__SHIFT     0x05 ///< Oscillator Suspend Enable                         
 638      =2  #define HFO0CN_SUSPEND__DISABLED  0x00 ///< The internal oscillator is not in suspend mode.   
 639      =2  #define HFO0CN_SUSPEND__ENABLED   0x20 ///< Place the internal oscillator in suspend mode.    
 640      =2                                                                                                
 641      =2  #define HFO0CN_IFRDY__BMASK       0x40 ///< Oscillator Frequency Ready Flag                   
 642      =2  #define HFO0CN_IFRDY__SHIFT       0x06 ///< Oscillator Frequency Ready Flag                   
 643      =2  #define HFO0CN_IFRDY__NOT_SET     0x00 ///< The Internal High Frequency Oscillator is not     
 644      =2                                         ///< running at the programmed frequency.              
 645      =2  #define HFO0CN_IFRDY__SET         0x40 ///< The Internal High Frequency Oscillator is running 
 646      =2                                         ///< at the programmed frequency.                      
 647      =2                                                                                                
 648      =2  #define HFO0CN_IOSCEN__BMASK      0x80 ///< Oscillator Enable                                 
 649      =2  #define HFO0CN_IOSCEN__SHIFT      0x07 ///< Oscillator Enable                                 
 650      =2  #define HFO0CN_IOSCEN__DISABLED   0x00 ///< Disable the High Frequency Oscillator.            
 651      =2  #define HFO0CN_IOSCEN__ENABLED    0x80 ///< Enable the High Frequency Oscillator.             
 652      =2                                                                                                
 653      =2  //------------------------------------------------------------------------------
 654      =2  // EIE1 Enums (Extended Interrupt Enable 1 @ 0xE6)
 655      =2  //------------------------------------------------------------------------------
 656      =2  #define EIE1_ESMB0__BMASK     0x01 ///< SMBus (SMB0) Interrupt Enable                     
 657      =2  #define EIE1_ESMB0__SHIFT     0x00 ///< SMBus (SMB0) Interrupt Enable                     
 658      =2  #define EIE1_ESMB0__DISABLED  0x00 ///< Disable all SMB0 interrupts.                      
 659      =2  #define EIE1_ESMB0__ENABLED   0x01 ///< Enable interrupt requests generated by SMB0.      
 660      =2                                                                                            
 661      =2  #define EIE1_EUSB0__BMASK     0x02 ///< USB (USB0) Interrupt Enable                       
 662      =2  #define EIE1_EUSB0__SHIFT     0x01 ///< USB (USB0) Interrupt Enable                       
 663      =2  #define EIE1_EUSB0__DISABLED  0x00 ///< Disable all USB0 interrupts.                      
 664      =2  #define EIE1_EUSB0__ENABLED   0x02 ///< Enable interrupt requests generated by USB0.      
 665      =2                                                                                            
 666      =2  #define EIE1_EWADC0__BMASK    0x04 ///< ADC0 Window Comparison Interrupt Enable           
 667      =2  #define EIE1_EWADC0__SHIFT    0x02 ///< ADC0 Window Comparison Interrupt Enable           
 668      =2  #define EIE1_EWADC0__DISABLED 0x00 ///< Disable ADC0 Window Comparison interrupt.         
 669      =2  #define EIE1_EWADC0__ENABLED  0x04 ///< Enable interrupt requests generated by ADC0 Window
 670      =2                                     ///< Compare flag (ADWINT).                            
 671      =2                                                                                            
 672      =2  #define EIE1_EADC0__BMASK     0x08 ///< ADC0 Conversion Complete Interrupt Enable         
 673      =2  #define EIE1_EADC0__SHIFT     0x03 ///< ADC0 Conversion Complete Interrupt Enable         
 674      =2  #define EIE1_EADC0__DISABLED  0x00 ///< Disable ADC0 Conversion Complete interrupt.       
 675      =2  #define EIE1_EADC0__ENABLED   0x08 ///< Enable interrupt requests generated by the ADINT  
 676      =2                                     ///< flag.                                             
 677      =2                                                                                            
 678      =2  #define EIE1_EPCA0__BMASK     0x10 ///< Programmable Counter Array (PCA0) Interrupt Enable
 679      =2  #define EIE1_EPCA0__SHIFT     0x04 ///< Programmable Counter Array (PCA0) Interrupt Enable
 680      =2  #define EIE1_EPCA0__DISABLED  0x00 ///< Disable all PCA0 interrupts.                      
 681      =2  #define EIE1_EPCA0__ENABLED   0x10 ///< Enable interrupt requests generated by PCA0.      
 682      =2                                                                                            
 683      =2  #define EIE1_ECP0__BMASK      0x20 ///< Comparator0 (CP0) Interrupt Enable                
 684      =2  #define EIE1_ECP0__SHIFT      0x05 ///< Comparator0 (CP0) Interrupt Enable                
 685      =2  #define EIE1_ECP0__DISABLED   0x00 ///< Disable CP0 interrupts.                           
 686      =2  #define EIE1_ECP0__ENABLED    0x20 ///< Enable interrupt requests generated by the        
 687      =2                                     ///< comparator 0 CPRIF or CPFIF flags.                
 688      =2                                                                                            
 689      =2  #define EIE1_ECP1__BMASK      0x40 ///< Comparator1 (CP1) Interrupt Enable                
 690      =2  #define EIE1_ECP1__SHIFT      0x06 ///< Comparator1 (CP1) Interrupt Enable                
 691      =2  #define EIE1_ECP1__DISABLED   0x00 ///< Disable CP1 interrupts.                           
 692      =2  #define EIE1_ECP1__ENABLED    0x40 ///< Enable interrupt requests generated by the        
 693      =2                                     ///< comparator 1 CPRIF or CPFIF flags.                
C51 COMPILER V9.56.0.0   I2C_0                                                             10/28/2016 17:37:02 PAGE 38  

 694      =2                                                                                            
 695      =2  #define EIE1_ET3__BMASK       0x80 ///< Timer 3 Interrupt Enable                          
 696      =2  #define EIE1_ET3__SHIFT       0x07 ///< Timer 3 Interrupt Enable                          
 697      =2  #define EIE1_ET3__DISABLED    0x00 ///< Disable Timer 3 interrupts.                       
 698      =2  #define EIE1_ET3__ENABLED     0x80 ///< Enable interrupt requests generated by the TF3L or
 699      =2                                     ///< TF3H flags.                                       
 700      =2                                                                                            
 701      =2  //------------------------------------------------------------------------------
 702      =2  // EIE2 Enums (Extended Interrupt Enable 2 @ 0xE7)
 703      =2  //------------------------------------------------------------------------------
 704      =2  #define EIE2_EVBUS__BMASK    0x01 ///< VBUS Level Interrupt Enable                       
 705      =2  #define EIE2_EVBUS__SHIFT    0x00 ///< VBUS Level Interrupt Enable                       
 706      =2  #define EIE2_EVBUS__DISABLED 0x00 ///< Disable all VBUS interrupts.                      
 707      =2  #define EIE2_EVBUS__ENABLED  0x01 ///< Enable interrupt requests generated by VBUS level 
 708      =2                                    ///< sense.                                            
 709      =2                                                                                           
 710      =2  #define EIE2_ES1__BMASK      0x02 ///< UART1 Interrupt Enable                            
 711      =2  #define EIE2_ES1__SHIFT      0x01 ///< UART1 Interrupt Enable                            
 712      =2  #define EIE2_ES1__DISABLED   0x00 ///< Disable UART1 interrupt.                          
 713      =2  #define EIE2_ES1__ENABLED    0x02 ///< Enable UART1 interrupt.                           
 714      =2                                                                                           
 715      =2  #define EIE2_ESMB1__BMASK    0x08 ///< SMBus1 Interrupt Enable                           
 716      =2  #define EIE2_ESMB1__SHIFT    0x03 ///< SMBus1 Interrupt Enable                           
 717      =2  #define EIE2_ESMB1__DISABLED 0x00 ///< Disable all SMB1 interrupts.                      
 718      =2  #define EIE2_ESMB1__ENABLED  0x08 ///< Enable interrupt requests generated by SMB1.      
 719      =2                                                                                           
 720      =2  #define EIE2_ET4__BMASK      0x10 ///< Timer 4 Interrupt Enable                          
 721      =2  #define EIE2_ET4__SHIFT      0x04 ///< Timer 4 Interrupt Enable                          
 722      =2  #define EIE2_ET4__DISABLED   0x00 ///< Disable Timer 4interrupts.                        
 723      =2  #define EIE2_ET4__ENABLED    0x10 ///< Enable interrupt requests generated by the TF4L or
 724      =2                                    ///< TF4H flags.                                       
 725      =2                                                                                           
 726      =2  #define EIE2_ET5__BMASK      0x20 ///< Timer 5 Interrupt Enable                          
 727      =2  #define EIE2_ET5__SHIFT      0x05 ///< Timer 5 Interrupt Enable                          
 728      =2  #define EIE2_ET5__DISABLED   0x00 ///< Disable Timer 5 interrupts.                       
 729      =2  #define EIE2_ET5__ENABLED    0x20 ///< Enable interrupt requests generated by the TF5L or
 730      =2                                    ///< TF5H flags.                                       
 731      =2                                                                                           
 732      =2  //------------------------------------------------------------------------------
 733      =2  // EIP1 Enums (Extended Interrupt Priority 1 @ 0xF6)
 734      =2  //------------------------------------------------------------------------------
 735      =2  #define EIP1_PSMB0__BMASK  0x01 ///< SMBus (SMB0) Interrupt Priority Control                     
 736      =2  #define EIP1_PSMB0__SHIFT  0x00 ///< SMBus (SMB0) Interrupt Priority Control                     
 737      =2  #define EIP1_PSMB0__LOW    0x00 ///< SMB0 interrupt set to low priority level.                   
 738      =2  #define EIP1_PSMB0__HIGH   0x01 ///< SMB0 interrupt set to high priority level.                  
 739      =2                                                                                                   
 740      =2  #define EIP1_PUSB0__BMASK  0x02 ///< USB (USB0) Interrupt Priority Control                       
 741      =2  #define EIP1_PUSB0__SHIFT  0x01 ///< USB (USB0) Interrupt Priority Control                       
 742      =2  #define EIP1_PUSB0__LOW    0x00 ///< USB0 interrupt set to low priority level.                   
 743      =2  #define EIP1_PUSB0__HIGH   0x02 ///< USB0 interrupt set to high priority level.                  
 744      =2                                                                                                   
 745      =2  #define EIP1_PWADC0__BMASK 0x04 ///< ADC0 Window Comparator Interrupt Priority Control           
 746      =2  #define EIP1_PWADC0__SHIFT 0x02 ///< ADC0 Window Comparator Interrupt Priority Control           
 747      =2  #define EIP1_PWADC0__LOW   0x00 ///< ADC0 Window interrupt set to low priority level.            
 748      =2  #define EIP1_PWADC0__HIGH  0x04 ///< ADC0 Window interrupt set to high priority level.           
 749      =2                                                                                                   
 750      =2  #define EIP1_PADC0__BMASK  0x08 ///< ADC0 Conversion Complete Interrupt Priority Control         
 751      =2  #define EIP1_PADC0__SHIFT  0x03 ///< ADC0 Conversion Complete Interrupt Priority Control         
 752      =2  #define EIP1_PADC0__LOW    0x00 ///< ADC0 Conversion Complete interrupt set to low               
 753      =2                                  ///< priority level.                                             
 754      =2  #define EIP1_PADC0__HIGH   0x08 ///< ADC0 Conversion Complete interrupt set to high              
 755      =2                                  ///< priority level.                                             
C51 COMPILER V9.56.0.0   I2C_0                                                             10/28/2016 17:37:02 PAGE 39  

 756      =2                                                                                                   
 757      =2  #define EIP1_PPCA0__BMASK  0x10 ///< Programmable Counter Array (PCA0) Interrupt Priority Control
 758      =2  #define EIP1_PPCA0__SHIFT  0x04 ///< Programmable Counter Array (PCA0) Interrupt Priority Control
 759      =2  #define EIP1_PPCA0__LOW    0x00 ///< PCA0 interrupt set to low priority level.                   
 760      =2  #define EIP1_PPCA0__HIGH   0x10 ///< PCA0 interrupt set to high priority level.                  
 761      =2                                                                                                   
 762      =2  #define EIP1_PCP0__BMASK   0x20 ///< Comparator0 (CP0) Interrupt Priority Control                
 763      =2  #define EIP1_PCP0__SHIFT   0x05 ///< Comparator0 (CP0) Interrupt Priority Control                
 764      =2  #define EIP1_PCP0__LOW     0x00 ///< CP0 interrupt set to low priority level.                    
 765      =2  #define EIP1_PCP0__HIGH    0x20 ///< CP0 interrupt set to high priority level.                   
 766      =2                                                                                                   
 767      =2  #define EIP1_PCP1__BMASK   0x40 ///< Comparator1 (CP1) Interrupt Priority Control                
 768      =2  #define EIP1_PCP1__SHIFT   0x06 ///< Comparator1 (CP1) Interrupt Priority Control                
 769      =2  #define EIP1_PCP1__LOW     0x00 ///< CP1 interrupt set to low priority level.                    
 770      =2  #define EIP1_PCP1__HIGH    0x40 ///< CP1 interrupt set to high priority level.                   
 771      =2                                                                                                   
 772      =2  #define EIP1_PT3__BMASK    0x80 ///< Timer 3 Interrupt Priority Control                          
 773      =2  #define EIP1_PT3__SHIFT    0x07 ///< Timer 3 Interrupt Priority Control                          
 774      =2  #define EIP1_PT3__LOW      0x00 ///< Timer 3 interrupts set to low priority level.               
 775      =2  #define EIP1_PT3__HIGH     0x80 ///< Timer 3 interrupts set to high priority level.              
 776      =2                                                                                                   
 777      =2  //------------------------------------------------------------------------------
 778      =2  // EIP2 Enums (Extended Interrupt Priority 2 @ 0xF7)
 779      =2  //------------------------------------------------------------------------------
 780      =2  #define EIP2_PVBUS__BMASK 0x01 ///< VBUS Level Interrupt Priority Control        
 781      =2  #define EIP2_PVBUS__SHIFT 0x00 ///< VBUS Level Interrupt Priority Control        
 782      =2  #define EIP2_PVBUS__LOW   0x00 ///< VBUS interrupt set to low priority level.    
 783      =2  #define EIP2_PVBUS__HIGH  0x01 ///< VBUS interrupt set to high priority level.   
 784      =2                                                                                   
 785      =2  #define EIP2_PS1__BMASK   0x02 ///< UART1 Interrupt Priority Control             
 786      =2  #define EIP2_PS1__SHIFT   0x01 ///< UART1 Interrupt Priority Control             
 787      =2  #define EIP2_PS1__LOW     0x00 ///< UART1 interrupt set to low priority level.   
 788      =2  #define EIP2_PS1__HIGH    0x02 ///< UART1 interrupt set to high priority level.  
 789      =2                                                                                   
 790      =2  #define EIP2_PSMB1__BMASK 0x08 ///< SMBus1 Interrupt Priority Control            
 791      =2  #define EIP2_PSMB1__SHIFT 0x03 ///< SMBus1 Interrupt Priority Control            
 792      =2  #define EIP2_PSMB1__LOW   0x00 ///< SMB1 interrupt set to low priority level.    
 793      =2  #define EIP2_PSMB1__HIGH  0x08 ///< SMB1 interrupt set to high priority level.   
 794      =2                                                                                   
 795      =2  #define EIP2_PT4__BMASK   0x10 ///< Timer 4 Interrupt Priority Control           
 796      =2  #define EIP2_PT4__SHIFT   0x04 ///< Timer 4 Interrupt Priority Control           
 797      =2  #define EIP2_PT4__LOW     0x00 ///< Timer 4 interrupt set to low priority level. 
 798      =2  #define EIP2_PT4__HIGH    0x10 ///< Timer 4 interrupt set to high priority level.
 799      =2                                                                                   
 800      =2  #define EIP2_PT5__BMASK   0x20 ///< Timer 5 Interrupt Priority Control           
 801      =2  #define EIP2_PT5__SHIFT   0x05 ///< Timer 5 Interrupt Priority Control           
 802      =2  #define EIP2_PT5__LOW     0x00 ///< Timer 5 interrupt set to low priority level. 
 803      =2  #define EIP2_PT5__HIGH    0x20 ///< Timer 5 interrupt set to high priority level.
 804      =2                                                                                   
 805      =2  //------------------------------------------------------------------------------
 806      =2  // IE Enums (Interrupt Enable @ 0xA8)
 807      =2  //------------------------------------------------------------------------------
 808      =2  #define IE_EX0__BMASK      0x01 ///< External Interrupt 0 Enable                       
 809      =2  #define IE_EX0__SHIFT      0x00 ///< External Interrupt 0 Enable                       
 810      =2  #define IE_EX0__DISABLED   0x00 ///< Disable external interrupt 0.                     
 811      =2  #define IE_EX0__ENABLED    0x01 ///< Enable interrupt requests generated by the INT0   
 812      =2                                  ///< input.                                            
 813      =2                                                                                         
 814      =2  #define IE_ET0__BMASK      0x02 ///< Timer 0 Interrupt Enable                          
 815      =2  #define IE_ET0__SHIFT      0x01 ///< Timer 0 Interrupt Enable                          
 816      =2  #define IE_ET0__DISABLED   0x00 ///< Disable all Timer 0 interrupt.                    
 817      =2  #define IE_ET0__ENABLED    0x02 ///< Enable interrupt requests generated by the TF0    
C51 COMPILER V9.56.0.0   I2C_0                                                             10/28/2016 17:37:02 PAGE 40  

 818      =2                                  ///< flag.                                             
 819      =2                                                                                         
 820      =2  #define IE_EX1__BMASK      0x04 ///< External Interrupt 1 Enable                       
 821      =2  #define IE_EX1__SHIFT      0x02 ///< External Interrupt 1 Enable                       
 822      =2  #define IE_EX1__DISABLED   0x00 ///< Disable external interrupt 1.                     
 823      =2  #define IE_EX1__ENABLED    0x04 ///< Enable interrupt requests generated by the INT1   
 824      =2                                  ///< input.                                            
 825      =2                                                                                         
 826      =2  #define IE_ET1__BMASK      0x08 ///< Timer 1 Interrupt Enable                          
 827      =2  #define IE_ET1__SHIFT      0x03 ///< Timer 1 Interrupt Enable                          
 828      =2  #define IE_ET1__DISABLED   0x00 ///< Disable all Timer 1 interrupt.                    
 829      =2  #define IE_ET1__ENABLED    0x08 ///< Enable interrupt requests generated by the TF1    
 830      =2                                  ///< flag.                                             
 831      =2                                                                                         
 832      =2  #define IE_ES0__BMASK      0x10 ///< UART0 Interrupt Enable                            
 833      =2  #define IE_ES0__SHIFT      0x04 ///< UART0 Interrupt Enable                            
 834      =2  #define IE_ES0__DISABLED   0x00 ///< Disable UART0 interrupt.                          
 835      =2  #define IE_ES0__ENABLED    0x10 ///< Enable UART0 interrupt.                           
 836      =2                                                                                         
 837      =2  #define IE_ET2__BMASK      0x20 ///< Timer 2 Interrupt Enable                          
 838      =2  #define IE_ET2__SHIFT      0x05 ///< Timer 2 Interrupt Enable                          
 839      =2  #define IE_ET2__DISABLED   0x00 ///< Disable Timer 2 interrupt.                        
 840      =2  #define IE_ET2__ENABLED    0x20 ///< Enable interrupt requests generated by the TF2L or
 841      =2                                  ///< TF2H flags.                                       
 842      =2                                                                                         
 843      =2  #define IE_ESPI0__BMASK    0x40 ///< SPI0 Interrupt Enable                             
 844      =2  #define IE_ESPI0__SHIFT    0x06 ///< SPI0 Interrupt Enable                             
 845      =2  #define IE_ESPI0__DISABLED 0x00 ///< Disable all SPI0 interrupts.                      
 846      =2  #define IE_ESPI0__ENABLED  0x40 ///< Enable interrupt requests generated by SPI0.      
 847      =2                                                                                         
 848      =2  #define IE_EA__BMASK       0x80 ///< All Interrupts Enable                             
 849      =2  #define IE_EA__SHIFT       0x07 ///< All Interrupts Enable                             
 850      =2  #define IE_EA__DISABLED    0x00 ///< Disable all interrupt sources.                    
 851      =2  #define IE_EA__ENABLED     0x80 ///< Enable each interrupt according to its individual 
 852      =2                                  ///< mask setting.                                     
 853      =2                                                                                         
 854      =2  //------------------------------------------------------------------------------
 855      =2  // IP Enums (Interrupt Priority @ 0xB8)
 856      =2  //------------------------------------------------------------------------------
 857      =2  #define IP_PX0__BMASK   0x01 ///< External Interrupt 0 Priority Control                        
 858      =2  #define IP_PX0__SHIFT   0x00 ///< External Interrupt 0 Priority Control                        
 859      =2  #define IP_PX0__LOW     0x00 ///< External Interrupt 0 set to low priority level.              
 860      =2  #define IP_PX0__HIGH    0x01 ///< External Interrupt 0 set to high priority level.             
 861      =2                                                                                                 
 862      =2  #define IP_PT0__BMASK   0x02 ///< Timer 0 Interrupt Priority Control                           
 863      =2  #define IP_PT0__SHIFT   0x01 ///< Timer 0 Interrupt Priority Control                           
 864      =2  #define IP_PT0__LOW     0x00 ///< Timer 0 interrupt set to low priority level.                 
 865      =2  #define IP_PT0__HIGH    0x02 ///< Timer 0 interrupt set to high priority level.                
 866      =2                                                                                                 
 867      =2  #define IP_PX1__BMASK   0x04 ///< External Interrupt 1 Priority Control                        
 868      =2  #define IP_PX1__SHIFT   0x02 ///< External Interrupt 1 Priority Control                        
 869      =2  #define IP_PX1__LOW     0x00 ///< External Interrupt 1 set to low priority level.              
 870      =2  #define IP_PX1__HIGH    0x04 ///< External Interrupt 1 set to high priority level.             
 871      =2                                                                                                 
 872      =2  #define IP_PT1__BMASK   0x08 ///< Timer 1 Interrupt Priority Control                           
 873      =2  #define IP_PT1__SHIFT   0x03 ///< Timer 1 Interrupt Priority Control                           
 874      =2  #define IP_PT1__LOW     0x00 ///< Timer 1 interrupt set to low priority level.                 
 875      =2  #define IP_PT1__HIGH    0x08 ///< Timer 1 interrupt set to high priority level.                
 876      =2                                                                                                 
 877      =2  #define IP_PS0__BMASK   0x10 ///< UART0 Interrupt Priority Control                             
 878      =2  #define IP_PS0__SHIFT   0x04 ///< UART0 Interrupt Priority Control                             
 879      =2  #define IP_PS0__LOW     0x00 ///< UART0 interrupt set to low priority level.                   
C51 COMPILER V9.56.0.0   I2C_0                                                             10/28/2016 17:37:02 PAGE 41  

 880      =2  #define IP_PS0__HIGH    0x10 ///< UART0 interrupt set to high priority level.                  
 881      =2                                                                                                 
 882      =2  #define IP_PT2__BMASK   0x20 ///< Timer 2 Interrupt Priority Control                           
 883      =2  #define IP_PT2__SHIFT   0x05 ///< Timer 2 Interrupt Priority Control                           
 884      =2  #define IP_PT2__LOW     0x00 ///< Timer 2 interrupt set to low priority level.                 
 885      =2  #define IP_PT2__HIGH    0x20 ///< Timer 2 interrupt set to high priority level.                
 886      =2                                                                                                 
 887      =2  #define IP_PSPI0__BMASK 0x40 ///< Serial Peripheral Interface (SPI0) Interrupt Priority Control
 888      =2  #define IP_PSPI0__SHIFT 0x06 ///< Serial Peripheral Interface (SPI0) Interrupt Priority Control
 889      =2  #define IP_PSPI0__LOW   0x00 ///< SPI0 interrupt set to low priority level.                    
 890      =2  #define IP_PSPI0__HIGH  0x40 ///< SPI0 interrupt set to high priority level.                   
 891      =2                                                                                                 
 892      =2  //------------------------------------------------------------------------------
 893      =2  // LFO0CN Enums (Low Frequency Oscillator Control @ 0x86)
 894      =2  //------------------------------------------------------------------------------
 895      =2  #define LFO0CN_OSCLD__FMASK       0x03 ///< Internal L-F Oscillator Divider Select           
 896      =2  #define LFO0CN_OSCLD__SHIFT       0x00 ///< Internal L-F Oscillator Divider Select           
 897      =2  #define LFO0CN_OSCLD__DIVIDE_BY_8 0x00 ///< Divide by 8 selected.                            
 898      =2  #define LFO0CN_OSCLD__DIVIDE_BY_4 0x01 ///< Divide by 4 selected.                            
 899      =2  #define LFO0CN_OSCLD__DIVIDE_BY_2 0x02 ///< Divide by 2 selected.                            
 900      =2  #define LFO0CN_OSCLD__DIVIDE_BY_1 0x03 ///< Divide by 1 selected.                            
 901      =2                                                                                               
 902      =2  #define LFO0CN_OSCLF__FMASK       0x3C ///< Internal L-F Oscillator Frequency Control        
 903      =2  #define LFO0CN_OSCLF__SHIFT       0x02 ///< Internal L-F Oscillator Frequency Control        
 904      =2                                                                                               
 905      =2  #define LFO0CN_OSCLRDY__BMASK     0x40 ///< Internal L-F Oscillator Ready                    
 906      =2  #define LFO0CN_OSCLRDY__SHIFT     0x06 ///< Internal L-F Oscillator Ready                    
 907      =2  #define LFO0CN_OSCLRDY__NOT_SET   0x00 ///< Internal L-F Oscillator frequency not stabilized.
 908      =2  #define LFO0CN_OSCLRDY__SET       0x40 ///< Internal L-F Oscillator frequency stabilized.    
 909      =2                                                                                               
 910      =2  #define LFO0CN_OSCLEN__BMASK      0x80 ///< Internal L-F Oscillator Enable                   
 911      =2  #define LFO0CN_OSCLEN__SHIFT      0x07 ///< Internal L-F Oscillator Enable                   
 912      =2  #define LFO0CN_OSCLEN__DISABLED   0x00 ///< Internal L-F Oscillator Disabled.                
 913      =2  #define LFO0CN_OSCLEN__ENABLED    0x80 ///< Internal L-F Oscillator Enabled.                 
 914      =2                                                                                               
 915      =2  //------------------------------------------------------------------------------
 916      =2  // XBR0 Enums (Port I/O Crossbar 0 @ 0xE1)
 917      =2  //------------------------------------------------------------------------------
 918      =2  #define XBR0_URT0E__BMASK     0x01 ///< UART0 I/O Output Enable                        
 919      =2  #define XBR0_URT0E__SHIFT     0x00 ///< UART0 I/O Output Enable                        
 920      =2  #define XBR0_URT0E__DISABLED  0x00 ///< UART0 I/O unavailable at Port pin.             
 921      =2  #define XBR0_URT0E__ENABLED   0x01 ///< UART0 TX, RX routed to Port pins P0.4 and P0.5.
 922      =2                                                                                         
 923      =2  #define XBR0_SPI0E__BMASK     0x02 ///< SPI I/O Enable                                 
 924      =2  #define XBR0_SPI0E__SHIFT     0x01 ///< SPI I/O Enable                                 
 925      =2  #define XBR0_SPI0E__DISABLED  0x00 ///< SPI I/O unavailable at Port pins.              
 926      =2  #define XBR0_SPI0E__ENABLED   0x02 ///< SPI I/O routed to Port pins. The SPI can be    
 927      =2                                     ///< assigned either 3 or 4 GPIO pins.              
 928      =2                                                                                         
 929      =2  #define XBR0_SMB0E__BMASK     0x04 ///< SMB0 I/O Enable                                
 930      =2  #define XBR0_SMB0E__SHIFT     0x02 ///< SMB0 I/O Enable                                
 931      =2  #define XBR0_SMB0E__DISABLED  0x00 ///< SMBus 0 I/O unavailable at Port pins.          
 932      =2  #define XBR0_SMB0E__ENABLED   0x04 ///< SMBus 0 I/O routed to Port pins.               
 933      =2                                                                                         
 934      =2  #define XBR0_SYSCKE__BMASK    0x08 ///< SYSCLK Output Enable                           
 935      =2  #define XBR0_SYSCKE__SHIFT    0x03 ///< SYSCLK Output Enable                           
 936      =2  #define XBR0_SYSCKE__DISABLED 0x00 ///< SYSCLK unavailable at Port pin.                
 937      =2  #define XBR0_SYSCKE__ENABLED  0x08 ///< SYSCLK output routed to Port pin.              
 938      =2                                                                                         
 939      =2  #define XBR0_CP0E__BMASK      0x10 ///< Comparator0 Output Enable                      
 940      =2  #define XBR0_CP0E__SHIFT      0x04 ///< Comparator0 Output Enable                      
 941      =2  #define XBR0_CP0E__DISABLED   0x00 ///< CP0 unavailable at Port pin.                   
C51 COMPILER V9.56.0.0   I2C_0                                                             10/28/2016 17:37:02 PAGE 42  

 942      =2  #define XBR0_CP0E__ENABLED    0x10 ///< CP0 routed to Port pin.                        
 943      =2                                                                                         
 944      =2  #define XBR0_CP0AE__BMASK     0x20 ///< Comparator0 Asynchronous Output Enable         
 945      =2  #define XBR0_CP0AE__SHIFT     0x05 ///< Comparator0 Asynchronous Output Enable         
 946      =2  #define XBR0_CP0AE__DISABLED  0x00 ///< Asynchronous CP0 unavailable at Port pin.      
 947      =2  #define XBR0_CP0AE__ENABLED   0x20 ///< Asynchronous CP0 routed to Port pin.           
 948      =2                                                                                         
 949      =2  #define XBR0_CP1E__BMASK      0x40 ///< Comparator1 Output Enable                      
 950      =2  #define XBR0_CP1E__SHIFT      0x06 ///< Comparator1 Output Enable                      
 951      =2  #define XBR0_CP1E__DISABLED   0x00 ///< CP1 unavailable at Port pin.                   
 952      =2  #define XBR0_CP1E__ENABLED    0x40 ///< CP1 routed to Port pin.                        
 953      =2                                                                                         
 954      =2  #define XBR0_CP1AE__BMASK     0x80 ///< Comparator1 Asynchronous Output Enable         
 955      =2  #define XBR0_CP1AE__SHIFT     0x07 ///< Comparator1 Asynchronous Output Enable         
 956      =2  #define XBR0_CP1AE__DISABLED  0x00 ///< Asynchronous CP1 unavailable at Port pin.      
 957      =2  #define XBR0_CP1AE__ENABLED   0x80 ///< Asynchronous CP1 routed to Port pin.           
 958      =2                                                                                         
 959      =2  //------------------------------------------------------------------------------
 960      =2  // XBR1 Enums (Port I/O Crossbar 1 @ 0xE2)
 961      =2  //------------------------------------------------------------------------------
 962      =2  #define XBR1_PCA0ME__FMASK                    0x07 ///< PCA Module I/O Enable                            
 963      =2  #define XBR1_PCA0ME__SHIFT                    0x00 ///< PCA Module I/O Enable                            
 964      =2  #define XBR1_PCA0ME__DISABLED                 0x00 ///< All PCA I/O unavailable at Port pins.            
 965      =2  #define XBR1_PCA0ME__CEX0                     0x01 ///< CEX0 routed to Port pin.                         
 966      =2  #define XBR1_PCA0ME__CEX0_CEX1                0x02 ///< CEX0, CEX1 routed to Port pins.                  
 967      =2  #define XBR1_PCA0ME__CEX0_CEX1_CEX2           0x03 ///< CEX0, CEX1, CEX2 routed to Port pins.            
 968      =2  #define XBR1_PCA0ME__CEX0_CEX1_CEX2_CEX3      0x04 ///< CEX0, CEX1, CEX2, CEX3 routed to Port pins.      
 969      =2  #define XBR1_PCA0ME__CEX0_CEX1_CEX2_CEX3_CEX4 0x05 ///< CEX0, CEX1, CEX2, CEX3, CEX4 routed to Port pins.
 970      =2                                                                                                           
 971      =2  #define XBR1_ECIE__BMASK                      0x08 ///< PCA0 External Counter Input Enable               
 972      =2  #define XBR1_ECIE__SHIFT                      0x03 ///< PCA0 External Counter Input Enable               
 973      =2  #define XBR1_ECIE__DISABLED                   0x00 ///< ECI unavailable at Port pin.                     
 974      =2  #define XBR1_ECIE__ENABLED                    0x08 ///< ECI routed to Port pin.                          
 975      =2                                                                                                           
 976      =2  #define XBR1_T0E__BMASK                       0x10 ///< T0 Enable                                        
 977      =2  #define XBR1_T0E__SHIFT                       0x04 ///< T0 Enable                                        
 978      =2  #define XBR1_T0E__DISABLED                    0x00 ///< T0 unavailable at Port pin.                      
 979      =2  #define XBR1_T0E__ENABLED                     0x10 ///< T0 routed to Port pin.                           
 980      =2                                                                                                           
 981      =2  #define XBR1_T1E__BMASK                       0x20 ///< T1 Enable                                        
 982      =2  #define XBR1_T1E__SHIFT                       0x05 ///< T1 Enable                                        
 983      =2  #define XBR1_T1E__DISABLED                    0x00 ///< T1 unavailable at Port pin.                      
 984      =2  #define XBR1_T1E__ENABLED                     0x20 ///< T1 routed to Port pin.                           
 985      =2                                                                                                           
 986      =2  #define XBR1_XBARE__BMASK                     0x40 ///< Crossbar Enable                                  
 987      =2  #define XBR1_XBARE__SHIFT                     0x06 ///< Crossbar Enable                                  
 988      =2  #define XBR1_XBARE__DISABLED                  0x00 ///< Crossbar disabled.                               
 989      =2  #define XBR1_XBARE__ENABLED                   0x40 ///< Crossbar enabled.                                
 990      =2                                                                                                           
 991      =2  #define XBR1_WEAKPUD__BMASK                   0x80 ///< Port I/O Weak Pullup Disable                     
 992      =2  #define XBR1_WEAKPUD__SHIFT                   0x07 ///< Port I/O Weak Pullup Disable                     
 993      =2  #define XBR1_WEAKPUD__PULL_UPS_ENABLED        0x00 ///< Weak Pullups enabled (except for Ports whose I/O 
 994      =2                                                     ///< are configured for analog mode).                 
 995      =2  #define XBR1_WEAKPUD__PULL_UPS_DISABLED       0x80 ///< Weak Pullups disabled.                           
 996      =2                                                                                                           
 997      =2  //------------------------------------------------------------------------------
 998      =2  // XBR2 Enums (Port I/O Crossbar 2 @ 0xE3)
 999      =2  //------------------------------------------------------------------------------
1000      =2  #define XBR2_URT1E__BMASK    0x01 ///< UART1 I/O Output Enable             
1001      =2  #define XBR2_URT1E__SHIFT    0x00 ///< UART1 I/O Output Enable             
1002      =2  #define XBR2_URT1E__DISABLED 0x00 ///< UART1 I/O unavailable at Port pin.  
1003      =2  #define XBR2_URT1E__ENABLED  0x01 ///< UART1 TX, RX routed to Port pins.   
C51 COMPILER V9.56.0.0   I2C_0                                                             10/28/2016 17:37:02 PAGE 43  

1004      =2                                                                             
1005      =2  #define XBR2_SMB1E__BMASK    0x02 ///< SMBus1 I/O Enable                   
1006      =2  #define XBR2_SMB1E__SHIFT    0x01 ///< SMBus1 I/O Enable                   
1007      =2  #define XBR2_SMB1E__DISABLED 0x00 ///< SMBus1 I/O unavailable at Port pins.
1008      =2  #define XBR2_SMB1E__ENABLED  0x02 ///< SMBus1 I/O routed to Port pins.     
1009      =2                                                                             
1010      =2  //------------------------------------------------------------------------------
1011      =2  // PCA0CPH0 Enums (PCA Channel 0 Capture Module High Byte @ 0xFC)
1012      =2  //------------------------------------------------------------------------------
1013      =2  #define PCA0CPH0_PCA0CPH0__FMASK 0xFF ///< PCA Channel 0 Capture Module High Byte
1014      =2  #define PCA0CPH0_PCA0CPH0__SHIFT 0x00 ///< PCA Channel 0 Capture Module High Byte
1015      =2                                                                                   
1016      =2  //------------------------------------------------------------------------------
1017      =2  // PCA0CPL0 Enums (PCA Channel 0 Capture Module Low Byte @ 0xFB)
1018      =2  //------------------------------------------------------------------------------
1019      =2  #define PCA0CPL0_PCA0CPL0__FMASK 0xFF ///< PCA Channel 0 Capture Module Low Byte
1020      =2  #define PCA0CPL0_PCA0CPL0__SHIFT 0x00 ///< PCA Channel 0 Capture Module Low Byte
1021      =2                                                                                  
1022      =2  //------------------------------------------------------------------------------
1023      =2  // PCA0CPM0 Enums (PCA Channel 0 Capture/Compare Mode @ 0xDA)
1024      =2  //------------------------------------------------------------------------------
1025      =2  #define PCA0CPM0_ECCF__BMASK    0x01 ///< Channel 0 Capture/Compare Flag Interrupt Enable
1026      =2  #define PCA0CPM0_ECCF__SHIFT    0x00 ///< Channel 0 Capture/Compare Flag Interrupt Enable
1027      =2  #define PCA0CPM0_ECCF__DISABLED 0x00 ///< Disable CCF0 interrupts.                       
1028      =2  #define PCA0CPM0_ECCF__ENABLED  0x01 ///< Enable a Capture/Compare Flag interrupt request
1029      =2                                       ///< when CCF0 is set.                              
1030      =2                                                                                           
1031      =2  #define PCA0CPM0_PWM__BMASK     0x02 ///< Channel 0 Pulse Width Modulation Mode Enable   
1032      =2  #define PCA0CPM0_PWM__SHIFT     0x01 ///< Channel 0 Pulse Width Modulation Mode Enable   
1033      =2  #define PCA0CPM0_PWM__DISABLED  0x00 ///< Disable PWM function.                          
1034      =2  #define PCA0CPM0_PWM__ENABLED   0x02 ///< Enable PWM function.                           
1035      =2                                                                                           
1036      =2  #define PCA0CPM0_TOG__BMASK     0x04 ///< Channel 0 Toggle Function Enable               
1037      =2  #define PCA0CPM0_TOG__SHIFT     0x02 ///< Channel 0 Toggle Function Enable               
1038      =2  #define PCA0CPM0_TOG__DISABLED  0x00 ///< Disable toggle function.                       
1039      =2  #define PCA0CPM0_TOG__ENABLED   0x04 ///< Enable toggle function.                        
1040      =2                                                                                           
1041      =2  #define PCA0CPM0_MAT__BMASK     0x08 ///< Channel 0 Match Function Enable                
1042      =2  #define PCA0CPM0_MAT__SHIFT     0x03 ///< Channel 0 Match Function Enable                
1043      =2  #define PCA0CPM0_MAT__DISABLED  0x00 ///< Disable match function.                        
1044      =2  #define PCA0CPM0_MAT__ENABLED   0x08 ///< Enable match function.                         
1045      =2                                                                                           
1046      =2  #define PCA0CPM0_CAPN__BMASK    0x10 ///< Channel 0 Capture Negative Function Enable     
1047      =2  #define PCA0CPM0_CAPN__SHIFT    0x04 ///< Channel 0 Capture Negative Function Enable     
1048      =2  #define PCA0CPM0_CAPN__DISABLED 0x00 ///< Disable negative edge capture.                 
1049      =2  #define PCA0CPM0_CAPN__ENABLED  0x10 ///< Enable negative edge capture.                  
1050      =2                                                                                           
1051      =2  #define PCA0CPM0_CAPP__BMASK    0x20 ///< Channel 0 Capture Positive Function Enable     
1052      =2  #define PCA0CPM0_CAPP__SHIFT    0x05 ///< Channel 0 Capture Positive Function Enable     
1053      =2  #define PCA0CPM0_CAPP__DISABLED 0x00 ///< Disable positive edge capture.                 
1054      =2  #define PCA0CPM0_CAPP__ENABLED  0x20 ///< Enable positive edge capture.                  
1055      =2                                                                                           
1056      =2  #define PCA0CPM0_ECOM__BMASK    0x40 ///< Channel 0 Comparator Function Enable           
1057      =2  #define PCA0CPM0_ECOM__SHIFT    0x06 ///< Channel 0 Comparator Function Enable           
1058      =2  #define PCA0CPM0_ECOM__DISABLED 0x00 ///< Disable comparator function.                   
1059      =2  #define PCA0CPM0_ECOM__ENABLED  0x40 ///< Enable comparator function.                    
1060      =2                                                                                           
1061      =2  #define PCA0CPM0_PWM16__BMASK   0x80 ///< Channel 0 16-bit Pulse Width Modulation Enable 
1062      =2  #define PCA0CPM0_PWM16__SHIFT   0x07 ///< Channel 0 16-bit Pulse Width Modulation Enable 
1063      =2  #define PCA0CPM0_PWM16__8_BIT   0x00 ///< 8-bit PWM selected.                            
1064      =2  #define PCA0CPM0_PWM16__16_BIT  0x80 ///< 16-bit PWM selected.                           
1065      =2                                                                                           
C51 COMPILER V9.56.0.0   I2C_0                                                             10/28/2016 17:37:02 PAGE 44  

1066      =2  //------------------------------------------------------------------------------
1067      =2  // PCA0CPH1 Enums (PCA Channel 1 Capture Module High Byte @ 0xEA)
1068      =2  //------------------------------------------------------------------------------
1069      =2  #define PCA0CPH1_PCA0CPH1__FMASK 0xFF ///< PCA Channel 1 Capture Module High Byte
1070      =2  #define PCA0CPH1_PCA0CPH1__SHIFT 0x00 ///< PCA Channel 1 Capture Module High Byte
1071      =2                                                                                   
1072      =2  //------------------------------------------------------------------------------
1073      =2  // PCA0CPL1 Enums (PCA Channel 1 Capture Module Low Byte @ 0xE9)
1074      =2  //------------------------------------------------------------------------------
1075      =2  #define PCA0CPL1_PCA0CPL1__FMASK 0xFF ///< PCA Channel 1 Capture Module Low Byte
1076      =2  #define PCA0CPL1_PCA0CPL1__SHIFT 0x00 ///< PCA Channel 1 Capture Module Low Byte
1077      =2                                                                                  
1078      =2  //------------------------------------------------------------------------------
1079      =2  // PCA0CPM1 Enums (PCA Channel 1 Capture/Compare Mode @ 0xDB)
1080      =2  //------------------------------------------------------------------------------
1081      =2  #define PCA0CPM1_ECCF__BMASK    0x01 ///< Channel 1 Capture/Compare Flag Interrupt Enable
1082      =2  #define PCA0CPM1_ECCF__SHIFT    0x00 ///< Channel 1 Capture/Compare Flag Interrupt Enable
1083      =2  #define PCA0CPM1_ECCF__DISABLED 0x00 ///< Disable CCF1 interrupts.                       
1084      =2  #define PCA0CPM1_ECCF__ENABLED  0x01 ///< Enable a Capture/Compare Flag interrupt request
1085      =2                                       ///< when CCF1 is set.                              
1086      =2                                                                                           
1087      =2  #define PCA0CPM1_PWM__BMASK     0x02 ///< Channel 1 Pulse Width Modulation Mode Enable   
1088      =2  #define PCA0CPM1_PWM__SHIFT     0x01 ///< Channel 1 Pulse Width Modulation Mode Enable   
1089      =2  #define PCA0CPM1_PWM__DISABLED  0x00 ///< Disable PWM function.                          
1090      =2  #define PCA0CPM1_PWM__ENABLED   0x02 ///< Enable PWM function.                           
1091      =2                                                                                           
1092      =2  #define PCA0CPM1_TOG__BMASK     0x04 ///< Channel 1 Toggle Function Enable               
1093      =2  #define PCA0CPM1_TOG__SHIFT     0x02 ///< Channel 1 Toggle Function Enable               
1094      =2  #define PCA0CPM1_TOG__DISABLED  0x00 ///< Disable toggle function.                       
1095      =2  #define PCA0CPM1_TOG__ENABLED   0x04 ///< Enable toggle function.                        
1096      =2                                                                                           
1097      =2  #define PCA0CPM1_MAT__BMASK     0x08 ///< Channel 1 Match Function Enable                
1098      =2  #define PCA0CPM1_MAT__SHIFT     0x03 ///< Channel 1 Match Function Enable                
1099      =2  #define PCA0CPM1_MAT__DISABLED  0x00 ///< Disable match function.                        
1100      =2  #define PCA0CPM1_MAT__ENABLED   0x08 ///< Enable match function.                         
1101      =2                                                                                           
1102      =2  #define PCA0CPM1_CAPN__BMASK    0x10 ///< Channel 1 Capture Negative Function Enable     
1103      =2  #define PCA0CPM1_CAPN__SHIFT    0x04 ///< Channel 1 Capture Negative Function Enable     
1104      =2  #define PCA0CPM1_CAPN__DISABLED 0x00 ///< Disable negative edge capture.                 
1105      =2  #define PCA0CPM1_CAPN__ENABLED  0x10 ///< Enable negative edge capture.                  
1106      =2                                                                                           
1107      =2  #define PCA0CPM1_CAPP__BMASK    0x20 ///< Channel 1 Capture Positive Function Enable     
1108      =2  #define PCA0CPM1_CAPP__SHIFT    0x05 ///< Channel 1 Capture Positive Function Enable     
1109      =2  #define PCA0CPM1_CAPP__DISABLED 0x00 ///< Disable positive edge capture.                 
1110      =2  #define PCA0CPM1_CAPP__ENABLED  0x20 ///< Enable positive edge capture.                  
1111      =2                                                                                           
1112      =2  #define PCA0CPM1_ECOM__BMASK    0x40 ///< Channel 1 Comparator Function Enable           
1113      =2  #define PCA0CPM1_ECOM__SHIFT    0x06 ///< Channel 1 Comparator Function Enable           
1114      =2  #define PCA0CPM1_ECOM__DISABLED 0x00 ///< Disable comparator function.                   
1115      =2  #define PCA0CPM1_ECOM__ENABLED  0x40 ///< Enable comparator function.                    
1116      =2                                                                                           
1117      =2  #define PCA0CPM1_PWM16__BMASK   0x80 ///< Channel 1 16-bit Pulse Width Modulation Enable 
1118      =2  #define PCA0CPM1_PWM16__SHIFT   0x07 ///< Channel 1 16-bit Pulse Width Modulation Enable 
1119      =2  #define PCA0CPM1_PWM16__8_BIT   0x00 ///< 8-bit PWM selected.                            
1120      =2  #define PCA0CPM1_PWM16__16_BIT  0x80 ///< 16-bit PWM selected.                           
1121      =2                                                                                           
1122      =2  //------------------------------------------------------------------------------
1123      =2  // PCA0CPH2 Enums (PCA Channel 2 Capture Module High Byte @ 0xEC)
1124      =2  //------------------------------------------------------------------------------
1125      =2  #define PCA0CPH2_PCA0CPH2__FMASK 0xFF ///< PCA Channel 2 Capture Module High Byte
1126      =2  #define PCA0CPH2_PCA0CPH2__SHIFT 0x00 ///< PCA Channel 2 Capture Module High Byte
1127      =2                                                                                   
C51 COMPILER V9.56.0.0   I2C_0                                                             10/28/2016 17:37:02 PAGE 45  

1128      =2  //------------------------------------------------------------------------------
1129      =2  // PCA0CPL2 Enums (PCA Channel 2 Capture Module Low Byte @ 0xEB)
1130      =2  //------------------------------------------------------------------------------
1131      =2  #define PCA0CPL2_PCA0CPL2__FMASK 0xFF ///< PCA Channel 2 Capture Module Low Byte
1132      =2  #define PCA0CPL2_PCA0CPL2__SHIFT 0x00 ///< PCA Channel 2 Capture Module Low Byte
1133      =2                                                                                  
1134      =2  //------------------------------------------------------------------------------
1135      =2  // PCA0CPM2 Enums (PCA Channel 2 Capture/Compare Mode @ 0xDC)
1136      =2  //------------------------------------------------------------------------------
1137      =2  #define PCA0CPM2_ECCF__BMASK    0x01 ///< Channel 2 Capture/Compare Flag Interrupt Enable
1138      =2  #define PCA0CPM2_ECCF__SHIFT    0x00 ///< Channel 2 Capture/Compare Flag Interrupt Enable
1139      =2  #define PCA0CPM2_ECCF__DISABLED 0x00 ///< Disable CCF2 interrupts.                       
1140      =2  #define PCA0CPM2_ECCF__ENABLED  0x01 ///< Enable a Capture/Compare Flag interrupt request
1141      =2                                       ///< when CCF2 is set.                              
1142      =2                                                                                           
1143      =2  #define PCA0CPM2_PWM__BMASK     0x02 ///< Channel 2 Pulse Width Modulation Mode Enable   
1144      =2  #define PCA0CPM2_PWM__SHIFT     0x01 ///< Channel 2 Pulse Width Modulation Mode Enable   
1145      =2  #define PCA0CPM2_PWM__DISABLED  0x00 ///< Disable PWM function.                          
1146      =2  #define PCA0CPM2_PWM__ENABLED   0x02 ///< Enable PWM function.                           
1147      =2                                                                                           
1148      =2  #define PCA0CPM2_TOG__BMASK     0x04 ///< Channel 2 Toggle Function Enable               
1149      =2  #define PCA0CPM2_TOG__SHIFT     0x02 ///< Channel 2 Toggle Function Enable               
1150      =2  #define PCA0CPM2_TOG__DISABLED  0x00 ///< Disable toggle function.                       
1151      =2  #define PCA0CPM2_TOG__ENABLED   0x04 ///< Enable toggle function.                        
1152      =2                                                                                           
1153      =2  #define PCA0CPM2_MAT__BMASK     0x08 ///< Channel 2 Match Function Enable                
1154      =2  #define PCA0CPM2_MAT__SHIFT     0x03 ///< Channel 2 Match Function Enable                
1155      =2  #define PCA0CPM2_MAT__DISABLED  0x00 ///< Disable match function.                        
1156      =2  #define PCA0CPM2_MAT__ENABLED   0x08 ///< Enable match function.                         
1157      =2                                                                                           
1158      =2  #define PCA0CPM2_CAPN__BMASK    0x10 ///< Channel 2 Capture Negative Function Enable     
1159      =2  #define PCA0CPM2_CAPN__SHIFT    0x04 ///< Channel 2 Capture Negative Function Enable     
1160      =2  #define PCA0CPM2_CAPN__DISABLED 0x00 ///< Disable negative edge capture.                 
1161      =2  #define PCA0CPM2_CAPN__ENABLED  0x10 ///< Enable negative edge capture.                  
1162      =2                                                                                           
1163      =2  #define PCA0CPM2_CAPP__BMASK    0x20 ///< Channel 2 Capture Positive Function Enable     
1164      =2  #define PCA0CPM2_CAPP__SHIFT    0x05 ///< Channel 2 Capture Positive Function Enable     
1165      =2  #define PCA0CPM2_CAPP__DISABLED 0x00 ///< Disable positive edge capture.                 
1166      =2  #define PCA0CPM2_CAPP__ENABLED  0x20 ///< Enable positive edge capture.                  
1167      =2                                                                                           
1168      =2  #define PCA0CPM2_ECOM__BMASK    0x40 ///< Channel 2 Comparator Function Enable           
1169      =2  #define PCA0CPM2_ECOM__SHIFT    0x06 ///< Channel 2 Comparator Function Enable           
1170      =2  #define PCA0CPM2_ECOM__DISABLED 0x00 ///< Disable comparator function.                   
1171      =2  #define PCA0CPM2_ECOM__ENABLED  0x40 ///< Enable comparator function.                    
1172      =2                                                                                           
1173      =2  #define PCA0CPM2_PWM16__BMASK   0x80 ///< Channel 2 16-bit Pulse Width Modulation Enable 
1174      =2  #define PCA0CPM2_PWM16__SHIFT   0x07 ///< Channel 2 16-bit Pulse Width Modulation Enable 
1175      =2  #define PCA0CPM2_PWM16__8_BIT   0x00 ///< 8-bit PWM selected.                            
1176      =2  #define PCA0CPM2_PWM16__16_BIT  0x80 ///< 16-bit PWM selected.                           
1177      =2                                                                                           
1178      =2  //------------------------------------------------------------------------------
1179      =2  // PCA0CPH3 Enums (PCA Channel 3 Capture Module High Byte @ 0xEE)
1180      =2  //------------------------------------------------------------------------------
1181      =2  #define PCA0CPH3_PCA0CPH3__FMASK 0xFF ///< PCA Channel 3 Capture Module High Byte
1182      =2  #define PCA0CPH3_PCA0CPH3__SHIFT 0x00 ///< PCA Channel 3 Capture Module High Byte
1183      =2                                                                                   
1184      =2  //------------------------------------------------------------------------------
1185      =2  // PCA0CPL3 Enums (PCA Channel 3 Capture Module Low Byte @ 0xED)
1186      =2  //------------------------------------------------------------------------------
1187      =2  #define PCA0CPL3_PCA0CPL3__FMASK 0xFF ///< PCA Channel 3 Capture Module Low Byte
1188      =2  #define PCA0CPL3_PCA0CPL3__SHIFT 0x00 ///< PCA Channel 3 Capture Module Low Byte
1189      =2                                                                                  
C51 COMPILER V9.56.0.0   I2C_0                                                             10/28/2016 17:37:02 PAGE 46  

1190      =2  //------------------------------------------------------------------------------
1191      =2  // PCA0CPM3 Enums (PCA Channel 3 Capture/Compare Mode @ 0xDD)
1192      =2  //------------------------------------------------------------------------------
1193      =2  #define PCA0CPM3_ECCF__BMASK    0x01 ///< Channel 3 Capture/Compare Flag Interrupt Enable
1194      =2  #define PCA0CPM3_ECCF__SHIFT    0x00 ///< Channel 3 Capture/Compare Flag Interrupt Enable
1195      =2  #define PCA0CPM3_ECCF__DISABLED 0x00 ///< Disable CCF3 interrupts.                       
1196      =2  #define PCA0CPM3_ECCF__ENABLED  0x01 ///< Enable a Capture/Compare Flag interrupt request
1197      =2                                       ///< when CCF3 is set.                              
1198      =2                                                                                           
1199      =2  #define PCA0CPM3_PWM__BMASK     0x02 ///< Channel 3 Pulse Width Modulation Mode Enable   
1200      =2  #define PCA0CPM3_PWM__SHIFT     0x01 ///< Channel 3 Pulse Width Modulation Mode Enable   
1201      =2  #define PCA0CPM3_PWM__DISABLED  0x00 ///< Disable PWM function.                          
1202      =2  #define PCA0CPM3_PWM__ENABLED   0x02 ///< Enable PWM function.                           
1203      =2                                                                                           
1204      =2  #define PCA0CPM3_TOG__BMASK     0x04 ///< Channel 3 Toggle Function Enable               
1205      =2  #define PCA0CPM3_TOG__SHIFT     0x02 ///< Channel 3 Toggle Function Enable               
1206      =2  #define PCA0CPM3_TOG__DISABLED  0x00 ///< Disable toggle function.                       
1207      =2  #define PCA0CPM3_TOG__ENABLED   0x04 ///< Enable toggle function.                        
1208      =2                                                                                           
1209      =2  #define PCA0CPM3_MAT__BMASK     0x08 ///< Channel 3 Match Function Enable                
1210      =2  #define PCA0CPM3_MAT__SHIFT     0x03 ///< Channel 3 Match Function Enable                
1211      =2  #define PCA0CPM3_MAT__DISABLED  0x00 ///< Disable match function.                        
1212      =2  #define PCA0CPM3_MAT__ENABLED   0x08 ///< Enable match function.                         
1213      =2                                                                                           
1214      =2  #define PCA0CPM3_CAPN__BMASK    0x10 ///< Channel 3 Capture Negative Function Enable     
1215      =2  #define PCA0CPM3_CAPN__SHIFT    0x04 ///< Channel 3 Capture Negative Function Enable     
1216      =2  #define PCA0CPM3_CAPN__DISABLED 0x00 ///< Disable negative edge capture.                 
1217      =2  #define PCA0CPM3_CAPN__ENABLED  0x10 ///< Enable negative edge capture.                  
1218      =2                                                                                           
1219      =2  #define PCA0CPM3_CAPP__BMASK    0x20 ///< Channel 3 Capture Positive Function Enable     
1220      =2  #define PCA0CPM3_CAPP__SHIFT    0x05 ///< Channel 3 Capture Positive Function Enable     
1221      =2  #define PCA0CPM3_CAPP__DISABLED 0x00 ///< Disable positive edge capture.                 
1222      =2  #define PCA0CPM3_CAPP__ENABLED  0x20 ///< Enable positive edge capture.                  
1223      =2                                                                                           
1224      =2  #define PCA0CPM3_ECOM__BMASK    0x40 ///< Channel 3 Comparator Function Enable           
1225      =2  #define PCA0CPM3_ECOM__SHIFT    0x06 ///< Channel 3 Comparator Function Enable           
1226      =2  #define PCA0CPM3_ECOM__DISABLED 0x00 ///< Disable comparator function.                   
1227      =2  #define PCA0CPM3_ECOM__ENABLED  0x40 ///< Enable comparator function.                    
1228      =2                                                                                           
1229      =2  #define PCA0CPM3_PWM16__BMASK   0x80 ///< Channel 3 16-bit Pulse Width Modulation Enable 
1230      =2  #define PCA0CPM3_PWM16__SHIFT   0x07 ///< Channel 3 16-bit Pulse Width Modulation Enable 
1231      =2  #define PCA0CPM3_PWM16__8_BIT   0x00 ///< 8-bit PWM selected.                            
1232      =2  #define PCA0CPM3_PWM16__16_BIT  0x80 ///< 16-bit PWM selected.                           
1233      =2                                                                                           
1234      =2  //------------------------------------------------------------------------------
1235      =2  // PCA0CPH4 Enums (PCA Channel 4 Capture Module High Byte @ 0xFE)
1236      =2  //------------------------------------------------------------------------------
1237      =2  #define PCA0CPH4_PCA0CPH4__FMASK 0xFF ///< PCA Channel 4 Capture Module High Byte
1238      =2  #define PCA0CPH4_PCA0CPH4__SHIFT 0x00 ///< PCA Channel 4 Capture Module High Byte
1239      =2                                                                                   
1240      =2  //------------------------------------------------------------------------------
1241      =2  // PCA0CPL4 Enums (PCA Channel 4 Capture Module Low Byte @ 0xFD)
1242      =2  //------------------------------------------------------------------------------
1243      =2  #define PCA0CPL4_PCA0CPL4__FMASK 0xFF ///< PCA Channel 4 Capture Module Low Byte
1244      =2  #define PCA0CPL4_PCA0CPL4__SHIFT 0x00 ///< PCA Channel 4 Capture Module Low Byte
1245      =2                                                                                  
1246      =2  //------------------------------------------------------------------------------
1247      =2  // PCA0CPM4 Enums (PCA Channel 4 Capture/Compare Mode @ 0xDE)
1248      =2  //------------------------------------------------------------------------------
1249      =2  #define PCA0CPM4_ECCF__BMASK    0x01 ///< Channel 4 Capture/Compare Flag Interrupt Enable
1250      =2  #define PCA0CPM4_ECCF__SHIFT    0x00 ///< Channel 4 Capture/Compare Flag Interrupt Enable
1251      =2  #define PCA0CPM4_ECCF__DISABLED 0x00 ///< Disable CCF4 interrupts.                       
C51 COMPILER V9.56.0.0   I2C_0                                                             10/28/2016 17:37:02 PAGE 47  

1252      =2  #define PCA0CPM4_ECCF__ENABLED  0x01 ///< Enable a Capture/Compare Flag interrupt request
1253      =2                                       ///< when CCF4 is set.                              
1254      =2                                                                                           
1255      =2  #define PCA0CPM4_PWM__BMASK     0x02 ///< Channel 4 Pulse Width Modulation Mode Enable   
1256      =2  #define PCA0CPM4_PWM__SHIFT     0x01 ///< Channel 4 Pulse Width Modulation Mode Enable   
1257      =2  #define PCA0CPM4_PWM__DISABLED  0x00 ///< Disable PWM function.                          
1258      =2  #define PCA0CPM4_PWM__ENABLED   0x02 ///< Enable PWM function.                           
1259      =2                                                                                           
1260      =2  #define PCA0CPM4_TOG__BMASK     0x04 ///< Channel 4 Toggle Function Enable               
1261      =2  #define PCA0CPM4_TOG__SHIFT     0x02 ///< Channel 4 Toggle Function Enable               
1262      =2  #define PCA0CPM4_TOG__DISABLED  0x00 ///< Disable toggle function.                       
1263      =2  #define PCA0CPM4_TOG__ENABLED   0x04 ///< Enable toggle function.                        
1264      =2                                                                                           
1265      =2  #define PCA0CPM4_MAT__BMASK     0x08 ///< Channel 4 Match Function Enable                
1266      =2  #define PCA0CPM4_MAT__SHIFT     0x03 ///< Channel 4 Match Function Enable                
1267      =2  #define PCA0CPM4_MAT__DISABLED  0x00 ///< Disable match function.                        
1268      =2  #define PCA0CPM4_MAT__ENABLED   0x08 ///< Enable match function.                         
1269      =2                                                                                           
1270      =2  #define PCA0CPM4_CAPN__BMASK    0x10 ///< Channel 4 Capture Negative Function Enable     
1271      =2  #define PCA0CPM4_CAPN__SHIFT    0x04 ///< Channel 4 Capture Negative Function Enable     
1272      =2  #define PCA0CPM4_CAPN__DISABLED 0x00 ///< Disable negative edge capture.                 
1273      =2  #define PCA0CPM4_CAPN__ENABLED  0x10 ///< Enable negative edge capture.                  
1274      =2                                                                                           
1275      =2  #define PCA0CPM4_CAPP__BMASK    0x20 ///< Channel 4 Capture Positive Function Enable     
1276      =2  #define PCA0CPM4_CAPP__SHIFT    0x05 ///< Channel 4 Capture Positive Function Enable     
1277      =2  #define PCA0CPM4_CAPP__DISABLED 0x00 ///< Disable positive edge capture.                 
1278      =2  #define PCA0CPM4_CAPP__ENABLED  0x20 ///< Enable positive edge capture.                  
1279      =2                                                                                           
1280      =2  #define PCA0CPM4_ECOM__BMASK    0x40 ///< Channel 4 Comparator Function Enable           
1281      =2  #define PCA0CPM4_ECOM__SHIFT    0x06 ///< Channel 4 Comparator Function Enable           
1282      =2  #define PCA0CPM4_ECOM__DISABLED 0x00 ///< Disable comparator function.                   
1283      =2  #define PCA0CPM4_ECOM__ENABLED  0x40 ///< Enable comparator function.                    
1284      =2                                                                                           
1285      =2  #define PCA0CPM4_PWM16__BMASK   0x80 ///< Channel 4 16-bit Pulse Width Modulation Enable 
1286      =2  #define PCA0CPM4_PWM16__SHIFT   0x07 ///< Channel 4 16-bit Pulse Width Modulation Enable 
1287      =2  #define PCA0CPM4_PWM16__8_BIT   0x00 ///< 8-bit PWM selected.                            
1288      =2  #define PCA0CPM4_PWM16__16_BIT  0x80 ///< 16-bit PWM selected.                           
1289      =2                                                                                           
1290      =2  //------------------------------------------------------------------------------
1291      =2  // PCA0CN0 Enums (PCA Control 0 @ 0xD8)
1292      =2  //------------------------------------------------------------------------------
1293      =2  #define PCA0CN0_CCF0__BMASK   0x01 ///< PCA Module 0 Capture/Compare Flag             
1294      =2  #define PCA0CN0_CCF0__SHIFT   0x00 ///< PCA Module 0 Capture/Compare Flag             
1295      =2  #define PCA0CN0_CCF0__NOT_SET 0x00 ///< A match or capture did not occur on channel 0.
1296      =2  #define PCA0CN0_CCF0__SET     0x01 ///< A match or capture occurred on channel 0.     
1297      =2                                                                                        
1298      =2  #define PCA0CN0_CCF1__BMASK   0x02 ///< PCA Module 1 Capture/Compare Flag             
1299      =2  #define PCA0CN0_CCF1__SHIFT   0x01 ///< PCA Module 1 Capture/Compare Flag             
1300      =2  #define PCA0CN0_CCF1__NOT_SET 0x00 ///< A match or capture did not occur on channel 1.
1301      =2  #define PCA0CN0_CCF1__SET     0x02 ///< A match or capture occurred on channel 1.     
1302      =2                                                                                        
1303      =2  #define PCA0CN0_CCF2__BMASK   0x04 ///< PCA Module 2 Capture/Compare Flag             
1304      =2  #define PCA0CN0_CCF2__SHIFT   0x02 ///< PCA Module 2 Capture/Compare Flag             
1305      =2  #define PCA0CN0_CCF2__NOT_SET 0x00 ///< A match or capture did not occur on channel 2.
1306      =2  #define PCA0CN0_CCF2__SET     0x04 ///< A match or capture occurred on channel 2.     
1307      =2                                                                                        
1308      =2  #define PCA0CN0_CCF3__BMASK   0x08 ///< PCA Module 3 Capture/Compare Flag             
1309      =2  #define PCA0CN0_CCF3__SHIFT   0x03 ///< PCA Module 3 Capture/Compare Flag             
1310      =2  #define PCA0CN0_CCF3__NOT_SET 0x00 ///< A match or capture did not occur on channel 3.
1311      =2  #define PCA0CN0_CCF3__SET     0x08 ///< A match or capture occurred on channel 3.     
1312      =2                                                                                        
1313      =2  #define PCA0CN0_CCF4__BMASK   0x10 ///< PCA Module 4 Capture/Compare Flag             
C51 COMPILER V9.56.0.0   I2C_0                                                             10/28/2016 17:37:02 PAGE 48  

1314      =2  #define PCA0CN0_CCF4__SHIFT   0x04 ///< PCA Module 4 Capture/Compare Flag             
1315      =2  #define PCA0CN0_CCF4__NOT_SET 0x00 ///< A match or capture did not occur on channel 4.
1316      =2  #define PCA0CN0_CCF4__SET     0x10 ///< A match or capture occurred on channel 4.     
1317      =2                                                                                        
1318      =2  #define PCA0CN0_CR__BMASK     0x40 ///< PCA Counter/Timer Run Control                 
1319      =2  #define PCA0CN0_CR__SHIFT     0x06 ///< PCA Counter/Timer Run Control                 
1320      =2  #define PCA0CN0_CR__STOP      0x00 ///< Stop the PCA Counter/Timer.                   
1321      =2  #define PCA0CN0_CR__RUN       0x40 ///< Start the PCA Counter/Timer running.          
1322      =2                                                                                        
1323      =2  #define PCA0CN0_CF__BMASK     0x80 ///< PCA Counter/Timer Overflow Flag               
1324      =2  #define PCA0CN0_CF__SHIFT     0x07 ///< PCA Counter/Timer Overflow Flag               
1325      =2  #define PCA0CN0_CF__NOT_SET   0x00 ///< The PCA counter/timer did not overflow.       
1326      =2  #define PCA0CN0_CF__SET       0x80 ///< The PCA counter/timer overflowed.             
1327      =2                                                                                        
1328      =2  //------------------------------------------------------------------------------
1329      =2  // PCA0H Enums (PCA Counter/Timer High Byte @ 0xFA)
1330      =2  //------------------------------------------------------------------------------
1331      =2  #define PCA0H_PCA0H__FMASK 0xFF ///< PCA Counter/Timer High Byte
1332      =2  #define PCA0H_PCA0H__SHIFT 0x00 ///< PCA Counter/Timer High Byte
1333      =2                                                                  
1334      =2  //------------------------------------------------------------------------------
1335      =2  // PCA0L Enums (PCA Counter/Timer Low Byte @ 0xF9)
1336      =2  //------------------------------------------------------------------------------
1337      =2  #define PCA0L_PCA0L__FMASK 0xFF ///< PCA Counter/Timer Low Byte
1338      =2  #define PCA0L_PCA0L__SHIFT 0x00 ///< PCA Counter/Timer Low Byte
1339      =2                                                                 
1340      =2  //------------------------------------------------------------------------------
1341      =2  // PCA0MD Enums (PCA Mode @ 0xD9)
1342      =2  //------------------------------------------------------------------------------
1343      =2  #define PCA0MD_ECF__BMASK            0x01 ///< PCA Counter/Timer Overflow Interrupt Enable       
1344      =2  #define PCA0MD_ECF__SHIFT            0x00 ///< PCA Counter/Timer Overflow Interrupt Enable       
1345      =2  #define PCA0MD_ECF__OVF_INT_DISABLED 0x00 ///< Disable the CF interrupt.                         
1346      =2  #define PCA0MD_ECF__OVF_INT_ENABLED  0x01 ///< Enable a PCA Counter/Timer Overflow interrupt     
1347      =2                                            ///< request when CF is set.                           
1348      =2                                                                                                   
1349      =2  #define PCA0MD_CPS__FMASK            0x0E ///< PCA Counter/Timer Pulse Select                    
1350      =2  #define PCA0MD_CPS__SHIFT            0x01 ///< PCA Counter/Timer Pulse Select                    
1351      =2  #define PCA0MD_CPS__SYSCLK_DIV_12    0x00 ///< System clock divided by 12.                       
1352      =2  #define PCA0MD_CPS__SYSCLK_DIV_4     0x02 ///< System clock divided by 4.                        
1353      =2  #define PCA0MD_CPS__T0_OVERFLOW      0x04 ///< Timer 0 overflow.                                 
1354      =2  #define PCA0MD_CPS__ECI              0x06 ///< High-to-low transitions on ECI (max rate = system 
1355      =2                                            ///< clock divided by 4).                              
1356      =2  #define PCA0MD_CPS__SYSCLK           0x08 ///< System clock.                                     
1357      =2  #define PCA0MD_CPS__EXTOSC_DIV_8     0x0A ///< External clock divided by 8 (synchronized with the
1358      =2                                            ///< system clock).                                    
1359      =2                                                                                                   
1360      =2  #define PCA0MD_WDLCK__BMASK          0x20 ///< Watchdog Timer Lock                               
1361      =2  #define PCA0MD_WDLCK__SHIFT          0x05 ///< Watchdog Timer Lock                               
1362      =2  #define PCA0MD_WDLCK__UNLOCKED       0x00 ///< Watchdog Timer Enable unlocked.                   
1363      =2  #define PCA0MD_WDLCK__LOCKED         0x20 ///< Watchdog Timer Enable locked.                     
1364      =2                                                                                                   
1365      =2  #define PCA0MD_WDTE__BMASK           0x40 ///< Watchdog Timer Enable                             
1366      =2  #define PCA0MD_WDTE__SHIFT           0x06 ///< Watchdog Timer Enable                             
1367      =2  #define PCA0MD_WDTE__DISABLED        0x00 ///< Disable Watchdog Timer.                           
1368      =2  #define PCA0MD_WDTE__ENABLED         0x40 ///< Enable PCA Module 4 as the Watchdog Timer.        
1369      =2                                                                                                   
1370      =2  #define PCA0MD_CIDL__BMASK           0x80 ///< PCA Counter/Timer Idle Control                    
1371      =2  #define PCA0MD_CIDL__SHIFT           0x07 ///< PCA Counter/Timer Idle Control                    
1372      =2  #define PCA0MD_CIDL__NORMAL          0x00 ///< PCA continues to function normally while the      
1373      =2                                            ///< system controller is in Idle Mode.                
1374      =2  #define PCA0MD_CIDL__SUSPEND         0x80 ///< PCA operation is suspended while the system       
1375      =2                                            ///< controller is in Idle Mode.                       
C51 COMPILER V9.56.0.0   I2C_0                                                             10/28/2016 17:37:02 PAGE 49  

1376      =2                                                                                                   
1377      =2  //------------------------------------------------------------------------------
1378      =2  // PCON0 Enums (Power Control @ 0x87)
1379      =2  //------------------------------------------------------------------------------
1380      =2  #define PCON0_IDLE__BMASK  0x01 ///< Idle Mode Select                                
1381      =2  #define PCON0_IDLE__SHIFT  0x00 ///< Idle Mode Select                                
1382      =2  #define PCON0_IDLE__NORMAL 0x00 ///< Idle mode not activated.                        
1383      =2  #define PCON0_IDLE__IDLE   0x01 ///< CPU goes into Idle mode (shuts off clock to CPU,
1384      =2                                  ///< but clocks to enabled peripherals are still     
1385      =2                                  ///< active).                                        
1386      =2                                                                                       
1387      =2  #define PCON0_STOP__BMASK  0x02 ///< Stop Mode Select                                
1388      =2  #define PCON0_STOP__SHIFT  0x01 ///< Stop Mode Select                                
1389      =2  #define PCON0_STOP__NORMAL 0x00 ///< Stop mode not activated.                        
1390      =2  #define PCON0_STOP__STOP   0x02 ///< CPU goes into Stop mode (internal oscillator    
1391      =2                                  ///< stopped).                                       
1392      =2                                                                                       
1393      =2  #define PCON0_GF0__BMASK   0x04 ///< General Purpose Flag 0                          
1394      =2  #define PCON0_GF0__SHIFT   0x02 ///< General Purpose Flag 0                          
1395      =2  #define PCON0_GF0__NOT_SET 0x00 ///< The GF0 flag is not set. Clear the GF0 flag.    
1396      =2  #define PCON0_GF0__SET     0x04 ///< The GF0 flag is set. Set the GF0 flag.          
1397      =2                                                                                       
1398      =2  #define PCON0_GF1__BMASK   0x08 ///< General Purpose Flag 1                          
1399      =2  #define PCON0_GF1__SHIFT   0x03 ///< General Purpose Flag 1                          
1400      =2  #define PCON0_GF1__NOT_SET 0x00 ///< The GF1 flag is not set. Clear the GF1 flag.    
1401      =2  #define PCON0_GF1__SET     0x08 ///< The GF1 flag is set. Set the GF1 flag.          
1402      =2                                                                                       
1403      =2  #define PCON0_GF2__BMASK   0x10 ///< General Purpose Flag 2                          
1404      =2  #define PCON0_GF2__SHIFT   0x04 ///< General Purpose Flag 2                          
1405      =2  #define PCON0_GF2__NOT_SET 0x00 ///< The GF2 flag is not set. Clear the GF2 flag.    
1406      =2  #define PCON0_GF2__SET     0x10 ///< The GF2 flag is set. Set the GF2 flag.          
1407      =2                                                                                       
1408      =2  #define PCON0_GF3__BMASK   0x20 ///< General Purpose Flag 3                          
1409      =2  #define PCON0_GF3__SHIFT   0x05 ///< General Purpose Flag 3                          
1410      =2  #define PCON0_GF3__NOT_SET 0x00 ///< The GF3 flag is not set. Clear the GF3 flag.    
1411      =2  #define PCON0_GF3__SET     0x20 ///< The GF3 flag is set. Set the GF3 flag.          
1412      =2                                                                                       
1413      =2  #define PCON0_GF4__BMASK   0x40 ///< General Purpose Flag 4                          
1414      =2  #define PCON0_GF4__SHIFT   0x06 ///< General Purpose Flag 4                          
1415      =2  #define PCON0_GF4__NOT_SET 0x00 ///< The GF4 flag is not set. Clear the GF4 flag.    
1416      =2  #define PCON0_GF4__SET     0x40 ///< The GF4 flag is set. Set the GF4 flag.          
1417      =2                                                                                       
1418      =2  #define PCON0_GF5__BMASK   0x80 ///< General Purpose Flag 5                          
1419      =2  #define PCON0_GF5__SHIFT   0x07 ///< General Purpose Flag 5                          
1420      =2  #define PCON0_GF5__NOT_SET 0x00 ///< The GF5 flag is not set. Clear the GF5 flag.    
1421      =2  #define PCON0_GF5__SET     0x80 ///< The GF5 flag is set. Set the GF5 flag.          
1422      =2                                                                                       
1423      =2  //------------------------------------------------------------------------------
1424      =2  // P0 Enums (Port 0 Pin Latch @ 0x80)
1425      =2  //------------------------------------------------------------------------------
1426      =2  #define P0_B0__BMASK 0x01 ///< Port 0 Bit 0 Latch                            
1427      =2  #define P0_B0__SHIFT 0x00 ///< Port 0 Bit 0 Latch                            
1428      =2  #define P0_B0__LOW   0x00 ///< P0.0 is low. Set P0.0 to drive low.           
1429      =2  #define P0_B0__HIGH  0x01 ///< P0.0 is high. Set P0.0 to drive or float high.
1430      =2                                                                               
1431      =2  #define P0_B1__BMASK 0x02 ///< Port 0 Bit 1 Latch                            
1432      =2  #define P0_B1__SHIFT 0x01 ///< Port 0 Bit 1 Latch                            
1433      =2  #define P0_B1__LOW   0x00 ///< P0.1 is low. Set P0.1 to drive low.           
1434      =2  #define P0_B1__HIGH  0x02 ///< P0.1 is high. Set P0.1 to drive or float high.
1435      =2                                                                               
1436      =2  #define P0_B2__BMASK 0x04 ///< Port 0 Bit 2 Latch                            
1437      =2  #define P0_B2__SHIFT 0x02 ///< Port 0 Bit 2 Latch                            
C51 COMPILER V9.56.0.0   I2C_0                                                             10/28/2016 17:37:02 PAGE 50  

1438      =2  #define P0_B2__LOW   0x00 ///< P0.2 is low. Set P0.2 to drive low.           
1439      =2  #define P0_B2__HIGH  0x04 ///< P0.2 is high. Set P0.2 to drive or float high.
1440      =2                                                                               
1441      =2  #define P0_B3__BMASK 0x08 ///< Port 0 Bit 3 Latch                            
1442      =2  #define P0_B3__SHIFT 0x03 ///< Port 0 Bit 3 Latch                            
1443      =2  #define P0_B3__LOW   0x00 ///< P0.3 is low. Set P0.3 to drive low.           
1444      =2  #define P0_B3__HIGH  0x08 ///< P0.3 is high. Set P0.3 to drive or float high.
1445      =2                                                                               
1446      =2  #define P0_B4__BMASK 0x10 ///< Port 0 Bit 4 Latch                            
1447      =2  #define P0_B4__SHIFT 0x04 ///< Port 0 Bit 4 Latch                            
1448      =2  #define P0_B4__LOW   0x00 ///< P0.4 is low. Set P0.4 to drive low.           
1449      =2  #define P0_B4__HIGH  0x10 ///< P0.4 is high. Set P0.4 to drive or float high.
1450      =2                                                                               
1451      =2  #define P0_B5__BMASK 0x20 ///< Port 0 Bit 5 Latch                            
1452      =2  #define P0_B5__SHIFT 0x05 ///< Port 0 Bit 5 Latch                            
1453      =2  #define P0_B5__LOW   0x00 ///< P0.5 is low. Set P0.5 to drive low.           
1454      =2  #define P0_B5__HIGH  0x20 ///< P0.5 is high. Set P0.5 to drive or float high.
1455      =2                                                                               
1456      =2  #define P0_B6__BMASK 0x40 ///< Port 0 Bit 6 Latch                            
1457      =2  #define P0_B6__SHIFT 0x06 ///< Port 0 Bit 6 Latch                            
1458      =2  #define P0_B6__LOW   0x00 ///< P0.6 is low. Set P0.6 to drive low.           
1459      =2  #define P0_B6__HIGH  0x40 ///< P0.6 is high. Set P0.6 to drive or float high.
1460      =2                                                                               
1461      =2  #define P0_B7__BMASK 0x80 ///< Port 0 Bit 7 Latch                            
1462      =2  #define P0_B7__SHIFT 0x07 ///< Port 0 Bit 7 Latch                            
1463      =2  #define P0_B7__LOW   0x00 ///< P0.7 is low. Set P0.7 to drive low.           
1464      =2  #define P0_B7__HIGH  0x80 ///< P0.7 is high. Set P0.7 to drive or float high.
1465      =2                                                                               
1466      =2  //------------------------------------------------------------------------------
1467      =2  // P0MDIN Enums (Port 0 Input Mode @ 0xF1)
1468      =2  //------------------------------------------------------------------------------
1469      =2  #define P0MDIN_B0__BMASK   0x01 ///< Port 0 Bit 0 Input Mode                 
1470      =2  #define P0MDIN_B0__SHIFT   0x00 ///< Port 0 Bit 0 Input Mode                 
1471      =2  #define P0MDIN_B0__ANALOG  0x00 ///< P0.0 pin is configured for analog mode. 
1472      =2  #define P0MDIN_B0__DIGITAL 0x01 ///< P0.0 pin is configured for digital mode.
1473      =2                                                                               
1474      =2  #define P0MDIN_B1__BMASK   0x02 ///< Port 0 Bit 1 Input Mode                 
1475      =2  #define P0MDIN_B1__SHIFT   0x01 ///< Port 0 Bit 1 Input Mode                 
1476      =2  #define P0MDIN_B1__ANALOG  0x00 ///< P0.1 pin is configured for analog mode. 
1477      =2  #define P0MDIN_B1__DIGITAL 0x02 ///< P0.1 pin is configured for digital mode.
1478      =2                                                                               
1479      =2  #define P0MDIN_B2__BMASK   0x04 ///< Port 0 Bit 2 Input Mode                 
1480      =2  #define P0MDIN_B2__SHIFT   0x02 ///< Port 0 Bit 2 Input Mode                 
1481      =2  #define P0MDIN_B2__ANALOG  0x00 ///< P0.2 pin is configured for analog mode. 
1482      =2  #define P0MDIN_B2__DIGITAL 0x04 ///< P0.2 pin is configured for digital mode.
1483      =2                                                                               
1484      =2  #define P0MDIN_B3__BMASK   0x08 ///< Port 0 Bit 3 Input Mode                 
1485      =2  #define P0MDIN_B3__SHIFT   0x03 ///< Port 0 Bit 3 Input Mode                 
1486      =2  #define P0MDIN_B3__ANALOG  0x00 ///< P0.3 pin is configured for analog mode. 
1487      =2  #define P0MDIN_B3__DIGITAL 0x08 ///< P0.3 pin is configured for digital mode.
1488      =2                                                                               
1489      =2  #define P0MDIN_B4__BMASK   0x10 ///< Port 0 Bit 4 Input Mode                 
1490      =2  #define P0MDIN_B4__SHIFT   0x04 ///< Port 0 Bit 4 Input Mode                 
1491      =2  #define P0MDIN_B4__ANALOG  0x00 ///< P0.4 pin is configured for analog mode. 
1492      =2  #define P0MDIN_B4__DIGITAL 0x10 ///< P0.4 pin is configured for digital mode.
1493      =2                                                                               
1494      =2  #define P0MDIN_B5__BMASK   0x20 ///< Port 0 Bit 5 Input Mode                 
1495      =2  #define P0MDIN_B5__SHIFT   0x05 ///< Port 0 Bit 5 Input Mode                 
1496      =2  #define P0MDIN_B5__ANALOG  0x00 ///< P0.5 pin is configured for analog mode. 
1497      =2  #define P0MDIN_B5__DIGITAL 0x20 ///< P0.5 pin is configured for digital mode.
1498      =2                                                                               
1499      =2  #define P0MDIN_B6__BMASK   0x40 ///< Port 0 Bit 6 Input Mode                 
C51 COMPILER V9.56.0.0   I2C_0                                                             10/28/2016 17:37:02 PAGE 51  

1500      =2  #define P0MDIN_B6__SHIFT   0x06 ///< Port 0 Bit 6 Input Mode                 
1501      =2  #define P0MDIN_B6__ANALOG  0x00 ///< P0.6 pin is configured for analog mode. 
1502      =2  #define P0MDIN_B6__DIGITAL 0x40 ///< P0.6 pin is configured for digital mode.
1503      =2                                                                               
1504      =2  #define P0MDIN_B7__BMASK   0x80 ///< Port 0 Bit 7 Input Mode                 
1505      =2  #define P0MDIN_B7__SHIFT   0x07 ///< Port 0 Bit 7 Input Mode                 
1506      =2  #define P0MDIN_B7__ANALOG  0x00 ///< P0.7 pin is configured for analog mode. 
1507      =2  #define P0MDIN_B7__DIGITAL 0x80 ///< P0.7 pin is configured for digital mode.
1508      =2                                                                               
1509      =2  //------------------------------------------------------------------------------
1510      =2  // P0MDOUT Enums (Port 0 Output Mode @ 0xA4)
1511      =2  //------------------------------------------------------------------------------
1512      =2  #define P0MDOUT_B0__BMASK      0x01 ///< Port 0 Bit 0 Output Mode  
1513      =2  #define P0MDOUT_B0__SHIFT      0x00 ///< Port 0 Bit 0 Output Mode  
1514      =2  #define P0MDOUT_B0__OPEN_DRAIN 0x00 ///< P0.0 output is open-drain.
1515      =2  #define P0MDOUT_B0__PUSH_PULL  0x01 ///< P0.0 output is push-pull. 
1516      =2                                                                     
1517      =2  #define P0MDOUT_B1__BMASK      0x02 ///< Port 0 Bit 1 Output Mode  
1518      =2  #define P0MDOUT_B1__SHIFT      0x01 ///< Port 0 Bit 1 Output Mode  
1519      =2  #define P0MDOUT_B1__OPEN_DRAIN 0x00 ///< P0.1 output is open-drain.
1520      =2  #define P0MDOUT_B1__PUSH_PULL  0x02 ///< P0.1 output is push-pull. 
1521      =2                                                                     
1522      =2  #define P0MDOUT_B2__BMASK      0x04 ///< Port 0 Bit 2 Output Mode  
1523      =2  #define P0MDOUT_B2__SHIFT      0x02 ///< Port 0 Bit 2 Output Mode  
1524      =2  #define P0MDOUT_B2__OPEN_DRAIN 0x00 ///< P0.2 output is open-drain.
1525      =2  #define P0MDOUT_B2__PUSH_PULL  0x04 ///< P0.2 output is push-pull. 
1526      =2                                                                     
1527      =2  #define P0MDOUT_B3__BMASK      0x08 ///< Port 0 Bit 3 Output Mode  
1528      =2  #define P0MDOUT_B3__SHIFT      0x03 ///< Port 0 Bit 3 Output Mode  
1529      =2  #define P0MDOUT_B3__OPEN_DRAIN 0x00 ///< P0.3 output is open-drain.
1530      =2  #define P0MDOUT_B3__PUSH_PULL  0x08 ///< P0.3 output is push-pull. 
1531      =2                                                                     
1532      =2  #define P0MDOUT_B4__BMASK      0x10 ///< Port 0 Bit 4 Output Mode  
1533      =2  #define P0MDOUT_B4__SHIFT      0x04 ///< Port 0 Bit 4 Output Mode  
1534      =2  #define P0MDOUT_B4__OPEN_DRAIN 0x00 ///< P0.4 output is open-drain.
1535      =2  #define P0MDOUT_B4__PUSH_PULL  0x10 ///< P0.4 output is push-pull. 
1536      =2                                                                     
1537      =2  #define P0MDOUT_B5__BMASK      0x20 ///< Port 0 Bit 5 Output Mode  
1538      =2  #define P0MDOUT_B5__SHIFT      0x05 ///< Port 0 Bit 5 Output Mode  
1539      =2  #define P0MDOUT_B5__OPEN_DRAIN 0x00 ///< P0.5 output is open-drain.
1540      =2  #define P0MDOUT_B5__PUSH_PULL  0x20 ///< P0.5 output is push-pull. 
1541      =2                                                                     
1542      =2  #define P0MDOUT_B6__BMASK      0x40 ///< Port 0 Bit 6 Output Mode  
1543      =2  #define P0MDOUT_B6__SHIFT      0x06 ///< Port 0 Bit 6 Output Mode  
1544      =2  #define P0MDOUT_B6__OPEN_DRAIN 0x00 ///< P0.6 output is open-drain.
1545      =2  #define P0MDOUT_B6__PUSH_PULL  0x40 ///< P0.6 output is push-pull. 
1546      =2                                                                     
1547      =2  #define P0MDOUT_B7__BMASK      0x80 ///< Port 0 Bit 7 Output Mode  
1548      =2  #define P0MDOUT_B7__SHIFT      0x07 ///< Port 0 Bit 7 Output Mode  
1549      =2  #define P0MDOUT_B7__OPEN_DRAIN 0x00 ///< P0.7 output is open-drain.
1550      =2  #define P0MDOUT_B7__PUSH_PULL  0x80 ///< P0.7 output is push-pull. 
1551      =2                                                                     
1552      =2  //------------------------------------------------------------------------------
1553      =2  // P0SKIP Enums (Port 0 Skip @ 0xD4)
1554      =2  //------------------------------------------------------------------------------
1555      =2  #define P0SKIP_B0__BMASK       0x01 ///< Port 0 Bit 0 Skip                       
1556      =2  #define P0SKIP_B0__SHIFT       0x00 ///< Port 0 Bit 0 Skip                       
1557      =2  #define P0SKIP_B0__NOT_SKIPPED 0x00 ///< P0.0 pin is not skipped by the crossbar.
1558      =2  #define P0SKIP_B0__SKIPPED     0x01 ///< P0.0 pin is skipped by the crossbar.    
1559      =2                                                                                   
1560      =2  #define P0SKIP_B1__BMASK       0x02 ///< Port 0 Bit 1 Skip                       
1561      =2  #define P0SKIP_B1__SHIFT       0x01 ///< Port 0 Bit 1 Skip                       
C51 COMPILER V9.56.0.0   I2C_0                                                             10/28/2016 17:37:02 PAGE 52  

1562      =2  #define P0SKIP_B1__NOT_SKIPPED 0x00 ///< P0.1 pin is not skipped by the crossbar.
1563      =2  #define P0SKIP_B1__SKIPPED     0x02 ///< P0.1 pin is skipped by the crossbar.    
1564      =2                                                                                   
1565      =2  #define P0SKIP_B2__BMASK       0x04 ///< Port 0 Bit 2 Skip                       
1566      =2  #define P0SKIP_B2__SHIFT       0x02 ///< Port 0 Bit 2 Skip                       
1567      =2  #define P0SKIP_B2__NOT_SKIPPED 0x00 ///< P0.2 pin is not skipped by the crossbar.
1568      =2  #define P0SKIP_B2__SKIPPED     0x04 ///< P0.2 pin is skipped by the crossbar.    
1569      =2                                                                                   
1570      =2  #define P0SKIP_B3__BMASK       0x08 ///< Port 0 Bit 3 Skip                       
1571      =2  #define P0SKIP_B3__SHIFT       0x03 ///< Port 0 Bit 3 Skip                       
1572      =2  #define P0SKIP_B3__NOT_SKIPPED 0x00 ///< P0.3 pin is not skipped by the crossbar.
1573      =2  #define P0SKIP_B3__SKIPPED     0x08 ///< P0.3 pin is skipped by the crossbar.    
1574      =2                                                                                   
1575      =2  #define P0SKIP_B4__BMASK       0x10 ///< Port 0 Bit 4 Skip                       
1576      =2  #define P0SKIP_B4__SHIFT       0x04 ///< Port 0 Bit 4 Skip                       
1577      =2  #define P0SKIP_B4__NOT_SKIPPED 0x00 ///< P0.4 pin is not skipped by the crossbar.
1578      =2  #define P0SKIP_B4__SKIPPED     0x10 ///< P0.4 pin is skipped by the crossbar.    
1579      =2                                                                                   
1580      =2  #define P0SKIP_B5__BMASK       0x20 ///< Port 0 Bit 5 Skip                       
1581      =2  #define P0SKIP_B5__SHIFT       0x05 ///< Port 0 Bit 5 Skip                       
1582      =2  #define P0SKIP_B5__NOT_SKIPPED 0x00 ///< P0.5 pin is not skipped by the crossbar.
1583      =2  #define P0SKIP_B5__SKIPPED     0x20 ///< P0.5 pin is skipped by the crossbar.    
1584      =2                                                                                   
1585      =2  #define P0SKIP_B6__BMASK       0x40 ///< Port 0 Bit 6 Skip                       
1586      =2  #define P0SKIP_B6__SHIFT       0x06 ///< Port 0 Bit 6 Skip                       
1587      =2  #define P0SKIP_B6__NOT_SKIPPED 0x00 ///< P0.6 pin is not skipped by the crossbar.
1588      =2  #define P0SKIP_B6__SKIPPED     0x40 ///< P0.6 pin is skipped by the crossbar.    
1589      =2                                                                                   
1590      =2  #define P0SKIP_B7__BMASK       0x80 ///< Port 0 Bit 7 Skip                       
1591      =2  #define P0SKIP_B7__SHIFT       0x07 ///< Port 0 Bit 7 Skip                       
1592      =2  #define P0SKIP_B7__NOT_SKIPPED 0x00 ///< P0.7 pin is not skipped by the crossbar.
1593      =2  #define P0SKIP_B7__SKIPPED     0x80 ///< P0.7 pin is skipped by the crossbar.    
1594      =2                                                                                   
1595      =2  //------------------------------------------------------------------------------
1596      =2  // P1 Enums (Port 1 Pin Latch @ 0x90)
1597      =2  //------------------------------------------------------------------------------
1598      =2  #define P1_B0__BMASK 0x01 ///< Port 1 Bit 0 Latch                            
1599      =2  #define P1_B0__SHIFT 0x00 ///< Port 1 Bit 0 Latch                            
1600      =2  #define P1_B0__LOW   0x00 ///< P1.0 is low. Set P1.0 to drive low.           
1601      =2  #define P1_B0__HIGH  0x01 ///< P1.0 is high. Set P1.0 to drive or float high.
1602      =2                                                                               
1603      =2  #define P1_B1__BMASK 0x02 ///< Port 1 Bit 1 Latch                            
1604      =2  #define P1_B1__SHIFT 0x01 ///< Port 1 Bit 1 Latch                            
1605      =2  #define P1_B1__LOW   0x00 ///< P1.1 is low. Set P1.1 to drive low.           
1606      =2  #define P1_B1__HIGH  0x02 ///< P1.1 is high. Set P1.1 to drive or float high.
1607      =2                                                                               
1608      =2  #define P1_B2__BMASK 0x04 ///< Port 1 Bit 2 Latch                            
1609      =2  #define P1_B2__SHIFT 0x02 ///< Port 1 Bit 2 Latch                            
1610      =2  #define P1_B2__LOW   0x00 ///< P1.2 is low. Set P1.2 to drive low.           
1611      =2  #define P1_B2__HIGH  0x04 ///< P1.2 is high. Set P1.2 to drive or float high.
1612      =2                                                                               
1613      =2  #define P1_B3__BMASK 0x08 ///< Port 1 Bit 3 Latch                            
1614      =2  #define P1_B3__SHIFT 0x03 ///< Port 1 Bit 3 Latch                            
1615      =2  #define P1_B3__LOW   0x00 ///< P1.3 is low. Set P1.3 to drive low.           
1616      =2  #define P1_B3__HIGH  0x08 ///< P1.3 is high. Set P1.3 to drive or float high.
1617      =2                                                                               
1618      =2  #define P1_B4__BMASK 0x10 ///< Port 1 Bit 4 Latch                            
1619      =2  #define P1_B4__SHIFT 0x04 ///< Port 1 Bit 4 Latch                            
1620      =2  #define P1_B4__LOW   0x00 ///< P1.4 is low. Set P1.4 to drive low.           
1621      =2  #define P1_B4__HIGH  0x10 ///< P1.4 is high. Set P1.4 to drive or float high.
1622      =2                                                                               
1623      =2  #define P1_B5__BMASK 0x20 ///< Port 1 Bit 5 Latch                            
C51 COMPILER V9.56.0.0   I2C_0                                                             10/28/2016 17:37:02 PAGE 53  

1624      =2  #define P1_B5__SHIFT 0x05 ///< Port 1 Bit 5 Latch                            
1625      =2  #define P1_B5__LOW   0x00 ///< P1.5 is low. Set P1.5 to drive low.           
1626      =2  #define P1_B5__HIGH  0x20 ///< P1.5 is high. Set P1.5 to drive or float high.
1627      =2                                                                               
1628      =2  #define P1_B6__BMASK 0x40 ///< Port 1 Bit 6 Latch                            
1629      =2  #define P1_B6__SHIFT 0x06 ///< Port 1 Bit 6 Latch                            
1630      =2  #define P1_B6__LOW   0x00 ///< P1.6 is low. Set P1.6 to drive low.           
1631      =2  #define P1_B6__HIGH  0x40 ///< P1.6 is high. Set P1.6 to drive or float high.
1632      =2                                                                               
1633      =2  #define P1_B7__BMASK 0x80 ///< Port 1 Bit 7 Latch                            
1634      =2  #define P1_B7__SHIFT 0x07 ///< Port 1 Bit 7 Latch                            
1635      =2  #define P1_B7__LOW   0x00 ///< P1.7 is low. Set P1.7 to drive low.           
1636      =2  #define P1_B7__HIGH  0x80 ///< P1.7 is high. Set P1.7 to drive or float high.
1637      =2                                                                               
1638      =2  //------------------------------------------------------------------------------
1639      =2  // P1MDIN Enums (Port 1 Input Mode @ 0xF2)
1640      =2  //------------------------------------------------------------------------------
1641      =2  #define P1MDIN_B0__BMASK   0x01 ///< Port 1 Bit 0 Input Mode                 
1642      =2  #define P1MDIN_B0__SHIFT   0x00 ///< Port 1 Bit 0 Input Mode                 
1643      =2  #define P1MDIN_B0__ANALOG  0x00 ///< P1.0 pin is configured for analog mode. 
1644      =2  #define P1MDIN_B0__DIGITAL 0x01 ///< P1.0 pin is configured for digital mode.
1645      =2                                                                               
1646      =2  #define P1MDIN_B1__BMASK   0x02 ///< Port 1 Bit 1 Input Mode                 
1647      =2  #define P1MDIN_B1__SHIFT   0x01 ///< Port 1 Bit 1 Input Mode                 
1648      =2  #define P1MDIN_B1__ANALOG  0x00 ///< P1.1 pin is configured for analog mode. 
1649      =2  #define P1MDIN_B1__DIGITAL 0x02 ///< P1.1 pin is configured for digital mode.
1650      =2                                                                               
1651      =2  #define P1MDIN_B2__BMASK   0x04 ///< Port 1 Bit 2 Input Mode                 
1652      =2  #define P1MDIN_B2__SHIFT   0x02 ///< Port 1 Bit 2 Input Mode                 
1653      =2  #define P1MDIN_B2__ANALOG  0x00 ///< P1.2 pin is configured for analog mode. 
1654      =2  #define P1MDIN_B2__DIGITAL 0x04 ///< P1.2 pin is configured for digital mode.
1655      =2                                                                               
1656      =2  #define P1MDIN_B3__BMASK   0x08 ///< Port 1 Bit 3 Input Mode                 
1657      =2  #define P1MDIN_B3__SHIFT   0x03 ///< Port 1 Bit 3 Input Mode                 
1658      =2  #define P1MDIN_B3__ANALOG  0x00 ///< P1.3 pin is configured for analog mode. 
1659      =2  #define P1MDIN_B3__DIGITAL 0x08 ///< P1.3 pin is configured for digital mode.
1660      =2                                                                               
1661      =2  #define P1MDIN_B4__BMASK   0x10 ///< Port 1 Bit 4 Input Mode                 
1662      =2  #define P1MDIN_B4__SHIFT   0x04 ///< Port 1 Bit 4 Input Mode                 
1663      =2  #define P1MDIN_B4__ANALOG  0x00 ///< P1.4 pin is configured for analog mode. 
1664      =2  #define P1MDIN_B4__DIGITAL 0x10 ///< P1.4 pin is configured for digital mode.
1665      =2                                                                               
1666      =2  #define P1MDIN_B5__BMASK   0x20 ///< Port 1 Bit 5 Input Mode                 
1667      =2  #define P1MDIN_B5__SHIFT   0x05 ///< Port 1 Bit 5 Input Mode                 
1668      =2  #define P1MDIN_B5__ANALOG  0x00 ///< P1.5 pin is configured for analog mode. 
1669      =2  #define P1MDIN_B5__DIGITAL 0x20 ///< P1.5 pin is configured for digital mode.
1670      =2                                                                               
1671      =2  #define P1MDIN_B6__BMASK   0x40 ///< Port 1 Bit 6 Input Mode                 
1672      =2  #define P1MDIN_B6__SHIFT   0x06 ///< Port 1 Bit 6 Input Mode                 
1673      =2  #define P1MDIN_B6__ANALOG  0x00 ///< P1.6 pin is configured for analog mode. 
1674      =2  #define P1MDIN_B6__DIGITAL 0x40 ///< P1.6 pin is configured for digital mode.
1675      =2                                                                               
1676      =2  #define P1MDIN_B7__BMASK   0x80 ///< Port 1 Bit 7 Input Mode                 
1677      =2  #define P1MDIN_B7__SHIFT   0x07 ///< Port 1 Bit 7 Input Mode                 
1678      =2  #define P1MDIN_B7__ANALOG  0x00 ///< P1.7 pin is configured for analog mode. 
1679      =2  #define P1MDIN_B7__DIGITAL 0x80 ///< P1.7 pin is configured for digital mode.
1680      =2                                                                               
1681      =2  //------------------------------------------------------------------------------
1682      =2  // P1MDOUT Enums (Port 1 Output Mode @ 0xA5)
1683      =2  //------------------------------------------------------------------------------
1684      =2  #define P1MDOUT_B0__BMASK      0x01 ///< Port 1 Bit 0 Output Mode  
1685      =2  #define P1MDOUT_B0__SHIFT      0x00 ///< Port 1 Bit 0 Output Mode  
C51 COMPILER V9.56.0.0   I2C_0                                                             10/28/2016 17:37:02 PAGE 54  

1686      =2  #define P1MDOUT_B0__OPEN_DRAIN 0x00 ///< P1.0 output is open-drain.
1687      =2  #define P1MDOUT_B0__PUSH_PULL  0x01 ///< P1.0 output is push-pull. 
1688      =2                                                                     
1689      =2  #define P1MDOUT_B1__BMASK      0x02 ///< Port 1 Bit 1 Output Mode  
1690      =2  #define P1MDOUT_B1__SHIFT      0x01 ///< Port 1 Bit 1 Output Mode  
1691      =2  #define P1MDOUT_B1__OPEN_DRAIN 0x00 ///< P1.1 output is open-drain.
1692      =2  #define P1MDOUT_B1__PUSH_PULL  0x02 ///< P1.1 output is push-pull. 
1693      =2                                                                     
1694      =2  #define P1MDOUT_B2__BMASK      0x04 ///< Port 1 Bit 2 Output Mode  
1695      =2  #define P1MDOUT_B2__SHIFT      0x02 ///< Port 1 Bit 2 Output Mode  
1696      =2  #define P1MDOUT_B2__OPEN_DRAIN 0x00 ///< P1.2 output is open-drain.
1697      =2  #define P1MDOUT_B2__PUSH_PULL  0x04 ///< P1.2 output is push-pull. 
1698      =2                                                                     
1699      =2  #define P1MDOUT_B3__BMASK      0x08 ///< Port 1 Bit 3 Output Mode  
1700      =2  #define P1MDOUT_B3__SHIFT      0x03 ///< Port 1 Bit 3 Output Mode  
1701      =2  #define P1MDOUT_B3__OPEN_DRAIN 0x00 ///< P1.3 output is open-drain.
1702      =2  #define P1MDOUT_B3__PUSH_PULL  0x08 ///< P1.3 output is push-pull. 
1703      =2                                                                     
1704      =2  #define P1MDOUT_B4__BMASK      0x10 ///< Port 1 Bit 4 Output Mode  
1705      =2  #define P1MDOUT_B4__SHIFT      0x04 ///< Port 1 Bit 4 Output Mode  
1706      =2  #define P1MDOUT_B4__OPEN_DRAIN 0x00 ///< P1.4 output is open-drain.
1707      =2  #define P1MDOUT_B4__PUSH_PULL  0x10 ///< P1.4 output is push-pull. 
1708      =2                                                                     
1709      =2  #define P1MDOUT_B5__BMASK      0x20 ///< Port 1 Bit 5 Output Mode  
1710      =2  #define P1MDOUT_B5__SHIFT      0x05 ///< Port 1 Bit 5 Output Mode  
1711      =2  #define P1MDOUT_B5__OPEN_DRAIN 0x00 ///< P1.5 output is open-drain.
1712      =2  #define P1MDOUT_B5__PUSH_PULL  0x20 ///< P1.5 output is push-pull. 
1713      =2                                                                     
1714      =2  #define P1MDOUT_B6__BMASK      0x40 ///< Port 1 Bit 6 Output Mode  
1715      =2  #define P1MDOUT_B6__SHIFT      0x06 ///< Port 1 Bit 6 Output Mode  
1716      =2  #define P1MDOUT_B6__OPEN_DRAIN 0x00 ///< P1.6 output is open-drain.
1717      =2  #define P1MDOUT_B6__PUSH_PULL  0x40 ///< P1.6 output is push-pull. 
1718      =2                                                                     
1719      =2  #define P1MDOUT_B7__BMASK      0x80 ///< Port 1 Bit 7 Output Mode  
1720      =2  #define P1MDOUT_B7__SHIFT      0x07 ///< Port 1 Bit 7 Output Mode  
1721      =2  #define P1MDOUT_B7__OPEN_DRAIN 0x00 ///< P1.7 output is open-drain.
1722      =2  #define P1MDOUT_B7__PUSH_PULL  0x80 ///< P1.7 output is push-pull. 
1723      =2                                                                     
1724      =2  //------------------------------------------------------------------------------
1725      =2  // P1SKIP Enums (Port 1 Skip @ 0xD5)
1726      =2  //------------------------------------------------------------------------------
1727      =2  #define P1SKIP_B0__BMASK       0x01 ///< Port 1 Bit 0 Skip                       
1728      =2  #define P1SKIP_B0__SHIFT       0x00 ///< Port 1 Bit 0 Skip                       
1729      =2  #define P1SKIP_B0__NOT_SKIPPED 0x00 ///< P1.0 pin is not skipped by the crossbar.
1730      =2  #define P1SKIP_B0__SKIPPED     0x01 ///< P1.0 pin is skipped by the crossbar.    
1731      =2                                                                                   
1732      =2  #define P1SKIP_B1__BMASK       0x02 ///< Port 1 Bit 1 Skip                       
1733      =2  #define P1SKIP_B1__SHIFT       0x01 ///< Port 1 Bit 1 Skip                       
1734      =2  #define P1SKIP_B1__NOT_SKIPPED 0x00 ///< P1.1 pin is not skipped by the crossbar.
1735      =2  #define P1SKIP_B1__SKIPPED     0x02 ///< P1.1 pin is skipped by the crossbar.    
1736      =2                                                                                   
1737      =2  #define P1SKIP_B2__BMASK       0x04 ///< Port 1 Bit 2 Skip                       
1738      =2  #define P1SKIP_B2__SHIFT       0x02 ///< Port 1 Bit 2 Skip                       
1739      =2  #define P1SKIP_B2__NOT_SKIPPED 0x00 ///< P1.2 pin is not skipped by the crossbar.
1740      =2  #define P1SKIP_B2__SKIPPED     0x04 ///< P1.2 pin is skipped by the crossbar.    
1741      =2                                                                                   
1742      =2  #define P1SKIP_B3__BMASK       0x08 ///< Port 1 Bit 3 Skip                       
1743      =2  #define P1SKIP_B3__SHIFT       0x03 ///< Port 1 Bit 3 Skip                       
1744      =2  #define P1SKIP_B3__NOT_SKIPPED 0x00 ///< P1.3 pin is not skipped by the crossbar.
1745      =2  #define P1SKIP_B3__SKIPPED     0x08 ///< P1.3 pin is skipped by the crossbar.    
1746      =2                                                                                   
1747      =2  #define P1SKIP_B4__BMASK       0x10 ///< Port 1 Bit 4 Skip                       
C51 COMPILER V9.56.0.0   I2C_0                                                             10/28/2016 17:37:02 PAGE 55  

1748      =2  #define P1SKIP_B4__SHIFT       0x04 ///< Port 1 Bit 4 Skip                       
1749      =2  #define P1SKIP_B4__NOT_SKIPPED 0x00 ///< P1.4 pin is not skipped by the crossbar.
1750      =2  #define P1SKIP_B4__SKIPPED     0x10 ///< P1.4 pin is skipped by the crossbar.    
1751      =2                                                                                   
1752      =2  #define P1SKIP_B5__BMASK       0x20 ///< Port 1 Bit 5 Skip                       
1753      =2  #define P1SKIP_B5__SHIFT       0x05 ///< Port 1 Bit 5 Skip                       
1754      =2  #define P1SKIP_B5__NOT_SKIPPED 0x00 ///< P1.5 pin is not skipped by the crossbar.
1755      =2  #define P1SKIP_B5__SKIPPED     0x20 ///< P1.5 pin is skipped by the crossbar.    
1756      =2                                                                                   
1757      =2  #define P1SKIP_B6__BMASK       0x40 ///< Port 1 Bit 6 Skip                       
1758      =2  #define P1SKIP_B6__SHIFT       0x06 ///< Port 1 Bit 6 Skip                       
1759      =2  #define P1SKIP_B6__NOT_SKIPPED 0x00 ///< P1.6 pin is not skipped by the crossbar.
1760      =2  #define P1SKIP_B6__SKIPPED     0x40 ///< P1.6 pin is skipped by the crossbar.    
1761      =2                                                                                   
1762      =2  #define P1SKIP_B7__BMASK       0x80 ///< Port 1 Bit 7 Skip                       
1763      =2  #define P1SKIP_B7__SHIFT       0x07 ///< Port 1 Bit 7 Skip                       
1764      =2  #define P1SKIP_B7__NOT_SKIPPED 0x00 ///< P1.7 pin is not skipped by the crossbar.
1765      =2  #define P1SKIP_B7__SKIPPED     0x80 ///< P1.7 pin is skipped by the crossbar.    
1766      =2                                                                                   
1767      =2  //------------------------------------------------------------------------------
1768      =2  // P2 Enums (Port 2 Pin Latch @ 0xA0)
1769      =2  //------------------------------------------------------------------------------
1770      =2  #define P2_B0__BMASK 0x01 ///< Port 2 Bit 0 Latch                            
1771      =2  #define P2_B0__SHIFT 0x00 ///< Port 2 Bit 0 Latch                            
1772      =2  #define P2_B0__LOW   0x00 ///< P2.0 is low. Set P2.0 to drive low.           
1773      =2  #define P2_B0__HIGH  0x01 ///< P2.0 is high. Set P2.0 to drive or float high.
1774      =2                                                                               
1775      =2  #define P2_B1__BMASK 0x02 ///< Port 2 Bit 1 Latch                            
1776      =2  #define P2_B1__SHIFT 0x01 ///< Port 2 Bit 1 Latch                            
1777      =2  #define P2_B1__LOW   0x00 ///< P2.1 is low. Set P2.1 to drive low.           
1778      =2  #define P2_B1__HIGH  0x02 ///< P2.1 is high. Set P2.1 to drive or float high.
1779      =2                                                                               
1780      =2  #define P2_B2__BMASK 0x04 ///< Port 2 Bit 2 Latch                            
1781      =2  #define P2_B2__SHIFT 0x02 ///< Port 2 Bit 2 Latch                            
1782      =2  #define P2_B2__LOW   0x00 ///< P2.2 is low. Set P2.2 to drive low.           
1783      =2  #define P2_B2__HIGH  0x04 ///< P2.2 is high. Set P2.2 to drive or float high.
1784      =2                                                                               
1785      =2  #define P2_B3__BMASK 0x08 ///< Port 2 Bit 3 Latch                            
1786      =2  #define P2_B3__SHIFT 0x03 ///< Port 2 Bit 3 Latch                            
1787      =2  #define P2_B3__LOW   0x00 ///< P2.3 is low. Set P2.3 to drive low.           
1788      =2  #define P2_B3__HIGH  0x08 ///< P2.3 is high. Set P2.3 to drive or float high.
1789      =2                                                                               
1790      =2  #define P2_B4__BMASK 0x10 ///< Port 2 Bit 4 Latch                            
1791      =2  #define P2_B4__SHIFT 0x04 ///< Port 2 Bit 4 Latch                            
1792      =2  #define P2_B4__LOW   0x00 ///< P2.4 is low. Set P2.4 to drive low.           
1793      =2  #define P2_B4__HIGH  0x10 ///< P2.4 is high. Set P2.4 to drive or float high.
1794      =2                                                                               
1795      =2  #define P2_B5__BMASK 0x20 ///< Port 2 Bit 5 Latch                            
1796      =2  #define P2_B5__SHIFT 0x05 ///< Port 2 Bit 5 Latch                            
1797      =2  #define P2_B5__LOW   0x00 ///< P2.5 is low. Set P2.5 to drive low.           
1798      =2  #define P2_B5__HIGH  0x20 ///< P2.5 is high. Set P2.5 to drive or float high.
1799      =2                                                                               
1800      =2  #define P2_B6__BMASK 0x40 ///< Port 2 Bit 6 Latch                            
1801      =2  #define P2_B6__SHIFT 0x06 ///< Port 2 Bit 6 Latch                            
1802      =2  #define P2_B6__LOW   0x00 ///< P2.6 is low. Set P2.6 to drive low.           
1803      =2  #define P2_B6__HIGH  0x40 ///< P2.6 is high. Set P2.6 to drive or float high.
1804      =2                                                                               
1805      =2  #define P2_B7__BMASK 0x80 ///< Port 2 Bit 7 Latch                            
1806      =2  #define P2_B7__SHIFT 0x07 ///< Port 2 Bit 7 Latch                            
1807      =2  #define P2_B7__LOW   0x00 ///< P2.7 is low. Set P2.7 to drive low.           
1808      =2  #define P2_B7__HIGH  0x80 ///< P2.7 is high. Set P2.7 to drive or float high.
1809      =2                                                                               
C51 COMPILER V9.56.0.0   I2C_0                                                             10/28/2016 17:37:02 PAGE 56  

1810      =2  //------------------------------------------------------------------------------
1811      =2  // P2MDIN Enums (Port 2 Input Mode @ 0xF3)
1812      =2  //------------------------------------------------------------------------------
1813      =2  #define P2MDIN_B0__BMASK   0x01 ///< Port 2 Bit 0 Input Mode                 
1814      =2  #define P2MDIN_B0__SHIFT   0x00 ///< Port 2 Bit 0 Input Mode                 
1815      =2  #define P2MDIN_B0__ANALOG  0x00 ///< P2.0 pin is configured for analog mode. 
1816      =2  #define P2MDIN_B0__DIGITAL 0x01 ///< P2.0 pin is configured for digital mode.
1817      =2                                                                               
1818      =2  #define P2MDIN_B1__BMASK   0x02 ///< Port 2 Bit 1 Input Mode                 
1819      =2  #define P2MDIN_B1__SHIFT   0x01 ///< Port 2 Bit 1 Input Mode                 
1820      =2  #define P2MDIN_B1__ANALOG  0x00 ///< P2.1 pin is configured for analog mode. 
1821      =2  #define P2MDIN_B1__DIGITAL 0x02 ///< P2.1 pin is configured for digital mode.
1822      =2                                                                               
1823      =2  #define P2MDIN_B2__BMASK   0x04 ///< Port 2 Bit 2 Input Mode                 
1824      =2  #define P2MDIN_B2__SHIFT   0x02 ///< Port 2 Bit 2 Input Mode                 
1825      =2  #define P2MDIN_B2__ANALOG  0x00 ///< P2.2 pin is configured for analog mode. 
1826      =2  #define P2MDIN_B2__DIGITAL 0x04 ///< P2.2 pin is configured for digital mode.
1827      =2                                                                               
1828      =2  #define P2MDIN_B3__BMASK   0x08 ///< Port 2 Bit 3 Input Mode                 
1829      =2  #define P2MDIN_B3__SHIFT   0x03 ///< Port 2 Bit 3 Input Mode                 
1830      =2  #define P2MDIN_B3__ANALOG  0x00 ///< P2.3 pin is configured for analog mode. 
1831      =2  #define P2MDIN_B3__DIGITAL 0x08 ///< P2.3 pin is configured for digital mode.
1832      =2                                                                               
1833      =2  #define P2MDIN_B4__BMASK   0x10 ///< Port 2 Bit 4 Input Mode                 
1834      =2  #define P2MDIN_B4__SHIFT   0x04 ///< Port 2 Bit 4 Input Mode                 
1835      =2  #define P2MDIN_B4__ANALOG  0x00 ///< P2.4 pin is configured for analog mode. 
1836      =2  #define P2MDIN_B4__DIGITAL 0x10 ///< P2.4 pin is configured for digital mode.
1837      =2                                                                               
1838      =2  #define P2MDIN_B5__BMASK   0x20 ///< Port 2 Bit 5 Input Mode                 
1839      =2  #define P2MDIN_B5__SHIFT   0x05 ///< Port 2 Bit 5 Input Mode                 
1840      =2  #define P2MDIN_B5__ANALOG  0x00 ///< P2.5 pin is configured for analog mode. 
1841      =2  #define P2MDIN_B5__DIGITAL 0x20 ///< P2.5 pin is configured for digital mode.
1842      =2                                                                               
1843      =2  #define P2MDIN_B6__BMASK   0x40 ///< Port 2 Bit 6 Input Mode                 
1844      =2  #define P2MDIN_B6__SHIFT   0x06 ///< Port 2 Bit 6 Input Mode                 
1845      =2  #define P2MDIN_B6__ANALOG  0x00 ///< P2.6 pin is configured for analog mode. 
1846      =2  #define P2MDIN_B6__DIGITAL 0x40 ///< P2.6 pin is configured for digital mode.
1847      =2                                                                               
1848      =2  #define P2MDIN_B7__BMASK   0x80 ///< Port 2 Bit 7 Input Mode                 
1849      =2  #define P2MDIN_B7__SHIFT   0x07 ///< Port 2 Bit 7 Input Mode                 
1850      =2  #define P2MDIN_B7__ANALOG  0x00 ///< P2.7 pin is configured for analog mode. 
1851      =2  #define P2MDIN_B7__DIGITAL 0x80 ///< P2.7 pin is configured for digital mode.
1852      =2                                                                               
1853      =2  //------------------------------------------------------------------------------
1854      =2  // P2MDOUT Enums (Port 2 Output Mode @ 0xA6)
1855      =2  //------------------------------------------------------------------------------
1856      =2  #define P2MDOUT_B0__BMASK      0x01 ///< Port 2 Bit 0 Output Mode  
1857      =2  #define P2MDOUT_B0__SHIFT      0x00 ///< Port 2 Bit 0 Output Mode  
1858      =2  #define P2MDOUT_B0__OPEN_DRAIN 0x00 ///< P2.0 output is open-drain.
1859      =2  #define P2MDOUT_B0__PUSH_PULL  0x01 ///< P2.0 output is push-pull. 
1860      =2                                                                     
1861      =2  #define P2MDOUT_B1__BMASK      0x02 ///< Port 2 Bit 1 Output Mode  
1862      =2  #define P2MDOUT_B1__SHIFT      0x01 ///< Port 2 Bit 1 Output Mode  
1863      =2  #define P2MDOUT_B1__OPEN_DRAIN 0x00 ///< P2.1 output is open-drain.
1864      =2  #define P2MDOUT_B1__PUSH_PULL  0x02 ///< P2.1 output is push-pull. 
1865      =2                                                                     
1866      =2  #define P2MDOUT_B2__BMASK      0x04 ///< Port 2 Bit 2 Output Mode  
1867      =2  #define P2MDOUT_B2__SHIFT      0x02 ///< Port 2 Bit 2 Output Mode  
1868      =2  #define P2MDOUT_B2__OPEN_DRAIN 0x00 ///< P2.2 output is open-drain.
1869      =2  #define P2MDOUT_B2__PUSH_PULL  0x04 ///< P2.2 output is push-pull. 
1870      =2                                                                     
1871      =2  #define P2MDOUT_B3__BMASK      0x08 ///< Port 2 Bit 3 Output Mode  
C51 COMPILER V9.56.0.0   I2C_0                                                             10/28/2016 17:37:02 PAGE 57  

1872      =2  #define P2MDOUT_B3__SHIFT      0x03 ///< Port 2 Bit 3 Output Mode  
1873      =2  #define P2MDOUT_B3__OPEN_DRAIN 0x00 ///< P2.3 output is open-drain.
1874      =2  #define P2MDOUT_B3__PUSH_PULL  0x08 ///< P2.3 output is push-pull. 
1875      =2                                                                     
1876      =2  #define P2MDOUT_B4__BMASK      0x10 ///< Port 2 Bit 4 Output Mode  
1877      =2  #define P2MDOUT_B4__SHIFT      0x04 ///< Port 2 Bit 4 Output Mode  
1878      =2  #define P2MDOUT_B4__OPEN_DRAIN 0x00 ///< P2.4 output is open-drain.
1879      =2  #define P2MDOUT_B4__PUSH_PULL  0x10 ///< P2.4 output is push-pull. 
1880      =2                                                                     
1881      =2  #define P2MDOUT_B5__BMASK      0x20 ///< Port 2 Bit 5 Output Mode  
1882      =2  #define P2MDOUT_B5__SHIFT      0x05 ///< Port 2 Bit 5 Output Mode  
1883      =2  #define P2MDOUT_B5__OPEN_DRAIN 0x00 ///< P2.5 output is open-drain.
1884      =2  #define P2MDOUT_B5__PUSH_PULL  0x20 ///< P2.5 output is push-pull. 
1885      =2                                                                     
1886      =2  #define P2MDOUT_B6__BMASK      0x40 ///< Port 2 Bit 6 Output Mode  
1887      =2  #define P2MDOUT_B6__SHIFT      0x06 ///< Port 2 Bit 6 Output Mode  
1888      =2  #define P2MDOUT_B6__OPEN_DRAIN 0x00 ///< P2.6 output is open-drain.
1889      =2  #define P2MDOUT_B6__PUSH_PULL  0x40 ///< P2.6 output is push-pull. 
1890      =2                                                                     
1891      =2  #define P2MDOUT_B7__BMASK      0x80 ///< Port 2 Bit 7 Output Mode  
1892      =2  #define P2MDOUT_B7__SHIFT      0x07 ///< Port 2 Bit 7 Output Mode  
1893      =2  #define P2MDOUT_B7__OPEN_DRAIN 0x00 ///< P2.7 output is open-drain.
1894      =2  #define P2MDOUT_B7__PUSH_PULL  0x80 ///< P2.7 output is push-pull. 
1895      =2                                                                     
1896      =2  //------------------------------------------------------------------------------
1897      =2  // P2SKIP Enums (Port 2 Skip @ 0xD6)
1898      =2  //------------------------------------------------------------------------------
1899      =2  #define P2SKIP_B0__BMASK       0x01 ///< Port 2 Bit 0 Skip                       
1900      =2  #define P2SKIP_B0__SHIFT       0x00 ///< Port 2 Bit 0 Skip                       
1901      =2  #define P2SKIP_B0__NOT_SKIPPED 0x00 ///< P2.0 pin is not skipped by the crossbar.
1902      =2  #define P2SKIP_B0__SKIPPED     0x01 ///< P2.0 pin is skipped by the crossbar.    
1903      =2                                                                                   
1904      =2  #define P2SKIP_B1__BMASK       0x02 ///< Port 2 Bit 1 Skip                       
1905      =2  #define P2SKIP_B1__SHIFT       0x01 ///< Port 2 Bit 1 Skip                       
1906      =2  #define P2SKIP_B1__NOT_SKIPPED 0x00 ///< P2.1 pin is not skipped by the crossbar.
1907      =2  #define P2SKIP_B1__SKIPPED     0x02 ///< P2.1 pin is skipped by the crossbar.    
1908      =2                                                                                   
1909      =2  #define P2SKIP_B2__BMASK       0x04 ///< Port 2 Bit 2 Skip                       
1910      =2  #define P2SKIP_B2__SHIFT       0x02 ///< Port 2 Bit 2 Skip                       
1911      =2  #define P2SKIP_B2__NOT_SKIPPED 0x00 ///< P2.2 pin is not skipped by the crossbar.
1912      =2  #define P2SKIP_B2__SKIPPED     0x04 ///< P2.2 pin is skipped by the crossbar.    
1913      =2                                                                                   
1914      =2  #define P2SKIP_B3__BMASK       0x08 ///< Port 2 Bit 3 Skip                       
1915      =2  #define P2SKIP_B3__SHIFT       0x03 ///< Port 2 Bit 3 Skip                       
1916      =2  #define P2SKIP_B3__NOT_SKIPPED 0x00 ///< P2.3 pin is not skipped by the crossbar.
1917      =2  #define P2SKIP_B3__SKIPPED     0x08 ///< P2.3 pin is skipped by the crossbar.    
1918      =2                                                                                   
1919      =2  #define P2SKIP_B4__BMASK       0x10 ///< Port 2 Bit 4 Skip                       
1920      =2  #define P2SKIP_B4__SHIFT       0x04 ///< Port 2 Bit 4 Skip                       
1921      =2  #define P2SKIP_B4__NOT_SKIPPED 0x00 ///< P2.4 pin is not skipped by the crossbar.
1922      =2  #define P2SKIP_B4__SKIPPED     0x10 ///< P2.4 pin is skipped by the crossbar.    
1923      =2                                                                                   
1924      =2  #define P2SKIP_B5__BMASK       0x20 ///< Port 2 Bit 5 Skip                       
1925      =2  #define P2SKIP_B5__SHIFT       0x05 ///< Port 2 Bit 5 Skip                       
1926      =2  #define P2SKIP_B5__NOT_SKIPPED 0x00 ///< P2.5 pin is not skipped by the crossbar.
1927      =2  #define P2SKIP_B5__SKIPPED     0x20 ///< P2.5 pin is skipped by the crossbar.    
1928      =2                                                                                   
1929      =2  #define P2SKIP_B6__BMASK       0x40 ///< Port 2 Bit 6 Skip                       
1930      =2  #define P2SKIP_B6__SHIFT       0x06 ///< Port 2 Bit 6 Skip                       
1931      =2  #define P2SKIP_B6__NOT_SKIPPED 0x00 ///< P2.6 pin is not skipped by the crossbar.
1932      =2  #define P2SKIP_B6__SKIPPED     0x40 ///< P2.6 pin is skipped by the crossbar.    
1933      =2                                                                                   
C51 COMPILER V9.56.0.0   I2C_0                                                             10/28/2016 17:37:02 PAGE 58  

1934      =2  #define P2SKIP_B7__BMASK       0x80 ///< Port 2 Bit 7 Skip                       
1935      =2  #define P2SKIP_B7__SHIFT       0x07 ///< Port 2 Bit 7 Skip                       
1936      =2  #define P2SKIP_B7__NOT_SKIPPED 0x00 ///< P2.7 pin is not skipped by the crossbar.
1937      =2  #define P2SKIP_B7__SKIPPED     0x80 ///< P2.7 pin is skipped by the crossbar.    
1938      =2                                                                                   
1939      =2  //------------------------------------------------------------------------------
1940      =2  // P3 Enums (Port 3 Pin Latch @ 0xB0)
1941      =2  //------------------------------------------------------------------------------
1942      =2  #define P3_B0__BMASK 0x01 ///< Port 3 Bit 0 Latch                            
1943      =2  #define P3_B0__SHIFT 0x00 ///< Port 3 Bit 0 Latch                            
1944      =2  #define P3_B0__LOW   0x00 ///< P3.0 is low. Set P3.0 to drive low.           
1945      =2  #define P3_B0__HIGH  0x01 ///< P3.0 is high. Set P3.0 to drive or float high.
1946      =2                                                                               
1947      =2  #define P3_B1__BMASK 0x02 ///< Port 3 Bit 1 Latch                            
1948      =2  #define P3_B1__SHIFT 0x01 ///< Port 3 Bit 1 Latch                            
1949      =2  #define P3_B1__LOW   0x00 ///< P3.1 is low. Set P3.1 to drive low.           
1950      =2  #define P3_B1__HIGH  0x02 ///< P3.1 is high. Set P3.1 to drive or float high.
1951      =2                                                                               
1952      =2  #define P3_B2__BMASK 0x04 ///< Port 3 Bit 2 Latch                            
1953      =2  #define P3_B2__SHIFT 0x02 ///< Port 3 Bit 2 Latch                            
1954      =2  #define P3_B2__LOW   0x00 ///< P3.2 is low. Set P3.2 to drive low.           
1955      =2  #define P3_B2__HIGH  0x04 ///< P3.2 is high. Set P3.2 to drive or float high.
1956      =2                                                                               
1957      =2  #define P3_B3__BMASK 0x08 ///< Port 3 Bit 3 Latch                            
1958      =2  #define P3_B3__SHIFT 0x03 ///< Port 3 Bit 3 Latch                            
1959      =2  #define P3_B3__LOW   0x00 ///< P3.3 is low. Set P3.3 to drive low.           
1960      =2  #define P3_B3__HIGH  0x08 ///< P3.3 is high. Set P3.3 to drive or float high.
1961      =2                                                                               
1962      =2  #define P3_B4__BMASK 0x10 ///< Port 3 Bit 4 Latch                            
1963      =2  #define P3_B4__SHIFT 0x04 ///< Port 3 Bit 4 Latch                            
1964      =2  #define P3_B4__LOW   0x00 ///< P3.4 is low. Set P3.4 to drive low.           
1965      =2  #define P3_B4__HIGH  0x10 ///< P3.4 is high. Set P3.4 to drive or float high.
1966      =2                                                                               
1967      =2  #define P3_B5__BMASK 0x20 ///< Port 3 Bit 5 Latch                            
1968      =2  #define P3_B5__SHIFT 0x05 ///< Port 3 Bit 5 Latch                            
1969      =2  #define P3_B5__LOW   0x00 ///< P3.5 is low. Set P3.5 to drive low.           
1970      =2  #define P3_B5__HIGH  0x20 ///< P3.5 is high. Set P3.5 to drive or float high.
1971      =2                                                                               
1972      =2  #define P3_B6__BMASK 0x40 ///< Port 3 Bit 6 Latch                            
1973      =2  #define P3_B6__SHIFT 0x06 ///< Port 3 Bit 6 Latch                            
1974      =2  #define P3_B6__LOW   0x00 ///< P3.6 is low. Set P3.6 to drive low.           
1975      =2  #define P3_B6__HIGH  0x40 ///< P3.6 is high. Set P3.6 to drive or float high.
1976      =2                                                                               
1977      =2  #define P3_B7__BMASK 0x80 ///< Port 3 Bit 7 Latch                            
1978      =2  #define P3_B7__SHIFT 0x07 ///< Port 3 Bit 7 Latch                            
1979      =2  #define P3_B7__LOW   0x00 ///< P3.7 is low. Set P3.7 to drive low.           
1980      =2  #define P3_B7__HIGH  0x80 ///< P3.7 is high. Set P3.7 to drive or float high.
1981      =2                                                                               
1982      =2  //------------------------------------------------------------------------------
1983      =2  // P3MDIN Enums (Port 3 Input Mode @ 0xF4)
1984      =2  //------------------------------------------------------------------------------
1985      =2  #define P3MDIN_B0__BMASK   0x01 ///< Port 3 Bit 0 Input Mode                 
1986      =2  #define P3MDIN_B0__SHIFT   0x00 ///< Port 3 Bit 0 Input Mode                 
1987      =2  #define P3MDIN_B0__ANALOG  0x00 ///< P3.0 pin is configured for analog mode. 
1988      =2  #define P3MDIN_B0__DIGITAL 0x01 ///< P3.0 pin is configured for digital mode.
1989      =2                                                                               
1990      =2  #define P3MDIN_B1__BMASK   0x02 ///< Port 3 Bit 1 Input Mode                 
1991      =2  #define P3MDIN_B1__SHIFT   0x01 ///< Port 3 Bit 1 Input Mode                 
1992      =2  #define P3MDIN_B1__ANALOG  0x00 ///< P3.1 pin is configured for analog mode. 
1993      =2  #define P3MDIN_B1__DIGITAL 0x02 ///< P3.1 pin is configured for digital mode.
1994      =2                                                                               
1995      =2  #define P3MDIN_B2__BMASK   0x04 ///< Port 3 Bit 2 Input Mode                 
C51 COMPILER V9.56.0.0   I2C_0                                                             10/28/2016 17:37:02 PAGE 59  

1996      =2  #define P3MDIN_B2__SHIFT   0x02 ///< Port 3 Bit 2 Input Mode                 
1997      =2  #define P3MDIN_B2__ANALOG  0x00 ///< P3.2 pin is configured for analog mode. 
1998      =2  #define P3MDIN_B2__DIGITAL 0x04 ///< P3.2 pin is configured for digital mode.
1999      =2                                                                               
2000      =2  #define P3MDIN_B3__BMASK   0x08 ///< Port 3 Bit 3 Input Mode                 
2001      =2  #define P3MDIN_B3__SHIFT   0x03 ///< Port 3 Bit 3 Input Mode                 
2002      =2  #define P3MDIN_B3__ANALOG  0x00 ///< P3.3 pin is configured for analog mode. 
2003      =2  #define P3MDIN_B3__DIGITAL 0x08 ///< P3.3 pin is configured for digital mode.
2004      =2                                                                               
2005      =2  #define P3MDIN_B4__BMASK   0x10 ///< Port 3 Bit 4 Input Mode                 
2006      =2  #define P3MDIN_B4__SHIFT   0x04 ///< Port 3 Bit 4 Input Mode                 
2007      =2  #define P3MDIN_B4__ANALOG  0x00 ///< P3.4 pin is configured for analog mode. 
2008      =2  #define P3MDIN_B4__DIGITAL 0x10 ///< P3.4 pin is configured for digital mode.
2009      =2                                                                               
2010      =2  #define P3MDIN_B5__BMASK   0x20 ///< Port 3 Bit 5 Input Mode                 
2011      =2  #define P3MDIN_B5__SHIFT   0x05 ///< Port 3 Bit 5 Input Mode                 
2012      =2  #define P3MDIN_B5__ANALOG  0x00 ///< P3.5 pin is configured for analog mode. 
2013      =2  #define P3MDIN_B5__DIGITAL 0x20 ///< P3.5 pin is configured for digital mode.
2014      =2                                                                               
2015      =2  #define P3MDIN_B6__BMASK   0x40 ///< Port 3 Bit 6 Input Mode                 
2016      =2  #define P3MDIN_B6__SHIFT   0x06 ///< Port 3 Bit 6 Input Mode                 
2017      =2  #define P3MDIN_B6__ANALOG  0x00 ///< P3.6 pin is configured for analog mode. 
2018      =2  #define P3MDIN_B6__DIGITAL 0x40 ///< P3.6 pin is configured for digital mode.
2019      =2                                                                               
2020      =2  #define P3MDIN_B7__BMASK   0x80 ///< Port 3 Bit 7 Input Mode                 
2021      =2  #define P3MDIN_B7__SHIFT   0x07 ///< Port 3 Bit 7 Input Mode                 
2022      =2  #define P3MDIN_B7__ANALOG  0x00 ///< P3.7 pin is configured for analog mode. 
2023      =2  #define P3MDIN_B7__DIGITAL 0x80 ///< P3.7 pin is configured for digital mode.
2024      =2                                                                               
2025      =2  //------------------------------------------------------------------------------
2026      =2  // P3MDOUT Enums (Port 3 Output Mode @ 0xA7)
2027      =2  //------------------------------------------------------------------------------
2028      =2  #define P3MDOUT_B0__BMASK      0x01 ///< Port 3 Bit 0 Output Mode  
2029      =2  #define P3MDOUT_B0__SHIFT      0x00 ///< Port 3 Bit 0 Output Mode  
2030      =2  #define P3MDOUT_B0__OPEN_DRAIN 0x00 ///< P3.0 output is open-drain.
2031      =2  #define P3MDOUT_B0__PUSH_PULL  0x01 ///< P3.0 output is push-pull. 
2032      =2                                                                     
2033      =2  #define P3MDOUT_B1__BMASK      0x02 ///< Port 3 Bit 1 Output Mode  
2034      =2  #define P3MDOUT_B1__SHIFT      0x01 ///< Port 3 Bit 1 Output Mode  
2035      =2  #define P3MDOUT_B1__OPEN_DRAIN 0x00 ///< P3.1 output is open-drain.
2036      =2  #define P3MDOUT_B1__PUSH_PULL  0x02 ///< P3.1 output is push-pull. 
2037      =2                                                                     
2038      =2  #define P3MDOUT_B2__BMASK      0x04 ///< Port 3 Bit 2 Output Mode  
2039      =2  #define P3MDOUT_B2__SHIFT      0x02 ///< Port 3 Bit 2 Output Mode  
2040      =2  #define P3MDOUT_B2__OPEN_DRAIN 0x00 ///< P3.2 output is open-drain.
2041      =2  #define P3MDOUT_B2__PUSH_PULL  0x04 ///< P3.2 output is push-pull. 
2042      =2                                                                     
2043      =2  #define P3MDOUT_B3__BMASK      0x08 ///< Port 3 Bit 3 Output Mode  
2044      =2  #define P3MDOUT_B3__SHIFT      0x03 ///< Port 3 Bit 3 Output Mode  
2045      =2  #define P3MDOUT_B3__OPEN_DRAIN 0x00 ///< P3.3 output is open-drain.
2046      =2  #define P3MDOUT_B3__PUSH_PULL  0x08 ///< P3.3 output is push-pull. 
2047      =2                                                                     
2048      =2  #define P3MDOUT_B4__BMASK      0x10 ///< Port 3 Bit 4 Output Mode  
2049      =2  #define P3MDOUT_B4__SHIFT      0x04 ///< Port 3 Bit 4 Output Mode  
2050      =2  #define P3MDOUT_B4__OPEN_DRAIN 0x00 ///< P3.4 output is open-drain.
2051      =2  #define P3MDOUT_B4__PUSH_PULL  0x10 ///< P3.4 output is push-pull. 
2052      =2                                                                     
2053      =2  #define P3MDOUT_B5__BMASK      0x20 ///< Port 3 Bit 5 Output Mode  
2054      =2  #define P3MDOUT_B5__SHIFT      0x05 ///< Port 3 Bit 5 Output Mode  
2055      =2  #define P3MDOUT_B5__OPEN_DRAIN 0x00 ///< P3.5 output is open-drain.
2056      =2  #define P3MDOUT_B5__PUSH_PULL  0x20 ///< P3.5 output is push-pull. 
2057      =2                                                                     
C51 COMPILER V9.56.0.0   I2C_0                                                             10/28/2016 17:37:02 PAGE 60  

2058      =2  #define P3MDOUT_B6__BMASK      0x40 ///< Port 3 Bit 6 Output Mode  
2059      =2  #define P3MDOUT_B6__SHIFT      0x06 ///< Port 3 Bit 6 Output Mode  
2060      =2  #define P3MDOUT_B6__OPEN_DRAIN 0x00 ///< P3.6 output is open-drain.
2061      =2  #define P3MDOUT_B6__PUSH_PULL  0x40 ///< P3.6 output is push-pull. 
2062      =2                                                                     
2063      =2  #define P3MDOUT_B7__BMASK      0x80 ///< Port 3 Bit 7 Output Mode  
2064      =2  #define P3MDOUT_B7__SHIFT      0x07 ///< Port 3 Bit 7 Output Mode  
2065      =2  #define P3MDOUT_B7__OPEN_DRAIN 0x00 ///< P3.7 output is open-drain.
2066      =2  #define P3MDOUT_B7__PUSH_PULL  0x80 ///< P3.7 output is push-pull. 
2067      =2                                                                     
2068      =2  //------------------------------------------------------------------------------
2069      =2  // P3SKIP Enums (Port 3 Skip @ 0xDF)
2070      =2  //------------------------------------------------------------------------------
2071      =2  #define P3SKIP_B0__BMASK       0x01 ///< Port 3 Bit 0 Skip                       
2072      =2  #define P3SKIP_B0__SHIFT       0x00 ///< Port 3 Bit 0 Skip                       
2073      =2  #define P3SKIP_B0__NOT_SKIPPED 0x00 ///< P3.0 pin is not skipped by the crossbar.
2074      =2  #define P3SKIP_B0__SKIPPED     0x01 ///< P3.0 pin is skipped by the crossbar.    
2075      =2                                                                                   
2076      =2  #define P3SKIP_B1__BMASK       0x02 ///< Port 3 Bit 1 Skip                       
2077      =2  #define P3SKIP_B1__SHIFT       0x01 ///< Port 3 Bit 1 Skip                       
2078      =2  #define P3SKIP_B1__NOT_SKIPPED 0x00 ///< P3.1 pin is not skipped by the crossbar.
2079      =2  #define P3SKIP_B1__SKIPPED     0x02 ///< P3.1 pin is skipped by the crossbar.    
2080      =2                                                                                   
2081      =2  #define P3SKIP_B2__BMASK       0x04 ///< Port 3 Bit 2 Skip                       
2082      =2  #define P3SKIP_B2__SHIFT       0x02 ///< Port 3 Bit 2 Skip                       
2083      =2  #define P3SKIP_B2__NOT_SKIPPED 0x00 ///< P3.2 pin is not skipped by the crossbar.
2084      =2  #define P3SKIP_B2__SKIPPED     0x04 ///< P3.2 pin is skipped by the crossbar.    
2085      =2                                                                                   
2086      =2  #define P3SKIP_B3__BMASK       0x08 ///< Port 3 Bit 3 Skip                       
2087      =2  #define P3SKIP_B3__SHIFT       0x03 ///< Port 3 Bit 3 Skip                       
2088      =2  #define P3SKIP_B3__NOT_SKIPPED 0x00 ///< P3.3 pin is not skipped by the crossbar.
2089      =2  #define P3SKIP_B3__SKIPPED     0x08 ///< P3.3 pin is skipped by the crossbar.    
2090      =2                                                                                   
2091      =2  #define P3SKIP_B4__BMASK       0x10 ///< Port 3 Bit 4 Skip                       
2092      =2  #define P3SKIP_B4__SHIFT       0x04 ///< Port 3 Bit 4 Skip                       
2093      =2  #define P3SKIP_B4__NOT_SKIPPED 0x00 ///< P3.4 pin is not skipped by the crossbar.
2094      =2  #define P3SKIP_B4__SKIPPED     0x10 ///< P3.4 pin is skipped by the crossbar.    
2095      =2                                                                                   
2096      =2  #define P3SKIP_B5__BMASK       0x20 ///< Port 3 Bit 5 Skip                       
2097      =2  #define P3SKIP_B5__SHIFT       0x05 ///< Port 3 Bit 5 Skip                       
2098      =2  #define P3SKIP_B5__NOT_SKIPPED 0x00 ///< P3.5 pin is not skipped by the crossbar.
2099      =2  #define P3SKIP_B5__SKIPPED     0x20 ///< P3.5 pin is skipped by the crossbar.    
2100      =2                                                                                   
2101      =2  #define P3SKIP_B6__BMASK       0x40 ///< Port 3 Bit 6 Skip                       
2102      =2  #define P3SKIP_B6__SHIFT       0x06 ///< Port 3 Bit 6 Skip                       
2103      =2  #define P3SKIP_B6__NOT_SKIPPED 0x00 ///< P3.6 pin is not skipped by the crossbar.
2104      =2  #define P3SKIP_B6__SKIPPED     0x40 ///< P3.6 pin is skipped by the crossbar.    
2105      =2                                                                                   
2106      =2  #define P3SKIP_B7__BMASK       0x80 ///< Port 3 Bit 7 Skip                       
2107      =2  #define P3SKIP_B7__SHIFT       0x07 ///< Port 3 Bit 7 Skip                       
2108      =2  #define P3SKIP_B7__NOT_SKIPPED 0x00 ///< P3.7 pin is not skipped by the crossbar.
2109      =2  #define P3SKIP_B7__SKIPPED     0x80 ///< P3.7 pin is skipped by the crossbar.    
2110      =2                                                                                   
2111      =2  //------------------------------------------------------------------------------
2112      =2  // P4 Enums (Port 4 Pin Latch @ 0xC7)
2113      =2  //------------------------------------------------------------------------------
2114      =2  #define P4_B0__BMASK 0x01 ///< Port 4 Bit 0 Latch                            
2115      =2  #define P4_B0__SHIFT 0x00 ///< Port 4 Bit 0 Latch                            
2116      =2  #define P4_B0__LOW   0x00 ///< P4.0 is low. Set P4.0 to drive low.           
2117      =2  #define P4_B0__HIGH  0x01 ///< P4.0 is high. Set P4.0 to drive or float high.
2118      =2                                                                               
2119      =2  #define P4_B1__BMASK 0x02 ///< Port 4 Bit 1 Latch                            
C51 COMPILER V9.56.0.0   I2C_0                                                             10/28/2016 17:37:02 PAGE 61  

2120      =2  #define P4_B1__SHIFT 0x01 ///< Port 4 Bit 1 Latch                            
2121      =2  #define P4_B1__LOW   0x00 ///< P4.1 is low. Set P4.1 to drive low.           
2122      =2  #define P4_B1__HIGH  0x02 ///< P4.1 is high. Set P4.1 to drive or float high.
2123      =2                                                                               
2124      =2  #define P4_B2__BMASK 0x04 ///< Port 4 Bit 2 Latch                            
2125      =2  #define P4_B2__SHIFT 0x02 ///< Port 4 Bit 2 Latch                            
2126      =2  #define P4_B2__LOW   0x00 ///< P4.2 is low. Set P4.2 to drive low.           
2127      =2  #define P4_B2__HIGH  0x04 ///< P4.2 is high. Set P4.2 to drive or float high.
2128      =2                                                                               
2129      =2  #define P4_B3__BMASK 0x08 ///< Port 4 Bit 3 Latch                            
2130      =2  #define P4_B3__SHIFT 0x03 ///< Port 4 Bit 3 Latch                            
2131      =2  #define P4_B3__LOW   0x00 ///< P4.3 is low. Set P4.3 to drive low.           
2132      =2  #define P4_B3__HIGH  0x08 ///< P4.3 is high. Set P4.3 to drive or float high.
2133      =2                                                                               
2134      =2  #define P4_B4__BMASK 0x10 ///< Port 4 Bit 4 Latch                            
2135      =2  #define P4_B4__SHIFT 0x04 ///< Port 4 Bit 4 Latch                            
2136      =2  #define P4_B4__LOW   0x00 ///< P4.4 is low. Set P4.4 to drive low.           
2137      =2  #define P4_B4__HIGH  0x10 ///< P4.4 is high. Set P4.4 to drive or float high.
2138      =2                                                                               
2139      =2  #define P4_B5__BMASK 0x20 ///< Port 4 Bit 5 Latch                            
2140      =2  #define P4_B5__SHIFT 0x05 ///< Port 4 Bit 5 Latch                            
2141      =2  #define P4_B5__LOW   0x00 ///< P4.5 is low. Set P4.5 to drive low.           
2142      =2  #define P4_B5__HIGH  0x20 ///< P4.5 is high. Set P4.5 to drive or float high.
2143      =2                                                                               
2144      =2  #define P4_B6__BMASK 0x40 ///< Port 4 Bit 6 Latch                            
2145      =2  #define P4_B6__SHIFT 0x06 ///< Port 4 Bit 6 Latch                            
2146      =2  #define P4_B6__LOW   0x00 ///< P4.6 is low. Set P4.6 to drive low.           
2147      =2  #define P4_B6__HIGH  0x40 ///< P4.6 is high. Set P4.6 to drive or float high.
2148      =2                                                                               
2149      =2  #define P4_B7__BMASK 0x80 ///< Port 4 Bit 7 Latch                            
2150      =2  #define P4_B7__SHIFT 0x07 ///< Port 4 Bit 7 Latch                            
2151      =2  #define P4_B7__LOW   0x00 ///< P4.7 is low. Set P4.7 to drive low.           
2152      =2  #define P4_B7__HIGH  0x80 ///< P4.7 is high. Set P4.7 to drive or float high.
2153      =2                                                                               
2154      =2  //------------------------------------------------------------------------------
2155      =2  // P4MDIN Enums (Port 4 Input Mode @ 0xF5)
2156      =2  //------------------------------------------------------------------------------
2157      =2  #define P4MDIN_B0__BMASK   0x01 ///< Port 4 Bit 0 Input Mode                 
2158      =2  #define P4MDIN_B0__SHIFT   0x00 ///< Port 4 Bit 0 Input Mode                 
2159      =2  #define P4MDIN_B0__ANALOG  0x00 ///< P4.0 pin is configured for analog mode. 
2160      =2  #define P4MDIN_B0__DIGITAL 0x01 ///< P4.0 pin is configured for digital mode.
2161      =2                                                                               
2162      =2  #define P4MDIN_B1__BMASK   0x02 ///< Port 4 Bit 1 Input Mode                 
2163      =2  #define P4MDIN_B1__SHIFT   0x01 ///< Port 4 Bit 1 Input Mode                 
2164      =2  #define P4MDIN_B1__ANALOG  0x00 ///< P4.1 pin is configured for analog mode. 
2165      =2  #define P4MDIN_B1__DIGITAL 0x02 ///< P4.1 pin is configured for digital mode.
2166      =2                                                                               
2167      =2  #define P4MDIN_B2__BMASK   0x04 ///< Port 4 Bit 2 Input Mode                 
2168      =2  #define P4MDIN_B2__SHIFT   0x02 ///< Port 4 Bit 2 Input Mode                 
2169      =2  #define P4MDIN_B2__ANALOG  0x00 ///< P4.2 pin is configured for analog mode. 
2170      =2  #define P4MDIN_B2__DIGITAL 0x04 ///< P4.2 pin is configured for digital mode.
2171      =2                                                                               
2172      =2  #define P4MDIN_B3__BMASK   0x08 ///< Port 4 Bit 3 Input Mode                 
2173      =2  #define P4MDIN_B3__SHIFT   0x03 ///< Port 4 Bit 3 Input Mode                 
2174      =2  #define P4MDIN_B3__ANALOG  0x00 ///< P4.3 pin is configured for analog mode. 
2175      =2  #define P4MDIN_B3__DIGITAL 0x08 ///< P4.3 pin is configured for digital mode.
2176      =2                                                                               
2177      =2  #define P4MDIN_B4__BMASK   0x10 ///< Port 4 Bit 4 Input Mode                 
2178      =2  #define P4MDIN_B4__SHIFT   0x04 ///< Port 4 Bit 4 Input Mode                 
2179      =2  #define P4MDIN_B4__ANALOG  0x00 ///< P4.4 pin is configured for analog mode. 
2180      =2  #define P4MDIN_B4__DIGITAL 0x10 ///< P4.4 pin is configured for digital mode.
2181      =2                                                                               
C51 COMPILER V9.56.0.0   I2C_0                                                             10/28/2016 17:37:02 PAGE 62  

2182      =2  #define P4MDIN_B5__BMASK   0x20 ///< Port 4 Bit 5 Input Mode                 
2183      =2  #define P4MDIN_B5__SHIFT   0x05 ///< Port 4 Bit 5 Input Mode                 
2184      =2  #define P4MDIN_B5__ANALOG  0x00 ///< P4.5 pin is configured for analog mode. 
2185      =2  #define P4MDIN_B5__DIGITAL 0x20 ///< P4.5 pin is configured for digital mode.
2186      =2                                                                               
2187      =2  #define P4MDIN_B6__BMASK   0x40 ///< Port 4 Bit 6 Input Mode                 
2188      =2  #define P4MDIN_B6__SHIFT   0x06 ///< Port 4 Bit 6 Input Mode                 
2189      =2  #define P4MDIN_B6__ANALOG  0x00 ///< P4.6 pin is configured for analog mode. 
2190      =2  #define P4MDIN_B6__DIGITAL 0x40 ///< P4.6 pin is configured for digital mode.
2191      =2                                                                               
2192      =2  #define P4MDIN_B7__BMASK   0x80 ///< Port 4 Bit 7 Input Mode                 
2193      =2  #define P4MDIN_B7__SHIFT   0x07 ///< Port 4 Bit 7 Input Mode                 
2194      =2  #define P4MDIN_B7__ANALOG  0x00 ///< P4.7 pin is configured for analog mode. 
2195      =2  #define P4MDIN_B7__DIGITAL 0x80 ///< P4.7 pin is configured for digital mode.
2196      =2                                                                               
2197      =2  //------------------------------------------------------------------------------
2198      =2  // P4MDOUT Enums (Port 4 Output Mode @ 0xAE)
2199      =2  //------------------------------------------------------------------------------
2200      =2  #define P4MDOUT_B0__BMASK      0x01 ///< Port 4 Bit 0 Output Mode  
2201      =2  #define P4MDOUT_B0__SHIFT      0x00 ///< Port 4 Bit 0 Output Mode  
2202      =2  #define P4MDOUT_B0__OPEN_DRAIN 0x00 ///< P4.0 output is open-drain.
2203      =2  #define P4MDOUT_B0__PUSH_PULL  0x01 ///< P4.0 output is push-pull. 
2204      =2                                                                     
2205      =2  #define P4MDOUT_B1__BMASK      0x02 ///< Port 4 Bit 1 Output Mode  
2206      =2  #define P4MDOUT_B1__SHIFT      0x01 ///< Port 4 Bit 1 Output Mode  
2207      =2  #define P4MDOUT_B1__OPEN_DRAIN 0x00 ///< P4.1 output is open-drain.
2208      =2  #define P4MDOUT_B1__PUSH_PULL  0x02 ///< P4.1 output is push-pull. 
2209      =2                                                                     
2210      =2  #define P4MDOUT_B2__BMASK      0x04 ///< Port 4 Bit 2 Output Mode  
2211      =2  #define P4MDOUT_B2__SHIFT      0x02 ///< Port 4 Bit 2 Output Mode  
2212      =2  #define P4MDOUT_B2__OPEN_DRAIN 0x00 ///< P4.2 output is open-drain.
2213      =2  #define P4MDOUT_B2__PUSH_PULL  0x04 ///< P4.2 output is push-pull. 
2214      =2                                                                     
2215      =2  #define P4MDOUT_B3__BMASK      0x08 ///< Port 4 Bit 3 Output Mode  
2216      =2  #define P4MDOUT_B3__SHIFT      0x03 ///< Port 4 Bit 3 Output Mode  
2217      =2  #define P4MDOUT_B3__OPEN_DRAIN 0x00 ///< P4.3 output is open-drain.
2218      =2  #define P4MDOUT_B3__PUSH_PULL  0x08 ///< P4.3 output is push-pull. 
2219      =2                                                                     
2220      =2  #define P4MDOUT_B4__BMASK      0x10 ///< Port 4 Bit 4 Output Mode  
2221      =2  #define P4MDOUT_B4__SHIFT      0x04 ///< Port 4 Bit 4 Output Mode  
2222      =2  #define P4MDOUT_B4__OPEN_DRAIN 0x00 ///< P4.4 output is open-drain.
2223      =2  #define P4MDOUT_B4__PUSH_PULL  0x10 ///< P4.4 output is push-pull. 
2224      =2                                                                     
2225      =2  #define P4MDOUT_B5__BMASK      0x20 ///< Port 4 Bit 5 Output Mode  
2226      =2  #define P4MDOUT_B5__SHIFT      0x05 ///< Port 4 Bit 5 Output Mode  
2227      =2  #define P4MDOUT_B5__OPEN_DRAIN 0x00 ///< P4.5 output is open-drain.
2228      =2  #define P4MDOUT_B5__PUSH_PULL  0x20 ///< P4.5 output is push-pull. 
2229      =2                                                                     
2230      =2  #define P4MDOUT_B6__BMASK      0x40 ///< Port 4 Bit 6 Output Mode  
2231      =2  #define P4MDOUT_B6__SHIFT      0x06 ///< Port 4 Bit 6 Output Mode  
2232      =2  #define P4MDOUT_B6__OPEN_DRAIN 0x00 ///< P4.6 output is open-drain.
2233      =2  #define P4MDOUT_B6__PUSH_PULL  0x40 ///< P4.6 output is push-pull. 
2234      =2                                                                     
2235      =2  #define P4MDOUT_B7__BMASK      0x80 ///< Port 4 Bit 7 Output Mode  
2236      =2  #define P4MDOUT_B7__SHIFT      0x07 ///< Port 4 Bit 7 Output Mode  
2237      =2  #define P4MDOUT_B7__OPEN_DRAIN 0x00 ///< P4.7 output is open-drain.
2238      =2  #define P4MDOUT_B7__PUSH_PULL  0x80 ///< P4.7 output is push-pull. 
2239      =2                                                                     
2240      =2  //------------------------------------------------------------------------------
2241      =2  // RSTSRC Enums (Reset Source @ 0xEF)
2242      =2  //------------------------------------------------------------------------------
2243      =2  #define RSTSRC_PINRSF__BMASK   0x01 ///< HW Pin Reset Flag                                                
C51 COMPILER V9.56.0.0   I2C_0                                                             10/28/2016 17:37:02 PAGE 63  

             -    
2244      =2  #define RSTSRC_PINRSF__SHIFT   0x00 ///< HW Pin Reset Flag                                                
             -    
2245      =2  #define RSTSRC_PINRSF__NOT_SET 0x00 ///< The RSTb pin did not cause the last reset.                       
             -    
2246      =2  #define RSTSRC_PINRSF__SET     0x01 ///< The RSTb pin caused the last reset.                              
             -    
2247      =2                                                                                                            
             -    
2248      =2  #define RSTSRC_PORSF__BMASK    0x02 ///< Power-On / Supply Monitor Reset Flag, and Supply Monitor Reset En
             -able
2249      =2  #define RSTSRC_PORSF__SHIFT    0x01 ///< Power-On / Supply Monitor Reset Flag, and Supply Monitor Reset En
             -able
2250      =2  #define RSTSRC_PORSF__NOT_SET  0x00 ///< A power-on or supply monitor reset did not occur.                
             -    
2251      =2  #define RSTSRC_PORSF__SET      0x02 ///< A power-on or supply monitor reset occurred.                     
             -    
2252      =2                                                                                                            
             -    
2253      =2  #define RSTSRC_MCDRSF__BMASK   0x04 ///< Missing Clock Detector Enable and Flag                           
             -    
2254      =2  #define RSTSRC_MCDRSF__SHIFT   0x02 ///< Missing Clock Detector Enable and Flag                           
             -    
2255      =2  #define RSTSRC_MCDRSF__NOT_SET 0x00 ///< A missing clock detector reset did not occur.                    
             -    
2256      =2  #define RSTSRC_MCDRSF__SET     0x04 ///< A missing clock detector reset occurred.                         
             -    
2257      =2                                                                                                            
             -    
2258      =2  #define RSTSRC_WDTRSF__BMASK   0x08 ///< Watchdog Timer Reset Flag                                        
             -    
2259      =2  #define RSTSRC_WDTRSF__SHIFT   0x03 ///< Watchdog Timer Reset Flag                                        
             -    
2260      =2  #define RSTSRC_WDTRSF__NOT_SET 0x00 ///< A watchdog timer overflow reset did not occur.                   
             -    
2261      =2  #define RSTSRC_WDTRSF__SET     0x08 ///< A watchdog timer overflow reset occurred.                        
             -    
2262      =2                                                                                                            
             -    
2263      =2  #define RSTSRC_SWRSF__BMASK    0x10 ///< Software Reset Force and Flag                                    
             -    
2264      =2  #define RSTSRC_SWRSF__SHIFT    0x04 ///< Software Reset Force and Flag                                    
             -    
2265      =2  #define RSTSRC_SWRSF__NOT_SET  0x00 ///< A software reset did not occur.                                  
             -    
2266      =2  #define RSTSRC_SWRSF__SET      0x10 ///< A software reset occurred.                                       
             -    
2267      =2                                                                                                            
             -    
2268      =2  #define RSTSRC_C0RSEF__BMASK   0x20 ///< Comparator0 Reset Enable and Flag                                
             -    
2269      =2  #define RSTSRC_C0RSEF__SHIFT   0x05 ///< Comparator0 Reset Enable and Flag                                
             -    
2270      =2  #define RSTSRC_C0RSEF__NOT_SET 0x00 ///< A Comparator 0 reset did not occur.                              
             -    
2271      =2  #define RSTSRC_C0RSEF__SET     0x20 ///< A Comparator 0 reset occurred.                                   
             -    
2272      =2                                                                                                            
             -    
2273      =2  #define RSTSRC_FERROR__BMASK   0x40 ///< Flash Error Reset Flag                                           
             -    
2274      =2  #define RSTSRC_FERROR__SHIFT   0x06 ///< Flash Error Reset Flag                                           
C51 COMPILER V9.56.0.0   I2C_0                                                             10/28/2016 17:37:02 PAGE 64  

             -    
2275      =2  #define RSTSRC_FERROR__NOT_SET 0x00 ///< A flash error reset did not occur.                               
             -    
2276      =2  #define RSTSRC_FERROR__SET     0x40 ///< A flash error reset occurred.                                    
             -    
2277      =2                                                                                                            
             -    
2278      =2  #define RSTSRC_USBRSF__BMASK   0x80 ///< USB Reset Enable and Flag                                        
             -    
2279      =2  #define RSTSRC_USBRSF__SHIFT   0x07 ///< USB Reset Enable and Flag                                        
             -    
2280      =2  #define RSTSRC_USBRSF__NOT_SET 0x00 ///< A USB0 reset did not occur.                                      
             -    
2281      =2  #define RSTSRC_USBRSF__SET     0x80 ///< A USB0 reset occurred.                                           
             -    
2282      =2                                                                                                            
             -    
2283      =2  //------------------------------------------------------------------------------
2284      =2  // SFRPAGE Enums (SFR Page @ 0xBF)
2285      =2  //------------------------------------------------------------------------------
2286      =2  #define SFRPAGE_SFRPAGE__FMASK 0xFF ///< SFR Page
2287      =2  #define SFRPAGE_SFRPAGE__SHIFT 0x00 ///< SFR Page
2288      =2                                                   
2289      =2  //------------------------------------------------------------------------------
2290      =2  // SMB0ADM Enums (SMBus 0 Slave Address Mask @ 0xCE)
2291      =2  //------------------------------------------------------------------------------
2292      =2  #define SMB0ADM_EHACK__BMASK             0x01 ///< Hardware Acknowledge Enable                     
2293      =2  #define SMB0ADM_EHACK__SHIFT             0x00 ///< Hardware Acknowledge Enable                     
2294      =2  #define SMB0ADM_EHACK__ADR_ACK_MANUAL    0x00 ///< Firmware must manually acknowledge all incoming 
2295      =2                                                ///< address and data bytes.                         
2296      =2  #define SMB0ADM_EHACK__ADR_ACK_AUTOMATIC 0x01 ///< Automatic slave address recognition and hardware
2297      =2                                                ///< acknowledge is enabled.                         
2298      =2                                                                                                     
2299      =2  #define SMB0ADM_SLVM__FMASK              0xFE ///< SMBus Slave Address Mask                        
2300      =2  #define SMB0ADM_SLVM__SHIFT              0x01 ///< SMBus Slave Address Mask                        
2301      =2                                                                                                     
2302      =2  //------------------------------------------------------------------------------
2303      =2  // SMB0ADR Enums (SMBus 0 Slave Address @ 0xCF)
2304      =2  //------------------------------------------------------------------------------
2305      =2  #define SMB0ADR_GC__BMASK      0x01 ///< General Call Address Enable        
2306      =2  #define SMB0ADR_GC__SHIFT      0x00 ///< General Call Address Enable        
2307      =2  #define SMB0ADR_GC__IGNORED    0x00 ///< General Call Address is ignored.   
2308      =2  #define SMB0ADR_GC__RECOGNIZED 0x01 ///< General Call Address is recognized.
2309      =2                                                                              
2310      =2  #define SMB0ADR_SLV__FMASK     0xFE ///< SMBus Hardware Slave Address       
2311      =2  #define SMB0ADR_SLV__SHIFT     0x01 ///< SMBus Hardware Slave Address       
2312      =2                                                                              
2313      =2  //------------------------------------------------------------------------------
2314      =2  // SMB0CF Enums (SMBus 0 Configuration @ 0xC1)
2315      =2  //------------------------------------------------------------------------------
2316      =2  #define SMB0CF_SMBCS__FMASK             0x03 ///< SMBus Clock Source Selection                     
2317      =2  #define SMB0CF_SMBCS__SHIFT             0x00 ///< SMBus Clock Source Selection                     
2318      =2  #define SMB0CF_SMBCS__TIMER0            0x00 ///< Timer 0 Overflow.                                
2319      =2  #define SMB0CF_SMBCS__TIMER1            0x01 ///< Timer 1 Overflow.                                
2320      =2  #define SMB0CF_SMBCS__TIMER2_HIGH       0x02 ///< Timer 2 High Byte Overflow.                      
2321      =2  #define SMB0CF_SMBCS__TIMER2_LOW        0x03 ///< Timer 2 Low Byte Overflow.                       
2322      =2                                                                                                     
2323      =2  #define SMB0CF_SMBFTE__BMASK            0x04 ///< SMBus Free Timeout Detection Enable              
2324      =2  #define SMB0CF_SMBFTE__SHIFT            0x02 ///< SMBus Free Timeout Detection Enable              
2325      =2  #define SMB0CF_SMBFTE__FREE_TO_DISABLED 0x00 ///< Disable bus free timeouts.                       
2326      =2  #define SMB0CF_SMBFTE__FREE_TO_ENABLED  0x04 ///< Enable bus free timeouts. The bus the bus will be
2327      =2                                               ///< considered free if SCL and SDA remain high for   
C51 COMPILER V9.56.0.0   I2C_0                                                             10/28/2016 17:37:02 PAGE 65  

2328      =2                                               ///< more than 10 SMBus clock source periods.         
2329      =2                                                                                                     
2330      =2  #define SMB0CF_SMBTOE__BMASK            0x08 ///< SMBus SCL Timeout Detection Enable               
2331      =2  #define SMB0CF_SMBTOE__SHIFT            0x03 ///< SMBus SCL Timeout Detection Enable               
2332      =2  #define SMB0CF_SMBTOE__SCL_TO_DISABLED  0x00 ///< Disable SCL low timeouts.                        
2333      =2  #define SMB0CF_SMBTOE__SCL_TO_ENABLED   0x08 ///< Enable SCL low timeouts.                         
2334      =2                                                                                                     
2335      =2  #define SMB0CF_EXTHOLD__BMASK           0x10 ///< SMBus Setup and Hold Time Extension Enable       
2336      =2  #define SMB0CF_EXTHOLD__SHIFT           0x04 ///< SMBus Setup and Hold Time Extension Enable       
2337      =2  #define SMB0CF_EXTHOLD__DISABLED        0x00 ///< Disable SDA extended setup and hold times.       
2338      =2  #define SMB0CF_EXTHOLD__ENABLED         0x10 ///< Enable SDA extended setup and hold times.        
2339      =2                                                                                                     
2340      =2  #define SMB0CF_BUSY__BMASK              0x20 ///< SMBus Busy Indicator                             
2341      =2  #define SMB0CF_BUSY__SHIFT              0x05 ///< SMBus Busy Indicator                             
2342      =2  #define SMB0CF_BUSY__NOT_SET            0x00 ///< The bus is not busy.                             
2343      =2  #define SMB0CF_BUSY__SET                0x20 ///< The bus is busy and a transfer is currently in   
2344      =2                                               ///< progress.                                        
2345      =2                                                                                                     
2346      =2  #define SMB0CF_INH__BMASK               0x40 ///< SMBus Slave Inhibit                              
2347      =2  #define SMB0CF_INH__SHIFT               0x06 ///< SMBus Slave Inhibit                              
2348      =2  #define SMB0CF_INH__SLAVE_ENABLED       0x00 ///< Slave states are enabled.                        
2349      =2  #define SMB0CF_INH__SLAVE_DISABLED      0x40 ///< Slave states are inhibited.                      
2350      =2                                                                                                     
2351      =2  #define SMB0CF_ENSMB__BMASK             0x80 ///< SMBus Enable                                     
2352      =2  #define SMB0CF_ENSMB__SHIFT             0x07 ///< SMBus Enable                                     
2353      =2  #define SMB0CF_ENSMB__DISABLED          0x00 ///< Disable the SMBus module.                        
2354      =2  #define SMB0CF_ENSMB__ENABLED           0x80 ///< Enable the SMBus module.                         
2355      =2                                                                                                     
2356      =2  //------------------------------------------------------------------------------
2357      =2  // SMB0CN0 Enums (SMBus 0 Control @ 0xC0)
2358      =2  //------------------------------------------------------------------------------
2359      =2  #define SMB0CN0_SI__BMASK           0x01 ///< SMBus Interrupt Flag                           
2360      =2  #define SMB0CN0_SI__SHIFT           0x00 ///< SMBus Interrupt Flag                           
2361      =2  #define SMB0CN0_SI__NOT_SET         0x00 ///<                                                
2362      =2  #define SMB0CN0_SI__SET             0x01 ///<                                                
2363      =2                                                                                               
2364      =2  #define SMB0CN0_ACK__BMASK          0x02 ///< SMBus Acknowledge                              
2365      =2  #define SMB0CN0_ACK__SHIFT          0x01 ///< SMBus Acknowledge                              
2366      =2  #define SMB0CN0_ACK__NOT_SET        0x00 ///< Generate a NACK, or the response was a NACK.   
2367      =2  #define SMB0CN0_ACK__SET            0x02 ///< Generate an ACK, or the response was an ACK.   
2368      =2                                                                                               
2369      =2  #define SMB0CN0_ARBLOST__BMASK      0x04 ///< SMBus Arbitration Lost Indicator               
2370      =2  #define SMB0CN0_ARBLOST__SHIFT      0x02 ///< SMBus Arbitration Lost Indicator               
2371      =2  #define SMB0CN0_ARBLOST__NOT_SET    0x00 ///< No arbitration error.                          
2372      =2  #define SMB0CN0_ARBLOST__ERROR      0x04 ///< Arbitration error occurred.                    
2373      =2                                                                                               
2374      =2  #define SMB0CN0_ACKRQ__BMASK        0x08 ///< SMBus Acknowledge Request                      
2375      =2  #define SMB0CN0_ACKRQ__SHIFT        0x03 ///< SMBus Acknowledge Request                      
2376      =2  #define SMB0CN0_ACKRQ__NOT_SET      0x00 ///< No ACK requested.                              
2377      =2  #define SMB0CN0_ACKRQ__REQUESTED    0x08 ///< ACK requested.                                 
2378      =2                                                                                               
2379      =2  #define SMB0CN0_STO__BMASK          0x10 ///< SMBus Stop Flag                                
2380      =2  #define SMB0CN0_STO__SHIFT          0x04 ///< SMBus Stop Flag                                
2381      =2  #define SMB0CN0_STO__NOT_SET        0x00 ///< A STOP is not pending.                         
2382      =2  #define SMB0CN0_STO__SET            0x10 ///< Generate a STOP or a STOP is currently pending.
2383      =2                                                                                               
2384      =2  #define SMB0CN0_STA__BMASK          0x20 ///< SMBus Start Flag                               
2385      =2  #define SMB0CN0_STA__SHIFT          0x05 ///< SMBus Start Flag                               
2386      =2  #define SMB0CN0_STA__NOT_SET        0x00 ///< A START was not detected.                      
2387      =2  #define SMB0CN0_STA__SET            0x20 ///< Generate a START, repeated START, or a START is
2388      =2                                           ///< currently pending.                             
2389      =2                                                                                               
C51 COMPILER V9.56.0.0   I2C_0                                                             10/28/2016 17:37:02 PAGE 66  

2390      =2  #define SMB0CN0_TXMODE__BMASK       0x40 ///< SMBus Transmit Mode Indicator                  
2391      =2  #define SMB0CN0_TXMODE__SHIFT       0x06 ///< SMBus Transmit Mode Indicator                  
2392      =2  #define SMB0CN0_TXMODE__RECEIVER    0x00 ///< SMBus in Receiver Mode.                        
2393      =2  #define SMB0CN0_TXMODE__TRANSMITTER 0x40 ///< SMBus in Transmitter Mode.                     
2394      =2                                                                                               
2395      =2  #define SMB0CN0_MASTER__BMASK       0x80 ///< SMBus Master/Slave Indicator                   
2396      =2  #define SMB0CN0_MASTER__SHIFT       0x07 ///< SMBus Master/Slave Indicator                   
2397      =2  #define SMB0CN0_MASTER__SLAVE       0x00 ///< SMBus operating in slave mode.                 
2398      =2  #define SMB0CN0_MASTER__MASTER      0x80 ///< SMBus operating in master mode.                
2399      =2                                                                                               
2400      =2  //------------------------------------------------------------------------------
2401      =2  // SMB0DAT Enums (SMBus 0 Data @ 0xC2)
2402      =2  //------------------------------------------------------------------------------
2403      =2  #define SMB0DAT_SMB0DAT__FMASK 0xFF ///< SMBus 0 Data
2404      =2  #define SMB0DAT_SMB0DAT__SHIFT 0x00 ///< SMBus 0 Data
2405      =2                                                       
2406      =2  //------------------------------------------------------------------------------
2407      =2  // SMB1ADM Enums (SMBus 1 Slave Address Mask @ 0xCE)
2408      =2  //------------------------------------------------------------------------------
2409      =2  #define SMB1ADM_EHACK__BMASK             0x01 ///< Hardware Acknowledge Enable                     
2410      =2  #define SMB1ADM_EHACK__SHIFT             0x00 ///< Hardware Acknowledge Enable                     
2411      =2  #define SMB1ADM_EHACK__ADR_ACK_MANUAL    0x00 ///< Firmware must manually acknowledge all incoming 
2412      =2                                                ///< address and data bytes.                         
2413      =2  #define SMB1ADM_EHACK__ADR_ACK_AUTOMATIC 0x01 ///< Automatic slave address recognition and hardware
2414      =2                                                ///< acknowledge is enabled.                         
2415      =2                                                                                                     
2416      =2  #define SMB1ADM_SLVM__FMASK              0xFE ///< SMBus Slave Address Mask                        
2417      =2  #define SMB1ADM_SLVM__SHIFT              0x01 ///< SMBus Slave Address Mask                        
2418      =2                                                                                                     
2419      =2  //------------------------------------------------------------------------------
2420      =2  // SMB1ADR Enums (SMBus 1 Slave Address @ 0xCF)
2421      =2  //------------------------------------------------------------------------------
2422      =2  #define SMB1ADR_GC__BMASK      0x01 ///< General Call Address Enable        
2423      =2  #define SMB1ADR_GC__SHIFT      0x00 ///< General Call Address Enable        
2424      =2  #define SMB1ADR_GC__IGNORED    0x00 ///< General Call Address is ignored.   
2425      =2  #define SMB1ADR_GC__RECOGNIZED 0x01 ///< General Call Address is recognized.
2426      =2                                                                              
2427      =2  #define SMB1ADR_SLV__FMASK     0xFE ///< SMBus Hardware Slave Address       
2428      =2  #define SMB1ADR_SLV__SHIFT     0x01 ///< SMBus Hardware Slave Address       
2429      =2                                                                              
2430      =2  //------------------------------------------------------------------------------
2431      =2  // SMB1CF Enums (SMBus 1 Configuration @ 0xC1)
2432      =2  //------------------------------------------------------------------------------
2433      =2  #define SMB1CF_SMBCS__FMASK             0x03 ///< SMBus Clock Source Selection                     
2434      =2  #define SMB1CF_SMBCS__SHIFT             0x00 ///< SMBus Clock Source Selection                     
2435      =2  #define SMB1CF_SMBCS__TIMER0            0x00 ///< Timer 0 Overflow.                                
2436      =2  #define SMB1CF_SMBCS__TIMER5            0x01 ///< Timer 5 Overflow.                                
2437      =2  #define SMB1CF_SMBCS__TIMER2_HIGH       0x02 ///< Timer 2 High Byte Overflow.                      
2438      =2  #define SMB1CF_SMBCS__TIMER2_LOW        0x03 ///< Timer 2 Low Byte Overflow.                       
2439      =2                                                                                                     
2440      =2  #define SMB1CF_SMBFTE__BMASK            0x04 ///< SMBus Free Timeout Detection Enable              
2441      =2  #define SMB1CF_SMBFTE__SHIFT            0x02 ///< SMBus Free Timeout Detection Enable              
2442      =2  #define SMB1CF_SMBFTE__FREE_TO_DISABLED 0x00 ///< Disable bus free timeouts.                       
2443      =2  #define SMB1CF_SMBFTE__FREE_TO_ENABLED  0x04 ///< Enable bus free timeouts. The bus the bus will be
2444      =2                                               ///< considered free if SCL and SDA remain high for   
2445      =2                                               ///< more than 10 SMBus clock source periods.         
2446      =2                                                                                                     
2447      =2  #define SMB1CF_SMBTOE__BMASK            0x08 ///< SMBus SCL Timeout Detection Enable               
2448      =2  #define SMB1CF_SMBTOE__SHIFT            0x03 ///< SMBus SCL Timeout Detection Enable               
2449      =2  #define SMB1CF_SMBTOE__SCL_TO_DISABLED  0x00 ///< Disable SCL low timeouts.                        
2450      =2  #define SMB1CF_SMBTOE__SCL_TO_ENABLED   0x08 ///< Enable SCL low timeouts.                         
2451      =2                                                                                                     
C51 COMPILER V9.56.0.0   I2C_0                                                             10/28/2016 17:37:02 PAGE 67  

2452      =2  #define SMB1CF_EXTHOLD__BMASK           0x10 ///< SMBus Setup and Hold Time Extension Enable       
2453      =2  #define SMB1CF_EXTHOLD__SHIFT           0x04 ///< SMBus Setup and Hold Time Extension Enable       
2454      =2  #define SMB1CF_EXTHOLD__DISABLED        0x00 ///< Disable SDA extended setup and hold times.       
2455      =2  #define SMB1CF_EXTHOLD__ENABLED         0x10 ///< Enable SDA extended setup and hold times.        
2456      =2                                                                                                     
2457      =2  #define SMB1CF_BUSY__BMASK              0x20 ///< SMBus Busy Indicator                             
2458      =2  #define SMB1CF_BUSY__SHIFT              0x05 ///< SMBus Busy Indicator                             
2459      =2  #define SMB1CF_BUSY__NOT_SET            0x00 ///< The bus is not busy.                             
2460      =2  #define SMB1CF_BUSY__SET                0x20 ///< The bus is busy and a transfer is currently in   
2461      =2                                               ///< progress.                                        
2462      =2                                                                                                     
2463      =2  #define SMB1CF_INH__BMASK               0x40 ///< SMBus Slave Inhibit                              
2464      =2  #define SMB1CF_INH__SHIFT               0x06 ///< SMBus Slave Inhibit                              
2465      =2  #define SMB1CF_INH__SLAVE_ENABLED       0x00 ///< Slave states are enabled.                        
2466      =2  #define SMB1CF_INH__SLAVE_DISABLED      0x40 ///< Slave states are inhibited.                      
2467      =2                                                                                                     
2468      =2  #define SMB1CF_ENSMB__BMASK             0x80 ///< SMBus Enable                                     
2469      =2  #define SMB1CF_ENSMB__SHIFT             0x07 ///< SMBus Enable                                     
2470      =2  #define SMB1CF_ENSMB__DISABLED          0x00 ///< Disable the SMBus module.                        
2471      =2  #define SMB1CF_ENSMB__ENABLED           0x80 ///< Enable the SMBus module.                         
2472      =2                                                                                                     
2473      =2  //------------------------------------------------------------------------------
2474      =2  // SMB1CN0 Enums (SMBus 1 Control @ 0xC0)
2475      =2  //------------------------------------------------------------------------------
2476      =2  #define SMB1CN0_SI__BMASK           0x01 ///< SMBus Interrupt Flag                           
2477      =2  #define SMB1CN0_SI__SHIFT           0x00 ///< SMBus Interrupt Flag                           
2478      =2  #define SMB1CN0_SI__NOT_SET         0x00 ///<                                                
2479      =2  #define SMB1CN0_SI__SET             0x01 ///<                                                
2480      =2                                                                                               
2481      =2  #define SMB1CN0_ACK__BMASK          0x02 ///< SMBus Acknowledge                              
2482      =2  #define SMB1CN0_ACK__SHIFT          0x01 ///< SMBus Acknowledge                              
2483      =2  #define SMB1CN0_ACK__NOT_SET        0x00 ///< Generate a NACK, or the response was a NACK.   
2484      =2  #define SMB1CN0_ACK__SET            0x02 ///< Generate an ACK, or the response was an ACK.   
2485      =2                                                                                               
2486      =2  #define SMB1CN0_ARBLOST__BMASK      0x04 ///< SMBus Arbitration Lost Indicator               
2487      =2  #define SMB1CN0_ARBLOST__SHIFT      0x02 ///< SMBus Arbitration Lost Indicator               
2488      =2  #define SMB1CN0_ARBLOST__NOT_SET    0x00 ///< No arbitration error.                          
2489      =2  #define SMB1CN0_ARBLOST__ERROR      0x04 ///< Arbitration error occurred.                    
2490      =2                                                                                               
2491      =2  #define SMB1CN0_ACKRQ__BMASK        0x08 ///< SMBus Acknowledge Request                      
2492      =2  #define SMB1CN0_ACKRQ__SHIFT        0x03 ///< SMBus Acknowledge Request                      
2493      =2  #define SMB1CN0_ACKRQ__NOT_SET      0x00 ///< No ACK requested.                              
2494      =2  #define SMB1CN0_ACKRQ__REQUESTED    0x08 ///< ACK requested.                                 
2495      =2                                                                                               
2496      =2  #define SMB1CN0_STO__BMASK          0x10 ///< SMBus Stop Flag                                
2497      =2  #define SMB1CN0_STO__SHIFT          0x04 ///< SMBus Stop Flag                                
2498      =2  #define SMB1CN0_STO__NOT_SET        0x00 ///< A STOP is not pending.                         
2499      =2  #define SMB1CN0_STO__SET            0x10 ///< Generate a STOP or a STOP is currently pending.
2500      =2                                                                                               
2501      =2  #define SMB1CN0_STA__BMASK          0x20 ///< SMBus Start Flag                               
2502      =2  #define SMB1CN0_STA__SHIFT          0x05 ///< SMBus Start Flag                               
2503      =2  #define SMB1CN0_STA__NOT_SET        0x00 ///< A START was not detected.                      
2504      =2  #define SMB1CN0_STA__SET            0x20 ///< Generate a START, repeated START, or a START is
2505      =2                                           ///< currently pending.                             
2506      =2                                                                                               
2507      =2  #define SMB1CN0_TXMODE__BMASK       0x40 ///< SMBus Transmit Mode Indicator                  
2508      =2  #define SMB1CN0_TXMODE__SHIFT       0x06 ///< SMBus Transmit Mode Indicator                  
2509      =2  #define SMB1CN0_TXMODE__RECEIVER    0x00 ///< SMBus in Receiver Mode.                        
2510      =2  #define SMB1CN0_TXMODE__TRANSMITTER 0x40 ///< SMBus in Transmitter Mode.                     
2511      =2                                                                                               
2512      =2  #define SMB1CN0_MASTER__BMASK       0x80 ///< SMBus Master/Slave Indicator                   
2513      =2  #define SMB1CN0_MASTER__SHIFT       0x07 ///< SMBus Master/Slave Indicator                   
C51 COMPILER V9.56.0.0   I2C_0                                                             10/28/2016 17:37:02 PAGE 68  

2514      =2  #define SMB1CN0_MASTER__SLAVE       0x00 ///< SMBus operating in slave mode.                 
2515      =2  #define SMB1CN0_MASTER__MASTER      0x80 ///< SMBus operating in master mode.                
2516      =2                                                                                               
2517      =2  //------------------------------------------------------------------------------
2518      =2  // SMB1DAT Enums (SMBus 1 Data @ 0xC2)
2519      =2  //------------------------------------------------------------------------------
2520      =2  #define SMB1DAT_SMB1DAT__FMASK 0xFF ///< SMBus 1 Data
2521      =2  #define SMB1DAT_SMB1DAT__SHIFT 0x00 ///< SMBus 1 Data
2522      =2                                                       
2523      =2  //------------------------------------------------------------------------------
2524      =2  // SMBTC Enums (SMBus Timing and Pin Control @ 0xB9)
2525      =2  //------------------------------------------------------------------------------
2526      =2  #define SMBTC_SMB0SDD__FMASK         0x03 ///< SMBus 0 Start Detection Window                   
2527      =2  #define SMBTC_SMB0SDD__SHIFT         0x00 ///< SMBus 0 Start Detection Window                   
2528      =2  #define SMBTC_SMB0SDD__NONE          0x00 ///< No additional hold time window (0-1 SYSCLK).     
2529      =2  #define SMBTC_SMB0SDD__ADD_2_SYSCLKS 0x01 ///< Increase hold time window to 2-3 SYSCLKs.        
2530      =2  #define SMBTC_SMB0SDD__ADD_4_SYSCLKS 0x02 ///< Increase hold time window to 4-5 SYSCLKs.        
2531      =2  #define SMBTC_SMB0SDD__ADD_8_SYSCLKS 0x03 ///< Increase hold time window to 8-9 SYSCLKs.        
2532      =2                                                                                                  
2533      =2  #define SMBTC_SMB1SDD__FMASK         0x0C ///< SMBus 1 Start Detection Window                   
2534      =2  #define SMBTC_SMB1SDD__SHIFT         0x02 ///< SMBus 1 Start Detection Window                   
2535      =2  #define SMBTC_SMB1SDD__NONE          0x00 ///< No additional hold time requirement (0-1 SYSCLK).
2536      =2  #define SMBTC_SMB1SDD__ADD_2_SYSCLKS 0x04 ///< Increase hold time window to 2-3 SYSCLKs.        
2537      =2  #define SMBTC_SMB1SDD__ADD_4_SYSCLKS 0x08 ///< Increase hold time window to 4-5 SYSCLKs.        
2538      =2  #define SMBTC_SMB1SDD__ADD_8_SYSCLKS 0x0C ///< Increase hold time window to 8-9 SYSCLKs.        
2539      =2                                                                                                  
2540      =2  //------------------------------------------------------------------------------
2541      =2  // SPI0CFG Enums (SPI0 Configuration @ 0xA1)
2542      =2  //------------------------------------------------------------------------------
2543      =2  #define SPI0CFG_RXBMT__BMASK                0x01 ///< Receive Buffer Empty                              
2544      =2  #define SPI0CFG_RXBMT__SHIFT                0x00 ///< Receive Buffer Empty                              
2545      =2  #define SPI0CFG_RXBMT__NOT_SET              0x00 ///< New data is available in the receive buffer (Slave
2546      =2                                                   ///< mode).                                            
2547      =2  #define SPI0CFG_RXBMT__SET                  0x01 ///< No new data in the receive buffer (Slave mode).   
2548      =2                                                                                                          
2549      =2  #define SPI0CFG_SRMT__BMASK                 0x02 ///< Shift Register Empty                              
2550      =2  #define SPI0CFG_SRMT__SHIFT                 0x01 ///< Shift Register Empty                              
2551      =2  #define SPI0CFG_SRMT__NOT_SET               0x00 ///< The shift register is not empty.                  
2552      =2  #define SPI0CFG_SRMT__SET                   0x02 ///< The shift register is empty.                      
2553      =2                                                                                                          
2554      =2  #define SPI0CFG_NSSIN__BMASK                0x04 ///< NSS Instantaneous Pin Input                       
2555      =2  #define SPI0CFG_NSSIN__SHIFT                0x02 ///< NSS Instantaneous Pin Input                       
2556      =2  #define SPI0CFG_NSSIN__LOW                  0x00 ///< The NSS pin is low.                               
2557      =2  #define SPI0CFG_NSSIN__HIGH                 0x04 ///< The NSS pin is high.                              
2558      =2                                                                                                          
2559      =2  #define SPI0CFG_SLVSEL__BMASK               0x08 ///< Slave Selected Flag                               
2560      =2  #define SPI0CFG_SLVSEL__SHIFT               0x03 ///< Slave Selected Flag                               
2561      =2  #define SPI0CFG_SLVSEL__NOT_SELECTED        0x00 ///< The Slave is not selected (NSS is high).          
2562      =2  #define SPI0CFG_SLVSEL__SELECTED            0x08 ///< The Slave is selected (NSS is low).               
2563      =2                                                                                                          
2564      =2  #define SPI0CFG_CKPOL__BMASK                0x10 ///< SPI0 Clock Polarity                               
2565      =2  #define SPI0CFG_CKPOL__SHIFT                0x04 ///< SPI0 Clock Polarity                               
2566      =2  #define SPI0CFG_CKPOL__IDLE_LOW             0x00 ///< SCK line low in idle state.                       
2567      =2  #define SPI0CFG_CKPOL__IDLE_HIGH            0x10 ///< SCK line high in idle state.                      
2568      =2                                                                                                          
2569      =2  #define SPI0CFG_CKPHA__BMASK                0x20 ///< SPI0 Clock Phase                                  
2570      =2  #define SPI0CFG_CKPHA__SHIFT                0x05 ///< SPI0 Clock Phase                                  
2571      =2  #define SPI0CFG_CKPHA__DATA_CENTERED_FIRST  0x00 ///< Data centered on first edge of SCK period.        
2572      =2  #define SPI0CFG_CKPHA__DATA_CENTERED_SECOND 0x20 ///< Data centered on second edge of SCK period.       
2573      =2                                                                                                          
2574      =2  #define SPI0CFG_MSTEN__BMASK                0x40 ///< Master Mode Enable                                
2575      =2  #define SPI0CFG_MSTEN__SHIFT                0x06 ///< Master Mode Enable                                
C51 COMPILER V9.56.0.0   I2C_0                                                             10/28/2016 17:37:02 PAGE 69  

2576      =2  #define SPI0CFG_MSTEN__MASTER_DISABLED      0x00 ///< Disable master mode. Operate in slave mode.       
2577      =2  #define SPI0CFG_MSTEN__MASTER_ENABLED       0x40 ///< Enable master mode. Operate as a master.          
2578      =2                                                                                                          
2579      =2  #define SPI0CFG_SPIBSY__BMASK               0x80 ///< SPI Busy                                          
2580      =2  #define SPI0CFG_SPIBSY__SHIFT               0x07 ///< SPI Busy                                          
2581      =2  #define SPI0CFG_SPIBSY__NOT_SET             0x00 ///< A SPI transfer is not in progress.                
2582      =2  #define SPI0CFG_SPIBSY__SET                 0x80 ///< A SPI transfer is in progress.                    
2583      =2                                                                                                          
2584      =2  //------------------------------------------------------------------------------
2585      =2  // SPI0CKR Enums (SPI0 Clock Rate @ 0xA2)
2586      =2  //------------------------------------------------------------------------------
2587      =2  #define SPI0CKR_SPI0CKR__FMASK 0xFF ///< SPI0 Clock Rate
2588      =2  #define SPI0CKR_SPI0CKR__SHIFT 0x00 ///< SPI0 Clock Rate
2589      =2                                                          
2590      =2  //------------------------------------------------------------------------------
2591      =2  // SPI0CN0 Enums (SPI0 Control @ 0xF8)
2592      =2  //------------------------------------------------------------------------------
2593      =2  #define SPI0CN0_SPIEN__BMASK                  0x01 ///< SPI0 Enable                                       
2594      =2  #define SPI0CN0_SPIEN__SHIFT                  0x00 ///< SPI0 Enable                                       
2595      =2  #define SPI0CN0_SPIEN__DISABLED               0x00 ///< Disable the SPI module.                           
2596      =2  #define SPI0CN0_SPIEN__ENABLED                0x01 ///< Enable the SPI module.                            
2597      =2                                                                                                            
2598      =2  #define SPI0CN0_TXBMT__BMASK                  0x02 ///< Transmit Buffer Empty                             
2599      =2  #define SPI0CN0_TXBMT__SHIFT                  0x01 ///< Transmit Buffer Empty                             
2600      =2  #define SPI0CN0_TXBMT__NOT_SET                0x00 ///< The transmit buffer is not empty.                 
2601      =2  #define SPI0CN0_TXBMT__SET                    0x02 ///< The transmit buffer is empty.                     
2602      =2                                                                                                            
2603      =2  #define SPI0CN0_NSSMD__FMASK                  0x0C ///< Slave Select Mode                                 
2604      =2  #define SPI0CN0_NSSMD__SHIFT                  0x02 ///< Slave Select Mode                                 
2605      =2  #define SPI0CN0_NSSMD__3_WIRE                 0x00 ///< 3-Wire Slave or 3-Wire Master Mode. NSS signal is 
2606      =2                                                     ///< not routed to a port pin.                         
2607      =2  #define SPI0CN0_NSSMD__4_WIRE_SLAVE           0x04 ///< 4-Wire Slave or Multi-Master Mode. NSS is an input
2608      =2                                                     ///< to the device.                                    
2609      =2  #define SPI0CN0_NSSMD__4_WIRE_MASTER_NSS_LOW  0x08 ///< 4-Wire Single-Master Mode. NSS is an output and   
2610      =2                                                     ///< logic low.                                        
2611      =2  #define SPI0CN0_NSSMD__4_WIRE_MASTER_NSS_HIGH 0x0C ///< 4-Wire Single-Master Mode. NSS is an output and   
2612      =2                                                     ///< logic high.                                       
2613      =2                                                                                                            
2614      =2  #define SPI0CN0_RXOVRN__BMASK                 0x10 ///< Receive Overrun Flag                              
2615      =2  #define SPI0CN0_RXOVRN__SHIFT                 0x04 ///< Receive Overrun Flag                              
2616      =2  #define SPI0CN0_RXOVRN__NOT_SET               0x00 ///< A receive overrun did not occur.                  
2617      =2  #define SPI0CN0_RXOVRN__SET                   0x10 ///< A receive overrun occurred.                       
2618      =2                                                                                                            
2619      =2  #define SPI0CN0_MODF__BMASK                   0x20 ///< Mode Fault Flag                                   
2620      =2  #define SPI0CN0_MODF__SHIFT                   0x05 ///< Mode Fault Flag                                   
2621      =2  #define SPI0CN0_MODF__NOT_SET                 0x00 ///< A master collision did not occur.                 
2622      =2  #define SPI0CN0_MODF__SET                     0x20 ///< A master collision occurred.                      
2623      =2                                                                                                            
2624      =2  #define SPI0CN0_WCOL__BMASK                   0x40 ///< Write Collision Flag                              
2625      =2  #define SPI0CN0_WCOL__SHIFT                   0x06 ///< Write Collision Flag                              
2626      =2  #define SPI0CN0_WCOL__NOT_SET                 0x00 ///< A write collision did not occur.                  
2627      =2  #define SPI0CN0_WCOL__SET                     0x40 ///< A write collision occurred.                       
2628      =2                                                                                                            
2629      =2  #define SPI0CN0_SPIF__BMASK                   0x80 ///< SPI0 Interrupt Flag                               
2630      =2  #define SPI0CN0_SPIF__SHIFT                   0x07 ///< SPI0 Interrupt Flag                               
2631      =2  #define SPI0CN0_SPIF__NOT_SET                 0x00 ///< A data transfer has not completed since the last  
2632      =2                                                     ///< time SPIF was cleared.                            
2633      =2  #define SPI0CN0_SPIF__SET                     0x80 ///< A data transfer completed.                        
2634      =2                                                                                                            
2635      =2  //------------------------------------------------------------------------------
2636      =2  // SPI0DAT Enums (SPI0 Data @ 0xA3)
2637      =2  //------------------------------------------------------------------------------
C51 COMPILER V9.56.0.0   I2C_0                                                             10/28/2016 17:37:02 PAGE 70  

2638      =2  #define SPI0DAT_SPI0DAT__FMASK 0xFF ///< SPI0 Transmit and Receive Data
2639      =2  #define SPI0DAT_SPI0DAT__SHIFT 0x00 ///< SPI0 Transmit and Receive Data
2640      =2                                                                         
2641      =2  //------------------------------------------------------------------------------
2642      =2  // TH0 Enums (Timer 0 High Byte @ 0x8C)
2643      =2  //------------------------------------------------------------------------------
2644      =2  #define TH0_TH0__FMASK 0xFF ///< Timer 0 High Byte
2645      =2  #define TH0_TH0__SHIFT 0x00 ///< Timer 0 High Byte
2646      =2                                                    
2647      =2  //------------------------------------------------------------------------------
2648      =2  // TH1 Enums (Timer 1 High Byte @ 0x8D)
2649      =2  //------------------------------------------------------------------------------
2650      =2  #define TH1_TH1__FMASK 0xFF ///< Timer 1 High Byte
2651      =2  #define TH1_TH1__SHIFT 0x00 ///< Timer 1 High Byte
2652      =2                                                    
2653      =2  //------------------------------------------------------------------------------
2654      =2  // TL0 Enums (Timer 0 Low Byte @ 0x8A)
2655      =2  //------------------------------------------------------------------------------
2656      =2  #define TL0_TL0__FMASK 0xFF ///< Timer 0 Low Byte
2657      =2  #define TL0_TL0__SHIFT 0x00 ///< Timer 0 Low Byte
2658      =2                                                   
2659      =2  //------------------------------------------------------------------------------
2660      =2  // TL1 Enums (Timer 1 Low Byte @ 0x8B)
2661      =2  //------------------------------------------------------------------------------
2662      =2  #define TL1_TL1__FMASK 0xFF ///< Timer 1 Low Byte
2663      =2  #define TL1_TL1__SHIFT 0x00 ///< Timer 1 Low Byte
2664      =2                                                   
2665      =2  //------------------------------------------------------------------------------
2666      =2  // TMR2CN0 Enums (Timer 2 Control 0 @ 0xC8)
2667      =2  //------------------------------------------------------------------------------
2668      =2  #define TMR2CN0_T2XCLK__BMASK          0x01 ///< Timer 2 External Clock Select                    
2669      =2  #define TMR2CN0_T2XCLK__SHIFT          0x00 ///< Timer 2 External Clock Select                    
2670      =2  #define TMR2CN0_T2XCLK__SYSCLK_DIV_12  0x00 ///< Timer 2 clock is the system clock divided by 12. 
2671      =2  #define TMR2CN0_T2XCLK__EXTOSC_DIV_8   0x01 ///< Timer 2 clock is the external oscillator divided 
2672      =2                                              ///< by 8 (synchronized with SYSCLK).                 
2673      =2                                                                                                    
2674      =2  #define TMR2CN0_T2CSS__BMASK           0x02 ///< Timer 2 Capture Source Select                    
2675      =2  #define TMR2CN0_T2CSS__SHIFT           0x01 ///< Timer 2 Capture Source Select                    
2676      =2  #define TMR2CN0_T2CSS__USB_SOF_CAPTURE 0x00 ///< Capture source is USB SOF event.                 
2677      =2  #define TMR2CN0_T2CSS__LFOSC_CAPTURE   0x02 ///< Capture source is falling edge of Low-Frequency  
2678      =2                                              ///< Oscillator.                                      
2679      =2                                                                                                    
2680      =2  #define TMR2CN0_TR2__BMASK             0x04 ///< Timer 2 Run Control                              
2681      =2  #define TMR2CN0_TR2__SHIFT             0x02 ///< Timer 2 Run Control                              
2682      =2  #define TMR2CN0_TR2__STOP              0x00 ///< Stop Timer 2.                                    
2683      =2  #define TMR2CN0_TR2__RUN               0x04 ///< Start Timer 2 running.                           
2684      =2                                                                                                    
2685      =2  #define TMR2CN0_T2SPLIT__BMASK         0x08 ///< Timer 2 Split Mode Enable                        
2686      =2  #define TMR2CN0_T2SPLIT__SHIFT         0x03 ///< Timer 2 Split Mode Enable                        
2687      =2  #define TMR2CN0_T2SPLIT__16_BIT_RELOAD 0x00 ///< Timer 2 operates in 16-bit auto-reload mode.     
2688      =2  #define TMR2CN0_T2SPLIT__8_BIT_RELOAD  0x08 ///< Timer 2 operates as two 8-bit auto-reload timers.
2689      =2                                                                                                    
2690      =2  #define TMR2CN0_TF2CEN__BMASK          0x10 ///< Timer 2 Capture Enable                           
2691      =2  #define TMR2CN0_TF2CEN__SHIFT          0x04 ///< Timer 2 Capture Enable                           
2692      =2  #define TMR2CN0_TF2CEN__DISABLED       0x00 ///< Disable capture mode.                            
2693      =2  #define TMR2CN0_TF2CEN__ENABLED        0x10 ///< Enable capture mode.                             
2694      =2                                                                                                    
2695      =2  #define TMR2CN0_TF2LEN__BMASK          0x20 ///< Timer 2 Low Byte Interrupt Enable                
2696      =2  #define TMR2CN0_TF2LEN__SHIFT          0x05 ///< Timer 2 Low Byte Interrupt Enable                
2697      =2  #define TMR2CN0_TF2LEN__DISABLED       0x00 ///< Disable low byte interrupts.                     
2698      =2  #define TMR2CN0_TF2LEN__ENABLED        0x20 ///< Enable low byte interrupts.                      
2699      =2                                                                                                    
C51 COMPILER V9.56.0.0   I2C_0                                                             10/28/2016 17:37:02 PAGE 71  

2700      =2  #define TMR2CN0_TF2L__BMASK            0x40 ///< Timer 2 Low Byte Overflow Flag                   
2701      =2  #define TMR2CN0_TF2L__SHIFT            0x06 ///< Timer 2 Low Byte Overflow Flag                   
2702      =2  #define TMR2CN0_TF2L__NOT_SET          0x00 ///< Timer 2 low byte did not overflow.               
2703      =2  #define TMR2CN0_TF2L__SET              0x40 ///< Timer 2 low byte overflowed.                     
2704      =2                                                                                                    
2705      =2  #define TMR2CN0_TF2H__BMASK            0x80 ///< Timer 2 High Byte Overflow Flag                  
2706      =2  #define TMR2CN0_TF2H__SHIFT            0x07 ///< Timer 2 High Byte Overflow Flag                  
2707      =2  #define TMR2CN0_TF2H__NOT_SET          0x00 ///< Timer 2 8-bit high byte or 16-bit value did not  
2708      =2                                              ///< overflow.                                        
2709      =2  #define TMR2CN0_TF2H__SET              0x80 ///< Timer 2 8-bit high byte or 16-bit value          
2710      =2                                              ///< overflowed.                                      
2711      =2                                                                                                    
2712      =2  //------------------------------------------------------------------------------
2713      =2  // TMR2H Enums (Timer 2 High Byte @ 0xCD)
2714      =2  //------------------------------------------------------------------------------
2715      =2  #define TMR2H_TMR2H__FMASK 0xFF ///< Timer 2 High Byte
2716      =2  #define TMR2H_TMR2H__SHIFT 0x00 ///< Timer 2 High Byte
2717      =2                                                        
2718      =2  //------------------------------------------------------------------------------
2719      =2  // TMR2L Enums (Timer 2 Low Byte @ 0xCC)
2720      =2  //------------------------------------------------------------------------------
2721      =2  #define TMR2L_TMR2L__FMASK 0xFF ///< Timer 2 Low Byte
2722      =2  #define TMR2L_TMR2L__SHIFT 0x00 ///< Timer 2 Low Byte
2723      =2                                                       
2724      =2  //------------------------------------------------------------------------------
2725      =2  // TMR2RLH Enums (Timer 2 Reload High Byte @ 0xCB)
2726      =2  //------------------------------------------------------------------------------
2727      =2  #define TMR2RLH_TMR2RLH__FMASK 0xFF ///< Timer 2 Reload High Byte
2728      =2  #define TMR2RLH_TMR2RLH__SHIFT 0x00 ///< Timer 2 Reload High Byte
2729      =2                                                                   
2730      =2  //------------------------------------------------------------------------------
2731      =2  // TMR2RLL Enums (Timer 2 Reload Low Byte @ 0xCA)
2732      =2  //------------------------------------------------------------------------------
2733      =2  #define TMR2RLL_TMR2RLL__FMASK 0xFF ///< Timer 2 Reload Low Byte
2734      =2  #define TMR2RLL_TMR2RLL__SHIFT 0x00 ///< Timer 2 Reload Low Byte
2735      =2                                                                  
2736      =2  //------------------------------------------------------------------------------
2737      =2  // TMR3CN0 Enums (Timer 3 Control 0 @ 0x91)
2738      =2  //------------------------------------------------------------------------------
2739      =2  #define TMR3CN0_T3XCLK__BMASK          0x01 ///< Timer 3 External Clock Select                    
2740      =2  #define TMR3CN0_T3XCLK__SHIFT          0x00 ///< Timer 3 External Clock Select                    
2741      =2  #define TMR3CN0_T3XCLK__SYSCLK_DIV_12  0x00 ///< Timer 3 clock is the system clock divided by 12. 
2742      =2  #define TMR3CN0_T3XCLK__EXTOSC_DIV_8   0x01 ///< Timer 3 clock is the external oscillator divided 
2743      =2                                              ///< by 8 (synchronized with SYSCLK).                 
2744      =2                                                                                                    
2745      =2  #define TMR3CN0_T3CSS__BMASK           0x02 ///< Timer 3 Capture Source Select                    
2746      =2  #define TMR3CN0_T3CSS__SHIFT           0x01 ///< Timer 3 Capture Source Select                    
2747      =2  #define TMR3CN0_T3CSS__USB_SOF_CAPTURE 0x00 ///< Capture source is USB SOF event.                 
2748      =2  #define TMR3CN0_T3CSS__LFOSC_CAPTURE   0x02 ///< Capture source is falling edge of Low-Frequency  
2749      =2                                              ///< Oscillator.                                      
2750      =2                                                                                                    
2751      =2  #define TMR3CN0_TR3__BMASK             0x04 ///< Timer 3 Run Control                              
2752      =2  #define TMR3CN0_TR3__SHIFT             0x02 ///< Timer 3 Run Control                              
2753      =2  #define TMR3CN0_TR3__STOP              0x00 ///< Stop Timer 3.                                    
2754      =2  #define TMR3CN0_TR3__RUN               0x04 ///< Start Timer 3 running.                           
2755      =2                                                                                                    
2756      =2  #define TMR3CN0_T3SPLIT__BMASK         0x08 ///< Timer 3 Split Mode Enable                        
2757      =2  #define TMR3CN0_T3SPLIT__SHIFT         0x03 ///< Timer 3 Split Mode Enable                        
2758      =2  #define TMR3CN0_T3SPLIT__16_BIT_RELOAD 0x00 ///< Timer 3 operates in 16-bit auto-reload mode.     
2759      =2  #define TMR3CN0_T3SPLIT__8_BIT_RELOAD  0x08 ///< Timer 3 operates as two 8-bit auto-reload timers.
2760      =2                                                                                                    
2761      =2  #define TMR3CN0_TF3CEN__BMASK          0x10 ///< Timer 3 Capture Enable                           
C51 COMPILER V9.56.0.0   I2C_0                                                             10/28/2016 17:37:02 PAGE 72  

2762      =2  #define TMR3CN0_TF3CEN__SHIFT          0x04 ///< Timer 3 Capture Enable                           
2763      =2  #define TMR3CN0_TF3CEN__DISABLED       0x00 ///< Disable capture mode.                            
2764      =2  #define TMR3CN0_TF3CEN__ENABLED        0x10 ///< Enable capture mode.                             
2765      =2                                                                                                    
2766      =2  #define TMR3CN0_TF3LEN__BMASK          0x20 ///< Timer 3 Low Byte Interrupt Enable                
2767      =2  #define TMR3CN0_TF3LEN__SHIFT          0x05 ///< Timer 3 Low Byte Interrupt Enable                
2768      =2  #define TMR3CN0_TF3LEN__DISABLED       0x00 ///< Disable low byte interrupts.                     
2769      =2  #define TMR3CN0_TF3LEN__ENABLED        0x20 ///< Enable low byte interrupts.                      
2770      =2                                                                                                    
2771      =2  #define TMR3CN0_TF3L__BMASK            0x40 ///< Timer 3 Low Byte Overflow Flag                   
2772      =2  #define TMR3CN0_TF3L__SHIFT            0x06 ///< Timer 3 Low Byte Overflow Flag                   
2773      =2  #define TMR3CN0_TF3L__NOT_SET          0x00 ///< Timer 3 low byte did not overflow.               
2774      =2  #define TMR3CN0_TF3L__SET              0x40 ///< Timer 3 low byte overflowed.                     
2775      =2                                                                                                    
2776      =2  #define TMR3CN0_TF3H__BMASK            0x80 ///< Timer 3 High Byte Overflow Flag                  
2777      =2  #define TMR3CN0_TF3H__SHIFT            0x07 ///< Timer 3 High Byte Overflow Flag                  
2778      =2  #define TMR3CN0_TF3H__NOT_SET          0x00 ///< Timer 3 8-bit high byte or 16-bit value did not  
2779      =2                                              ///< overflow.                                        
2780      =2  #define TMR3CN0_TF3H__SET              0x80 ///< Timer 3 8-bit high byte or 16-bit value          
2781      =2                                              ///< overflowed.                                      
2782      =2                                                                                                    
2783      =2  //------------------------------------------------------------------------------
2784      =2  // TMR3H Enums (Timer 3 High Byte @ 0x95)
2785      =2  //------------------------------------------------------------------------------
2786      =2  #define TMR3H_TMR3H__FMASK 0xFF ///< Timer 3 High Byte
2787      =2  #define TMR3H_TMR3H__SHIFT 0x00 ///< Timer 3 High Byte
2788      =2                                                        
2789      =2  //------------------------------------------------------------------------------
2790      =2  // TMR3L Enums (Timer 3 Low Byte @ 0x94)
2791      =2  //------------------------------------------------------------------------------
2792      =2  #define TMR3L_TMR3L__FMASK 0xFF ///< Timer 3 Low Byte
2793      =2  #define TMR3L_TMR3L__SHIFT 0x00 ///< Timer 3 Low Byte
2794      =2                                                       
2795      =2  //------------------------------------------------------------------------------
2796      =2  // TMR3RLH Enums (Timer 3 Reload High Byte @ 0x93)
2797      =2  //------------------------------------------------------------------------------
2798      =2  #define TMR3RLH_TMR3RLH__FMASK 0xFF ///< Timer 3 Reload High Byte
2799      =2  #define TMR3RLH_TMR3RLH__SHIFT 0x00 ///< Timer 3 Reload High Byte
2800      =2                                                                   
2801      =2  //------------------------------------------------------------------------------
2802      =2  // TMR3RLL Enums (Timer 3 Reload Low Byte @ 0x92)
2803      =2  //------------------------------------------------------------------------------
2804      =2  #define TMR3RLL_TMR3RLL__FMASK 0xFF ///< Timer 3 Reload Low Byte
2805      =2  #define TMR3RLL_TMR3RLL__SHIFT 0x00 ///< Timer 3 Reload Low Byte
2806      =2                                                                  
2807      =2  //------------------------------------------------------------------------------
2808      =2  // TMR4CN0 Enums (Timer 4 Control 0 @ 0x91)
2809      =2  //------------------------------------------------------------------------------
2810      =2  #define TMR4CN0_T4XCLK__BMASK          0x01 ///< Timer 4 External Clock Select                    
2811      =2  #define TMR4CN0_T4XCLK__SHIFT          0x00 ///< Timer 4 External Clock Select                    
2812      =2  #define TMR4CN0_T4XCLK__SYSCLK_DIV_12  0x00 ///< Timer 4 clock is the system clock divided by 12. 
2813      =2  #define TMR4CN0_T4XCLK__EXTOSC_DIV_8   0x01 ///< Timer 4 clock is the external oscillator divided 
2814      =2                                              ///< by 8 (synchronized with SYSCLK).                 
2815      =2                                                                                                    
2816      =2  #define TMR4CN0_TR4__BMASK             0x04 ///< Timer 4 Run Control                              
2817      =2  #define TMR4CN0_TR4__SHIFT             0x02 ///< Timer 4 Run Control                              
2818      =2  #define TMR4CN0_TR4__STOP              0x00 ///< Stop Timer 4.                                    
2819      =2  #define TMR4CN0_TR4__RUN               0x04 ///< Start Timer 4 running.                           
2820      =2                                                                                                    
2821      =2  #define TMR4CN0_T4SPLIT__BMASK         0x08 ///< Timer 4 Split Mode Enable                        
2822      =2  #define TMR4CN0_T4SPLIT__SHIFT         0x03 ///< Timer 4 Split Mode Enable                        
2823      =2  #define TMR4CN0_T4SPLIT__16_BIT_RELOAD 0x00 ///< Timer 4 operates in 16-bit auto-reload mode.     
C51 COMPILER V9.56.0.0   I2C_0                                                             10/28/2016 17:37:02 PAGE 73  

2824      =2  #define TMR4CN0_T4SPLIT__8_BIT_RELOAD  0x08 ///< Timer 4 operates as two 8-bit auto-reload timers.
2825      =2                                                                                                    
2826      =2  #define TMR4CN0_TF4LEN__BMASK          0x20 ///< Timer 4 Low Byte Interrupt Enable                
2827      =2  #define TMR4CN0_TF4LEN__SHIFT          0x05 ///< Timer 4 Low Byte Interrupt Enable                
2828      =2  #define TMR4CN0_TF4LEN__DISABLED       0x00 ///< Disable low byte interrupts.                     
2829      =2  #define TMR4CN0_TF4LEN__ENABLED        0x20 ///< Enable low byte interrupts.                      
2830      =2                                                                                                    
2831      =2  #define TMR4CN0_TF4L__BMASK            0x40 ///< Timer 4 Low Byte Overflow Flag                   
2832      =2  #define TMR4CN0_TF4L__SHIFT            0x06 ///< Timer 4 Low Byte Overflow Flag                   
2833      =2  #define TMR4CN0_TF4L__NOT_SET          0x00 ///< Timer 4 low byte did not overflow.               
2834      =2  #define TMR4CN0_TF4L__SET              0x40 ///< Timer 4 low byte overflowed.                     
2835      =2                                                                                                    
2836      =2  #define TMR4CN0_TF4H__BMASK            0x80 ///< Timer 4 High Byte Overflow Flag                  
2837      =2  #define TMR4CN0_TF4H__SHIFT            0x07 ///< Timer 4 High Byte Overflow Flag                  
2838      =2  #define TMR4CN0_TF4H__NOT_SET          0x00 ///< Timer 4 8-bit high byte or 16-bit value did not  
2839      =2                                              ///< overflow.                                        
2840      =2  #define TMR4CN0_TF4H__SET              0x80 ///< Timer 4 8-bit high byte or 16-bit value          
2841      =2                                              ///< overflowed.                                      
2842      =2                                                                                                    
2843      =2  //------------------------------------------------------------------------------
2844      =2  // TMR4H Enums (Timer 4 High Byte @ 0x95)
2845      =2  //------------------------------------------------------------------------------
2846      =2  #define TMR4H_TMR4H__FMASK 0xFF ///< Timer 4 High Byte
2847      =2  #define TMR4H_TMR4H__SHIFT 0x00 ///< Timer 4 High Byte
2848      =2                                                        
2849      =2  //------------------------------------------------------------------------------
2850      =2  // TMR4L Enums (Timer 4 Low Byte @ 0x94)
2851      =2  //------------------------------------------------------------------------------
2852      =2  #define TMR4L_TMR4L__FMASK 0xFF ///< Timer 4 Low Byte
2853      =2  #define TMR4L_TMR4L__SHIFT 0x00 ///< Timer 4 Low Byte
2854      =2                                                       
2855      =2  //------------------------------------------------------------------------------
2856      =2  // TMR4RLH Enums (Timer 4 Reload High Byte @ 0x93)
2857      =2  //------------------------------------------------------------------------------
2858      =2  #define TMR4RLH_TMR4RLH__FMASK 0xFF ///< Timer 4 Reload High Byte
2859      =2  #define TMR4RLH_TMR4RLH__SHIFT 0x00 ///< Timer 4 Reload High Byte
2860      =2                                                                   
2861      =2  //------------------------------------------------------------------------------
2862      =2  // TMR4RLL Enums (Timer 4 Reload Low Byte @ 0x92)
2863      =2  //------------------------------------------------------------------------------
2864      =2  #define TMR4RLL_TMR4RLL__FMASK 0xFF ///< Timer 4 Reload Low Byte
2865      =2  #define TMR4RLL_TMR4RLL__SHIFT 0x00 ///< Timer 4 Reload Low Byte
2866      =2                                                                  
2867      =2  //------------------------------------------------------------------------------
2868      =2  // TMR5CN0 Enums (Timer 5 Control 0 @ 0xC8)
2869      =2  //------------------------------------------------------------------------------
2870      =2  #define TMR5CN0_T5XCLK__BMASK          0x01 ///< Timer 5 External Clock Select                    
2871      =2  #define TMR5CN0_T5XCLK__SHIFT          0x00 ///< Timer 5 External Clock Select                    
2872      =2  #define TMR5CN0_T5XCLK__SYSCLK_DIV_12  0x00 ///< Timer 5 clock is the system clock divided by 12. 
2873      =2  #define TMR5CN0_T5XCLK__EXTOSC_DIV_8   0x01 ///< Timer 5 clock is the external oscillator divided 
2874      =2                                              ///< by 8 (synchronized with SYSCLK).                 
2875      =2                                                                                                    
2876      =2  #define TMR5CN0_TR5__BMASK             0x04 ///< Timer 5 Run Control                              
2877      =2  #define TMR5CN0_TR5__SHIFT             0x02 ///< Timer 5 Run Control                              
2878      =2  #define TMR5CN0_TR5__STOP              0x00 ///< Stop Timer 5.                                    
2879      =2  #define TMR5CN0_TR5__RUN               0x04 ///< Start Timer 5 running.                           
2880      =2                                                                                                    
2881      =2  #define TMR5CN0_T5SPLIT__BMASK         0x08 ///< Timer 5 Split Mode Enable                        
2882      =2  #define TMR5CN0_T5SPLIT__SHIFT         0x03 ///< Timer 5 Split Mode Enable                        
2883      =2  #define TMR5CN0_T5SPLIT__16_BIT_RELOAD 0x00 ///< Timer 5 operates in 16-bit auto-reload mode.     
2884      =2  #define TMR5CN0_T5SPLIT__8_BIT_RELOAD  0x08 ///< Timer 5 operates as two 8-bit auto-reload timers.
2885      =2                                                                                                    
C51 COMPILER V9.56.0.0   I2C_0                                                             10/28/2016 17:37:02 PAGE 74  

2886      =2  #define TMR5CN0_TF5LEN__BMASK          0x20 ///< Timer 5 Low Byte Interrupt Enable                
2887      =2  #define TMR5CN0_TF5LEN__SHIFT          0x05 ///< Timer 5 Low Byte Interrupt Enable                
2888      =2  #define TMR5CN0_TF5LEN__DISABLED       0x00 ///< Disable low byte interrupts.                     
2889      =2  #define TMR5CN0_TF5LEN__ENABLED        0x20 ///< Enable low byte interrupts.                      
2890      =2                                                                                                    
2891      =2  #define TMR5CN0_TF5L__BMASK            0x40 ///< Timer 5 Low Byte Overflow Flag                   
2892      =2  #define TMR5CN0_TF5L__SHIFT            0x06 ///< Timer 5 Low Byte Overflow Flag                   
2893      =2  #define TMR5CN0_TF5L__NOT_SET          0x00 ///< Timer 5 low byte did not overflow.               
2894      =2  #define TMR5CN0_TF5L__SET              0x40 ///< Timer 5 low byte overflowed.                     
2895      =2                                                                                                    
2896      =2  #define TMR5CN0_TF5H__BMASK            0x80 ///< Timer 5 High Byte Overflow Flag                  
2897      =2  #define TMR5CN0_TF5H__SHIFT            0x07 ///< Timer 5 High Byte Overflow Flag                  
2898      =2  #define TMR5CN0_TF5H__NOT_SET          0x00 ///< Timer 5 8-bit high byte or 16-bit value did not  
2899      =2                                              ///< overflow.                                        
2900      =2  #define TMR5CN0_TF5H__SET              0x80 ///< Timer 5 8-bit high byte or 16-bit value          
2901      =2                                              ///< overflowed.                                      
2902      =2                                                                                                    
2903      =2  //------------------------------------------------------------------------------
2904      =2  // TMR5H Enums (Timer 5 High Byte @ 0xCD)
2905      =2  //------------------------------------------------------------------------------
2906      =2  #define TMR5H_TMR5H__FMASK 0xFF ///< Timer 5 High Byte
2907      =2  #define TMR5H_TMR5H__SHIFT 0x00 ///< Timer 5 High Byte
2908      =2                                                        
2909      =2  //------------------------------------------------------------------------------
2910      =2  // TMR5L Enums (Timer 5 Low Byte @ 0xCC)
2911      =2  //------------------------------------------------------------------------------
2912      =2  #define TMR5L_TMR5L__FMASK 0xFF ///< Timer 5 Low Byte
2913      =2  #define TMR5L_TMR5L__SHIFT 0x00 ///< Timer 5 Low Byte
2914      =2                                                       
2915      =2  //------------------------------------------------------------------------------
2916      =2  // TMR5RLH Enums (Timer 5 Reload High Byte @ 0xCB)
2917      =2  //------------------------------------------------------------------------------
2918      =2  #define TMR5RLH_TMR5RLH__FMASK 0xFF ///< Timer 5 Reload High Byte
2919      =2  #define TMR5RLH_TMR5RLH__SHIFT 0x00 ///< Timer 5 Reload High Byte
2920      =2                                                                   
2921      =2  //------------------------------------------------------------------------------
2922      =2  // TMR5RLL Enums (Timer 5 Reload Low Byte @ 0xCA)
2923      =2  //------------------------------------------------------------------------------
2924      =2  #define TMR5RLL_TMR5RLL__FMASK 0xFF ///< Timer 5 Reload Low Byte
2925      =2  #define TMR5RLL_TMR5RLL__SHIFT 0x00 ///< Timer 5 Reload Low Byte
2926      =2                                                                  
2927      =2  //------------------------------------------------------------------------------
2928      =2  // CKCON0 Enums (Clock Control 0 @ 0x8E)
2929      =2  //------------------------------------------------------------------------------
2930      =2  #define CKCON0_SCA__FMASK           0x03 ///< Timer 0/1 Prescale                                
2931      =2  #define CKCON0_SCA__SHIFT           0x00 ///< Timer 0/1 Prescale                                
2932      =2  #define CKCON0_SCA__SYSCLK_DIV_12   0x00 ///< System clock divided by 12.                       
2933      =2  #define CKCON0_SCA__SYSCLK_DIV_4    0x01 ///< System clock divided by 4.                        
2934      =2  #define CKCON0_SCA__SYSCLK_DIV_48   0x02 ///< System clock divided by 48.                       
2935      =2  #define CKCON0_SCA__EXTOSC_DIV_8    0x03 ///< External oscillator divided by 8 (synchronized    
2936      =2                                           ///< with the system clock).                           
2937      =2                                                                                                  
2938      =2  #define CKCON0_T0M__BMASK           0x04 ///< Timer 0 Clock Select                              
2939      =2  #define CKCON0_T0M__SHIFT           0x02 ///< Timer 0 Clock Select                              
2940      =2  #define CKCON0_T0M__PRESCALE        0x00 ///< Counter/Timer 0 uses the clock defined by the     
2941      =2                                           ///< prescale field, SCA.                              
2942      =2  #define CKCON0_T0M__SYSCLK          0x04 ///< Counter/Timer 0 uses the system clock.            
2943      =2                                                                                                  
2944      =2  #define CKCON0_T1M__BMASK           0x08 ///< Timer 1 Clock Select                              
2945      =2  #define CKCON0_T1M__SHIFT           0x03 ///< Timer 1 Clock Select                              
2946      =2  #define CKCON0_T1M__PRESCALE        0x00 ///< Timer 1 uses the clock defined by the prescale    
2947      =2                                           ///< field, SCA.                                       
C51 COMPILER V9.56.0.0   I2C_0                                                             10/28/2016 17:37:02 PAGE 75  

2948      =2  #define CKCON0_T1M__SYSCLK          0x08 ///< Timer 1 uses the system clock.                    
2949      =2                                                                                                  
2950      =2  #define CKCON0_T2ML__BMASK          0x10 ///< Timer 2 Low Byte Clock Select                     
2951      =2  #define CKCON0_T2ML__SHIFT          0x04 ///< Timer 2 Low Byte Clock Select                     
2952      =2  #define CKCON0_T2ML__EXTERNAL_CLOCK 0x00 ///< Timer 2 low byte uses the clock defined by T2XCLK 
2953      =2                                           ///< in TMR2CN0.                                       
2954      =2  #define CKCON0_T2ML__SYSCLK         0x10 ///< Timer 2 low byte uses the system clock.           
2955      =2                                                                                                  
2956      =2  #define CKCON0_T2MH__BMASK          0x20 ///< Timer 2 High Byte Clock Select                    
2957      =2  #define CKCON0_T2MH__SHIFT          0x05 ///< Timer 2 High Byte Clock Select                    
2958      =2  #define CKCON0_T2MH__EXTERNAL_CLOCK 0x00 ///< Timer 2 high byte uses the clock defined by T2XCLK
2959      =2                                           ///< in TMR2CN0.                                       
2960      =2  #define CKCON0_T2MH__SYSCLK         0x20 ///< Timer 2 high byte uses the system clock.          
2961      =2                                                                                                  
2962      =2  #define CKCON0_T3ML__BMASK          0x40 ///< Timer 3 Low Byte Clock Select                     
2963      =2  #define CKCON0_T3ML__SHIFT          0x06 ///< Timer 3 Low Byte Clock Select                     
2964      =2  #define CKCON0_T3ML__EXTERNAL_CLOCK 0x00 ///< Timer 3 low byte uses the clock defined by T3XCLK 
2965      =2                                           ///< in TMR3CN0.                                       
2966      =2  #define CKCON0_T3ML__SYSCLK         0x40 ///< Timer 3 low byte uses the system clock.           
2967      =2                                                                                                  
2968      =2  #define CKCON0_T3MH__BMASK          0x80 ///< Timer 3 High Byte Clock Select                    
2969      =2  #define CKCON0_T3MH__SHIFT          0x07 ///< Timer 3 High Byte Clock Select                    
2970      =2  #define CKCON0_T3MH__EXTERNAL_CLOCK 0x00 ///< Timer 3 high byte uses the clock defined by T3XCLK
2971      =2                                           ///< in TMR3CN0.                                       
2972      =2  #define CKCON0_T3MH__SYSCLK         0x80 ///< Timer 3 high byte uses the system clock.          
2973      =2                                                                                                  
2974      =2  //------------------------------------------------------------------------------
2975      =2  // CKCON1 Enums (Clock Control 1 @ 0xE4)
2976      =2  //------------------------------------------------------------------------------
2977      =2  #define CKCON1_T4ML__BMASK          0x01 ///< Timer 4 Low Byte Clock Select                     
2978      =2  #define CKCON1_T4ML__SHIFT          0x00 ///< Timer 4 Low Byte Clock Select                     
2979      =2  #define CKCON1_T4ML__EXTERNAL_CLOCK 0x00 ///< Timer 4 low byte uses the clock defined by T4XCLK 
2980      =2                                           ///< in TMR4CN0.                                       
2981      =2  #define CKCON1_T4ML__SYSCLK         0x01 ///< Timer 4 low byte uses the system clock.           
2982      =2                                                                                                  
2983      =2  #define CKCON1_T4MH__BMASK          0x02 ///< Timer 4 High Byte Clock Select                    
2984      =2  #define CKCON1_T4MH__SHIFT          0x01 ///< Timer 4 High Byte Clock Select                    
2985      =2  #define CKCON1_T4MH__EXTERNAL_CLOCK 0x00 ///< Timer 4 high byte uses the clock defined by T4XCLK
2986      =2                                           ///< in TMR4CN0.                                       
2987      =2  #define CKCON1_T4MH__SYSCLK         0x02 ///< Timer 4 high byte uses the system clock.          
2988      =2                                                                                                  
2989      =2  #define CKCON1_T5ML__BMASK          0x04 ///< Timer 5 Low Byte Clock Select                     
2990      =2  #define CKCON1_T5ML__SHIFT          0x02 ///< Timer 5 Low Byte Clock Select                     
2991      =2  #define CKCON1_T5ML__EXTERNAL_CLOCK 0x00 ///< Timer 5 low byte uses the clock defined by T5XCLK 
2992      =2                                           ///< in TMR5CN.                                        
2993      =2  #define CKCON1_T5ML__SYSCLK         0x04 ///< Timer 5 low byte uses the system clock.           
2994      =2                                                                                                  
2995      =2  #define CKCON1_T5MH__BMASK          0x08 ///< Timer 5 High Byte Clock Select                    
2996      =2  #define CKCON1_T5MH__SHIFT          0x03 ///< Timer 5 High Byte Clock Select                    
2997      =2  #define CKCON1_T5MH__EXTERNAL_CLOCK 0x00 ///< Timer 5 high byte uses the clock defined by T5XCLK
2998      =2                                           ///< in TMR5CN.                                        
2999      =2  #define CKCON1_T5MH__SYSCLK         0x08 ///< Timer 5 high byte uses the system clock.          
3000      =2                                                                                                  
3001      =2  //------------------------------------------------------------------------------
3002      =2  // TCON Enums (Timer 0/1 Control @ 0x88)
3003      =2  //------------------------------------------------------------------------------
3004      =2  #define TCON_IT0__BMASK   0x01 ///< Interrupt 0 Type Select  
3005      =2  #define TCON_IT0__SHIFT   0x00 ///< Interrupt 0 Type Select  
3006      =2  #define TCON_IT0__LEVEL   0x00 ///< INT0 is level triggered. 
3007      =2  #define TCON_IT0__EDGE    0x01 ///< INT0 is edge triggered.  
3008      =2                                                               
3009      =2  #define TCON_IE0__BMASK   0x02 ///< External Interrupt 0     
C51 COMPILER V9.56.0.0   I2C_0                                                             10/28/2016 17:37:02 PAGE 76  

3010      =2  #define TCON_IE0__SHIFT   0x01 ///< External Interrupt 0     
3011      =2  #define TCON_IE0__NOT_SET 0x00 ///< Edge/level not detected. 
3012      =2  #define TCON_IE0__SET     0x02 ///< Edge/level detected      
3013      =2                                                               
3014      =2  #define TCON_IT1__BMASK   0x04 ///< Interrupt 1 Type Select  
3015      =2  #define TCON_IT1__SHIFT   0x02 ///< Interrupt 1 Type Select  
3016      =2  #define TCON_IT1__LEVEL   0x00 ///< INT1 is level triggered. 
3017      =2  #define TCON_IT1__EDGE    0x04 ///< INT1 is edge triggered.  
3018      =2                                                               
3019      =2  #define TCON_IE1__BMASK   0x08 ///< External Interrupt 1     
3020      =2  #define TCON_IE1__SHIFT   0x03 ///< External Interrupt 1     
3021      =2  #define TCON_IE1__NOT_SET 0x00 ///< Edge/level not detected. 
3022      =2  #define TCON_IE1__SET     0x08 ///< Edge/level detected      
3023      =2                                                               
3024      =2  #define TCON_TR0__BMASK   0x10 ///< Timer 0 Run Control      
3025      =2  #define TCON_TR0__SHIFT   0x04 ///< Timer 0 Run Control      
3026      =2  #define TCON_TR0__STOP    0x00 ///< Stop Timer 0.            
3027      =2  #define TCON_TR0__RUN     0x10 ///< Start Timer 0 running.   
3028      =2                                                               
3029      =2  #define TCON_TF0__BMASK   0x20 ///< Timer 0 Overflow Flag    
3030      =2  #define TCON_TF0__SHIFT   0x05 ///< Timer 0 Overflow Flag    
3031      =2  #define TCON_TF0__NOT_SET 0x00 ///< Timer 0 did not overflow.
3032      =2  #define TCON_TF0__SET     0x20 ///< Timer 0 overflowed.      
3033      =2                                                               
3034      =2  #define TCON_TR1__BMASK   0x40 ///< Timer 1 Run Control      
3035      =2  #define TCON_TR1__SHIFT   0x06 ///< Timer 1 Run Control      
3036      =2  #define TCON_TR1__STOP    0x00 ///< Stop Timer 1.            
3037      =2  #define TCON_TR1__RUN     0x40 ///< Start Timer 1 running.   
3038      =2                                                               
3039      =2  #define TCON_TF1__BMASK   0x80 ///< Timer 1 Overflow Flag    
3040      =2  #define TCON_TF1__SHIFT   0x07 ///< Timer 1 Overflow Flag    
3041      =2  #define TCON_TF1__NOT_SET 0x00 ///< Timer 1 did not overflow.
3042      =2  #define TCON_TF1__SET     0x80 ///< Timer 1 overflowed.      
3043      =2                                                               
3044      =2  //------------------------------------------------------------------------------
3045      =2  // TMOD Enums (Timer 0/1 Mode @ 0x89)
3046      =2  //------------------------------------------------------------------------------
3047      =2  #define TMOD_T0M__FMASK      0x03 ///< Timer 0 Mode Select                               
3048      =2  #define TMOD_T0M__SHIFT      0x00 ///< Timer 0 Mode Select                               
3049      =2  #define TMOD_T0M__MODE0      0x00 ///< Mode 0, 13-bit Counter/Timer                      
3050      =2  #define TMOD_T0M__MODE1      0x01 ///< Mode 1, 16-bit Counter/Timer                      
3051      =2  #define TMOD_T0M__MODE2      0x02 ///< Mode 2, 8-bit Counter/Timer with Auto-Reload      
3052      =2  #define TMOD_T0M__MODE3      0x03 ///< Mode 3, Two 8-bit Counter/Timers                  
3053      =2                                                                                           
3054      =2  #define TMOD_CT0__BMASK      0x04 ///< Counter/Timer 0 Select                            
3055      =2  #define TMOD_CT0__SHIFT      0x02 ///< Counter/Timer 0 Select                            
3056      =2  #define TMOD_CT0__TIMER      0x00 ///< Timer Mode. Timer 0 increments on the clock       
3057      =2                                    ///< defined by T0M in the CKCON0 register.            
3058      =2  #define TMOD_CT0__COUNTER    0x04 ///< Counter Mode. Timer 0 increments on high-to-low   
3059      =2                                    ///< transitions of an external pin (T0).              
3060      =2                                                                                           
3061      =2  #define TMOD_GATE0__BMASK    0x08 ///< Timer 0 Gate Control                              
3062      =2  #define TMOD_GATE0__SHIFT    0x03 ///< Timer 0 Gate Control                              
3063      =2  #define TMOD_GATE0__DISABLED 0x00 ///< Timer 0 enabled when TR0 = 1 irrespective of INT0 
3064      =2                                    ///< logic level.                                      
3065      =2  #define TMOD_GATE0__ENABLED  0x08 ///< Timer 0 enabled only when TR0 = 1 and INT0 is     
3066      =2                                    ///< active as defined by bit IN0PL in register IT01CF.
3067      =2                                                                                           
3068      =2  #define TMOD_T1M__FMASK      0x30 ///< Timer 1 Mode Select                               
3069      =2  #define TMOD_T1M__SHIFT      0x04 ///< Timer 1 Mode Select                               
3070      =2  #define TMOD_T1M__MODE0      0x00 ///< Mode 0, 13-bit Counter/Timer                      
3071      =2  #define TMOD_T1M__MODE1      0x10 ///< Mode 1, 16-bit Counter/Timer                      
C51 COMPILER V9.56.0.0   I2C_0                                                             10/28/2016 17:37:02 PAGE 77  

3072      =2  #define TMOD_T1M__MODE2      0x20 ///< Mode 2, 8-bit Counter/Timer with Auto-Reload      
3073      =2  #define TMOD_T1M__MODE3      0x30 ///< Mode 3, Timer 1 Inactive                          
3074      =2                                                                                           
3075      =2  #define TMOD_CT1__BMASK      0x40 ///< Counter/Timer 1 Select                            
3076      =2  #define TMOD_CT1__SHIFT      0x06 ///< Counter/Timer 1 Select                            
3077      =2  #define TMOD_CT1__TIMER      0x00 ///< Timer Mode. Timer 1 increments on the clock       
3078      =2                                    ///< defined by T1M in the CKCON0 register.            
3079      =2  #define TMOD_CT1__COUNTER    0x40 ///< Counter Mode. Timer 1 increments on high-to-low   
3080      =2                                    ///< transitions of an external pin (T1).              
3081      =2                                                                                           
3082      =2  #define TMOD_GATE1__BMASK    0x80 ///< Timer 1 Gate Control                              
3083      =2  #define TMOD_GATE1__SHIFT    0x07 ///< Timer 1 Gate Control                              
3084      =2  #define TMOD_GATE1__DISABLED 0x00 ///< Timer 1 enabled when TR1 = 1 irrespective of INT1 
3085      =2                                    ///< logic level.                                      
3086      =2  #define TMOD_GATE1__ENABLED  0x80 ///< Timer 1 enabled only when TR1 = 1 and INT1 is     
3087      =2                                    ///< active as defined by bit IN1PL in register IT01CF.
3088      =2                                                                                           
3089      =2  //------------------------------------------------------------------------------
3090      =2  // SBCON1 Enums (UART1 Baud Rate Generator Control @ 0xAC)
3091      =2  //------------------------------------------------------------------------------
3092      =2  #define SBCON1_BPS__FMASK     0x03 ///< Baud Rate Prescaler Select                     
3093      =2  #define SBCON1_BPS__SHIFT     0x00 ///< Baud Rate Prescaler Select                     
3094      =2  #define SBCON1_BPS__DIV_BY_12 0x00 ///< Prescaler = 12.                                
3095      =2  #define SBCON1_BPS__DIV_BY_4  0x01 ///< Prescaler = 4.                                 
3096      =2  #define SBCON1_BPS__DIV_BY_48 0x02 ///< Prescaler = 48.                                
3097      =2  #define SBCON1_BPS__DIV_BY_1  0x03 ///< Prescaler = 1.                                 
3098      =2                                                                                         
3099      =2  #define SBCON1_BREN__BMASK    0x40 ///< Baud Rate Generator Enable                     
3100      =2  #define SBCON1_BREN__SHIFT    0x06 ///< Baud Rate Generator Enable                     
3101      =2  #define SBCON1_BREN__DISABLED 0x00 ///< Disable the baud rate generator. UART1 will not
3102      =2                                     ///< function.                                      
3103      =2  #define SBCON1_BREN__ENABLED  0x40 ///< Enable the baud rate generator.                
3104      =2                                                                                         
3105      =2  //------------------------------------------------------------------------------
3106      =2  // SBRLH1 Enums (UART1 Baud Rate Generator High Byte @ 0xB5)
3107      =2  //------------------------------------------------------------------------------
3108      =2  #define SBRLH1_BRH__FMASK 0xFF ///< UART1 Baud Rate Reload High
3109      =2  #define SBRLH1_BRH__SHIFT 0x00 ///< UART1 Baud Rate Reload High
3110      =2                                                                 
3111      =2  //------------------------------------------------------------------------------
3112      =2  // SBRLL1 Enums (UART1 Baud Rate Generator Low Byte @ 0xB4)
3113      =2  //------------------------------------------------------------------------------
3114      =2  #define SBRLL1_BRL__FMASK 0xFF ///< UART1 Baud Rate Reload Low
3115      =2  #define SBRLL1_BRL__SHIFT 0x00 ///< UART1 Baud Rate Reload Low
3116      =2                                                                
3117      =2  //------------------------------------------------------------------------------
3118      =2  // SBUF1 Enums (UART1 Serial Port Data Buffer @ 0xD3)
3119      =2  //------------------------------------------------------------------------------
3120      =2  #define SBUF1_SBUF1__FMASK 0xFF ///< Serial Port Data Buffer
3121      =2  #define SBUF1_SBUF1__SHIFT 0x00 ///< Serial Port Data Buffer
3122      =2                                                              
3123      =2  //------------------------------------------------------------------------------
3124      =2  // SCON1 Enums (UART1 Serial Port Control @ 0xD2)
3125      =2  //------------------------------------------------------------------------------
3126      =2  #define SCON1_RI__BMASK             0x01 ///< Receive Interrupt Flag                           
3127      =2  #define SCON1_RI__SHIFT             0x00 ///< Receive Interrupt Flag                           
3128      =2  #define SCON1_RI__NOT_SET           0x00 ///< New data has not been received by UART1.         
3129      =2  #define SCON1_RI__SET               0x01 ///< UART1 received one or more data bytes.           
3130      =2                                                                                                 
3131      =2  #define SCON1_TI__BMASK             0x02 ///< Transmit Interrupt Flag                          
3132      =2  #define SCON1_TI__SHIFT             0x01 ///< Transmit Interrupt Flag                          
3133      =2  #define SCON1_TI__NOT_SET           0x00 ///< A byte of data has not been transmitted by UART1.
C51 COMPILER V9.56.0.0   I2C_0                                                             10/28/2016 17:37:02 PAGE 78  

3134      =2  #define SCON1_TI__SET               0x02 ///< UART1 transmitted a byte of data.                
3135      =2                                                                                                 
3136      =2  #define SCON1_RBX__BMASK            0x04 ///< Extra Receive Bit                                
3137      =2  #define SCON1_RBX__SHIFT            0x02 ///< Extra Receive Bit                                
3138      =2  #define SCON1_RBX__LOW              0x00 ///< The extra bit or the first stop bit is 0.        
3139      =2  #define SCON1_RBX__HIGH             0x04 ///< The extra bit or the first stop bit is 1.        
3140      =2                                                                                                 
3141      =2  #define SCON1_TBX__BMASK            0x08 ///< Extra Transmission Bit                           
3142      =2  #define SCON1_TBX__SHIFT            0x03 ///< Extra Transmission Bit                           
3143      =2  #define SCON1_TBX__LOW              0x00 ///< Set extra bit to 0 (low).                        
3144      =2  #define SCON1_TBX__HIGH             0x08 ///< Set extra bit to 1 (high).                       
3145      =2                                                                                                 
3146      =2  #define SCON1_REN__BMASK            0x10 ///< Receive Enable                                   
3147      =2  #define SCON1_REN__SHIFT            0x04 ///< Receive Enable                                   
3148      =2  #define SCON1_REN__RECEIVE_DISABLED 0x00 ///< UART1 reception disabled.                        
3149      =2  #define SCON1_REN__RECEIVE_ENABLED  0x10 ///< UART1 reception enabled.                         
3150      =2                                                                                                 
3151      =2  #define SCON1_PERR__BMASK           0x40 ///< Parity Error Flag                                
3152      =2  #define SCON1_PERR__SHIFT           0x06 ///< Parity Error Flag                                
3153      =2  #define SCON1_PERR__NOT_SET         0x00 ///< Parity error has not occurred.                   
3154      =2  #define SCON1_PERR__SET             0x40 ///< Parity error has occurred.                       
3155      =2                                                                                                 
3156      =2  #define SCON1_OVR__BMASK            0x80 ///< Receive FIFO Overrun Flag                        
3157      =2  #define SCON1_OVR__SHIFT            0x07 ///< Receive FIFO Overrun Flag                        
3158      =2  #define SCON1_OVR__NOT_SET          0x00 ///< Receive FIFO overrun has not occurred.           
3159      =2  #define SCON1_OVR__SET              0x80 ///< Receive FIFO overrun has occurred.               
3160      =2                                                                                                 
3161      =2  //------------------------------------------------------------------------------
3162      =2  // SMOD1 Enums (UART1 Mode @ 0xE5)
3163      =2  //------------------------------------------------------------------------------
3164      =2  #define SMOD1_SBL__BMASK          0x01 ///< Stop Bit Length                                 
3165      =2  #define SMOD1_SBL__SHIFT          0x00 ///< Stop Bit Length                                 
3166      =2  #define SMOD1_SBL__SHORT          0x00 ///< Short: Stop bit is active for one bit time.     
3167      =2  #define SMOD1_SBL__LONG           0x01 ///< Long: Stop bit is active for two bit times (data
3168      =2                                         ///< length = 6, 7, or 8 bits) or 1.5 bit times (data
3169      =2                                         ///< length = 5 bits).                               
3170      =2                                                                                              
3171      =2  #define SMOD1_XBE__BMASK          0x02 ///< Extra Bit Enable                                
3172      =2  #define SMOD1_XBE__SHIFT          0x01 ///< Extra Bit Enable                                
3173      =2  #define SMOD1_XBE__DISABLED       0x00 ///< Disable the extra bit.                          
3174      =2  #define SMOD1_XBE__ENABLED        0x02 ///< Enable the extra bit.                           
3175      =2                                                                                              
3176      =2  #define SMOD1_SDL__FMASK          0x0C ///< Data Length                                     
3177      =2  #define SMOD1_SDL__SHIFT          0x02 ///< Data Length                                     
3178      =2  #define SMOD1_SDL__5_BITS         0x00 ///< 5 bits.                                         
3179      =2  #define SMOD1_SDL__6_BITS         0x04 ///< 6 bits.                                         
3180      =2  #define SMOD1_SDL__7_BITS         0x08 ///< 7 bits.                                         
3181      =2  #define SMOD1_SDL__8_BITS         0x0C ///< 8 bits.                                         
3182      =2                                                                                              
3183      =2  #define SMOD1_PE__BMASK           0x10 ///< Parity Enable                                   
3184      =2  #define SMOD1_PE__SHIFT           0x04 ///< Parity Enable                                   
3185      =2  #define SMOD1_PE__PARITY_DISABLED 0x00 ///< Disable hardware parity.                        
3186      =2  #define SMOD1_PE__PARITY_ENABLED  0x10 ///< Enable hardware parity.                         
3187      =2                                                                                              
3188      =2  #define SMOD1_SPT__FMASK          0x60 ///< Parity Type                                     
3189      =2  #define SMOD1_SPT__SHIFT          0x05 ///< Parity Type                                     
3190      =2  #define SMOD1_SPT__ODD_PARITY     0x00 ///< Odd.                                            
3191      =2  #define SMOD1_SPT__EVEN_PARITY    0x20 ///< Even.                                           
3192      =2  #define SMOD1_SPT__MARK_PARITY    0x40 ///< Mark.                                           
3193      =2  #define SMOD1_SPT__SPACE_PARITY   0x60 ///< Space.                                          
3194      =2                                                                                              
3195      =2  #define SMOD1_MCE__BMASK          0x80 ///< Multiprocessor Communication Enable             
C51 COMPILER V9.56.0.0   I2C_0                                                             10/28/2016 17:37:02 PAGE 79  

3196      =2  #define SMOD1_MCE__SHIFT          0x07 ///< Multiprocessor Communication Enable             
3197      =2  #define SMOD1_MCE__MULTI_DISABLED 0x00 ///< RI will be activated if the stop bits are 1.    
3198      =2  #define SMOD1_MCE__MULTI_ENABLED  0x80 ///< RI will be activated if the stop bits and extra 
3199      =2                                         ///< bit are 1. The extra bit must be enabled using  
3200      =2                                         ///< XBE.                                            
3201      =2                                                                                              
3202      =2  //------------------------------------------------------------------------------
3203      =2  // SBUF0 Enums (UART0 Serial Port Data Buffer @ 0x99)
3204      =2  //------------------------------------------------------------------------------
3205      =2  #define SBUF0_SBUF0__FMASK 0xFF ///< Serial Data Buffer
3206      =2  #define SBUF0_SBUF0__SHIFT 0x00 ///< Serial Data Buffer
3207      =2                                                         
3208      =2  //------------------------------------------------------------------------------
3209      =2  // SCON0 Enums (UART0 Serial Port Control @ 0x98)
3210      =2  //------------------------------------------------------------------------------
3211      =2  #define SCON0_RI__BMASK             0x01 ///< Receive Interrupt Flag                           
3212      =2  #define SCON0_RI__SHIFT             0x00 ///< Receive Interrupt Flag                           
3213      =2  #define SCON0_RI__NOT_SET           0x00 ///< A byte of data has not been received by UART0.   
3214      =2  #define SCON0_RI__SET               0x01 ///< UART0 received a byte of data.                   
3215      =2                                                                                                 
3216      =2  #define SCON0_TI__BMASK             0x02 ///< Transmit Interrupt Flag                          
3217      =2  #define SCON0_TI__SHIFT             0x01 ///< Transmit Interrupt Flag                          
3218      =2  #define SCON0_TI__NOT_SET           0x00 ///< A byte of data has not been transmitted by UART0.
3219      =2  #define SCON0_TI__SET               0x02 ///< UART0 transmitted a byte of data.                
3220      =2                                                                                                 
3221      =2  #define SCON0_RB8__BMASK            0x04 ///< Ninth Receive Bit                                
3222      =2  #define SCON0_RB8__SHIFT            0x02 ///< Ninth Receive Bit                                
3223      =2  #define SCON0_RB8__CLEARED_TO_0     0x00 ///< In Mode 0, the STOP bit was 0. In Mode 1, the 9th
3224      =2                                           ///< bit was 0.                                       
3225      =2  #define SCON0_RB8__SET_TO_1         0x04 ///< In Mode 0, the STOP bit was 1. In Mode 1, the 9th
3226      =2                                           ///< bit was 1.                                       
3227      =2                                                                                                 
3228      =2  #define SCON0_TB8__BMASK            0x08 ///< Ninth Transmission Bit                           
3229      =2  #define SCON0_TB8__SHIFT            0x03 ///< Ninth Transmission Bit                           
3230      =2  #define SCON0_TB8__CLEARED_TO_0     0x00 ///< In Mode 1, set the 9th transmission bit to 0.    
3231      =2  #define SCON0_TB8__SET_TO_1         0x08 ///< In Mode 1, set the 9th transmission bit to 1.    
3232      =2                                                                                                 
3233      =2  #define SCON0_REN__BMASK            0x10 ///< Receive Enable                                   
3234      =2  #define SCON0_REN__SHIFT            0x04 ///< Receive Enable                                   
3235      =2  #define SCON0_REN__RECEIVE_DISABLED 0x00 ///< UART0 reception disabled.                        
3236      =2  #define SCON0_REN__RECEIVE_ENABLED  0x10 ///< UART0 reception enabled.                         
3237      =2                                                                                                 
3238      =2  #define SCON0_MCE__BMASK            0x20 ///< Multiprocessor Communication Enable              
3239      =2  #define SCON0_MCE__SHIFT            0x05 ///< Multiprocessor Communication Enable              
3240      =2  #define SCON0_MCE__MULTI_DISABLED   0x00 ///< Ignore level of 9th bit / Stop bit.              
3241      =2  #define SCON0_MCE__MULTI_ENABLED    0x20 ///< RI is set and an interrupt is generated only when
3242      =2                                           ///< the stop bit is logic 1 (Mode 0) or when the 9th 
3243      =2                                           ///< bit is logic 1 (Mode 1).                         
3244      =2                                                                                                 
3245      =2  #define SCON0_SMODE__BMASK          0x80 ///< Serial Port 0 Operation Mode                     
3246      =2  #define SCON0_SMODE__SHIFT          0x07 ///< Serial Port 0 Operation Mode                     
3247      =2  #define SCON0_SMODE__8_BIT          0x00 ///< 8-bit UART with Variable Baud Rate (Mode 0).     
3248      =2  #define SCON0_SMODE__9_BIT          0x80 ///< 9-bit UART with Variable Baud Rate (Mode 1).     
3249      =2                                                                                                 
3250      =2  //------------------------------------------------------------------------------
3251      =2  // CLKREC Enums (USB0 Clock Recovery Control @ 0x0F)
3252      =2  //------------------------------------------------------------------------------
3253      =2  #define CLKREC_CRLOW__BMASK      0x20 ///< Low Speed Clock Recovery Mode               
3254      =2  #define CLKREC_CRLOW__SHIFT      0x05 ///< Low Speed Clock Recovery Mode               
3255      =2  #define CLKREC_CRLOW__FULL_SPEED 0x00 ///< Full Speed Mode.                            
3256      =2  #define CLKREC_CRLOW__LOW_SPEED  0x20 ///< Low Speed Mode.                             
3257      =2                                                                                         
C51 COMPILER V9.56.0.0   I2C_0                                                             10/28/2016 17:37:02 PAGE 80  

3258      =2  #define CLKREC_CRSSEN__BMASK     0x40 ///< Clock Recovery Single Step                  
3259      =2  #define CLKREC_CRSSEN__SHIFT     0x06 ///< Clock Recovery Single Step                  
3260      =2  #define CLKREC_CRSSEN__DISABLED  0x00 ///< Disable single-step mode (normal calibration
3261      =2                                        ///< mode).                                      
3262      =2  #define CLKREC_CRSSEN__ENABLED   0x40 ///< Enable single-step mode.                    
3263      =2                                                                                         
3264      =2  #define CLKREC_CRE__BMASK        0x80 ///< Clock Recovery Enable                       
3265      =2  #define CLKREC_CRE__SHIFT        0x07 ///< Clock Recovery Enable                       
3266      =2  #define CLKREC_CRE__DISABLED     0x00 ///< Disable clock recovery.                     
3267      =2  #define CLKREC_CRE__ENABLED      0x80 ///< Enable clock recovery.                      
3268      =2                                                                                         
3269      =2  //------------------------------------------------------------------------------
3270      =2  // CMIE Enums (USB0 Common Interrupt Enable @ 0x0B)
3271      =2  //------------------------------------------------------------------------------
3272      =2  #define CMIE_SUSINTE__BMASK    0x01 ///< Suspend Interrupt Enable       
3273      =2  #define CMIE_SUSINTE__SHIFT    0x00 ///< Suspend Interrupt Enable       
3274      =2  #define CMIE_SUSINTE__DISABLED 0x00 ///< Disable suspend interrupts.    
3275      =2  #define CMIE_SUSINTE__ENABLED  0x01 ///< Enable suspend interrupts.     
3276      =2                                                                          
3277      =2  #define CMIE_RSUINTE__BMASK    0x02 ///< Resume Interrupt Enable        
3278      =2  #define CMIE_RSUINTE__SHIFT    0x01 ///< Resume Interrupt Enable        
3279      =2  #define CMIE_RSUINTE__DISABLED 0x00 ///< Disable resume interrupts.     
3280      =2  #define CMIE_RSUINTE__ENABLED  0x02 ///< Enable resume interrupts.      
3281      =2                                                                          
3282      =2  #define CMIE_RSTINTE__BMASK    0x04 ///< Reset Interrupt Enable         
3283      =2  #define CMIE_RSTINTE__SHIFT    0x02 ///< Reset Interrupt Enable         
3284      =2  #define CMIE_RSTINTE__DISABLED 0x00 ///< Disable reset interrupts.      
3285      =2  #define CMIE_RSTINTE__ENABLED  0x04 ///< Enable reset interrupts.       
3286      =2                                                                          
3287      =2  #define CMIE_SOFE__BMASK       0x08 ///< Start of Frame Interrupt Enable
3288      =2  #define CMIE_SOFE__SHIFT       0x03 ///< Start of Frame Interrupt Enable
3289      =2  #define CMIE_SOFE__DISABLED    0x00 ///< Disable SOF interrupts.        
3290      =2  #define CMIE_SOFE__ENABLED     0x08 ///< Enable SOF interrupts.         
3291      =2                                                                          
3292      =2  //------------------------------------------------------------------------------
3293      =2  // CMINT Enums (USB0 Common Interrupt @ 0x06)
3294      =2  //------------------------------------------------------------------------------
3295      =2  #define CMINT_SUSINT__BMASK   0x01 ///< Suspend Interrupt Flag       
3296      =2  #define CMINT_SUSINT__SHIFT   0x00 ///< Suspend Interrupt Flag       
3297      =2  #define CMINT_SUSINT__NOT_SET 0x00 ///< Suspend interrupt inactive.  
3298      =2  #define CMINT_SUSINT__SET     0x01 ///< Suspend interrupt active.    
3299      =2                                                                       
3300      =2  #define CMINT_RSUINT__BMASK   0x02 ///< Resume Interrupt Flag        
3301      =2  #define CMINT_RSUINT__SHIFT   0x01 ///< Resume Interrupt Flag        
3302      =2  #define CMINT_RSUINT__NOT_SET 0x00 ///< Resume interrupt inactive.   
3303      =2  #define CMINT_RSUINT__SET     0x02 ///< Resume interrupt active.     
3304      =2                                                                       
3305      =2  #define CMINT_RSTINT__BMASK   0x04 ///< Reset Interrupt Flag         
3306      =2  #define CMINT_RSTINT__SHIFT   0x02 ///< Reset Interrupt Flag         
3307      =2  #define CMINT_RSTINT__NOT_SET 0x00 ///< Reset interrupt inactive.    
3308      =2  #define CMINT_RSTINT__SET     0x04 ///< Reset interrupt active.      
3309      =2                                                                       
3310      =2  #define CMINT_SOF__BMASK      0x08 ///< Start of Frame Interrupt Flag
3311      =2  #define CMINT_SOF__SHIFT      0x03 ///< Start of Frame Interrupt Flag
3312      =2  #define CMINT_SOF__NOT_SET    0x00 ///< SOF interrupt inactive.      
3313      =2  #define CMINT_SOF__SET        0x08 ///< SOF interrupt active.        
3314      =2                                                                       
3315      =2  //------------------------------------------------------------------------------
3316      =2  // E0CNT Enums (USB0 Endpoint0 Data Count @ 0x16)
3317      =2  //------------------------------------------------------------------------------
3318      =2  #define E0CNT_E0CNT__FMASK 0x7F ///< Endpoint 0 Data Count
3319      =2  #define E0CNT_E0CNT__SHIFT 0x00 ///< Endpoint 0 Data Count
C51 COMPILER V9.56.0.0   I2C_0                                                             10/28/2016 17:37:02 PAGE 81  

3320      =2                                                            
3321      =2  //------------------------------------------------------------------------------
3322      =2  // E0CSR Enums (USB0 Endpoint0 Control @ 0x11)
3323      =2  //------------------------------------------------------------------------------
3324      =2  #define E0CSR_OPRDY__BMASK     0x01 ///< OUT Packet Ready                                  
3325      =2  #define E0CSR_OPRDY__SHIFT     0x00 ///< OUT Packet Ready                                  
3326      =2  #define E0CSR_OPRDY__NOT_SET   0x00 ///< A data packet has not been received.              
3327      =2  #define E0CSR_OPRDY__SET       0x01 ///< A data packet has been received.                  
3328      =2                                                                                             
3329      =2  #define E0CSR_INPRDY__BMASK    0x02 ///< IN Packet Ready                                   
3330      =2  #define E0CSR_INPRDY__SHIFT    0x01 ///< IN Packet Ready                                   
3331      =2  #define E0CSR_INPRDY__NOT_SET  0x00 ///< An IN packet is not ready to transmit.            
3332      =2  #define E0CSR_INPRDY__SET      0x02 ///< An IN packet is ready to transmit.                
3333      =2                                                                                             
3334      =2  #define E0CSR_STSTL__BMASK     0x04 ///< Sent Stall                                        
3335      =2  #define E0CSR_STSTL__SHIFT     0x02 ///< Sent Stall                                        
3336      =2  #define E0CSR_STSTL__NOT_SET   0x00 ///< A STALL handshake signal was not transmitted.     
3337      =2  #define E0CSR_STSTL__SET       0x04 ///< A STALL handshake signal was transmitted.         
3338      =2                                                                                             
3339      =2  #define E0CSR_DATAEND__BMASK   0x08 ///< Data End                                          
3340      =2  #define E0CSR_DATAEND__SHIFT   0x03 ///< Data End                                          
3341      =2  #define E0CSR_DATAEND__NOT_SET 0x00 ///< This is not the last data packet.                 
3342      =2  #define E0CSR_DATAEND__SET     0x08 ///< This is the last data packet.                     
3343      =2                                                                                             
3344      =2  #define E0CSR_SUEND__BMASK     0x10 ///< Setup End                                         
3345      =2  #define E0CSR_SUEND__SHIFT     0x04 ///< Setup End                                         
3346      =2  #define E0CSR_SUEND__NOT_SET   0x00 ///< A control transaction did not end before firmware 
3347      =2                                      ///< wrote a 1 to the DATAEND bit.                     
3348      =2  #define E0CSR_SUEND__SET       0x10 ///< A control transaction ended before firmware wrote 
3349      =2                                      ///< a 1 to the DATAEND bit.                           
3350      =2                                                                                             
3351      =2  #define E0CSR_SDSTL__BMASK     0x20 ///< Send Stall                                        
3352      =2  #define E0CSR_SDSTL__SHIFT     0x05 ///< Send Stall                                        
3353      =2  #define E0CSR_SDSTL__NOT_SET   0x00 ///< Do not send a STALL.                              
3354      =2  #define E0CSR_SDSTL__SET       0x20 ///< Send a STALL.                                     
3355      =2                                                                                             
3356      =2  #define E0CSR_SOPRDY__BMASK    0x40 ///< Serviced OPRDY                                    
3357      =2  #define E0CSR_SOPRDY__SHIFT    0x06 ///< Serviced OPRDY                                    
3358      =2  #define E0CSR_SOPRDY__NOT_SET  0x00 ///< OUT packet has not been serviced.                 
3359      =2  #define E0CSR_SOPRDY__SET      0x40 ///< OUT packet has been serviced.                     
3360      =2                                                                                             
3361      =2  #define E0CSR_SSUEND__BMASK    0x80 ///< Serviced Setup End                                
3362      =2  #define E0CSR_SSUEND__SHIFT    0x07 ///< Serviced Setup End                                
3363      =2  #define E0CSR_SSUEND__NOT_SET  0x00 ///< The setup end (SUEND) event has not been serviced.
3364      =2  #define E0CSR_SSUEND__SET      0x80 ///< The setup end (SUEND) event has been serviced.    
3365      =2                                                                                             
3366      =2  //------------------------------------------------------------------------------
3367      =2  // EENABLE Enums (USB0 Endpoint Enable @ 0x1E)
3368      =2  //------------------------------------------------------------------------------
3369      =2  #define EENABLE_EEN1__BMASK    0x02 ///< Endpoint 1 Enable                                
3370      =2  #define EENABLE_EEN1__SHIFT    0x01 ///< Endpoint 1 Enable                                
3371      =2  #define EENABLE_EEN1__DISABLED 0x00 ///< Disable Endpoint 1 (no NACK, ACK, or STALL on the
3372      =2                                      ///< USB network).                                    
3373      =2  #define EENABLE_EEN1__ENABLED  0x02 ///< Enable Endpoint 1 (normal).                      
3374      =2                                                                                            
3375      =2  #define EENABLE_EEN2__BMASK    0x04 ///< Endpoint 2 Enable                                
3376      =2  #define EENABLE_EEN2__SHIFT    0x02 ///< Endpoint 2 Enable                                
3377      =2  #define EENABLE_EEN2__DISABLED 0x00 ///< Disable Endpoint 2 (no NACK, ACK, or STALL on the
3378      =2                                      ///< USB network).                                    
3379      =2  #define EENABLE_EEN2__ENABLED  0x04 ///< Enable Endpoint 2 (normal).                      
3380      =2                                                                                            
3381      =2  #define EENABLE_EEN3__BMASK    0x08 ///< Endpoint 3 Enable                                
C51 COMPILER V9.56.0.0   I2C_0                                                             10/28/2016 17:37:02 PAGE 82  

3382      =2  #define EENABLE_EEN3__SHIFT    0x03 ///< Endpoint 3 Enable                                
3383      =2  #define EENABLE_EEN3__DISABLED 0x00 ///< Disable Endpoint 3 (no NACK, ACK, or STALL on the
3384      =2                                      ///< USB network).                                    
3385      =2  #define EENABLE_EEN3__ENABLED  0x08 ///< Enable Endpoint 3 (normal).                      
3386      =2                                                                                            
3387      =2  //------------------------------------------------------------------------------
3388      =2  // EINCSRH Enums (USB0 IN Endpoint Control High @ 0x12)
3389      =2  //------------------------------------------------------------------------------
3390      =2  #define EINCSRH_SPLIT__BMASK        0x04 ///< FIFO Split Enable                                
3391      =2  #define EINCSRH_SPLIT__SHIFT        0x02 ///< FIFO Split Enable                                
3392      =2  #define EINCSRH_SPLIT__DISABLED     0x00 ///< Disable split mode.                              
3393      =2  #define EINCSRH_SPLIT__ENABLED      0x04 ///< Enable split mode.                               
3394      =2                                                                                                 
3395      =2  #define EINCSRH_FCDT__BMASK         0x08 ///< Force Data Toggle                                
3396      =2  #define EINCSRH_FCDT__SHIFT         0x03 ///< Force Data Toggle                                
3397      =2  #define EINCSRH_FCDT__ACK_TOGGLE    0x00 ///< Endpoint data toggle switches only when an ACK is
3398      =2                                           ///< received following a data packet transmission.   
3399      =2  #define EINCSRH_FCDT__ALWAYS_TOGGLE 0x08 ///< Endpoint data toggle forced to switch after every
3400      =2                                           ///< data packet is transmitted, regardless of ACK    
3401      =2                                           ///< reception.                                       
3402      =2                                                                                                 
3403      =2  #define EINCSRH_DIRSEL__BMASK       0x20 ///< Endpoint Direction Select                        
3404      =2  #define EINCSRH_DIRSEL__SHIFT       0x05 ///< Endpoint Direction Select                        
3405      =2  #define EINCSRH_DIRSEL__OUT         0x00 ///< Endpoint direction selected as OUT.              
3406      =2  #define EINCSRH_DIRSEL__IN          0x20 ///< Endpoint direction selected as IN.               
3407      =2                                                                                                 
3408      =2  #define EINCSRH_ISO__BMASK          0x40 ///< Isochronous Transfer Enable                      
3409      =2  #define EINCSRH_ISO__SHIFT          0x06 ///< Isochronous Transfer Enable                      
3410      =2  #define EINCSRH_ISO__DISABLED       0x00 ///< Endpoint configured for Bulk/Interrupt transfers.
3411      =2  #define EINCSRH_ISO__ENABLED        0x40 ///< Endpoint configured for Isochronous transfers.   
3412      =2                                                                                                 
3413      =2  #define EINCSRH_DBIEN__BMASK        0x80 ///< IN Endpoint Double-Buffer Enable                 
3414      =2  #define EINCSRH_DBIEN__SHIFT        0x07 ///< IN Endpoint Double-Buffer Enable                 
3415      =2  #define EINCSRH_DBIEN__DISABLED     0x00 ///< Disable double-buffering for the selected IN     
3416      =2                                           ///< endpoint.                                        
3417      =2  #define EINCSRH_DBIEN__ENABLED      0x80 ///< Enable double-buffering for the selected IN      
3418      =2                                           ///< endpoint.                                        
3419      =2                                                                                                 
3420      =2  //------------------------------------------------------------------------------
3421      =2  // EINCSRL Enums (USB0 IN Endpoint Control Low @ 0x11)
3422      =2  //------------------------------------------------------------------------------
3423      =2  #define EINCSRL_INPRDY__BMASK     0x01 ///< In Packet Ready                                   
3424      =2  #define EINCSRL_INPRDY__SHIFT     0x00 ///< In Packet Ready                                   
3425      =2  #define EINCSRL_INPRDY__NOT_SET   0x00 ///< A packet is not available in the Endpoint IN FIFO.
3426      =2  #define EINCSRL_INPRDY__SET       0x01 ///< A packet is available in the Endpoint IN FIFO.    
3427      =2                                                                                                
3428      =2  #define EINCSRL_FIFONE__BMASK     0x02 ///< FIFO Not Empty                                    
3429      =2  #define EINCSRL_FIFONE__SHIFT     0x01 ///< FIFO Not Empty                                    
3430      =2  #define EINCSRL_FIFONE__EMPTY     0x00 ///< The IN Endpoint FIFO is empty.                    
3431      =2  #define EINCSRL_FIFONE__NOT_EMPTY 0x02 ///< The IN Endpoint FIFO contains one or more packets.
3432      =2                                                                                                
3433      =2  #define EINCSRL_UNDRUN__BMASK     0x04 ///< Data Underrun Flag                                
3434      =2  #define EINCSRL_UNDRUN__SHIFT     0x02 ///< Data Underrun Flag                                
3435      =2  #define EINCSRL_UNDRUN__NOT_SET   0x00 ///< A data underrun did not occur.                    
3436      =2  #define EINCSRL_UNDRUN__SET       0x04 ///< A data underrun occurred.                         
3437      =2                                                                                                
3438      =2  #define EINCSRL_FLUSH__BMASK      0x08 ///< FIFO Flush                                        
3439      =2  #define EINCSRL_FLUSH__SHIFT      0x03 ///< FIFO Flush                                        
3440      =2  #define EINCSRL_FLUSH__NOT_SET    0x00 ///< Do not flush the next packet.                     
3441      =2  #define EINCSRL_FLUSH__SET        0x08 ///< Flush the next packet to be transmitted from the  
3442      =2                                         ///< IN Endpoint FIFO.                                 
3443      =2                                                                                                
C51 COMPILER V9.56.0.0   I2C_0                                                             10/28/2016 17:37:02 PAGE 83  

3444      =2  #define EINCSRL_SDSTL__BMASK      0x10 ///< Send Stall                                        
3445      =2  #define EINCSRL_SDSTL__SHIFT      0x04 ///< Send Stall                                        
3446      =2  #define EINCSRL_SDSTL__NOT_SET    0x00 ///< Terminate the STALL.                              
3447      =2  #define EINCSRL_SDSTL__SET        0x10 ///< Generate a STALL in response to an IN token.      
3448      =2                                                                                                
3449      =2  #define EINCSRL_STSTL__BMASK      0x20 ///< Sent Stall Flag                                   
3450      =2  #define EINCSRL_STSTL__SHIFT      0x05 ///< Sent Stall Flag                                   
3451      =2  #define EINCSRL_STSTL__NOT_SET    0x00 ///< A STALL handshake was not transmitted.            
3452      =2  #define EINCSRL_STSTL__SET        0x20 ///< A STALL handshake was transmitted.                
3453      =2                                                                                                
3454      =2  #define EINCSRL_CLRDT__BMASK      0x40 ///< Clear Data Toggle                                 
3455      =2  #define EINCSRL_CLRDT__SHIFT      0x06 ///< Clear Data Toggle                                 
3456      =2  #define EINCSRL_CLRDT__CLEAR      0x00 ///< Clear the IN Endpoint data toggle.                
3457      =2                                                                                                
3458      =2  //------------------------------------------------------------------------------
3459      =2  // EOUTCNTH Enums (USB0 OUT Endpoint Count High @ 0x17)
3460      =2  //------------------------------------------------------------------------------
3461      =2  #define EOUTCNTH_EOCH__FMASK 0x03 ///< OUT Endpoint Count High
3462      =2  #define EOUTCNTH_EOCH__SHIFT 0x00 ///< OUT Endpoint Count High
3463      =2                                                                
3464      =2  //------------------------------------------------------------------------------
3465      =2  // EOUTCNTL Enums (USB0 OUT Endpoint Count Low @ 0x16)
3466      =2  //------------------------------------------------------------------------------
3467      =2  #define EOUTCNTL_EOCL__FMASK 0xFF ///< OUT Endpoint Count Low
3468      =2  #define EOUTCNTL_EOCL__SHIFT 0x00 ///< OUT Endpoint Count Low
3469      =2                                                               
3470      =2  //------------------------------------------------------------------------------
3471      =2  // EOUTCSRH Enums (USB0 OUT Endpoint Control High @ 0x15)
3472      =2  //------------------------------------------------------------------------------
3473      =2  #define EOUTCSRH_ISO__BMASK      0x40 ///< Isochronous Transfer Enable                      
3474      =2  #define EOUTCSRH_ISO__SHIFT      0x06 ///< Isochronous Transfer Enable                      
3475      =2  #define EOUTCSRH_ISO__DISABLED   0x00 ///< Endpoint configured for Bulk/Interrupt transfers.
3476      =2  #define EOUTCSRH_ISO__ENABLED    0x40 ///< Endpoint configured for Isochronous transfers.   
3477      =2                                                                                              
3478      =2  #define EOUTCSRH_DBOEN__BMASK    0x80 ///< Double-Buffer Enable                             
3479      =2  #define EOUTCSRH_DBOEN__SHIFT    0x07 ///< Double-Buffer Enable                             
3480      =2  #define EOUTCSRH_DBOEN__DISABLED 0x00 ///< Disable double-buffering for the selected OUT    
3481      =2                                        ///< endpoint.                                        
3482      =2  #define EOUTCSRH_DBOEN__ENABLED  0x80 ///< Enable double-buffering for the selected OUT     
3483      =2                                        ///< endpoint.                                        
3484      =2                                                                                              
3485      =2  //------------------------------------------------------------------------------
3486      =2  // EOUTCSRL Enums (USB0 OUT Endpoint Control Low @ 0x14)
3487      =2  //------------------------------------------------------------------------------
3488      =2  #define EOUTCSRL_OPRDY__BMASK      0x01 ///< OUT Packet Ready                                  
3489      =2  #define EOUTCSRL_OPRDY__SHIFT      0x00 ///< OUT Packet Ready                                  
3490      =2  #define EOUTCSRL_OPRDY__NOT_SET    0x00 ///< A data packet is not available in the Endpoint OUT
3491      =2                                          ///< FIFO.                                             
3492      =2  #define EOUTCSRL_OPRDY__SET        0x01 ///< A data packet is available in the Endpoint OUT    
3493      =2                                          ///< FIFO.                                             
3494      =2                                                                                                 
3495      =2  #define EOUTCSRL_FIFOFUL__BMASK    0x02 ///< OUT FIFO Full                                     
3496      =2  #define EOUTCSRL_FIFOFUL__SHIFT    0x01 ///< OUT FIFO Full                                     
3497      =2  #define EOUTCSRL_FIFOFUL__NOT_FULL 0x00 ///< OUT endpoint FIFO is not full.                    
3498      =2  #define EOUTCSRL_FIFOFUL__FULL     0x02 ///< OUT endpoint FIFO is full.                        
3499      =2                                                                                                 
3500      =2  #define EOUTCSRL_OVRUN__BMASK      0x04 ///< Data Overrun Flag                                 
3501      =2  #define EOUTCSRL_OVRUN__SHIFT      0x02 ///< Data Overrun Flag                                 
3502      =2  #define EOUTCSRL_OVRUN__NOT_SET    0x00 ///< No data overrun.                                  
3503      =2  #define EOUTCSRL_OVRUN__SET        0x04 ///< A data packet was lost because of a full FIFO     
3504      =2                                          ///< since this flag was last cleared.                 
3505      =2                                                                                                 
C51 COMPILER V9.56.0.0   I2C_0                                                             10/28/2016 17:37:02 PAGE 84  

3506      =2  #define EOUTCSRL_DATERR__BMASK     0x08 ///< Data Error Flag                                   
3507      =2  #define EOUTCSRL_DATERR__SHIFT     0x03 ///< Data Error Flag                                   
3508      =2  #define EOUTCSRL_DATERR__NOT_SET   0x00 ///< A received packet does not have a CRC or bit-     
3509      =2                                          ///< stuffing error.                                   
3510      =2  #define EOUTCSRL_DATERR__SET       0x08 ///< A received packet has a CRC or bit-stuffing error.
3511      =2                                                                                                 
3512      =2  #define EOUTCSRL_FLUSH__BMASK      0x10 ///< FIFO Flush                                        
3513      =2  #define EOUTCSRL_FLUSH__SHIFT      0x04 ///< FIFO Flush                                        
3514      =2  #define EOUTCSRL_FLUSH__NOT_SET    0x00 ///< Do not flush the next packet.                     
3515      =2  #define EOUTCSRL_FLUSH__SET        0x10 ///< Flush the next packet to be read from the OUT     
3516      =2                                          ///< endpoint FIFO.                                    
3517      =2                                                                                                 
3518      =2  #define EOUTCSRL_SDSTL__BMASK      0x20 ///< Send Stall                                        
3519      =2  #define EOUTCSRL_SDSTL__SHIFT      0x05 ///< Send Stall                                        
3520      =2  #define EOUTCSRL_SDSTL__NOT_SET    0x00 ///< Terminate the STALL.                              
3521      =2  #define EOUTCSRL_SDSTL__SET        0x20 ///< Generate a STALL handshake.                       
3522      =2                                                                                                 
3523      =2  #define EOUTCSRL_STSTL__BMASK      0x40 ///< Sent Stall Flag                                   
3524      =2  #define EOUTCSRL_STSTL__SHIFT      0x06 ///< Sent Stall Flag                                   
3525      =2  #define EOUTCSRL_STSTL__NOT_SET    0x00 ///< A STALL handshake was not transmitted.            
3526      =2  #define EOUTCSRL_STSTL__SET        0x40 ///< A STALL handshake was transmitted.                
3527      =2                                                                                                 
3528      =2  #define EOUTCSRL_CLRDT__BMASK      0x80 ///< Clear Data Toggle                                 
3529      =2  #define EOUTCSRL_CLRDT__SHIFT      0x07 ///< Clear Data Toggle                                 
3530      =2  #define EOUTCSRL_CLRDT__CLEAR      0x00 ///< Clear the OUT Endpoint data toggle.               
3531      =2                                                                                                 
3532      =2  //------------------------------------------------------------------------------
3533      =2  // FADDR Enums (USB0 Function Address @ 0x00)
3534      =2  //------------------------------------------------------------------------------
3535      =2  #define FADDR_FADDR__FMASK    0x7F ///< Function Address                               
3536      =2  #define FADDR_FADDR__SHIFT    0x00 ///< Function Address                               
3537      =2                                                                                         
3538      =2  #define FADDR_UPDATE__BMASK   0x80 ///< Function Address Update                        
3539      =2  #define FADDR_UPDATE__SHIFT   0x07 ///< Function Address Update                        
3540      =2  #define FADDR_UPDATE__NOT_SET 0x00 ///< The last address written to FADDR is in effect.
3541      =2  #define FADDR_UPDATE__SET     0x80 ///< The last address written to FADDR is not yet in
3542      =2                                     ///< effect.                                        
3543      =2                                                                                         
3544      =2  //------------------------------------------------------------------------------
3545      =2  // FIFO0 Enums (USB0 Endpoint 0 FIFO Access @ 0x20)
3546      =2  //------------------------------------------------------------------------------
3547      =2  #define FIFO0_FIFODATA__FMASK 0xFF ///< Endpoint 0 FIFO Access
3548      =2  #define FIFO0_FIFODATA__SHIFT 0x00 ///< Endpoint 0 FIFO Access
3549      =2                                                                
3550      =2  //------------------------------------------------------------------------------
3551      =2  // FIFO1 Enums (USB0 Endpoint 1 FIFO Access @ 0x21)
3552      =2  //------------------------------------------------------------------------------
3553      =2  #define FIFO1_FIFODATA__FMASK 0xFF ///< Endpoint 1 FIFO Access
3554      =2  #define FIFO1_FIFODATA__SHIFT 0x00 ///< Endpoint 1 FIFO Access
3555      =2                                                                
3556      =2  //------------------------------------------------------------------------------
3557      =2  // FIFO2 Enums (USB0 Endpoint 2 FIFO Access @ 0x22)
3558      =2  //------------------------------------------------------------------------------
3559      =2  #define FIFO2_FIFODATA__FMASK 0xFF ///< Endpoint 2 FIFO Access
3560      =2  #define FIFO2_FIFODATA__SHIFT 0x00 ///< Endpoint 2 FIFO Access
3561      =2                                                                
3562      =2  //------------------------------------------------------------------------------
3563      =2  // FIFO3 Enums (USB0 Endpoint 3 FIFO Access @ 0x23)
3564      =2  //------------------------------------------------------------------------------
3565      =2  #define FIFO3_FIFODATA__FMASK 0xFF ///< Endpoint 3 FIFO Access
3566      =2  #define FIFO3_FIFODATA__SHIFT 0x00 ///< Endpoint 3 FIFO Access
3567      =2                                                                
C51 COMPILER V9.56.0.0   I2C_0                                                             10/28/2016 17:37:02 PAGE 85  

3568      =2  //------------------------------------------------------------------------------
3569      =2  // FRAMEH Enums (USB0 Frame Number High @ 0x0D)
3570      =2  //------------------------------------------------------------------------------
3571      =2  #define FRAMEH_FRMEH__FMASK 0x07 ///< Frame Number High
3572      =2  #define FRAMEH_FRMEH__SHIFT 0x00 ///< Frame Number High
3573      =2                                                         
3574      =2  //------------------------------------------------------------------------------
3575      =2  // FRAMEL Enums (USB0 Frame Number Low @ 0x0C)
3576      =2  //------------------------------------------------------------------------------
3577      =2  #define FRAMEL_FRMEL__FMASK 0xFF ///< Frame Number Low
3578      =2  #define FRAMEL_FRMEL__SHIFT 0x00 ///< Frame Number Low
3579      =2                                                        
3580      =2  //------------------------------------------------------------------------------
3581      =2  // IN1IE Enums (USB0 IN Endpoint Interrupt Enable @ 0x07)
3582      =2  //------------------------------------------------------------------------------
3583      =2  #define IN1IE_EP0E__BMASK    0x01 ///< Endpoint 0 Interrupt Enable      
3584      =2  #define IN1IE_EP0E__SHIFT    0x00 ///< Endpoint 0 Interrupt Enable      
3585      =2  #define IN1IE_EP0E__DISABLED 0x00 ///< Disable Endpoint 0 interrupts.   
3586      =2  #define IN1IE_EP0E__ENABLED  0x01 ///< Enable Endpoint 0 interrupts.    
3587      =2                                                                          
3588      =2  #define IN1IE_IN1E__BMASK    0x02 ///< IN Endpoint 1 Interrupt Enable   
3589      =2  #define IN1IE_IN1E__SHIFT    0x01 ///< IN Endpoint 1 Interrupt Enable   
3590      =2  #define IN1IE_IN1E__DISABLED 0x00 ///< Disable Endpoint 1 IN interrupts.
3591      =2  #define IN1IE_IN1E__ENABLED  0x02 ///< Enable Endpoint 1 IN interrupts. 
3592      =2                                                                          
3593      =2  #define IN1IE_IN2E__BMASK    0x04 ///< IN Endpoint 2 Interrupt Enable   
3594      =2  #define IN1IE_IN2E__SHIFT    0x02 ///< IN Endpoint 2 Interrupt Enable   
3595      =2  #define IN1IE_IN2E__DISABLED 0x00 ///< Disable Endpoint 2 IN interrupts.
3596      =2  #define IN1IE_IN2E__ENABLED  0x04 ///< Enable Endpoint 2 IN interrupts. 
3597      =2                                                                          
3598      =2  #define IN1IE_IN3E__BMASK    0x08 ///< IN Endpoint 3 Interrupt Enable   
3599      =2  #define IN1IE_IN3E__SHIFT    0x03 ///< IN Endpoint 3 Interrupt Enable   
3600      =2  #define IN1IE_IN3E__DISABLED 0x00 ///< Disable Endpoint 3 IN interrupts.
3601      =2  #define IN1IE_IN3E__ENABLED  0x08 ///< Enable Endpoint 3 IN interrupts. 
3602      =2                                                                          
3603      =2  //------------------------------------------------------------------------------
3604      =2  // IN1INT Enums (USB0 IN Endpoint Interrupt @ 0x02)
3605      =2  //------------------------------------------------------------------------------
3606      =2  #define IN1INT_EP0__BMASK   0x01 ///< Endpoint 0 Interrupt Flag        
3607      =2  #define IN1INT_EP0__SHIFT   0x00 ///< Endpoint 0 Interrupt Flag        
3608      =2  #define IN1INT_EP0__NOT_SET 0x00 ///< Endpoint 0 interrupt inactive.   
3609      =2  #define IN1INT_EP0__SET     0x01 ///< Endpoint 0 interrupt active.     
3610      =2                                                                         
3611      =2  #define IN1INT_IN1__BMASK   0x02 ///< IN Endpoint 1 Interrupt Flag     
3612      =2  #define IN1INT_IN1__SHIFT   0x01 ///< IN Endpoint 1 Interrupt Flag     
3613      =2  #define IN1INT_IN1__NOT_SET 0x00 ///< IN Endpoint 1 interrupt inactive.
3614      =2  #define IN1INT_IN1__SET     0x02 ///< IN Endpoint 1 interrupt active.  
3615      =2                                                                         
3616      =2  #define IN1INT_IN2__BMASK   0x04 ///< IN Endpoint 2 Interrupt Flag     
3617      =2  #define IN1INT_IN2__SHIFT   0x02 ///< IN Endpoint 2 Interrupt Flag     
3618      =2  #define IN1INT_IN2__NOT_SET 0x00 ///< IN Endpoint 2 interrupt inactive.
3619      =2  #define IN1INT_IN2__SET     0x04 ///< IN Endpoint 2 interrupt active.  
3620      =2                                                                         
3621      =2  #define IN1INT_IN3__BMASK   0x08 ///< IN Endpoint 3 Interrupt Flag     
3622      =2  #define IN1INT_IN3__SHIFT   0x03 ///< IN Endpoint 3 Interrupt Flag     
3623      =2  #define IN1INT_IN3__NOT_SET 0x00 ///< IN Endpoint 3 interrupt inactive.
3624      =2  #define IN1INT_IN3__SET     0x08 ///< IN Endpoint 3 interrupt active.  
3625      =2                                                                         
3626      =2  //------------------------------------------------------------------------------
3627      =2  // INDEX Enums (USB0 Endpoint Index @ 0x0E)
3628      =2  //------------------------------------------------------------------------------
3629      =2  #define INDEX_EPSEL__FMASK      0x0F ///< Endpoint Select Bits
C51 COMPILER V9.56.0.0   I2C_0                                                             10/28/2016 17:37:02 PAGE 86  

3630      =2  #define INDEX_EPSEL__SHIFT      0x00 ///< Endpoint Select Bits
3631      =2  #define INDEX_EPSEL__ENDPOINT_0 0x00 ///< Endpoint 0.         
3632      =2  #define INDEX_EPSEL__ENDPOINT_1 0x01 ///< Endpoint 1.         
3633      =2  #define INDEX_EPSEL__ENDPOINT_2 0x02 ///< Endpoint 2.         
3634      =2  #define INDEX_EPSEL__ENDPOINT_3 0x03 ///< Endpoint 3.         
3635      =2                                                                
3636      =2  //------------------------------------------------------------------------------
3637      =2  // OUT1IE Enums (USB0 OUT Endpoint Interrupt Enable @ 0x09)
3638      =2  //------------------------------------------------------------------------------
3639      =2  #define OUT1IE_OUT1E__BMASK    0x02 ///< OUT Endpoint 1 Interrupt Enable   
3640      =2  #define OUT1IE_OUT1E__SHIFT    0x01 ///< OUT Endpoint 1 Interrupt Enable   
3641      =2  #define OUT1IE_OUT1E__DISABLED 0x00 ///< Disable Endpoint 1 OUT interrupts.
3642      =2  #define OUT1IE_OUT1E__ENABLED  0x02 ///< Enable Endpoint 1 OUT interrupts. 
3643      =2                                                                             
3644      =2  #define OUT1IE_OUT2E__BMASK    0x04 ///< OUT Endpoint 2 Interrupt Enable   
3645      =2  #define OUT1IE_OUT2E__SHIFT    0x02 ///< OUT Endpoint 2 Interrupt Enable   
3646      =2  #define OUT1IE_OUT2E__DISABLED 0x00 ///< Disable Endpoint 2 OUT interrupts.
3647      =2  #define OUT1IE_OUT2E__ENABLED  0x04 ///< Enable Endpoint 2 OUT interrupts. 
3648      =2                                                                             
3649      =2  #define OUT1IE_OUT3E__BMASK    0x08 ///< OUT Endpoint 3 Interrupt Enable   
3650      =2  #define OUT1IE_OUT3E__SHIFT    0x03 ///< OUT Endpoint 3 Interrupt Enable   
3651      =2  #define OUT1IE_OUT3E__DISABLED 0x00 ///< Disable Endpoint 3 OUT interrupts.
3652      =2  #define OUT1IE_OUT3E__ENABLED  0x08 ///< Enable Endpoint 3 OUT interrupts. 
3653      =2                                                                             
3654      =2  //------------------------------------------------------------------------------
3655      =2  // OUT1INT Enums (USB0 OUT Endpoint Interrupt @ 0x04)
3656      =2  //------------------------------------------------------------------------------
3657      =2  #define OUT1INT_OUT1__BMASK   0x02 ///< OUT Endpoint 1 Interrupt Flag     
3658      =2  #define OUT1INT_OUT1__SHIFT   0x01 ///< OUT Endpoint 1 Interrupt Flag     
3659      =2  #define OUT1INT_OUT1__NOT_SET 0x00 ///< OUT Endpoint 1 interrupt inactive.
3660      =2  #define OUT1INT_OUT1__SET     0x02 ///< OUT Endpoint 1 interrupt active.  
3661      =2                                                                            
3662      =2  #define OUT1INT_OUT2__BMASK   0x04 ///< OUT Endpoint 2 Interrupt Flag     
3663      =2  #define OUT1INT_OUT2__SHIFT   0x02 ///< OUT Endpoint 2 Interrupt Flag     
3664      =2  #define OUT1INT_OUT2__NOT_SET 0x00 ///< OUT Endpoint 2 interrupt inactive.
3665      =2  #define OUT1INT_OUT2__SET     0x04 ///< OUT Endpoint 2 interrupt active.  
3666      =2                                                                            
3667      =2  #define OUT1INT_OUT3__BMASK   0x08 ///< OUT Endpoint 3 Interrupt Flag     
3668      =2  #define OUT1INT_OUT3__SHIFT   0x03 ///< OUT Endpoint 3 Interrupt Flag     
3669      =2  #define OUT1INT_OUT3__NOT_SET 0x00 ///< OUT Endpoint 3 interrupt inactive.
3670      =2  #define OUT1INT_OUT3__SET     0x08 ///< OUT Endpoint 3 interrupt active.  
3671      =2                                                                            
3672      =2  //------------------------------------------------------------------------------
3673      =2  // POWER Enums (USB0 Power @ 0x01)
3674      =2  //------------------------------------------------------------------------------
3675      =2  #define POWER_SUSEN__BMASK         0x01 ///< Suspend Detection Enable                          
3676      =2  #define POWER_SUSEN__SHIFT         0x00 ///< Suspend Detection Enable                          
3677      =2  #define POWER_SUSEN__DISABLED      0x00 ///< Disable suspend detection. USB0 will ignore       
3678      =2                                          ///< suspend signaling on the bus.                     
3679      =2  #define POWER_SUSEN__ENABLED       0x01 ///< Enable suspend detection. USB0 will enter suspend 
3680      =2                                          ///< mode if it detects suspend signaling on the bus.  
3681      =2                                                                                                 
3682      =2  #define POWER_SUSMD__BMASK         0x02 ///< Suspend Mode                                      
3683      =2  #define POWER_SUSMD__SHIFT         0x01 ///< Suspend Mode                                      
3684      =2  #define POWER_SUSMD__NOT_SUSPENDED 0x00 ///< USB0 not in suspend mode.                         
3685      =2  #define POWER_SUSMD__SUSPENDED     0x02 ///< USB0 in suspend mode.                             
3686      =2                                                                                                 
3687      =2  #define POWER_RESUME__BMASK        0x04 ///< Force Resume                                      
3688      =2  #define POWER_RESUME__SHIFT        0x02 ///< Force Resume                                      
3689      =2  #define POWER_RESUME__START        0x04 ///< Generate resume signalling to create a remote     
3690      =2                                          ///< wakeup event.                                     
3691      =2                                                                                                 
C51 COMPILER V9.56.0.0   I2C_0                                                             10/28/2016 17:37:02 PAGE 87  

3692      =2  #define POWER_USBRST__BMASK        0x08 ///< Reset Detect                                      
3693      =2  #define POWER_USBRST__SHIFT        0x03 ///< Reset Detect                                      
3694      =2  #define POWER_USBRST__NOT_SET      0x00 ///< USB reset signalling not detected.                
3695      =2  #define POWER_USBRST__SET          0x08 ///< USB reset signalling detected.                    
3696      =2                                                                                                 
3697      =2  #define POWER_USBINH__BMASK        0x10 ///< USB0 Inhibit                                      
3698      =2  #define POWER_USBINH__SHIFT        0x04 ///< USB0 Inhibit                                      
3699      =2  #define POWER_USBINH__ENABLED      0x00 ///< USB0 enabled.                                     
3700      =2  #define POWER_USBINH__DISABLED     0x10 ///< USB0 inhibited. All USB traffic is ignored.       
3701      =2                                                                                                 
3702      =2  #define POWER_ISOUD__BMASK         0x80 ///< Isochronous Update Mode                           
3703      =2  #define POWER_ISOUD__SHIFT         0x07 ///< Isochronous Update Mode                           
3704      =2  #define POWER_ISOUD__IN_TOKEN      0x00 ///< When firmware writes INPRDY = 1, USB0 will send   
3705      =2                                          ///< the packet when the next IN token is received.    
3706      =2  #define POWER_ISOUD__SOF_TOKEN     0x80 ///< When firmware writes INPRDY = 1, USB0 will wait   
3707      =2                                          ///< for a SOF token before sending the packet. If an  
3708      =2                                          ///< IN token is received before a SOF token, USB0 will
3709      =2                                          ///< send a zero-length data packet.                   
3710      =2                                                                                                 
3711      =2  //------------------------------------------------------------------------------
3712      =2  // USB0ADR Enums (USB0 Indirect Address @ 0x96)
3713      =2  //------------------------------------------------------------------------------
3714      =2  #define USB0ADR_USB0ADR__FMASK          0x3F ///< USB0 Indirect Register Address                    
3715      =2  #define USB0ADR_USB0ADR__SHIFT          0x00 ///< USB0 Indirect Register Address                    
3716      =2  #define USB0ADR_USB0ADR__FADDR          0x00 ///< Function Address.                                 
3717      =2  #define USB0ADR_USB0ADR__POWER          0x01 ///< Power Management.                                 
3718      =2  #define USB0ADR_USB0ADR__IN1INT         0x02 ///< Endpoint 0 and Endpoints 1-3 IN Interrupt Flags.  
3719      =2  #define USB0ADR_USB0ADR__OUT1INT        0x04 ///< Endpoints 1-3 OUT Interrupt Flags.                
3720      =2  #define USB0ADR_USB0ADR__CMINT          0x06 ///< Common USB Interrupt Flags.                       
3721      =2  #define USB0ADR_USB0ADR__IN1IE          0x07 ///< Endpoint 0 and Endpoints 1-3 IN Interrupt Enables.
3722      =2  #define USB0ADR_USB0ADR__OUT1IE         0x09 ///< Endpoints 1-3 OUT Interrupt Enables.              
3723      =2  #define USB0ADR_USB0ADR__CMIE           0x0B ///< Common USB Interrupt Enables.                     
3724      =2  #define USB0ADR_USB0ADR__FRAMEL         0x0C ///< Frame Number Low Byte.                            
3725      =2  #define USB0ADR_USB0ADR__FRAMEH         0x0D ///< Frame Number High Byte.                           
3726      =2  #define USB0ADR_USB0ADR__INDEX          0x0E ///< Endpoint Index Selection.                         
3727      =2  #define USB0ADR_USB0ADR__CLKREC         0x0F ///< Clock Recovery Control.                           
3728      =2  #define USB0ADR_USB0ADR__E0CSR_EINCSRL  0x11 ///< Endpoint 0 Control / Status, Endpoint IN Control /
3729      =2                                               ///< Status Low Byte.                                  
3730      =2  #define USB0ADR_USB0ADR__EINCSRH        0x12 ///< Endpoint IN Control / Status High Byte.           
3731      =2  #define USB0ADR_USB0ADR__EOUTCSRL       0x14 ///< Endpoint OUT Control / Status Low Byte.           
3732      =2  #define USB0ADR_USB0ADR__EOUTCSRH       0x15 ///< Endpoint OUT Control / Status High Byte.          
3733      =2  #define USB0ADR_USB0ADR__E0CNT_EOUTCNTL 0x16 ///< Number of Received Bytes in Endpoint 0 FIFO,      
3734      =2                                               ///< Endpoint OUT Packet Count Low Byte.               
3735      =2  #define USB0ADR_USB0ADR__EOUTCNTH       0x17 ///< Endpoint OUT Packet Count High Byte.              
3736      =2  #define USB0ADR_USB0ADR__EENABLE        0x1E ///< Endpoint Enable.                                  
3737      =2  #define USB0ADR_USB0ADR__FIFO0          0x20 ///< Endpoint 0 FIFO.                                  
3738      =2  #define USB0ADR_USB0ADR__FIFO1          0x21 ///< Endpoint 1 FIFO.                                  
3739      =2  #define USB0ADR_USB0ADR__FIFO2          0x22 ///< Endpoint 2 FIFO.                                  
3740      =2  #define USB0ADR_USB0ADR__FIFO3          0x23 ///< Endpoint 3 FIFO.                                  
3741      =2                                                                                                      
3742      =2  #define USB0ADR_AUTORD__BMASK           0x40 ///< USB0 Register Auto-Read Flag                      
3743      =2  #define USB0ADR_AUTORD__SHIFT           0x06 ///< USB0 Register Auto-Read Flag                      
3744      =2  #define USB0ADR_AUTORD__DISABLED        0x00 ///< BUSY must be written manually for each USB0       
3745      =2                                               ///< indirect register read.                           
3746      =2  #define USB0ADR_AUTORD__ENABLED         0x40 ///< The next indirect register read will automatically
3747      =2                                               ///< be initiated when firmware reads USB0DAT (USBADDR 
3748      =2                                               ///< bits will not be changed).                        
3749      =2                                                                                                      
3750      =2  #define USB0ADR_BUSY__BMASK             0x80 ///< USB0 Register Read Busy Flag                      
3751      =2  #define USB0ADR_BUSY__SHIFT             0x07 ///< USB0 Register Read Busy Flag                      
3752      =2  #define USB0ADR_BUSY__NOT_SET           0x00 ///< A read is not in progress.                        
3753      =2  #define USB0ADR_BUSY__SET               0x80 ///< Initiate a read or a read is in progress.         
C51 COMPILER V9.56.0.0   I2C_0                                                             10/28/2016 17:37:02 PAGE 88  

3754      =2                                                                                                      
3755      =2  //------------------------------------------------------------------------------
3756      =2  // USB0DAT Enums (USB0 Data @ 0x97)
3757      =2  //------------------------------------------------------------------------------
3758      =2  #define USB0DAT_USB0DAT__FMASK 0xFF ///< USB0 Data
3759      =2  #define USB0DAT_USB0DAT__SHIFT 0x00 ///< USB0 Data
3760      =2                                                    
3761      =2  //------------------------------------------------------------------------------
3762      =2  // USB0XCN Enums (USB0 Transceiver Control @ 0xD7)
3763      =2  //------------------------------------------------------------------------------
3764      =2  #define USB0XCN_Dn__BMASK                0x01 ///< D- Signal Status                                 
3765      =2  #define USB0XCN_Dn__SHIFT                0x00 ///< D- Signal Status                                 
3766      =2  #define USB0XCN_Dn__LOW                  0x00 ///< D- signal currently at logic 0.                  
3767      =2  #define USB0XCN_Dn__HIGH                 0x01 ///< D- signal currently at logic 1.                  
3768      =2                                                                                                      
3769      =2  #define USB0XCN_Dp__BMASK                0x02 ///< D+ Signal Status                                 
3770      =2  #define USB0XCN_Dp__SHIFT                0x01 ///< D+ Signal Status                                 
3771      =2  #define USB0XCN_Dp__LOW                  0x00 ///< D+ signal currently at logic 0.                  
3772      =2  #define USB0XCN_Dp__HIGH                 0x02 ///< D+ signal currently at logic 1.                  
3773      =2                                                                                                      
3774      =2  #define USB0XCN_DFREC__BMASK             0x04 ///< Differential Receiver                            
3775      =2  #define USB0XCN_DFREC__SHIFT             0x02 ///< Differential Receiver                            
3776      =2  #define USB0XCN_DFREC__DIFFERENTIAL_ZERO 0x00 ///< Differential 0 signalling on the bus.            
3777      =2  #define USB0XCN_DFREC__DIFFERENTIAL_ONE  0x04 ///< Differential 1 signalling on the bus.            
3778      =2                                                                                                      
3779      =2  #define USB0XCN_PHYTST__FMASK            0x18 ///< Physical Layer Test                              
3780      =2  #define USB0XCN_PHYTST__SHIFT            0x03 ///< Physical Layer Test                              
3781      =2  #define USB0XCN_PHYTST__MODE0            0x00 ///< Mode 0: Normal (non-test mode) (D+ = X, D- = X). 
3782      =2  #define USB0XCN_PHYTST__MODE1            0x08 ///< Mode 1: Differential 1 forced (D+ = 1, D- = 0).  
3783      =2  #define USB0XCN_PHYTST__MODE2            0x10 ///< Mode 2: Differential 0 forced (D+ = 0, D- = 1).  
3784      =2  #define USB0XCN_PHYTST__MODE3            0x18 ///< Mode 3: Single-Ended 0 forced (D+ = 0, D- = 0).  
3785      =2                                                                                                      
3786      =2  #define USB0XCN_SPEED__BMASK             0x20 ///< USB0 Speed Select                                
3787      =2  #define USB0XCN_SPEED__SHIFT             0x05 ///< USB0 Speed Select                                
3788      =2  #define USB0XCN_SPEED__LOW_SPEED         0x00 ///< USB0 operates as a Low Speed device. If enabled, 
3789      =2                                                ///< the internal pull-up resistor appears on the D-  
3790      =2                                                ///< line.                                            
3791      =2  #define USB0XCN_SPEED__FULL_SPEED        0x20 ///< USB0 operates as a Full Speed device. If enabled,
3792      =2                                                ///< the internal pull-up resistor appears on the D+  
3793      =2                                                ///< line.                                            
3794      =2                                                                                                      
3795      =2  #define USB0XCN_PHYEN__BMASK             0x40 ///< Physical Layer Enable                            
3796      =2  #define USB0XCN_PHYEN__SHIFT             0x06 ///< Physical Layer Enable                            
3797      =2  #define USB0XCN_PHYEN__DISABLED          0x00 ///< Disable the USB0 physical layer transceiver      
3798      =2                                                ///< (suspend).                                       
3799      =2  #define USB0XCN_PHYEN__ENABLED           0x40 ///< Enable the USB0 physical layer transceiver       
3800      =2                                                ///< (normal).                                        
3801      =2                                                                                                      
3802      =2  #define USB0XCN_PREN__BMASK              0x80 ///< Internal Pull-up Resistor Enable                 
3803      =2  #define USB0XCN_PREN__SHIFT              0x07 ///< Internal Pull-up Resistor Enable                 
3804      =2  #define USB0XCN_PREN__PULL_UP_DISABLED   0x00 ///< Internal pull-up resistor disabled (device       
3805      =2                                                ///< effectively detached from USB network).          
3806      =2  #define USB0XCN_PREN__PULL_UP_ENABLED    0x80 ///< Internal pull-up resistor enabled when VBUS is   
3807      =2                                                ///< present (device attached to the USB network).    
3808      =2                                                                                                      
3809      =2  //------------------------------------------------------------------------------
3810      =2  // VDM0CN Enums (Supply Monitor Control @ 0xFF)
3811      =2  //------------------------------------------------------------------------------
3812      =2  #define VDM0CN_VDDSTAT__BMASK  0x40 ///< Supply Status                                   
3813      =2  #define VDM0CN_VDDSTAT__SHIFT  0x06 ///< Supply Status                                   
3814      =2  #define VDM0CN_VDDSTAT__BELOW  0x00 ///< VDD is at or below the supply monitor threshold.
3815      =2  #define VDM0CN_VDDSTAT__ABOVE  0x40 ///< VDD is above the supply monitor threshold.      
C51 COMPILER V9.56.0.0   I2C_0                                                             10/28/2016 17:37:02 PAGE 89  

3816      =2                                                                                           
3817      =2  #define VDM0CN_VDMEN__BMASK    0x80 ///< Supply Monitor Enable                           
3818      =2  #define VDM0CN_VDMEN__SHIFT    0x07 ///< Supply Monitor Enable                           
3819      =2  #define VDM0CN_VDMEN__DISABLED 0x00 ///< Supply Monitor Disabled.                        
3820      =2  #define VDM0CN_VDMEN__ENABLED  0x80 ///< Supply Monitor Enabled.                         
3821      =2                                                                                           
3822      =2  //------------------------------------------------------------------------------
3823      =2  // REF0CN Enums (Voltage Reference Control @ 0xD1)
3824      =2  //------------------------------------------------------------------------------
3825      =2  #define REF0CN_REFBE__BMASK    0x01 ///< Internal Reference Buffer Enable                  
3826      =2  #define REF0CN_REFBE__SHIFT    0x00 ///< Internal Reference Buffer Enable                  
3827      =2  #define REF0CN_REFBE__DISABLED 0x00 ///< Disable the internal reference buffer.            
3828      =2  #define REF0CN_REFBE__ENABLED  0x01 ///< Enable the internal reference buffer. The internal
3829      =2                                      ///< voltage reference is driven on the VREF pin.      
3830      =2                                                                                             
3831      =2  #define REF0CN_TEMPE__BMASK    0x04 ///< Temperature Sensor Enable                         
3832      =2  #define REF0CN_TEMPE__SHIFT    0x02 ///< Temperature Sensor Enable                         
3833      =2  #define REF0CN_TEMPE__DISABLED 0x00 ///< Disable the internal Temperature Sensor.          
3834      =2  #define REF0CN_TEMPE__ENABLED  0x04 ///< Enable the internal Temperature Sensor.           
3835      =2                                                                                             
3836      =2  #define REF0CN_REFSL__BMASK    0x08 ///< Voltage Reference Select                          
3837      =2  #define REF0CN_REFSL__SHIFT    0x03 ///< Voltage Reference Select                          
3838      =2  #define REF0CN_REFSL__VREF     0x00 ///< Use the VREF pin as the voltage reference.        
3839      =2  #define REF0CN_REFSL__VDD      0x08 ///< Use VDD as the voltage reference.                 
3840      =2                                                                                             
3841      =2  #define REF0CN_REGOVR__BMASK   0x10 ///< Regulator Reference Override                      
3842      =2  #define REF0CN_REGOVR__SHIFT   0x04 ///< Regulator Reference Override                      
3843      =2  #define REF0CN_REGOVR__REFSL   0x00 ///< The REFSL bit selects the voltage reference       
3844      =2                                      ///< source.                                           
3845      =2  #define REF0CN_REGOVR__VREG    0x10 ///< Use the output of the internal regulator as the   
3846      =2                                      ///< voltage reference source.                         
3847      =2                                                                                             
3848      =2  #define REF0CN_REFBGS__BMASK   0x80 ///< Reference Buffer Gain Select                      
3849      =2  #define REF0CN_REFBGS__SHIFT   0x07 ///< Reference Buffer Gain Select                      
3850      =2  #define REF0CN_REFBGS__GAIN_2  0x00 ///< The on-chip voltage reference buffer gain is 2.   
3851      =2  #define REF0CN_REFBGS__GAIN_1  0x80 ///< The on-chip voltage reference buffer gain is 1.   
3852      =2                                                                                             
3853      =2  //------------------------------------------------------------------------------
3854      =2  // REG01CN Enums (Voltage Regulator Control @ 0xC9)
3855      =2  //------------------------------------------------------------------------------
3856      =2  #define REG01CN_REG1MD__BMASK     0x02 ///< VREG1 Voltage Regulator Mode                     
3857      =2  #define REG01CN_REG1MD__SHIFT     0x01 ///< VREG1 Voltage Regulator Mode                     
3858      =2  #define REG01CN_REG1MD__NORMAL    0x00 ///< VREG1 Voltage Regulator in normal mode.          
3859      =2  #define REG01CN_REG1MD__LOW_POWER 0x02 ///< VREG1 Voltage Regulator in low power mode.       
3860      =2                                                                                               
3861      =2  #define REG01CN_STOPCF__BMASK     0x08 ///< VREG1 Stop and Shutdown Mode Configuration       
3862      =2  #define REG01CN_STOPCF__SHIFT     0x03 ///< VREG1 Stop and Shutdown Mode Configuration       
3863      =2  #define REG01CN_STOPCF__ACTIVE    0x00 ///< VREG1 Regulator is still active in stop mode. Any
3864      =2                                         ///< enabled reset source will reset the device.      
3865      =2  #define REG01CN_STOPCF__SHUTDOWN  0x08 ///< VREG1 Regulator is shut down in stop mode (device
3866      =2                                         ///< enters Shutdown mode). Only the RSTb pin or power
3867      =2                                         ///< cycle can reset the device.                      
3868      =2                                                                                               
3869      =2  #define REG01CN_REG0MD__BMASK     0x10 ///< VREG0 Voltage Regulator Mode                     
3870      =2  #define REG01CN_REG0MD__SHIFT     0x04 ///< VREG0 Voltage Regulator Mode                     
3871      =2  #define REG01CN_REG0MD__NORMAL    0x00 ///< VREG0 Voltage Regulator in normal mode.          
3872      =2  #define REG01CN_REG0MD__LOW_POWER 0x10 ///< VREG0 Voltage Regulator in low power mode.       
3873      =2                                                                                               
3874      =2  #define REG01CN_VBSTAT__BMASK     0x40 ///< VBUS Signal Status                               
3875      =2  #define REG01CN_VBSTAT__SHIFT     0x06 ///< VBUS Signal Status                               
3876      =2  #define REG01CN_VBSTAT__NOT_SET   0x00 ///< VBUS signal currently absent (device not attached
3877      =2                                         ///< to USB network).                                 
C51 COMPILER V9.56.0.0   I2C_0                                                             10/28/2016 17:37:02 PAGE 90  

3878      =2  #define REG01CN_VBSTAT__SET       0x40 ///< VBUS signal currently present (device attached to
3879      =2                                         ///< USB network).                                    
3880      =2                                                                                               
3881      =2  #define REG01CN_REG0DIS__BMASK    0x80 ///< Voltage Regulator (REG0) Disable                 
3882      =2  #define REG01CN_REG0DIS__SHIFT    0x07 ///< Voltage Regulator (REG0) Disable                 
3883      =2  #define REG01CN_REG0DIS__ENABLED  0x00 ///< Enable the VREG0 Voltage Regulator.              
3884      =2  #define REG01CN_REG0DIS__DISABLED 0x80 ///< Disable the VREG0 Voltage Regulator.             
3885      =2                                                                                               
3886      =2  //------------------------------------------------------------------------------
3887      =2  // EMI0CF Enums (External Memory Configuration @ 0x85)
3888      =2  //------------------------------------------------------------------------------
3889      =2  #define EMI0CF_EALE__FMASK                    0x03 ///< ALE Pulse-Width Select                            
3890      =2  #define EMI0CF_EALE__SHIFT                    0x00 ///< ALE Pulse-Width Select                            
3891      =2  #define EMI0CF_EALE__1_CLOCK                  0x00 ///< ALE high and ALE low pulse width = 1 SYSCLK cycle.
3892      =2  #define EMI0CF_EALE__2_CLOCKS                 0x01 ///< ALE high and ALE low pulse width = 2 SYSCLK       
3893      =2                                                     ///< cycles.                                           
3894      =2  #define EMI0CF_EALE__3_CLOCKS                 0x02 ///< ALE high and ALE low pulse width = 3 SYSCLK       
3895      =2                                                     ///< cycles.                                           
3896      =2  #define EMI0CF_EALE__4_CLOCKS                 0x03 ///< ALE high and ALE low pulse width = 4 SYSCLK       
3897      =2                                                     ///< cycles.                                           
3898      =2                                                                                                            
3899      =2  #define EMI0CF_EMD__FMASK                     0x0C ///< EMIF Operating Mode Select                        
3900      =2  #define EMI0CF_EMD__SHIFT                     0x02 ///< EMIF Operating Mode Select                        
3901      =2  #define EMI0CF_EMD__INTERNAL_ONLY             0x00 ///< Internal Only: MOVX accesses on-chip XRAM only.   
3902      =2                                                     ///< All effective addresses alias to on-chip memory   
3903      =2                                                     ///< space.                                            
3904      =2  #define EMI0CF_EMD__SPLIT_WITHOUT_BANK_SELECT 0x04 ///< Split Mode without Bank Select: Accesses below the
3905      =2                                                     ///< internal XRAM boundary are directed on-chip.      
3906      =2                                                     ///< Accesses above the internal XRAM boundary are     
3907      =2                                                     ///< directed off-chip. 8-bit off-chip MOVX operations 
3908      =2                                                     ///< use the current contents of the Address high port 
3909      =2                                                     ///< latches to resolve the upper address byte. To     
3910      =2                                                     ///< access off chip space, EMI0CN must be set to a    
3911      =2                                                     ///< page that is not contained in the on-chip address 
3912      =2                                                     ///< space.                                            
3913      =2  #define EMI0CF_EMD__SPLIT_WITH_BANK_SELECT    0x08 ///< Split Mode with Bank Select: Accesses below the   
3914      =2                                                     ///< internal XRAM boundary are directed on-chip.      
3915      =2                                                     ///< Accesses above the internal XRAM boundary are     
3916      =2                                                     ///< directed off-chip. 8-bit off-chip MOVX operations 
3917      =2                                                     ///< uses the contents of EMI0CN to determine the high-
3918      =2                                                     ///< byte of the address.                              
3919      =2  #define EMI0CF_EMD__EXTERNAL_ONLY             0x0C ///< External Only: MOVX accesses off-chip XRAM only.  
3920      =2                                                     ///< On-chip XRAM is not visible to the core.          
3921      =2                                                                                                            
3922      =2  #define EMI0CF_MUXMD__BMASK                   0x10 ///< EMIF Multiplex Mode Select                        
3923      =2  #define EMI0CF_MUXMD__SHIFT                   0x04 ///< EMIF Multiplex Mode Select                        
3924      =2  #define EMI0CF_MUXMD__MULTIPLEXED             0x00 ///< EMIF operates in multiplexed address/data mode.   
3925      =2  #define EMI0CF_MUXMD__NON_MULTIPLEXED         0x10 ///< EMIF operates in non-multiplexed mode (separate   
3926      =2                                                     ///< address and data pins).                           
3927      =2                                                                                                            
3928      =2  #define EMI0CF_USBFAE__BMASK                  0x40 ///< USB FIFO Access Enable                            
3929      =2  #define EMI0CF_USBFAE__SHIFT                  0x06 ///< USB FIFO Access Enable                            
3930      =2  #define EMI0CF_USBFAE__FIFO_ACCESS_DISABLED   0x00 ///< USB FIFO RAM not available through MOVX           
3931      =2                                                     ///< instructions.                                     
3932      =2  #define EMI0CF_USBFAE__FIFO_ACCESS_ENABLED    0x40 ///< USB FIFO RAM available using MOVX instructions.   
3933      =2                                                     ///< The 1 KB of USB RAM will be mapped in XRAM space  
3934      =2                                                     ///< at addresses 0x0400 to 0x07FF. The USB clock must 
3935      =2                                                     ///< be active and greater than or equal to twice the  
3936      =2                                                     ///< SYSCLK (USBCLK > 2 x SYSCLK) to access this area  
3937      =2                                                     ///< with MOVX instructions.                           
3938      =2                                                                                                            
3939      =2  //------------------------------------------------------------------------------
C51 COMPILER V9.56.0.0   I2C_0                                                             10/28/2016 17:37:02 PAGE 91  

3940      =2  // EMI0CN Enums (External Memory Interface Control @ 0xAA)
3941      =2  //------------------------------------------------------------------------------
3942      =2  #define EMI0CN_PGSEL__FMASK 0xFF ///< XRAM Page Select
3943      =2  #define EMI0CN_PGSEL__SHIFT 0x00 ///< XRAM Page Select
3944      =2                                                        
3945      =2  //------------------------------------------------------------------------------
3946      =2  // EMI0TC Enums (External Memory Timing Control @ 0x84)
3947      =2  //------------------------------------------------------------------------------
3948      =2  #define EMI0TC_AHOLD__FMASK      0x03 ///< EMIF Address Hold Time                      
3949      =2  #define EMI0TC_AHOLD__SHIFT      0x00 ///< EMIF Address Hold Time                      
3950      =2  #define EMI0TC_AHOLD__0_CLOCKS   0x00 ///< Address hold time = 0 SYSCLK cycles.        
3951      =2  #define EMI0TC_AHOLD__1_CLOCK    0x01 ///< Address hold time = 1 SYSCLK cycle.         
3952      =2  #define EMI0TC_AHOLD__2_CLOCKS   0x02 ///< Address hold time = 2 SYSCLK cycles.        
3953      =2  #define EMI0TC_AHOLD__3_CLOCKS   0x03 ///< Address hold time = 3 SYSCLK cycles.        
3954      =2                                                                                         
3955      =2  #define EMI0TC_PWIDTH__FMASK     0x3C ///< EMIF /WR and /RD Pulse-Width Control        
3956      =2  #define EMI0TC_PWIDTH__SHIFT     0x02 ///< EMIF /WR and /RD Pulse-Width Control        
3957      =2  #define EMI0TC_PWIDTH__1_CLOCK   0x00 ///< /WR and /RD pulse width is 1 SYSCLK cycle.  
3958      =2  #define EMI0TC_PWIDTH__2_CLOCKS  0x04 ///< /WR and /RD pulse width is 2 SYSCLK cycles. 
3959      =2  #define EMI0TC_PWIDTH__3_CLOCKS  0x08 ///< /WR and /RD pulse width is 3 SYSCLK cycles. 
3960      =2  #define EMI0TC_PWIDTH__4_CLOCKS  0x0C ///< /WR and /RD pulse width is 4 SYSCLK cycles. 
3961      =2  #define EMI0TC_PWIDTH__5_CLOCKS  0x10 ///< /WR and /RD pulse width is 5 SYSCLK cycles. 
3962      =2  #define EMI0TC_PWIDTH__6_CLOCKS  0x14 ///< /WR and /RD pulse width is 6 SYSCLK cycles. 
3963      =2  #define EMI0TC_PWIDTH__7_CLOCKS  0x18 ///< /WR and /RD pulse width is 7 SYSCLK cycles. 
3964      =2  #define EMI0TC_PWIDTH__8_CLOCKS  0x1C ///< /WR and /RD pulse width is 8 SYSCLK cycles. 
3965      =2  #define EMI0TC_PWIDTH__9_CLOCKS  0x20 ///< /WR and /RD pulse width is 9 SYSCLK cycles. 
3966      =2  #define EMI0TC_PWIDTH__10_CLOCKS 0x24 ///< /WR and /RD pulse width is 10 SYSCLK cycles.
3967      =2  #define EMI0TC_PWIDTH__11_CLOCKS 0x28 ///< /WR and /RD pulse width is 11 SYSCLK cycles.
3968      =2  #define EMI0TC_PWIDTH__12_CLOCKS 0x2C ///< /WR and /RD pulse width is 12 SYSCLK cycles.
3969      =2  #define EMI0TC_PWIDTH__13_CLOCKS 0x30 ///< /WR and /RD pulse width is 13 SYSCLK cycles.
3970      =2  #define EMI0TC_PWIDTH__14_CLOCKS 0x34 ///< /WR and /RD pulse width is 14 SYSCLK cycles.
3971      =2  #define EMI0TC_PWIDTH__15_CLOCKS 0x38 ///< /WR and /RD pulse width is 15 SYSCLK cycles.
3972      =2  #define EMI0TC_PWIDTH__16_CLOCKS 0x3C ///< /WR and /RD pulse width is 16 SYSCLK cycles.
3973      =2                                                                                         
3974      =2  #define EMI0TC_ASETUP__FMASK     0xC0 ///< EMIF Address Setup Time                     
3975      =2  #define EMI0TC_ASETUP__SHIFT     0x06 ///< EMIF Address Setup Time                     
3976      =2  #define EMI0TC_ASETUP__0_CLOCKS  0x00 ///< Address setup time = 0 SYSCLK cycles.       
3977      =2  #define EMI0TC_ASETUP__1_CLOCK   0x40 ///< Address setup time = 1 SYSCLK cycle.        
3978      =2  #define EMI0TC_ASETUP__2_CLOCKS  0x80 ///< Address setup time = 2 SYSCLK cycles.       
3979      =2  #define EMI0TC_ASETUP__3_CLOCKS  0xC0 ///< Address setup time = 3 SYSCLK cycles.       
3980      =2                                                                                         
3981      =2  #endif // SI_EFM8UB2_REGISTER_ENUMS_H
3982      =2  //-eof--------------------------------------------------------------------------
3983      =2  
  13      =1  
  14      =1  /**************************************************************************//**
  15      =1   *
  16      =1   * @addtogroup i2c_0 I2C0 Driver
  17      =1   * @{
  18      =1   *
  19      =1   * @brief Peripheral driver for I2C0
  20      =1   *
  21      =1   * # Introduction #
  22      =1   *
  23      =1   * This module contains all the driver content for I2C0
  24      =1   *
  25      =1   * ### Memory Usage ###
  26      =1   *
  27      =1   * The table below shows the memory consumption of the library with various
  28      =1   * options. The 'default' entry shows the consumption when most or all available
  29      =1   * functions are called. Typical consumption is expected to be less than this
  30      =1   * since there are normally many uncalled functions that will consume no
C51 COMPILER V9.56.0.0   I2C_0                                                             10/28/2016 17:37:02 PAGE 92  

  31      =1   * resources.
  32      =1   *
  33      =1   * @note It is possible for memory usage to exceed the listed values in rare cases
  34      =1   *
  35      =1   * | condition          | CODE | XRAM | IRAM | RAM |
  36      =1   * |--------------------|------|------|------|-----|
  37      =1   * |BUFFER              |  586 |   15 |    0 |   0 |
  38      =1   * |default             |  198 |    0 |    0 |   0 |
  39      =1   *
  40      =1   * # Theory of Operation #
  41      =1   *
  42      =1   * This driver supports both SMBus and I2C style communication.
  43      =1   * It can be configured as a high level driver which takes care of the
  44      =1   * the entire I2C state machine, or it can be used as a lower level library
  45      =1   * and the state-machine constructed by the user.
  46      =1   *
  47      =1   * ### Buffered Operation ###
  48      =1   *
  49      =1   * The buffer API is a high level API that is intended to make I2C as simple
  50      =1   * as possible while sill providing enough flexibility to be useful in most
  51      =1   * applications.
  52      =1   *
  53      =1   * #### Master ####
  54      =1   *
  55      =1   * The driver can perform a full read/write transaction and issue a callback
  56      =1   * when the entire transfer is complete.
  57      =1   *
  58      =1   * @image html I2C_readwrite.svg
  59      =1   *
  60      =1   * In this example we issue a 1 byte command to the slave device and
  61      =1   * read 3 bytes of data as a response (repeated start between write and read).
  62      =1   *
  63      =1   * ~~~~~.c
  64      =1   * SI_SEGMENT_VARIABLE(command[4], uint8_t, SI_SEG_XDATA);
  65      =1   * SI_SEGMENT_VARIABLE(response[32], uint8_t, SI_SEG_XDATA);
  66      =1   * bool commandComplete;
  67      =1   *
  68      =1   * //In some code we need to read from the slave
  69      =1   * I2C0_init(I2C0_TIMER2_LOW, false);
  70      =1   * commandComplete = false;
  71      =1   * command[0] = READ_STATUS; //some code for the slave
  72      =1   * I2C0_transfer(SLAVE_ADDRESS, command, response, 1, 3);
  73      =1   * while(!comandComplete);
  74      =1   * //Do something with status data in command[2:0]
  75      =1   *
  76      =1   * //We need to tell our main thread to continue when transfer complete.
  77      =1   * void I2C0_transferCompleteCb()
  78      =1   * {
  79      =1   *   commandComplete();
  80      =1   * }
  81      =1   * ~~~~~
  82      =1   *
  83      =1   * @image html I2C_example.svg
  84      =1   *
  85      =1   * If no receive data is given (rx_len = 0) the library performs a write
  86      =1   * only operation.
  87      =1   *
  88      =1   * @image html I2C_write.svg
  89      =1   *
  90      =1   * If no transmit data is provided (tx_len = 0) the library performs a
  91      =1   * read only operation.
  92      =1   *
C51 COMPILER V9.56.0.0   I2C_0                                                             10/28/2016 17:37:02 PAGE 93  

  93      =1   * @image html I2C_read.svg
  94      =1   *
  95      =1   * #### Slave ####
  96      =1   *
  97      =1   * For slave operation the library will save incoming data from the master
  98      =1   * to a buffer and issue a call-back when the master is finished sending.
  99      =1   * At that point users code can prepare a response for the master to read.
 100      =1   *
 101      =1   * A commandReceived callback is issued under the following conditions:
 102      =1   *
 103      =1   *  ~ The last byte of the buffer is written to. After the call back returns
 104      =1   *    the command buffer is reset to empty an more bytes can be received.
 105      =1   *  ~ A stop is seen and the command buffer contains data.
 106      =1   *  ~ A repeated start is seen and the command buffer contains data.
 107      =1   *  ~ A start (not repeated) is seen and the transfer is a read (master reading).
 108      =1   *    In this case the the command buffer have 0 bytes of data.
 109      =1   *
 110      =1   * @note
 111      =1   * the device will clock stretch while the callback is being executed.
 112      =1   *
 113      =1   * In this example we define 3 commands the master can send each command
 114      =1   * consists of a command number and 2 single byte arguments. We return a
 115      =1   * single byte response.
 116      =1   *
 117      =1   * ~~~~~.c
 118      =1   * SI_SEGMENT_VARIABLE(command[3], uint8_t, SI_SEG_XDATA);
 119      =1   * SI_SEGMENT_VARIABLE(response, uint8_t, SI_SEG_XDATA);
 120      =1   * #define ADD_COMMAND 0x01
 121      =1   * #define MUL_COMMAND 0x02
 122      =1   * #define DIV_COMMAND 0x03
 123      =1   *
 124      =1   * //In main we must prime the
 125      =1   * I2C0_init(I2C0_TIMER2_LOW, false);
 126      =1   * I2C0_initSlave(MY_ADDRESS, command, 3);
 127      =1   *
 128      =1   * //This is called whenever the master finishes a write of data.
 129      =1   * void I2C0_commandReceivedCb()
 130      =1   * {
 131      =1   *   if(command[0] == ADD_COMMAND){
 132      =1   *     response = command[1] + command[2];
 133      =1   *   }
 134      =1   *   if(command[0] == ADD_MUL){
 135      =1   *     response = command[1] * command[2];
 136      =1   *   }
 137      =1   *   if(command[0] == ADD_DIV){
 138      =1   *     response = command[1] / command[2];
 139      =1   *   }
 140      =1   *
 141      =1   *   //Inform driver we have a response
 142      =1   *   I2C_sendResponse(&response, 1);
 143      =1   *
 144      =1   *   //SCL held low during the execution of this function ensuring
 145      =1   *   //  that data is ready before the master can attempt to read.
 146      =1   * }
 147      =1   * ~~~~~
 148      =1   *
 149      =1   * ### Manual operation ###
 150      =1   *
 151      =1   * If the buffered driver is not suitable for an application functions are
 152      =1   * provided to manually implement whatever protocol is required. An ISR is
 153      =1   * provided to do the first level of state decoding but it may be disabled
 154      =1   * if the user wishes to write their own ISR.
C51 COMPILER V9.56.0.0   I2C_0                                                             10/28/2016 17:37:02 PAGE 94  

 155      =1   *
 156      =1   * The I2C driver will issue callbacks under according to the following
 157      =1   * state diagrams. In addition to the listed callbacks I2C0_arbLostCb() and
 158      =1   * I2C0_errorCb() may be issued at any time.
 159      =1   *
 160      =1   * @image html I2C_masterwrite_callbacks.svg Master Write
 161      =1   *
 162      =1   * @image html I2C_masterread_callbacks.svg Master Read
 163      =1   *
 164      =1   * @image html I2C_slaveread_callbacks.svg Slave Write
 165      =1   *
 166      =1   * @image html I2C_slavewrite_callbacks.svg Slave Read
 167      =1   *
 168      =1   * The driver ISR handles clearing of flags where necessary but the user
 169      =1   * callback must handle setting of flags such as STA, STO and ACK.
 170      =1   *
 171      =1   * ### Hardware Configuration ###
 172      =1   *
 173      =1   * This Driver provides a basic level of configuration through the API. However
 174      =1   * use of the Simplicity Hardware Configuration tool is highly recommended and
 175      =1   * some options will only be accessible through that tool (or direct register
 176      =1   * access).
 177      =1   *
 178      =1   * By default the slave is disable when I2C0_init is called and enabled when
 179      =1   * I2C0_initSlave or I2C0_initSlaveAddress are called (depending on which
 180      =1   * version of the api is being used.) Because of this I2C0_init should always
 181      =1   * be called first.
 182      =1   *
 183      =1   * ~~~~~.c
 184      =1   * //Init with no slave
 185      =1   * I2C0_init(I2C0_TIMER2_LOW, false);
 186      =1   *
 187      =1   * //Init with slave (buffered
 188      =1   * I2C0_init(I2C0_TIMER2_LOW, false);
 189      =1   * I2C0_initSlave(MY_ADDRESS, command, 3);
 190      =1   *
 191      =1   * //Init with slave (manual state machine)
 192      =1   * I2C0_init(I2C0_TIMER2_LOW, false);
 193      =1   * I2C0_initSlaveAddress(MY_ADDRESS, mask);
 194      =1   *
 195      =1   * //This is an error the slave will be disabled by the
 196      =1   * // second call
 197      =1   * I2C0_initSlaveAddress(MY_ADDRESS, mask);
 198      =1   * I2C0_init(I2C0_TIMER2_LOW, false);
 199      =1   * ~~~~~
 200      =1   *
 201      =1   *****************************************************************************/
 202      =1  
 203      =1  //Option macro documentation
 204      =1  /**************************************************************************//**
 205      =1   * @addtogroup i2c_config Driver Configuration
 206      =1   * @{
 207      =1   *  
 208      =1   * @brief
 209      =1   * Driver configuration constants read from SI_EFM8UB2_Defs.h
 210      =1   * 
 211      =1   * This peripheral driver will look for configuration constants in
 212      =1   * **SI_EFM8UB2_Defs.h**. This file is provided/written by the user and should be
 213      =1   * located in a directory that is part of the include path.
 214      =1   *  
 215      =1   ******************************************************************************/
 216      =1  
C51 COMPILER V9.56.0.0   I2C_0                                                             10/28/2016 17:37:02 PAGE 95  

 217      =1  /**************************************************************************//**
 218      =1   * @def EFM8PDL_I2C0_AUTO_PAGE
 219      =1   * @brief Controls if the library handles SI_SFR paging.
 220      =1   *
 221      =1   * When '1' the I2C0 driver automatically handles setting and restoring
 222      =1   * SI_SFR page for each call. When disabled the library consumes less code
 223      =1   * space but the user must ensure that the correct page is set when calling
 224      =1   * driver functions that access hardware.
 225      =1   *
 226      =1   * Default setting is '1' and may be overridden by defining in 'SI_EFM8UB2_Defs.h'.
 227      =1   *
 228      =1   *****************************************************************************/
 229      =1  
 230      =1  /**************************************************************************//**
 231      =1   * @def EFM8PDL_I2C0_USE_STATEMACHINE
 232      =1   * @brief Controls inclusion of I2C0 ISR and callbacks.
 233      =1   *
 234      =1   * When '1' the I2C0 ISR in the driver is used and callbacks are
 235      =1   * made for each I2C state transition.
 236      =1   *
 237      =1   * Default setting is '1' if USE is enabled and may be overridden by
 238      =1   * defining in 'SI_EFM8UB2_Defs.h'.
 239      =1   *
 240      =1   *****************************************************************************/
 241      =1  
 242      =1  /**************************************************************************//**
 243      =1   * @def EFM8PDL_I2C0_USE_BUFFER
 244      =1   * @brief Controls inclusion of tje Buffered I2C transfer API.
 245      =1   *
 246      =1   * When '1' an API is provided for high level buffered transfers. This setting
 247      =1   * is mutually exclusive with EFM8PDL_I2C0_USE_STATEMACHINE
 248      =1   *
 249      =1   * Default setting is '1' and may be overridden by defining in 'SI_EFM8UB2_Defs.h'.
 250      =1   *
 251      =1   *****************************************************************************/
 252      =1  
 253      =1  /**************************************************************************//**
 254      =1   * @addtogroup i2c_config_buffered Buffered API Options
 255      =1   * @{
 256      =1   *****************************************************************************/
 257      =1  
 258      =1  /**************************************************************************//**
 259      =1   * @def EFM8PDL_I2C0_MASTER_RETRIES
 260      =1   * @brief Controls number of arbitration loss retries.
 261      =1   *
 262      =1   * When a master transfer fails due to arbitration loss the library will
 263      =1   * automatically retry the transfer until it succeeds or EFM8PDL_I2C0_MASTER_RETRIES
 264      =1   * failures have occurred. If the transfer is not completed successfully
 265      =1   * the error callback is fired with I2C0_ARBLOST_ERROR as the error.
 266      =1   *
 267      =1   * Valid values are between 0 and 255 retries. 255 is the default value
 268      =1   *
 269      =1   *****************************************************************************/
 270      =1  
 271      =1  /**************************************************************************//**
 272      =1   * @def EFM8PDL_I2C0_TX_BUFTYPE
 273      =1   * @brief Controls the type of pointer used when transmitting buffered data.
 274      =1   *
 275      =1   * Sets the memory segment for the tx data buffer pointer when EFM8PDL_I2C0_USE_BUFFER is '1'.
 276      =1   * This applies to both master and slave functions.
 277      =1   * valid values are:
 278      =1   *
C51 COMPILER V9.56.0.0   I2C_0                                                             10/28/2016 17:37:02 PAGE 96  

 279      =1   * - SI_SEG_XDATA (default)
 280      =1   * - SI_SEG_PDATA
 281      =1   * - SI_SEG_IDATA
 282      =1   * - SI_SEG_CODE
 283      =1   * - SI_SEG_GENERIC
 284      =1   *
 285      =1   * @warning:
 286      =1   * Use of generic pointers will adversely effect the size and performance
 287      =1   * of the buffering functions.
 288      =1   *
 289      =1   *****************************************************************************/
 290      =1  
 291      =1  /**************************************************************************//**
 292      =1   * @def EFM8PDL_I2C0_RX_BUFTYPE
 293      =1   * @brief Controls the type of pointer used when receiving buffered data.
 294      =1   *
 295      =1   * Sets the memory segment for the rx data buffer pointer when EFM8PDL_UART0_USE_BUFFER
 296      =1   * is '1'. This applies to both master and slave functions
 297      =1   * valid values are:
 298      =1   *
 299      =1   * - SI_SEG_XDATA (default)
 300      =1   * - SI_SEG_PDATA
 301      =1   * - SI_SEG_IDATA
 302      =1   * - SI_SEG_CODE
 303      =1   * - SI_SEG_GENERIC
 304      =1   *
 305      =1   * @warning:
 306      =1   * Use of generic pointers will adversely effect the size and performance
 307      =1   * of the buffering functions.
 308      =1   *
 309      =1   *****************************************************************************/
 310      =1  
 311      =1  /** @} (end addtogroup i2c_config_buffered Buffered API Options) */
 312      =1  /** @} (end addtogroup i2c_config Driver Configuration) */
 313      =1  
 314      =1  
 315      =1  //Configuration defaults
 316      =1  #ifndef IS_DOXYGEN
 317      =1    #define IS_DOXYGEN 0
 318      =1  #endif
 319      =1  
 320      =1  #ifndef EFM8PDL_I2C0_AUTO_PAGE
 321      =1    #define EFM8PDL_I2C0_AUTO_PAGE 1
 322      =1  #endif
 323      =1  
 324      =1  #ifndef EFM8PDL_I2C0_USE_STATEMACHINE
 325      =1    #define EFM8PDL_I2C0_USE_STATEMACHINE 0
 326      =1  #endif
 327      =1  
 328      =1  #ifndef EFM8PDL_I2C0_USE_BUFFER
 329      =1    #if (EFM8PDL_I2C0_USE_STATEMACHINE == 1)
           =1     #define EFM8PDL_I2C0_USE_BUFFER 0
           =1   #else
 332      =1      #define EFM8PDL_I2C0_USE_BUFFER 1
 333      =1    #endif
 334      =1  #endif
 335      =1  
 336      =1  #if ((EFM8PDL_I2C0_USE_STATEMACHINE == 1) && (EFM8PDL_I2C0_USE_BUFFER == 1))
           =1 #error("EFM8PDL_I2C0_USE_STATEMACHINE and EFM8PDL_I2C0_USE_BUFFER can not be used at the same time. Disabl
             -e one.")
           =1 #endif
 339      =1  
C51 COMPILER V9.56.0.0   I2C_0                                                             10/28/2016 17:37:02 PAGE 97  

 340      =1  #ifndef EFM8PDL_I2C0_MASTER_RETRIES
 341      =1    #define EFM8PDL_I2C0_MASTER_RETRIES 255
 342      =1  #endif
 343      =1  #ifndef EFM8PDL_I2C0_TX_BUFTYPE
 344      =1    #define EFM8PDL_I2C0_TX_BUFTYPE SI_SEG_XDATA
 345      =1  #endif
 346      =1  #ifndef EFM8PDL_I2C0_RX_BUFTYPE
 347      =1    #define EFM8PDL_I2C0_RX_BUFTYPE SI_SEG_XDATA
 348      =1  #endif
 349      =1  
 350      =1  /***************************************************************************//**
 351      =1   * @addtogroup i2c0_if Status Flag Enums
 352      =1   * @{
 353      =1   ******************************************************************************/
 354      =1  #define I2C0_MASTER_SF   SMB0CN0_MASTER__BMASK  //!< Master Mode Status Flag
 355      =1  #define I2C0_TXMODE_SF   SMB0CN0_TXMODE__BMASK  //!< TXMode Status Flag
 356      =1  #define I2C0_START_SF    SMB0CN0_STA__BMASK     //!< Start Status Flag
 357      =1  #define I2C0_STOP_SF     SMB0CN0_STO__BMASK     //!< Stop Status Flag
 358      =1  #define I2C0_ACKREQ_SF   SMB0CN0_ACKRQ__BMASK   //!< ACK Request Status Flag
 359      =1  #define I2C0_ARBLOST_SF  SMB0CN0_ARBLOST__BMASK //!< Arbitration Lost Status Flag
 360      =1  #define I2C0_ACK_SF      SMB0CN0_ACK__BMASK     //!< ACK Status Flag
 361      =1  /** @} (end addtogroup i2c0_if Status Flag Enums) */
 362      =1  
 363      =1  
 364      =1  // Runtime API
 365      =1  /***************************************************************************//**
 366      =1   *  @addtogroup i2c0_runtime I2C0 Runtime API
 367      =1   *  @{
 368      =1   ******************************************************************************/
 369      =1  
 370      =1  /***************************************************************************//**
 371      =1   * @brief I2C State.
 372      =1   ******************************************************************************/
 373      =1  typedef enum
 374      =1  {
 375      =1    I2C0_MASTER_START  = 0xE0,   ///!< start transmitted (master)
 376      =1    I2C0_MASTER_TXDATA = 0xC0,   ///!< data byte transmitted (master)
 377      =1    I2C0_MASTER_RXDATA = 0x80,   ///!< data byte received (master)
 378      =1    I2C0_SLAVE_ADDRESS = 0x20,   ///!< slave address received (slave)
 379      =1    I2C0_SLAVE_RX_STOP = 0x10,   ///!< STOP detected during write (slave)
 380      =1    I2C0_SLAVE_RXDATA  = 0x00,   ///!< data byte received (slave)
 381      =1    I2C0_SLAVE_TXDATA  = 0x40,   ///!< data byte transmitted (slave)
 382      =1    I2C0_SLAVE_TX_STOP = 0x50,   ///!< STOP detected during a write (slave)
 383      =1  } I2C0_State_t;
 384      =1  
 385      =1  /***************************************************************************//**
 386      =1   * @brief
 387      =1   * Return the value of the specified interrupt flag
 388      =1   *
 389      =1   * @return
 390      =1   * The state of the flags. This value is the OR of all flags which are set.
 391      =1   *
 392      =1   ******************************************************************************/
 393      =1  bool I2C0_getIntFlag();
 394      =1  
 395      =1  /***************************************************************************//**
 396      =1   * @brief
 397      =1   * Clear I2C Interrupt flag.
 398      =1   *
 399      =1   ******************************************************************************/
 400      =1  void I2C0_clearIntFlag();
 401      =1  
C51 COMPILER V9.56.0.0   I2C_0                                                             10/28/2016 17:37:02 PAGE 98  

 402      =1  /***************************************************************************//**
 403      =1   * @brief
 404      =1   * Return the specified status flag
 405      =1   *
 406      =1   * @return
 407      =1   * Value of the requested status flag/flags.
 408      =1   *
 409      =1   * Valid enums flag can be found in the Status Flag Enums group.
 410      =1   ******************************************************************************/
 411      =1  uint8_t I2C0_getStatusFlags() reentrant;
 412      =1  
 413      =1  /***************************************************************************//**
 414      =1   * @brief
 415      =1   * Set the status flag.
 416      =1   *
 417      =1   * @param flag:
 418      =1   * Status bit to change. Multiple flags can be effected by OR-ing the passed flags.
 419      =1   * @param state:
 420      =1   * State to set (1 = set). All flags passed in the flag argument will have this value applied.
 421      =1   *
 422      =1   * Valid enums can be found in the Status Flag Enums group.
 423      =1   *
 424      =1   ******************************************************************************/
 425      =1  void I2C0_setStatusFlag(uint8_t flag, uint8_t state) reentrant;
 426      =1  
 427      =1  /***************************************************************************//**
 428      =1   * @brief
 429      =1   * Read a byte from I2C.
 430      =1   *
 431      =1   * @return
 432      =1   * Most recent byte received by I2C.
 433      =1   *
 434      =1   * If no new byte was received since last call the value of the previous byte will be returned.
 435      =1   *
 436      =1   ******************************************************************************/
 437      =1  uint8_t I2C0_read();
 438      =1  
 439      =1  /***************************************************************************//**
 440      =1   * @brief
 441      =1   * Write a byte to the I2C
 442      =1   *
 443      =1   * @param value:
 444      =1   * Value to write.
 445      =1   *
 446      =1   * Write a byte via I2C
 447      =1   *
 448      =1   ******************************************************************************/
 449      =1  void I2C0_write(uint8_t value);
 450      =1  
 451      =1  /***************************************************************************//**
 452      =1   * @brief
 453      =1   * Abort current I2C transfer
 454      =1   *
 455      =1   * This is a reset of the I2C state machine that will force the
 456      =1   * block into listening for the next start. Generally this is done
 457      =1   * in response to an error event like loss of arbitration.
 458      =1   *
 459      =1   ******************************************************************************/
 460      =1  void I2C0_abort();
 461      =1  
 462      =1  /***************************************************************************//**
 463      =1   * @brief
C51 COMPILER V9.56.0.0   I2C_0                                                             10/28/2016 17:37:02 PAGE 99  

 464      =1   * Send ACK/NACK
 465      =1   *
 466      =1   * @param ack:
 467      =1   * value of ACK/NACK.
 468      =1   *
 469      =1   * Set or clear ACK bit. ACK/NACK will be sent over the bus.
 470      =1   *
 471      =1   ******************************************************************************/
 472      =1  void I2C0_ack(bool ack);
 473      =1  
 474      =1  //#if EFM8PDL_I2C0_USE_MASTER == 1
 475      =1  
 476      =1  /***************************************************************************//**
 477      =1   * @brief
 478      =1   * Send a Start.
 479      =1   *
 480      =1   * Send a start on the bus (hardware waits for any current transfer to finish)
 481      =1   *
 482      =1   ******************************************************************************/
 483      =1  void I2C0_start();
 484      =1  
 485      =1  /***************************************************************************//**
 486      =1   * @brief
 487      =1   * Send a Stop.
 488      =1   *
 489      =1   * Send a stop on the bus.
 490      =1   *
 491      =1   ******************************************************************************/
 492      =1  void I2C0_stop();
 493      =1  
 494      =1  /** @} (end addtogroup i2c0_runtime I2C0 Runtime API) */
 495      =1  
 496      =1  // Initialization API
 497      =1  /***************************************************************************//**
 498      =1   * @addtogroup i2c0_init I2C0 Initialization API
 499      =1   * @{
 500      =1   ******************************************************************************/
 501      =1  
 502      =1  /***************************************************************************//**
 503      =1   * @brief
 504      =1   * Clock Selection Enum.
 505      =1   *
 506      =1   ******************************************************************************/
 507      =1  typedef enum
 508      =1  {
 509      =1    I2C0_TIMER0      = SMB0CF_SMBCS__TIMER0,      //!< Select SystemClock/12
 510      =1    I2C0_TIMER1      = SMB0CF_SMBCS__TIMER1,      //!< Select SystemClock/4
 511      =1    I2C0_TIMER2_HIGH = SMB0CF_SMBCS__TIMER2_HIGH, //!< Select Timer0 Overflow
 512      =1    I2C0_TIMER2_LOW  = SMB0CF_SMBCS__TIMER2_LOW,  //!< Select ECI falling edge
 513      =1  } I2C0_Timebase_t;
 514      =1  
 515      =1  /***************************************************************************//**
 516      =1   * @brief
 517      =1   *   Initialize the I2C
 518      =1   *
 519      =1   * @param timebase:
 520      =1   * Timebase selection.
 521      =1   * @param sclLow:
 522      =1   * SCL Low timeout enabled if true.
 523      =1   *
 524      =1   * This function configures the I2C with the selected options AND :
 525      =1   * 
C51 COMPILER V9.56.0.0   I2C_0                                                             10/28/2016 17:37:02 PAGE 100 

 526      =1   * - SmBus Free Timeout = enabled
 527      =1   * - Start Detection Window = 0-1 SYSCLK
 528      =1   * - Hardware Acknowledge = enabled
 529      =1   * - Slave = disabled.
 530      =1   *
 531      =1   * To enable the I2C slave call I2C0_initAddress AFTER calling I2C0_init.
 532      =1   * Enabling the I2C slave does not prevent the device from operating
 533      =1   * as a master.
 534      =1   *
 535      =1   * Additional configuration can be performed manually, or through Simplicity Hardware Configurator.
 536      =1   *
 537      =1   ******************************************************************************/
 538      =1  void I2C0_init(I2C0_Timebase_t  timebase, bool sclLow);
 539      =1  
 540      =1  /***************************************************************************//**
 541      =1   * @brief
 542      =1   *   Initialize the I2C Slave address
 543      =1   *
 544      =1   * @param address:
 545      =1   * slave address
 546      =1   * @param mask:
 547      =1   * slave address mask
 548      =1   *
 549      =1   * This function configures the I2C slave address an mask. it
 550      =1   * also enables slave reception (SMB0CF_INH).
 551      =1   *
 552      =1   ******************************************************************************/
 553      =1  void I2C0_initSlaveAddress(uint8_t address, uint8_t mask);
 554      =1  
 555      =1  /***************************************************************************//**
 556      =1   * @brief
 557      =1   * Restore the I2C to it's uninitialized (reset) state.
 558      =1   *
 559      =1   * This function restores the SMB block to it's reset state. This
 560      =1   * includes both master and slave configuration.
 561      =1   ******************************************************************************/
 562      =1  void I2C0_reset();
 563      =1  
 564      =1  /** @} (end addtogroup i2c0_init I2C0 Initialization API) */
 565      =1  
 566      =1  //=========================================================
 567      =1  // StateMachine API
 568      =1  //=========================================================
 569      =1  #if (EFM8PDL_I2C0_USE_STATEMACHINE == 1) || IS_DOXYGEN
           =1 /***************************************************************************//**
           =1  * @brief
           =1  * I2C Interrupt handler (not a callback).
           =1  *
           =1  * This ISR is provided by the library when EFM8PDL_I2C0_USE_CALLBACKS = "1".
           =1  *
           =1  ******************************************************************************/
           =1 SI_INTERRUPT_PROTO(I2C0_ISR, SMBUS0_IRQn);
           =1 #endif //EFM8PDL_I2C0_USE_STATEMACHINE
 579      =1  
 580      =1  // Buffered API
 581      =1  /***************************************************************************//**
 582      =1   * @addtogroup i2c0_buffered I2C0 Buffered API
 583      =1   * @{
 584      =1   ******************************************************************************/
 585      =1  #if (EFM8PDL_I2C0_USE_BUFFER == 1) || IS_DOXYGEN
 586      =1  
 587      =1  /***************************************************************************//**
C51 COMPILER V9.56.0.0   I2C_0                                                             10/28/2016 17:37:02 PAGE 101 

 588      =1   * @def void I2C0_ISR()
 589      =1   * @brief
 590      =1   * I2C Interrupt handler (not a callback).
 591      =1   *
 592      =1   * This ISR is provided by the library when EFM8PDL_I2C0_USE_CALLBACKS = "1".
 593      =1   *
 594      =1   ******************************************************************************/
 595      =1  
 596      =1  /***************************************************************************//**
 597      =1   * @brief
 598      =1   * I2C Transfer Errors.
 599      =1   *
 600      =1   ******************************************************************************/
 601      =1  typedef enum
 602      =1  {
 603      =1    I2C0_ARBLOST_ERROR  = 0x00,   /// Master lost arbitration on EFM8PDL_I2C0_MASTER_RETRIES consecutive att
             -empts
 604      =1    I2C0_NACK_ERROR     = 0x01,   /// Master got a NACK while writing the slave
 605      =1    I2C0_UNKNOWN_ERROR  = 0x02,   /// An Unknown error occurred
 606      =1    I2C0_TXUNDER_ERROR  = 0x03,   /// Master read more data then is available
 607      =1  } I2C0_TransferError_t;
 608      =1  
 609      =1  
 610      =1  /***************************************************************************//**
 611      =1   * @brief performs a transfer to the specified address.
 612      =1   *
 613      =1   * @param address:
 614      =1   * Address to write to with LSB (R/W) bit cleared. 6-bit I2C address
 615      =1   * must be properly placed in bits 7:1 of the address parameter.
 616      =1   * @param[in] txBuffer:
 617      =1   * Buffer containing tx data (NULL if unused)
 618      =1   * @param[out] rxBuffer:
 619      =1   * Buffer for rx data (NULL if unused)
 620      =1   * @param tx_len:
 621      =1   * Number of bytes to transmit from txBuffer
 622      =1   * @param rx_len:
 623      =1   * Number of bytes to receive into rxBuffer
 624      =1   *
 625      =1   * This function sets up a transfer over I2C to the address defined.
 626      =1   *
 627      =1   * When a rx_len of 0 is issued a I2C write will be performed and the application
 628      =1   * will be called back when the transfer has completed.
 629      =1   *
 630      =1   * When tx_len is 0 a I2C read will be performed and the application will be
 631      =1   * called back when the transfer is complete.
 632      =1   *
 633      =1   * When tx_len and rx_len are both non-zero a repeated start will be used.
 634      =1   * A write of the tx data will be executed followed by a repeated start,
 635      =1   * Followed by a read of rx data. The application will be called back when
 636      =1   * the entire transfer is complete.
 637      =1   *
 638      =1   * If this function is called while a slave transfer is in progress the
 639      =1   * requested transfer will take place after the current transfer is completed.
 640      =1   * This is ONLY valid for slave transfers. If I2C0_transfer is called before the
 641      =1   * previous master transfer complete it will overwrite the state of the in-progress
 642      =1   * transfer.
 643      =1   *
 644      =1   ******************************************************************************/
 645      =1  void I2C0_transfer(uint8_t address,
 646      =1                     SI_VARIABLE_SEGMENT_POINTER(txBuffer, uint8_t, EFM8PDL_I2C0_TX_BUFTYPE),
 647      =1                     SI_VARIABLE_SEGMENT_POINTER(rxBuffer, uint8_t, EFM8PDL_I2C0_RX_BUFTYPE),
 648      =1                     uint8_t tx_len,
C51 COMPILER V9.56.0.0   I2C_0                                                             10/28/2016 17:37:02 PAGE 102 

 649      =1                     uint8_t rx_len);
 650      =1  
 651      =1  /***************************************************************************//**
 652      =1   * @brief
 653      =1   * Abort current buffered transfer
 654      =1   *
 655      =1   * This function will set rx and tx len to 0 causing the current
 656      =1   * transfer to end immediately.
 657      =1   ******************************************************************************/
 658      =1  void I2C0_abortTransfer();
 659      =1  
 660      =1  /***************************************************************************//**
 661      =1   * @brief
 662      =1   * Get remaining bytes to write.
 663      =1   *
 664      =1   * @return
 665      =1   * Number of bytes to transfer.
 666      =1   *
 667      =1   ******************************************************************************/
 668      =1  uint8_t I2C0_txBytesRemaining();
 669      =1  
 670      =1  /***************************************************************************//**
 671      =1   * @brief
 672      =1   * Get remaining bytes to read.
 673      =1   *
 674      =1   * @return
 675      =1   * Number of bytes to read.
 676      =1   *
 677      =1   ******************************************************************************/
 678      =1  uint8_t I2C0_rxBytesRemaining();
 679      =1  
 680      =1  /***************************************************************************//**
 681      =1   * @brief Initializes slave block.
 682      =1   *
 683      =1   * @param address:
 684      =1   * Slaves address only access to this address will be acknowledged
 685      =1   * @param[out] commandBuffer:
 686      =1   * Buffer to save incoming data to.
 687      =1   * @param length:
 688      =1   * length of command buffer.
 689      =1   *
 690      =1   * Any master writes to the slave address will be buffered in commandBuffer.
 691      =1   * When the end of the write (stop or repeated start) occurs the
 692      =1   * I2C_commandReceived callback will be fired. The I2C bus will be stalled
 693      =1   * (SCL held low) until that callback returns.
 694      =1   *
 695      =1   * The callback will also be fired if the command buffer becomes full. In all cases
 696      =1   * the commandBuffer pointer is reset to the head of the buffer when the
 697      =1   * commandReceived callback returns. The next data received will then be
 698      =1   * written to the buffer as normal. Because of this the the implementation of the
 699      =1   * callback should ensure that the buffer is processed before returning.
 700      =1   *
 701      =1   ******************************************************************************/
 702      =1  void I2C0_initSlave(uint8_t address,
 703      =1                     SI_VARIABLE_SEGMENT_POINTER(commandBuffer, uint8_t, EFM8PDL_I2C0_RX_BUFTYPE),
 704      =1                     uint8_t length);
 705      =1  
 706      =1  /***************************************************************************//**
 707      =1   * @brief
 708      =1   * Returns length of received command.
 709      =1   *
 710      =1   * @return
C51 COMPILER V9.56.0.0   I2C_0                                                             10/28/2016 17:37:02 PAGE 103 

 711      =1   * Number of bytes in commandBuffer
 712      =1   *
 713      =1   ******************************************************************************/
 714      =1  uint8_t I2C0_getCommandLength();
 715      =1  
 716      =1  /***************************************************************************//**
 717      =1   * @brief Loads return data.
 718      =1   *
 719      =1   * @param[out] dataBuffer:
 720      =1   * Buffer of data to return to the slave.
 721      =1   * @param length:
 722      =1   * length of data buffer.
 723      =1   *
 724      =1   * This function sets up the data to be returned to the master in the event
 725      =1   * of an I2C read. It may be called during the commandRecived callback to set up
 726      =1   * response to a repeated start.
 727      =1   *
 728      =1   * There does not exist a mechanism for providing extended (ping-pong) buffers.
 729      =1   *
 730      =1   ******************************************************************************/
 731      =1  void I2C0_sendResponse(SI_VARIABLE_SEGMENT_POINTER(dataBuffer, uint8_t, EFM8PDL_I2C0_TX_BUFTYPE),
 732      =1                        uint8_t length);
 733      =1  
 734      =1  #endif //EFM8PDL_I2C0_USE_BUFFER
 735      =1  /** @} (end addtogroup i2c0_buffered I2C0 Buffered API) */
 736      =1  
 737      =1  // Callbacks
 738      =1  /***************************************************************************//**
 739      =1   * @addtogroup i2c0_callbacks User Callbacks
 740      =1   * @{
 741      =1   ******************************************************************************/
 742      =1  
 743      =1  /***************************************************************************//**
 744      =1   * @addtogroup i2c0_callbacks_statemachine StateMachine API
 745      =1   * @{
 746      =1   *
 747      =1   * These callbacks will be called by the library when
 748      =1   * EFM8PDL_I2C0_USE_STATEMACHINE. If the StateMachine api is disabled
 749      =1   * the callbacks do not need to be provided by the user.
 750      =1   *
 751      =1   ******************************************************************************/
 752      =1  
 753      =1  #if (EFM8PDL_I2C0_USE_STATEMACHINE == 1) || IS_DOXYGEN
           =1 /***************************************************************************//**
           =1  * @brief
           =1  * Callback for arbitration lost.
           =1  *
           =1  * @param state:
           =1  * The state being transitioned to when arbitration was lost
           =1  *
           =1  * @warning
           =1  * This function is called from an ISR and should be as short as possible.
           =1  *
           =1  * This function is defined by the user and called by the peripheral driver when
           =1  * arbitration is lost. Details on the state of the transfer during lost of
           =1  * arbitration can be found in the passed state information.
           =1  ******************************************************************************/
           =1 extern void I2C0_arbLostCb(I2C0_State_t state);
           =1 
           =1 /***************************************************************************//**
           =1  * @brief
           =1  * Callback for data transmitted.
C51 COMPILER V9.56.0.0   I2C_0                                                             10/28/2016 17:37:02 PAGE 104 

           =1  *
           =1  * @param master:
           =1  * True if data was transmitted while acting as a master.
           =1  * @param ack:
           =1  * True if transmitted data was ack'd (false if nack).
           =1  *
           =1  * @warning
           =1  * This function is called from an ISR and should be as short as possible.
           =1  *
           =1  * This function is defined by the user and called by the peripheral driver when
           =1  * Transmission of a byte is complete.
           =1  *
           =1  ******************************************************************************/
           =1 extern void I2C0_TxDataCb(bool master, bool ack);
           =1 
           =1 /***************************************************************************//**
           =1  * @brief
           =1  * Callback for receive of data.
           =1  *
           =1  * @param master:
           =1  * True if device was acting as a master when data received.
           =1  *
           =1  * @warning
           =1  * This function is called from an ISR and should be as short as possible.
           =1  *
           =1  * This function is defined by the user and called by the peripheral driver when
           =1  * data is received. The implementation should set the ACK status bit to ack the
           =1  * transfer. The bus is stalled (SCL low time extension) until the callback returns
           =1  ******************************************************************************/
           =1 extern void I2C0_RxDataCb(bool master);
           =1 
           =1 /***************************************************************************//**
           =1  * @brief
           =1  * Callback for receive of start.
           =1  *
           =1  * @warning
           =1  * This function is called from an ISR and should be as short as possible.
           =1  *
           =1  * This function is defined by the user and called by the peripheral driver when
           =1  * a start is seen. It is only called when acting as an I2C master. The
           =1  * implementation should write the slave address and R/W bit to the I2C.
           =1  ******************************************************************************/
           =1 extern void I2C0_startCb();  //master only
           =1 
           =1 /***************************************************************************//**
           =1  * @brief
           =1  * Callback for address received.
           =1  *
           =1  * @warning
           =1  * This function is called from an ISR and should be as short as possible.
           =1  *
           =1  * This function is defined by the user and called by the peripheral driver when
           =1  * an address is received. This callback is only fired when acting as a slave. The
           =1  * implementation should ack if the address is for the slave and nack if it is for
           =1  * another slave.
           =1  ******************************************************************************/
           =1 extern void I2C0_addressCb();   // slave only
           =1 
           =1 /***************************************************************************//**
           =1  * @brief
           =1  * Callback for stop received.
           =1  *
C51 COMPILER V9.56.0.0   I2C_0                                                             10/28/2016 17:37:02 PAGE 105 

           =1  * @warning
           =1  * This function is called from an ISR and should be as short as possible.
           =1  *
           =1  * This function is defined by the user and called by the peripheral driver when
           =1  * a stop is seen. It is only fired when acting as a slave.
           =1  *
           =1  ******************************************************************************/
           =1 extern void I2C0_stopCb();      // slave only
           =1 #endif //EFM8PDL_I2C0_USE_STATEMACHINE
 844      =1  /** @} (end addtogroup i2c0_callbacks_statemachine StateMachine API) */
 845      =1  
 846      =1  
 847      =1  /***************************************************************************//**
 848      =1   * @addtogroup i2c0_callbacks_buffer Buffer API
 849      =1   * @{
 850      =1   *
 851      =1   * These callbacks will be called by the library when
 852      =1   * EFM8PDL_I2C0_USE_BUFFER. If the Buffered API is disabled
 853      =1   * the callbacks do not need to be provided by the user.
 854      =1   *
 855      =1   ******************************************************************************/
 856      =1  #if (EFM8PDL_I2C0_USE_BUFFER == 1) || IS_DOXYGEN
 857      =1  
 858      =1  /***************************************************************************//**
 859      =1   * @brief
 860      =1   * Callback transfer complete.
 861      =1   *
 862      =1   * @warning
 863      =1   * This function is called from an ISR and should be as short as possible.
 864      =1   *
 865      =1   * This function is defined by the user and called by the peripheral driver when
 866      =1   * a master transmission is completed.
 867      =1   ******************************************************************************/
 868      =1  extern void I2C0_transferCompleteCb();
 869      =1  
 870      =1  /***************************************************************************//**
 871      =1   * @brief
 872      =1   * Callback for any error.
 873      =1   *
 874      =1   * @param error:
 875      =1   * I2C transfer error which caused the callback.
 876      =1   *
 877      =1   * @warning
 878      =1   * This function is called from an ISR and should be as short as possible.
 879      =1   *
 880      =1   * This function is defined by the user and called by the peripheral driver when
 881      =1   * any error occurs. This includes an unexpected NACK,  arbitration loss, or
 882      =1   * encountering any unknown or unexpected SMBus/I2C state.
 883      =1   *
 884      =1   * In all error conditions the transfer will be aborted.
 885      =1   *
 886      =1   ******************************************************************************/
 887      =1  extern void I2C0_errorCb(I2C0_TransferError_t error);
 888      =1  
 889      =1  /***************************************************************************//**
 890      =1   * @brief
 891      =1   * Callback for slave command reception.
 892      =1   *
 893      =1   * @warning
 894      =1   * This function is called from an ISR and should be as short as possible.
 895      =1   *
 896      =1   * This function is defined by the user and called by the peripheral driver when
C51 COMPILER V9.56.0.0   I2C_0                                                             10/28/2016 17:37:02 PAGE 106 

 897      =1   *
 898      =1   * A command is received from the master or the command buffer is full.
 899      =1   *
 900      =1   ******************************************************************************/
 901      =1  extern void I2C0_commandReceivedCb();
 902      =1  
 903      =1  #endif //EFM8PDL_I2C0_USE_BUFFER
 904      =1  /** @} (end addtogroup i2c0_callbacks_buffer Buffer API) */
 905      =1  /** @} (end addtogroup i2c0_callbacks User Callbacks) */
 906      =1  /** @} (end addtogroup i2c_0 I2C0 Driver) */
 907      =1  #endif //__I2C_0_H__
   8          #include "assert.h"
   1      =1  /*--------------------------------------------------------------------------
   2      =1  ASSERT.H
   3      =1  
   4      =1  Copyright (c) 1988-2008 Keil Elektronik GmbH and Keil Software, Inc.
   5      =1  Copyright (c) 2008-2016 ARM Germany GmbH
   6      =1  All rights reserved.
   7      =1  --------------------------------------------------------------------------*/
   8      =1  
   9      =1  #ifndef __ASSERT_H__
  10      =1  #define __ASSERT_H__
  11      =1  
  12      =1  #ifdef assert
           =1 #undef assert
           =1 #endif
  15      =1  
  16      =1  #ifndef __ASSERT_INC
  17      =1  #include <stdio.h>  /* prototype for 'printf' */
   1      =2  /*--------------------------------------------------------------------------
   2      =2  STDIO.H
   3      =2  
   4      =2  Prototypes for standard I/O functions.
   5      =2  Copyright (c) 1988-2002 Keil Elektronik GmbH and Keil Software, Inc.
   6      =2  All rights reserved.
   7      =2  --------------------------------------------------------------------------*/
   8      =2  
   9      =2  #ifndef __STDIO_H__
  10      =2  #define __STDIO_H__
  11      =2  
  12      =2  #ifndef EOF
  13      =2   #define EOF -1
  14      =2  #endif
  15      =2  
  16      =2  #ifndef NULL
           =2  #define NULL ((void *) 0)
           =2 #endif
  19      =2  
  20      =2  #ifndef _SIZE_T
  21      =2   #define _SIZE_T
  22      =2   typedef unsigned int size_t;
  23      =2  #endif
  24      =2  
  25      =2  #pragma SAVE
  26      =2  #pragma REGPARMS
  27      =2  extern char _getkey (void);
  28      =2  extern char getchar (void);
  29      =2  extern char ungetchar (char);
  30      =2  extern char putchar (char);
  31      =2  extern int printf   (const char *, ...);
  32      =2  extern int sprintf  (char *, const char *, ...);
  33      =2  extern int vprintf  (const char *, char *);
C51 COMPILER V9.56.0.0   I2C_0                                                             10/28/2016 17:37:02 PAGE 107 

  34      =2  extern int vsprintf (char *, const char *, char *);
  35      =2  extern char *gets (char *, int n);
  36      =2  extern int scanf (const char *, ...);
  37      =2  extern int sscanf (char *, const char *, ...);
  38      =2  extern int puts (const char *);
  39      =2  
  40      =2  #pragma RESTORE
  41      =2  
  42      =2  #endif
  43      =2  
  18      =1  #include <stdlib.h> /* prototype for 'abort' */
   1      =2  /*--------------------------------------------------------------------------
   2      =2  STDLIB.H
   3      =2  
   4      =2  Standard functions.
   5      =2  Copyright (c) 1988-2008 Keil Elektronik GmbH and Keil Software, Inc.
   6      =2  Copyright (c) 2008-2016 ARM Germany GmbH
   7      =2  All rights reserved.
   8      =2  --------------------------------------------------------------------------*/
   9      =2  
  10      =2  #ifndef __STDLIB_H__
  11      =2  #define __STDLIB_H__
  12      =2  
  13      =2  #ifndef _SIZE_T
           =2  #define _SIZE_T
           =2  typedef unsigned int size_t;
           =2 #endif
  17      =2  
  18      =2  #ifndef NULL
           =2  #define NULL ((void *)0)
           =2 #endif
  21      =2  
  22      =2  #ifndef _WCHAR_T_DEFINED_
  23      =2  #define _WCHAR_T_DEFINED_
  24      =2  typedef char wchar_t;
  25      =2  #endif
  26      =2  
  27      =2  #if defined (__CX2__)
           =2 #ifndef _DIV_T_DEFINED
           =2 typedef struct _div_t {
           =2         int quot;
           =2         int rem;
           =2 } div_t;
           =2 typedef struct _ldiv_t {
           =2         long quot;
           =2         long rem;
           =2 } ldiv_t;
           =2 #define _DIV_T_DEFINED
           =2 #endif // _DIV_T_DEFINED
           =2 #endif // __CX2__
  40      =2  
  41      =2  #ifndef RAND_MAX
  42      =2   #define RAND_MAX  32767u
  43      =2  #endif
  44      =2  
  45      =2  #if defined (__CX2__)
           =2 #pragma SAVE
           =2 #pragma FUNCTIONS(STATIC)
           =2 /* intrinsic functions are reentrant, but need static attribute */
           =2 extern int    abs  (int   val);
           =2 #pragma RESTORE
           =2 #endif // __CX2__
C51 COMPILER V9.56.0.0   I2C_0                                                             10/28/2016 17:37:02 PAGE 108 

  52      =2  
  53      =2  #pragma SAVE
  54      =2  #pragma REGPARMS
  55      =2  
  56      =2  extern char   cabs (char  val);
  57      =2  #if !defined (__CX2__)
  58      =2  extern int    abs  (int   val);
  59      =2  #endif // __CX2__
  60      =2  extern long   labs (long  val);
  61      =2  
  62      =2  extern float  atof (const char *s1);
  63      =2  extern long   atol (const char *s1);
  64      =2  extern int    atoi (const char *s1);
  65      =2  extern int    rand (void);
  66      =2  extern void   srand (unsigned int seed);
  67      =2  
  68      =2  #ifdef _DIV_T_DEFINED
           =2 extern div_t  __div (int numer, int denom);
           =2 #define div(numer,denom)  __div((numer),(denom));
           =2 extern ldiv_t ldiv (long numer, long denom);
           =2 #endif // _DIV_T_DEFINED
  73      =2  
  74      =2  extern float         strtod  (const char *nptr, char **endptr);
  75      =2  extern long          strtol  (const char *nptr, char **endptr, unsigned char base);
  76      =2  extern unsigned long strtoul (const char *nptr, char **endptr, unsigned char base);
  77      =2  
  78      =2  #define _MALLOC_MEM_  xdata
  79      =2  
  80      =2  extern void init_mempool          (void _MALLOC_MEM_ *p, size_t size);
  81      =2  extern void _MALLOC_MEM_ *malloc  (size_t size);
  82      =2  extern void free                  (void _MALLOC_MEM_ *p);
  83      =2  extern void _MALLOC_MEM_ *realloc (void _MALLOC_MEM_ *p, size_t size);
  84      =2  extern void _MALLOC_MEM_ *calloc  (size_t nmemb, size_t size);
  85      =2  
  86      =2  #if defined (__CX2__)
           =2 extern void abort(void);
           =2 #endif // __CX2__
  89      =2  
  90      =2  #pragma RESTORE
  91      =2  
  92      =2  #endif // __STDLIB_H__
  19      =1  #define __ASSERT_INC
  20      =1  #endif
  21      =1  
  22      =1  #ifndef NDEBUG
  23      =1  
  24      =1  #define assert(expr) \
  25      =1    do { \
  26      =1      if (expr) { ; } \
  27      =1      else { \
  28      =1        printf("Assert failed: " #expr " (file %s line %d)\n", __FILE__, (int) __LINE__ );\
  29      =1        abort();\
  30      =1      } \
  31      =1    } while (0)
  32      =1  #else
           =1 #define assert(expr)  ((void)0)
           =1 #endif
  35      =1  
  36      =1  #endif
   9          
  10          #if EFM8PDL_I2C0_AUTO_PAGE == 1
  11          // declare variable needed for autopage enter/exit
C51 COMPILER V9.56.0.0   I2C_0                                                             10/28/2016 17:37:02 PAGE 109 

  12          #define DECL_PAGE uint8_t savedPage
  13          // enter autopage section
  14          #define SET_PAGE(p)     do                                                    \
  15                                  {                                                     \
  16                                    savedPage = SFRPAGE;  /* save current SFR page */   \
  17                                    SFRPAGE = (p);        /* set SFR page */            \
  18                                  } while(0)
  19          // exit autopage section
  20          #define RESTORE_PAGE    do                                                    \
  21                                  {                                                     \
  22                                    SFRPAGE = savedPage;  /* restore saved SFR page */  \
  23                                  } while(0)
  24          
  25          #else
              #define DECL_PAGE
              #define SET_PAGE
              #define RESTORE_PAGE
              #endif
  30          
  31          #define ALL_FLAGS  I2C0_TXMODE_SF \
  32                             | I2C0_START_SF \
  33                             | I2C0_STOP_SF \
  34                             | I2C0_ACKREQ_SF \
  35                             | I2C0_ARBLOST_SF \
  36                             | I2C0_ACK_SF
  37          
  38          bool I2C0_getIntFlag()
  39          {
  40   1        bool val;
  41   1        DECL_PAGE;
  42   1        SET_PAGE(0x0);
  43   1        val = SMB0CN0_SI;
  44   1        RESTORE_PAGE;
  45   1        return val;
  46   1      }
  47          
  48          void I2C0_clearIntFlag()
  49          {
  50   1        DECL_PAGE;
  51   1        SET_PAGE(0x0);
  52   1        SMB0CN0_SI = 0;
  53   1        RESTORE_PAGE;
  54   1      }
  55          
  56          uint8_t I2C0_getStatusFlags() reentrant
  57          {
  58   1        uint8_t val;
  59   1        DECL_PAGE;
  60   1        SET_PAGE(0x0);
  61   1        val = SMB0CN0 & (I2C0_TXMODE_SF
  62   1                         | I2C0_START_SF
  63   1                         | I2C0_STOP_SF
  64   1                         | I2C0_ACKREQ_SF
  65   1                         | I2C0_ARBLOST_SF
  66   1                         | I2C0_ACK_SF);
  67   1        RESTORE_PAGE;
  68   1        return val;
  69   1      }
  70          
  71          void I2C0_setStatusFlag(uint8_t flag, uint8_t state) reentrant
  72          {
  73   1        DECL_PAGE;
C51 COMPILER V9.56.0.0   I2C_0                                                             10/28/2016 17:37:02 PAGE 110 

  74   1        SET_PAGE(0x0);
  75   1        if (state)
  76   1        {
  77   2          SMB0CN0 |= flag;
  78   2        }
  79   1        else
  80   1        {
  81   2          SMB0CN0 &= ~flag;
  82   2        }
  83   1        RESTORE_PAGE;
  84   1      }
  85          
  86          uint8_t I2C0_read()
  87          {
  88   1        uint8_t val;
  89   1        DECL_PAGE;
  90   1        SET_PAGE(0x0);
  91   1        val = SMB0DAT;
  92   1        RESTORE_PAGE;
  93   1        return val;
  94   1      }
  95          
  96          void I2C0_write(uint8_t value)
  97          {
  98   1        DECL_PAGE;
  99   1        SET_PAGE(0x0);
 100   1        SMB0DAT = value;
 101   1        RESTORE_PAGE;
 102   1      }
 103          
 104          void I2C0_abort()
 105          {
 106   1        DECL_PAGE;
 107   1        SET_PAGE(0x0);
 108   1        SMB0CF &= ~SMB0CF_ENSMB__BMASK;
 109   1        SMB0CF |= SMB0CF_ENSMB__BMASK;
 110   1        SMB0CN0 &= ~(SMB0CN0_STA__BMASK
 111   1            | SMB0CN0_STO__BMASK
 112   1            | SMB0CN0_ACKRQ__BMASK);
 113   1        RESTORE_PAGE;
 114   1      }
 115          
 116          void I2C0_ack(bool ack)
 117          {
 118   1        DECL_PAGE;
 119   1        SET_PAGE(0x0);
 120   1        SMB0CN0_ACK = ack;
 121   1        RESTORE_PAGE;
 122   1      }
 123          
 124          void I2C0_start()
 125          {
 126   1        DECL_PAGE;
 127   1        SET_PAGE(0x0);
 128   1        SMB0CN0_STA = 1;
 129   1        RESTORE_PAGE;
 130   1      }
 131          
 132          void I2C0_stop()
 133          {
 134   1        DECL_PAGE;
 135   1        SET_PAGE(0x0);
C51 COMPILER V9.56.0.0   I2C_0                                                             10/28/2016 17:37:02 PAGE 111 

 136   1        SMB0CN0_STO = 1;
 137   1        RESTORE_PAGE;
 138   1      }
 139          
 140          void I2C0_init(I2C0_Timebase_t timebase, bool sclLow) {
 141   1        DECL_PAGE;
 142   1        SET_PAGE(0x0);
 143   1        SMB0CF &= ~(SMB0CF_SMBCS__FMASK | SMB0CF_SMBTOE__BMASK);
 144   1        SMB0CF |= timebase
 145   1                  | SMB0CF_ENSMB__ENABLED
 146   1                  | SMB0CF_INH__SLAVE_DISABLED
 147   1                  | SMB0CF_SMBFTE__FREE_TO_ENABLED
 148   1                  | (uint8_t) sclLow << SMB0CF_SMBTOE__SHIFT;
 149   1        SMB0ADM |= SMB0ADM_EHACK__ADR_ACK_AUTOMATIC;
 150   1        RESTORE_PAGE;
 151   1      }
 152          
 153          void I2C0_initSlaveAddress(uint8_t address, uint8_t mask) {
 154   1        DECL_PAGE;
 155   1        SET_PAGE(0x0);
 156   1        SMB0CF  &= ~SMB0CF_INH__BMASK;
 157   1        SMB0ADR = address;
 158   1        SMB0ADM = mask | SMB0ADM_EHACK__BMASK;
 159   1        RESTORE_PAGE;
 160   1      }
 161          
 162          void I2C0_reset() {
 163   1        DECL_PAGE;
 164   1        SET_PAGE(0x0);
 165   1        SMB0CF = 0x0;
 166   1        SMBTC &= ~SMBTC_SMB0SDD__FMASK;
 167   1        SMB0CN0 = 0x0;
 168   1        SMB0ADR = 0x0;
 169   1        SMB0ADM = 0x0;
 170   1        RESTORE_PAGE;
 171   1      }
 172          
 173          #if EFM8PDL_I2C0_USE_STATEMACHINE == 1
              SI_INTERRUPT_PROTO(I2C0_ISR, SMBUS0_IRQn);
              SI_INTERRUPT(I2C0_ISR, SMBUS0_IRQn)
              {
                DECL_PAGE;
                SET_PAGE(0x0);
              
                if(SMB0CN0_ARBLOST) {
                  I2C0_arbLostCb(SMB0CN0 & 0xF0);
                }
              
                // Normal operation
                switch (SMB0CN0 & 0xF0)// Status vector
                {
                  // SMB0CN0_MASTER ---------------------------------------------------------------
              
                  // Master Transmitter/Receiver: START condition transmitted.
                  case I2C0_MASTER_START:
                    I2C0_startCb();
                    SMB0CN0_STA = 0;
                    break;
              
                  // Master Transmitter: Data byte transmitted
                  case I2C0_MASTER_TXDATA:
                    I2C0_TxDataCb(true, SMB0CN0_ACK);
C51 COMPILER V9.56.0.0   I2C_0                                                             10/28/2016 17:37:02 PAGE 112 

                    break;
              
                  // Master Receiver: byte received
                  case I2C0_MASTER_RXDATA:
                    I2C0_RxDataCb(true);
                    break;
              
                  case I2C0_SLAVE_TXDATA:
                    I2C0_TxDataCb(false, SMB0CN0_ACK);
                    break;
              
                  case I2C0_SLAVE_ADDRESS:
                    if(SMB0CN0_ARBLOST)
                    {
                      I2C0_arbLostCb(SMB0CN0 & 0xF0);
                    }
                    else
                    {
                      I2C0_addressCb();
                    }
                    SMB0CN0_STA = 0;  // Clear SMB0CN0_STA bit
                    break;
                                                    // Slave Receiver: Data received
                  case I2C0_SLAVE_RXDATA:
                    I2C0_RxDataCb(false);
                    break;
              
                                                    // Slave Receiver: Stop received while either a Slave Receiver or Sl
             -ave
                                                    // Transmitter
                  case I2C0_SLAVE_RX_STOP:
                  case I2C0_SLAVE_TX_STOP:
                    I2C0_stopCb();
                    SMB0CN0_STO = 0;
                    break;
              
                  default:
                    break;
              
                } // end switch
              
                //Need an SMBus Restart?
                SMB0CN0_SI = 0;// Clear interrupt flag
                RESTORE_PAGE;
              }
              #endif //EFM8PDL_I2C0_USE_STATEMACHINE
 243          
 244          #if EFM8PDL_I2C0_USE_BUFFER == 1
 245          
 246          SI_SEGMENT_VARIABLE(mAddress, uint8_t, SI_SEG_XDATA);
 247          SI_SEGMENT_VARIABLE(mTxCount, uint8_t, SI_SEG_XDATA);
 248          SI_SEGMENT_VARIABLE(mRxCount, uint8_t, SI_SEG_XDATA);
 249          SI_SEGMENT_VARIABLE_SEGMENT_POINTER(mTxBuffer, uint8_t, EFM8PDL_I2C0_RX_BUFTYPE,
 250              SI_SEG_XDATA);
 251          SI_SEGMENT_VARIABLE_SEGMENT_POINTER(mRxBuffer, uint8_t, EFM8PDL_I2C0_TX_BUFTYPE,
 252              SI_SEG_XDATA);
 253          
 254          SI_SEGMENT_VARIABLE(sRxSize, uint8_t, SI_SEG_XDATA);
 255          SI_SEGMENT_VARIABLE(sRxCount, uint8_t, SI_SEG_XDATA);
 256          SI_SEGMENT_VARIABLE(sTxCount, uint8_t, SI_SEG_XDATA);
 257          SI_SEGMENT_VARIABLE_SEGMENT_POINTER(sRxBuffer, uint8_t, EFM8PDL_I2C0_RX_BUFTYPE,
 258              SI_SEG_XDATA);
C51 COMPILER V9.56.0.0   I2C_0                                                             10/28/2016 17:37:02 PAGE 113 

 259          SI_SEGMENT_VARIABLE_SEGMENT_POINTER(sTxBuffer, uint8_t, EFM8PDL_I2C0_TX_BUFTYPE,
 260              SI_SEG_XDATA);
 261          
 262          SI_SEGMENT_VARIABLE(i2cBusy, bool, SI_SEG_IDATA);
*** WARNING C185 IN LINE 262 OF ..\..\SdkTool\EFM8UB2\Perip\Src\i2c_0.c: 'i2cBusy': different memory space
 263          SI_SEGMENT_VARIABLE(i2cReq, bool, SI_SEG_IDATA);
*** WARNING C185 IN LINE 263 OF ..\..\SdkTool\EFM8UB2\Perip\Src\i2c_0.c: 'i2cReq': different memory space
 264          SI_SEGMENT_VARIABLE(i2cReceive, bool, SI_SEG_IDATA);
*** WARNING C185 IN LINE 264 OF ..\..\SdkTool\EFM8UB2\Perip\Src\i2c_0.c: 'i2cReceive': different memory space
 265          SI_SEGMENT_VARIABLE(mRetries, uint8_t, SI_SEG_XDATA);
 266          
 267          void I2C0_transfer(uint8_t address,
 268              SI_VARIABLE_SEGMENT_POINTER(txBuffer, uint8_t, EFM8PDL_I2C0_TX_BUFTYPE),
 269              SI_VARIABLE_SEGMENT_POINTER(rxBuffer, uint8_t, EFM8PDL_I2C0_RX_BUFTYPE),
 270              uint8_t tx_len, uint8_t rx_len) {
 271   1      
 272   1        DECL_PAGE;
 273   1        SET_PAGE(0x0);
 274   1        //Setup transfer
 275   1        mAddress = address;
 276   1        mTxBuffer = txBuffer;
 277   1        mRxBuffer = rxBuffer;
 278   1        mTxCount = tx_len;
 279   1        mRxCount = rx_len;
 280   1        mRetries = EFM8PDL_I2C0_MASTER_RETRIES;
 281   1      
 282   1        if (i2cBusy) {
 283   2          i2cReq = true;
 284   2        } else {
 285   2          //Start transfer
 286   2          SMB0CN0_STA = 1;
 287   2        }
 288   1        RESTORE_PAGE;
 289   1      }
 290          
 291          void I2C0_abortTransfer(){
 292   1        mTxCount = 0;
 293   1        mRxCount = 0;
 294   1        sTxCount = 0;
 295   1        
 296   1        i2cBusy = false;
 297   1        i2cReq = false;
 298   1      }
 299          
 300          uint8_t I2C0_txBytesRemaining() {
 301   1        return mTxCount;
 302   1      }
 303          
 304          uint8_t I2C0_rxBytesRemaining() {
 305   1        return mRxCount;
 306   1      }
 307          
 308          void I2C0_initSlave(uint8_t address,
 309                              SI_VARIABLE_SEGMENT_POINTER(commandBuffer, uint8_t, EFM8PDL_I2C0_RX_BUFTYPE), uint8_t 
             -length) {
 310   1        DECL_PAGE;
 311   1        SET_PAGE(0x0);
 312   1        SMB0CF  &= ~SMB0CF_INH__BMASK;
 313   1        SMB0ADR = address;
 314   1        SMB0ADM = 0xFF | SMB0ADM_EHACK__BMASK;
 315   1        sRxBuffer = commandBuffer;
 316   1        sRxSize = length;
C51 COMPILER V9.56.0.0   I2C_0                                                             10/28/2016 17:37:02 PAGE 114 

 317   1        sRxCount = 0;
 318   1        RESTORE_PAGE;
 319   1      }
 320          
 321          uint8_t I2C0_getCommandLength() {
 322   1        return sRxCount;
 323   1      }
 324          
 325          void I2C0_sendResponse(
 326              SI_VARIABLE_SEGMENT_POINTER(dataBuffer, uint8_t, EFM8PDL_I2C0_TX_BUFTYPE),
 327              uint8_t length) {
 328   1        sTxBuffer = dataBuffer;
 329   1        sTxCount = length;
 330   1      }
 331          
 332          SI_INTERRUPT_PROTO(I2C0_ISR, SMBUS0_IRQn);
 333          
 334          SI_INTERRUPT(I2C0_ISR, SMBUS0_IRQn)
 335          {
 336   1        DECL_PAGE;
 337   1        SET_PAGE(0x0);
 338   1      
 339   1        // Jump to status vector handler
 340   1        switch (SMB0CN0 & 0xF0)
 341   1        {
 342   2        // Master Transmitter/Receiver: START condition transmitted.
 343   2        case I2C0_MASTER_START:
 344   2          //Send address. If no tx data then initiate read.
 345   2          SMB0DAT = mAddress;
 346   2          if (!mTxCount)
 347   2          {
 348   3            SMB0DAT |= 0x01;
 349   3          }
 350   2          i2cReceive = SMB0DAT & 0x01;
 351   2      
 352   2          //tailchain: clear_start; Other cases will jump here to execute this sequence
 353   2          // due to compiler case statment optomization (tailchaining)
 354   2          SMB0CN0_STA = 0;
 355   2          i2cBusy = true;
 356   2          break;
 357   2      
 358   2        // Master Transmitter: Data byte transmitted
 359   2        case I2C0_MASTER_TXDATA:
 360   2          if (SMB0CN0_ACK)
 361   2          {
 362   3            if (i2cReceive)
 363   3            {
 364   4              //Handle read transfer
 365   4              if(!--mRxCount)
 366   4              {
 367   5                SMB0CN0_ACK = 0; //ack for first data receviced byte
 368   5              }
 369   4              //ACK = 1 by default so no need to set it
 370   4            }
 371   3            else
 372   3            {
 373   4              //Handle write's
 374   4              if (mTxCount)
 375   4              {
 376   5                //if data remains in tx buffer send next byte
 377   5                SMB0DAT = *mTxBuffer++;
 378   5                mTxCount--;
C51 COMPILER V9.56.0.0   I2C_0                                                             10/28/2016 17:37:02 PAGE 115 

 379   5              }
 380   4              else
 381   4              {
 382   5                //Handle writes finished
 383   5                if (mRxCount)
 384   5                {
 385   6                  //if tx done and rx remaining do repeated start
 386   6                  SMB0CN0_STA = 1;
 387   6                }
 388   5                else
 389   5                {
 390   6                  //if tx done and no rx then stop
 391   6                  //tailchain: stop_seq
 392   6                  I2C0_transferCompleteCb();
 393   6                  SMB0CN0_STO = 1;
 394   6                  SMB0CN0_STA = i2cReq;
 395   6                  i2cReq = false;
 396   6                  i2cBusy = false;
 397   6                } // if rxCount else
 398   5              }   //if txCount else
 399   4            }     //if ! rxReceive (rxReceive = ack of address so ignore)
 400   3          }       // if ACK
 401   2          else
 402   2          {
 403   3            //Error on NAC
 404   3            I2C0_errorCb(I2C0_NACK_ERROR);
 405   3      
 406   3            //tailchain: stop_seq
 407   3            SMB0CN0_STO = 1;
 408   3            SMB0CN0_STA = i2cReq; //necessary for tailchain
 409   3            i2cReq = false; //necessary for tailchain
 410   3            i2cBusy = false;
 411   3          }
 412   2          break;
 413   2      
 414   2        // Master Receiver: byte received
 415   2        case I2C0_MASTER_RXDATA:
 416   2          //Read in data we just received
 417   2          *mRxBuffer++ = SMB0DAT;
 418   2      
 419   2          //if bytes remain read this one and set up for next one
 420   2          if (mRxCount)
 421   2          {
 422   3            //NACK if the byte we are about to read is our last
 423   3            if (!--mRxCount)
 424   3            {
 425   4              SMB0CN0_ACK = 0;
 426   4            }
 427   3            //ACK =1  by default so no need to set it.
 428   3          }
 429   2          else
 430   2          {
 431   3            SMB0CN0_ACK = 0;
 432   3      
 433   3            // If no bytes remain notify user xfer complete and issue stop.
 434   3            //tailchain: stop_seq
 435   3            I2C0_transferCompleteCb();
 436   3            SMB0CN0_STO = 1;
 437   3            SMB0CN0_STA = i2cReq;
 438   3            i2cReq = false;
 439   3            i2cBusy = false;
 440   3          }
C51 COMPILER V9.56.0.0   I2C_0                                                             10/28/2016 17:37:02 PAGE 116 

 441   2          break;
 442   2      
 443   2        // Slave Transmitter: Data byte transmitted
 444   2        case I2C0_SLAVE_TXDATA:
 445   2          if(SMB0CN0_ACK)
 446   2          {
 447   3            if(--sTxCount)
 448   3            {
 449   4              SMB0DAT = *sTxBuffer++;
 450   4            }
 451   3            else
 452   3            {
 453   4              I2C0_errorCb(I2C0_TXUNDER_ERROR);
 454   4            }
 455   3          }
 456   2          break;
 457   2      
 458   2        // Slave Receiver: Start+Address received
 459   2        case I2C0_SLAVE_ADDRESS:
 460   2          if(SMB0CN0_ARBLOST)
 461   2          {
 462   3            if(mRetries--)
 463   3            {
 464   4              i2cReq = true;
 465   4            }
 466   3            else
 467   3            {
 468   4              I2C0_errorCb(I2C0_ARBLOST_ERROR);
 469   4            }
 470   3          }
 471   2      
 472   2          i2cReceive = !(SMB0DAT & 0x01);
 473   2          // Nack defaults to 1 so no need to set it
 474   2      
 475   2          //Clear receive count if we are about to receive OR
 476   2          // if we have no rx phase (we are a write only xfer)
 477   2          // We leave rxCount alone if this is a repeated start
 478   2          if(i2cReceive | !i2cBusy)
 479   2          {
 480   3            sRxCount = 0;
 481   3          }
 482   2      
 483   2          // If this is a read then fire command received
 484   2          // either a read or a repeated start has been requested
 485   2          if (!i2cReceive) {
 486   3            if(sRxCount || !i2cBusy){
 487   4              //Issue a command received callback if there is RX data or if this
 488   4              // is not a repeated start
 489   4              I2C0_commandReceivedCb();
 490   4          }
 491   3      
 492   3            SMB0DAT = *sTxBuffer++;
 493   3            //DO NOT dec sTxSize This is handled AFTER the first byte is transmitted
 494   3          }
 495   2      
 496   2          //tailchain: clear_start
 497   2          SMB0CN0_STA = 0;
 498   2          i2cBusy = true;
 499   2          break;
 500   2      
 501   2        // Slave Receiver: Data received
 502   2        case I2C0_SLAVE_RXDATA:
C51 COMPILER V9.56.0.0   I2C_0                                                             10/28/2016 17:37:02 PAGE 117 

 503   2          //Read data into buffer
 504   2          sRxBuffer[sRxCount++] = SMB0DAT;
 505   2      
 506   2          //If buffer is about to overflow callback user and reset buffer
 507   2          if (sRxCount == sRxSize)
 508   2          {
 509   3            I2C0_commandReceivedCb();
 510   3            sRxCount = 0;
 511   3          }
 512   2      
 513   2          //ACK = 1 by default so no need to set it
 514   2          break;
 515   2      
 516   2        // Slave Receiver: Stop received while either a Slave Receiver or Transmitter
 517   2        case I2C0_SLAVE_RX_STOP:
 518   2        case I2C0_SLAVE_TX_STOP:
 519   2          if (i2cReceive && sRxCount)
 520   2          {
 521   3            I2C0_commandReceivedCb();
 522   3          }
 523   2      
 524   2          //clear stop
 525   2          SMB0CN0_STO = 0;
 526   2      
 527   2          //If master request pending send a start.
 528   2          //tailchain: stop_seq
 529   2          SMB0CN0_STA = i2cReq;
 530   2          i2cReq = false;
 531   2          i2cBusy = false;
 532   2          break;
 533   2      
 534   2        default:
 535   2          // All other cases are an error
 536   2          I2C0_errorCb(I2C0_UNKNOWN_ERROR);
 537   2          // ----------------------------------------------------------------------
 538   2        } // end switch
 539   1      
 540   1        //Clear interrupt flag
 541   1        SMB0CN0_SI = 0;
 542   1        RESTORE_PAGE;
 543   1      }
 544          
 545          #endif //EFM8PDL_I2C0_USE_BUFFER
C51 COMPILER V9.56.0.0   I2C_0                                                             10/28/2016 17:37:02 PAGE 118 

ASSEMBLY LISTING OF GENERATED OBJECT CODE


             ; FUNCTION I2C0_getIntFlag (BEGIN)
                                           ; SOURCE LINE # 38
                                           ; SOURCE LINE # 39
0000         ?C0003:
                                           ; SOURCE LINE # 42
0000 900000      R     MOV     DPTR,#savedPage
0003 E5BF              MOV     A,SFRPAGE
0005 F0                MOVX    @DPTR,A
0006 75BF00            MOV     SFRPAGE,#00H
0009         ?C0001:
0009         ?C0002:
                                           ; SOURCE LINE # 43
0009 A2C0              MOV     C,SMB0CN0_SI
000B 9200        R     MOV     val,C
000D         ?C0006:
                                           ; SOURCE LINE # 44
000D 900000      R     MOV     DPTR,#savedPage
0010 E0                MOVX    A,@DPTR
0011 FF                MOV     R7,A
0012 8FBF              MOV     SFRPAGE,R7
0014         ?C0004:
0014         ?C0005:
                                           ; SOURCE LINE # 45
0014 A200        R     MOV     C,val
                                           ; SOURCE LINE # 46
0016         ?C0007:
0016 22                RET     
             ; FUNCTION I2C0_getIntFlag (END)

             ; FUNCTION I2C0_clearIntFlag (BEGIN)
                                           ; SOURCE LINE # 48
                                           ; SOURCE LINE # 49
0000         ?C0010:
                                           ; SOURCE LINE # 51
0000 900000      R     MOV     DPTR,#savedPage
0003 E5BF              MOV     A,SFRPAGE
0005 F0                MOVX    @DPTR,A
0006 75BF00            MOV     SFRPAGE,#00H
0009         ?C0008:
0009         ?C0009:
                                           ; SOURCE LINE # 52
0009 C2C0              CLR     SMB0CN0_SI
000B         ?C0013:
                                           ; SOURCE LINE # 53
000B 900000      R     MOV     DPTR,#savedPage
000E E0                MOVX    A,@DPTR
000F FF                MOV     R7,A
0010 8FBF              MOV     SFRPAGE,R7
0012         ?C0011:
0012         ?C0012:
                                           ; SOURCE LINE # 54
0012         ?C0014:
0012 22                RET     
             ; FUNCTION I2C0_clearIntFlag (END)

             ; FUNCTION _?I2C0_getStatusFlags (BEGIN)
                                           ; SOURCE LINE # 56
0000 90FFFE            MOV     DPTR,#0FFFEH
0003 120000      E     LCALL   ?C?ADDXBP
C51 COMPILER V9.56.0.0   I2C_0                                                             10/28/2016 17:37:02 PAGE 119 

0006         ?C0017:
                                           ; SOURCE LINE # 60
0006 850083      E     MOV     DPH,?C_XBP
0009 850082      E     MOV     DPL,?C_XBP+01H
000C A3                INC     DPTR
000D E5BF              MOV     A,SFRPAGE
000F F0                MOVX    @DPTR,A
0010 75BF00            MOV     SFRPAGE,#00H
0013         ?C0015:
0013         ?C0016:
                                           ; SOURCE LINE # 61
0013 E5C0              MOV     A,SMB0CN0
0015 547E              ANL     A,#07EH
0017 FF                MOV     R7,A
0018 850083      E     MOV     DPH,?C_XBP
001B 850082      E     MOV     DPL,?C_XBP+01H
001E EF                MOV     A,R7
001F F0                MOVX    @DPTR,A
0020         ?C0020:
                                           ; SOURCE LINE # 67
0020 850083      E     MOV     DPH,?C_XBP
0023 850082      E     MOV     DPL,?C_XBP+01H
0026 A3                INC     DPTR
0027 E0                MOVX    A,@DPTR
0028 FF                MOV     R7,A
0029 8FBF              MOV     SFRPAGE,R7
002B         ?C0018:
002B         ?C0019:
                                           ; SOURCE LINE # 68
002B 850083      E     MOV     DPH,?C_XBP
002E 850082      E     MOV     DPL,?C_XBP+01H
0031 E0                MOVX    A,@DPTR
0032 FF                MOV     R7,A
                                           ; SOURCE LINE # 69
0033         ?C0021:
0033 900002            MOV     DPTR,#02H
0036 120000      E     LCALL   ?C?ADDXBP
0039 22                RET     
             ; FUNCTION _?I2C0_getStatusFlags (END)

             ; FUNCTION _?I2C0_setStatusFlag (BEGIN)
                                           ; SOURCE LINE # 71
0000 90FFFF            MOV     DPTR,#0FFFFH
0003 120000      E     LCALL   ?C?ADDXBP
0006 ED                MOV     A,R5
0007 F0                MOVX    @DPTR,A
0008 90FFFF            MOV     DPTR,#0FFFFH
000B 120000      E     LCALL   ?C?ADDXBP
000E EF                MOV     A,R7
000F F0                MOVX    @DPTR,A
0010 90FFFF            MOV     DPTR,#0FFFFH
0013 120000      E     LCALL   ?C?ADDXBP
0016         ?C0024:
                                           ; SOURCE LINE # 74
0016 850083      E     MOV     DPH,?C_XBP
0019 850082      E     MOV     DPL,?C_XBP+01H
001C E5BF              MOV     A,SFRPAGE
001E F0                MOVX    @DPTR,A
001F 75BF00            MOV     SFRPAGE,#00H
0022         ?C0022:
0022         ?C0023:
                                           ; SOURCE LINE # 75
C51 COMPILER V9.56.0.0   I2C_0                                                             10/28/2016 17:37:02 PAGE 120 

0022 850083      E     MOV     DPH,?C_XBP
0025 850082      E     MOV     DPL,?C_XBP+01H
0028 A3                INC     DPTR
0029 A3                INC     DPTR
002A E0                MOVX    A,@DPTR
002B FF                MOV     R7,A
002C EF                MOV     A,R7
002D 600E              JZ      ?C0025
                                           ; SOURCE LINE # 76
                                           ; SOURCE LINE # 77
002F 850083      E     MOV     DPH,?C_XBP
0032 850082      E     MOV     DPL,?C_XBP+01H
0035 A3                INC     DPTR
0036 E0                MOVX    A,@DPTR
0037 FF                MOV     R7,A
0038 EF                MOV     A,R7
0039 42C0              ORL     SMB0CN0,A
                                           ; SOURCE LINE # 78
003B 800F              SJMP    ?C0029
003D         ?C0025:
                                           ; SOURCE LINE # 80
                                           ; SOURCE LINE # 81
003D 850083      E     MOV     DPH,?C_XBP
0040 850082      E     MOV     DPL,?C_XBP+01H
0043 A3                INC     DPTR
0044 E0                MOVX    A,@DPTR
0045 FF                MOV     R7,A
0046 EF                MOV     A,R7
0047 F4                CPL     A
0048 FF                MOV     R7,A
0049 EF                MOV     A,R7
004A 52C0              ANL     SMB0CN0,A
                                           ; SOURCE LINE # 82
004C         ?C0026:
004C         ?C0029:
                                           ; SOURCE LINE # 83
004C 850083      E     MOV     DPH,?C_XBP
004F 850082      E     MOV     DPL,?C_XBP+01H
0052 E0                MOVX    A,@DPTR
0053 FF                MOV     R7,A
0054 8FBF              MOV     SFRPAGE,R7
0056         ?C0027:
0056         ?C0028:
                                           ; SOURCE LINE # 84
0056         ?C0030:
0056 900003            MOV     DPTR,#03H
0059 120000      E     LCALL   ?C?ADDXBP
005C 22                RET     
             ; FUNCTION _?I2C0_setStatusFlag (END)

             ; FUNCTION I2C0_read (BEGIN)
                                           ; SOURCE LINE # 86
                                           ; SOURCE LINE # 87
0000         ?C0033:
                                           ; SOURCE LINE # 90
0000 900000      R     MOV     DPTR,#savedPage
0003 E5BF              MOV     A,SFRPAGE
0005 F0                MOVX    @DPTR,A
0006 75BF00            MOV     SFRPAGE,#00H
0009         ?C0031:
0009         ?C0032:
                                           ; SOURCE LINE # 91
C51 COMPILER V9.56.0.0   I2C_0                                                             10/28/2016 17:37:02 PAGE 121 

0009 900000      R     MOV     DPTR,#val
000C E5C2              MOV     A,SMB0DAT
000E F0                MOVX    @DPTR,A
000F         ?C0036:
                                           ; SOURCE LINE # 92
000F 900000      R     MOV     DPTR,#savedPage
0012 E0                MOVX    A,@DPTR
0013 FF                MOV     R7,A
0014 8FBF              MOV     SFRPAGE,R7
0016         ?C0034:
0016         ?C0035:
                                           ; SOURCE LINE # 93
0016 900000      R     MOV     DPTR,#val
0019 E0                MOVX    A,@DPTR
001A FF                MOV     R7,A
                                           ; SOURCE LINE # 94
001B         ?C0037:
001B 22                RET     
             ; FUNCTION I2C0_read (END)

             ; FUNCTION _I2C0_write (BEGIN)
                                           ; SOURCE LINE # 96
0000 900000      R     MOV     DPTR,#value
0003 EF                MOV     A,R7
0004 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 97
0005         ?C0040:
                                           ; SOURCE LINE # 99
0005 900000      R     MOV     DPTR,#savedPage
0008 E5BF              MOV     A,SFRPAGE
000A F0                MOVX    @DPTR,A
000B 75BF00            MOV     SFRPAGE,#00H
000E         ?C0038:
000E         ?C0039:
                                           ; SOURCE LINE # 100
000E 900000      R     MOV     DPTR,#value
0011 E0                MOVX    A,@DPTR
0012 FF                MOV     R7,A
0013 8FC2              MOV     SMB0DAT,R7
0015         ?C0043:
                                           ; SOURCE LINE # 101
0015 900000      R     MOV     DPTR,#savedPage
0018 E0                MOVX    A,@DPTR
0019 FF                MOV     R7,A
001A 8FBF              MOV     SFRPAGE,R7
001C         ?C0041:
001C         ?C0042:
                                           ; SOURCE LINE # 102
001C         ?C0044:
001C 22                RET     
             ; FUNCTION _I2C0_write (END)

             ; FUNCTION I2C0_abort (BEGIN)
                                           ; SOURCE LINE # 104
                                           ; SOURCE LINE # 105
0000         ?C0047:
                                           ; SOURCE LINE # 107
0000 900000      R     MOV     DPTR,#savedPage
0003 E5BF              MOV     A,SFRPAGE
0005 F0                MOVX    @DPTR,A
0006 75BF00            MOV     SFRPAGE,#00H
0009         ?C0045:
C51 COMPILER V9.56.0.0   I2C_0                                                             10/28/2016 17:37:02 PAGE 122 

0009         ?C0046:
                                           ; SOURCE LINE # 108
0009 53C17F            ANL     SMB0CF,#07FH
                                           ; SOURCE LINE # 109
000C 43C180            ORL     SMB0CF,#080H
                                           ; SOURCE LINE # 110
000F 53C0C7            ANL     SMB0CN0,#0C7H
0012         ?C0050:
                                           ; SOURCE LINE # 113
0012 900000      R     MOV     DPTR,#savedPage
0015 E0                MOVX    A,@DPTR
0016 FF                MOV     R7,A
0017 8FBF              MOV     SFRPAGE,R7
0019         ?C0048:
0019         ?C0049:
                                           ; SOURCE LINE # 114
0019         ?C0051:
0019 22                RET     
             ; FUNCTION I2C0_abort (END)

             ; FUNCTION I2C0_ack (BEGIN)
                                           ; SOURCE LINE # 116
                                           ; SOURCE LINE # 117
0000         ?C0054:
                                           ; SOURCE LINE # 119
0000 900000      R     MOV     DPTR,#savedPage
0003 E5BF              MOV     A,SFRPAGE
0005 F0                MOVX    @DPTR,A
0006 75BF00            MOV     SFRPAGE,#00H
0009         ?C0052:
0009         ?C0053:
                                           ; SOURCE LINE # 120
0009 A200        R     MOV     C,ack
000B 92C1              MOV     SMB0CN0_ACK,C
000D         ?C0057:
                                           ; SOURCE LINE # 121
000D 900000      R     MOV     DPTR,#savedPage
0010 E0                MOVX    A,@DPTR
0011 FF                MOV     R7,A
0012 8FBF              MOV     SFRPAGE,R7
0014         ?C0055:
0014         ?C0056:
                                           ; SOURCE LINE # 122
0014         ?C0058:
0014 22                RET     
             ; FUNCTION I2C0_ack (END)

             ; FUNCTION I2C0_start (BEGIN)
                                           ; SOURCE LINE # 124
                                           ; SOURCE LINE # 125
0000         ?C0061:
                                           ; SOURCE LINE # 127
0000 900000      R     MOV     DPTR,#savedPage
0003 E5BF              MOV     A,SFRPAGE
0005 F0                MOVX    @DPTR,A
0006 75BF00            MOV     SFRPAGE,#00H
0009         ?C0059:
0009         ?C0060:
                                           ; SOURCE LINE # 128
0009 D2C5              SETB    SMB0CN0_STA
000B         ?C0064:
                                           ; SOURCE LINE # 129
C51 COMPILER V9.56.0.0   I2C_0                                                             10/28/2016 17:37:02 PAGE 123 

000B 900000      R     MOV     DPTR,#savedPage
000E E0                MOVX    A,@DPTR
000F FF                MOV     R7,A
0010 8FBF              MOV     SFRPAGE,R7
0012         ?C0062:
0012         ?C0063:
                                           ; SOURCE LINE # 130
0012         ?C0065:
0012 22                RET     
             ; FUNCTION I2C0_start (END)

             ; FUNCTION I2C0_stop (BEGIN)
                                           ; SOURCE LINE # 132
                                           ; SOURCE LINE # 133
0000         ?C0068:
                                           ; SOURCE LINE # 135
0000 900000      R     MOV     DPTR,#savedPage
0003 E5BF              MOV     A,SFRPAGE
0005 F0                MOVX    @DPTR,A
0006 75BF00            MOV     SFRPAGE,#00H
0009         ?C0066:
0009         ?C0067:
                                           ; SOURCE LINE # 136
0009 D2C4              SETB    SMB0CN0_STO
000B         ?C0071:
                                           ; SOURCE LINE # 137
000B 900000      R     MOV     DPTR,#savedPage
000E E0                MOVX    A,@DPTR
000F FF                MOV     R7,A
0010 8FBF              MOV     SFRPAGE,R7
0012         ?C0069:
0012         ?C0070:
                                           ; SOURCE LINE # 138
0012         ?C0072:
0012 22                RET     
             ; FUNCTION I2C0_stop (END)

             ; FUNCTION _I2C0_init (BEGIN)
                                           ; SOURCE LINE # 140
0000 900000      R     MOV     DPTR,#timebase
0003 EF                MOV     A,R7
0004 F0                MOVX    @DPTR,A
0005         ?C0075:
                                           ; SOURCE LINE # 142
0005 900000      R     MOV     DPTR,#savedPage
0008 E5BF              MOV     A,SFRPAGE
000A F0                MOVX    @DPTR,A
000B 75BF00            MOV     SFRPAGE,#00H
000E         ?C0073:
000E         ?C0074:
                                           ; SOURCE LINE # 143
000E 53C1F4            ANL     SMB0CF,#0F4H
                                           ; SOURCE LINE # 148
0011 A200        R     MOV     C,sclLow
0013 E4                CLR     A
0014 33                RLC     A
0015 FF                MOV     R7,A
0016 EF                MOV     A,R7
0017 33                RLC     A
0018 33                RLC     A
0019 33                RLC     A
001A 54F8              ANL     A,#0F8H
C51 COMPILER V9.56.0.0   I2C_0                                                             10/28/2016 17:37:02 PAGE 124 

001C FF                MOV     R7,A
001D 900000      R     MOV     DPTR,#timebase
0020 E0                MOVX    A,@DPTR
0021 FE                MOV     R6,A
0022 EE                MOV     A,R6
0023 44C4              ORL     A,#0C4H
0025 FE                MOV     R6,A
0026 EF                MOV     A,R7
0027 4E                ORL     A,R6
0028 FF                MOV     R7,A
0029 EF                MOV     A,R7
002A 42C1              ORL     SMB0CF,A
                                           ; SOURCE LINE # 149
002C 43CE01            ORL     SMB0ADM,#01H
002F         ?C0078:
                                           ; SOURCE LINE # 150
002F 900000      R     MOV     DPTR,#savedPage
0032 E0                MOVX    A,@DPTR
0033 FF                MOV     R7,A
0034 8FBF              MOV     SFRPAGE,R7
0036         ?C0076:
0036         ?C0077:
                                           ; SOURCE LINE # 151
0036         ?C0079:
0036 22                RET     
             ; FUNCTION _I2C0_init (END)

             ; FUNCTION _I2C0_initSlaveAddress (BEGIN)
                                           ; SOURCE LINE # 153
0000 900000      R     MOV     DPTR,#address
0003 EF                MOV     A,R7
0004 F0                MOVX    @DPTR,A
0005 900000      R     MOV     DPTR,#mask
0008 ED                MOV     A,R5
0009 F0                MOVX    @DPTR,A
000A         ?C0082:
                                           ; SOURCE LINE # 155
000A 900000      R     MOV     DPTR,#savedPage
000D E5BF              MOV     A,SFRPAGE
000F F0                MOVX    @DPTR,A
0010 75BF00            MOV     SFRPAGE,#00H
0013         ?C0080:
0013         ?C0081:
                                           ; SOURCE LINE # 156
0013 53C1BF            ANL     SMB0CF,#0BFH
                                           ; SOURCE LINE # 157
0016 900000      R     MOV     DPTR,#address
0019 E0                MOVX    A,@DPTR
001A FF                MOV     R7,A
001B 8FCF              MOV     SMB0ADR,R7
                                           ; SOURCE LINE # 158
001D 900000      R     MOV     DPTR,#mask
0020 E0                MOVX    A,@DPTR
0021 FF                MOV     R7,A
0022 EF                MOV     A,R7
0023 4401              ORL     A,#01H
0025 F5CE              MOV     SMB0ADM,A
0027         ?C0085:
                                           ; SOURCE LINE # 159
0027 900000      R     MOV     DPTR,#savedPage
002A E0                MOVX    A,@DPTR
002B FF                MOV     R7,A
C51 COMPILER V9.56.0.0   I2C_0                                                             10/28/2016 17:37:02 PAGE 125 

002C 8FBF              MOV     SFRPAGE,R7
002E         ?C0083:
002E         ?C0084:
                                           ; SOURCE LINE # 160
002E         ?C0086:
002E 22                RET     
             ; FUNCTION _I2C0_initSlaveAddress (END)

             ; FUNCTION I2C0_reset (BEGIN)
                                           ; SOURCE LINE # 162
0000         ?C0089:
                                           ; SOURCE LINE # 164
0000 900000      R     MOV     DPTR,#savedPage
0003 E5BF              MOV     A,SFRPAGE
0005 F0                MOVX    @DPTR,A
0006 75BF00            MOV     SFRPAGE,#00H
0009         ?C0087:
0009         ?C0088:
                                           ; SOURCE LINE # 165
0009 75C100            MOV     SMB0CF,#00H
                                           ; SOURCE LINE # 166
000C 53B9FC            ANL     SMBTC,#0FCH
                                           ; SOURCE LINE # 167
000F 75C000            MOV     SMB0CN0,#00H
                                           ; SOURCE LINE # 168
0012 75CF00            MOV     SMB0ADR,#00H
                                           ; SOURCE LINE # 169
0015 75CE00            MOV     SMB0ADM,#00H
0018         ?C0092:
                                           ; SOURCE LINE # 170
0018 900000      R     MOV     DPTR,#savedPage
001B E0                MOVX    A,@DPTR
001C FF                MOV     R7,A
001D 8FBF              MOV     SFRPAGE,R7
001F         ?C0090:
001F         ?C0091:
                                           ; SOURCE LINE # 171
001F         ?C0093:
001F 22                RET     
             ; FUNCTION I2C0_reset (END)

             ; FUNCTION _I2C0_transfer (BEGIN)
                                           ; SOURCE LINE # 267
0000 900000      R     MOV     DPTR,#address
0003 EF                MOV     A,R7
0004 F0                MOVX    @DPTR,A
0005 900000      R     MOV     DPTR,#txBuffer
0008 EC                MOV     A,R4
0009 F0                MOVX    @DPTR,A
000A A3                INC     DPTR
000B ED                MOV     A,R5
000C F0                MOVX    @DPTR,A
000D 900000      R     MOV     DPTR,#rxBuffer
0010 EA                MOV     A,R2
0011 F0                MOVX    @DPTR,A
0012 A3                INC     DPTR
0013 EB                MOV     A,R3
0014 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 270
0015         ?C0096:
                                           ; SOURCE LINE # 273
0015 900000      R     MOV     DPTR,#savedPage
C51 COMPILER V9.56.0.0   I2C_0                                                             10/28/2016 17:37:02 PAGE 126 

0018 E5BF              MOV     A,SFRPAGE
001A F0                MOVX    @DPTR,A
001B 75BF00            MOV     SFRPAGE,#00H
001E         ?C0094:
001E         ?C0095:
                                           ; SOURCE LINE # 275
001E 900000      R     MOV     DPTR,#address
0021 E0                MOVX    A,@DPTR
0022 FF                MOV     R7,A
0023 900000      R     MOV     DPTR,#mAddress
0026 EF                MOV     A,R7
0027 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 276
0028 900000      R     MOV     DPTR,#txBuffer
002B E0                MOVX    A,@DPTR
002C FE                MOV     R6,A
002D A3                INC     DPTR
002E E0                MOVX    A,@DPTR
002F FF                MOV     R7,A
0030 900000      R     MOV     DPTR,#mTxBuffer
0033 EE                MOV     A,R6
0034 F0                MOVX    @DPTR,A
0035 A3                INC     DPTR
0036 EF                MOV     A,R7
0037 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 277
0038 900000      R     MOV     DPTR,#rxBuffer
003B E0                MOVX    A,@DPTR
003C FE                MOV     R6,A
003D A3                INC     DPTR
003E E0                MOVX    A,@DPTR
003F FF                MOV     R7,A
0040 900000      R     MOV     DPTR,#mRxBuffer
0043 EE                MOV     A,R6
0044 F0                MOVX    @DPTR,A
0045 A3                INC     DPTR
0046 EF                MOV     A,R7
0047 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 278
0048 900000      R     MOV     DPTR,#tx_len
004B E0                MOVX    A,@DPTR
004C FF                MOV     R7,A
004D 900000      R     MOV     DPTR,#mTxCount
0050 EF                MOV     A,R7
0051 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 279
0052 900000      R     MOV     DPTR,#rx_len
0055 E0                MOVX    A,@DPTR
0056 FF                MOV     R7,A
0057 900000      R     MOV     DPTR,#mRxCount
005A EF                MOV     A,R7
005B F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 280
005C 900000      R     MOV     DPTR,#mRetries
005F 74FF              MOV     A,#0FFH
0061 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 282
0062 300004            JNB     i2cBusy,?C0097
                                           ; SOURCE LINE # 283
0065 D200        R     SETB    i2cReq
                                           ; SOURCE LINE # 284
0067 8002              SJMP    ?C0101
C51 COMPILER V9.56.0.0   I2C_0                                                             10/28/2016 17:37:02 PAGE 127 

0069         ?C0097:
                                           ; SOURCE LINE # 286
0069 D2C5              SETB    SMB0CN0_STA
                                           ; SOURCE LINE # 287
006B         ?C0098:
006B         ?C0101:
                                           ; SOURCE LINE # 288
006B 900000      R     MOV     DPTR,#savedPage
006E E0                MOVX    A,@DPTR
006F FF                MOV     R7,A
0070 8FBF              MOV     SFRPAGE,R7
0072         ?C0099:
0072         ?C0100:
                                           ; SOURCE LINE # 289
0072         ?C0102:
0072 22                RET     
             ; FUNCTION _I2C0_transfer (END)

             ; FUNCTION I2C0_abortTransfer (BEGIN)
                                           ; SOURCE LINE # 291
                                           ; SOURCE LINE # 292
0000 900000      R     MOV     DPTR,#mTxCount
0003 E4                CLR     A
0004 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 293
0005 900000      R     MOV     DPTR,#mRxCount
0008 E4                CLR     A
0009 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 294
000A 900000      R     MOV     DPTR,#sTxCount
000D E4                CLR     A
000E F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 296
000F C200        R     CLR     i2cBusy
                                           ; SOURCE LINE # 297
0011 C200        R     CLR     i2cReq
                                           ; SOURCE LINE # 298
0013         ?C0103:
0013 22                RET     
             ; FUNCTION I2C0_abortTransfer (END)

             ; FUNCTION I2C0_txBytesRemaining (BEGIN)
                                           ; SOURCE LINE # 300
                                           ; SOURCE LINE # 301
0000 900000      R     MOV     DPTR,#mTxCount
0003 E0                MOVX    A,@DPTR
0004 FF                MOV     R7,A
                                           ; SOURCE LINE # 302
0005         ?C0104:
0005 22                RET     
             ; FUNCTION I2C0_txBytesRemaining (END)

             ; FUNCTION I2C0_rxBytesRemaining (BEGIN)
                                           ; SOURCE LINE # 304
                                           ; SOURCE LINE # 305
0000 900000      R     MOV     DPTR,#mRxCount
0003 E0                MOVX    A,@DPTR
0004 FF                MOV     R7,A
                                           ; SOURCE LINE # 306
0005         ?C0105:
0005 22                RET     
             ; FUNCTION I2C0_rxBytesRemaining (END)
C51 COMPILER V9.56.0.0   I2C_0                                                             10/28/2016 17:37:02 PAGE 128 


             ; FUNCTION _I2C0_initSlave (BEGIN)
                                           ; SOURCE LINE # 308
0000 900000      R     MOV     DPTR,#address
0003 EF                MOV     A,R7
0004 F0                MOVX    @DPTR,A
0005 900000      R     MOV     DPTR,#commandBuffer
0008 EC                MOV     A,R4
0009 F0                MOVX    @DPTR,A
000A A3                INC     DPTR
000B ED                MOV     A,R5
000C F0                MOVX    @DPTR,A
000D 900000      R     MOV     DPTR,#length
0010 EB                MOV     A,R3
0011 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 309
0012         ?C0108:
                                           ; SOURCE LINE # 311
0012 900000      R     MOV     DPTR,#savedPage
0015 E5BF              MOV     A,SFRPAGE
0017 F0                MOVX    @DPTR,A
0018 75BF00            MOV     SFRPAGE,#00H
001B         ?C0106:
001B         ?C0107:
                                           ; SOURCE LINE # 312
001B 53C1BF            ANL     SMB0CF,#0BFH
                                           ; SOURCE LINE # 313
001E 900000      R     MOV     DPTR,#address
0021 E0                MOVX    A,@DPTR
0022 FF                MOV     R7,A
0023 8FCF              MOV     SMB0ADR,R7
                                           ; SOURCE LINE # 314
0025 75CEFF            MOV     SMB0ADM,#0FFH
                                           ; SOURCE LINE # 315
0028 900000      R     MOV     DPTR,#commandBuffer
002B E0                MOVX    A,@DPTR
002C FE                MOV     R6,A
002D A3                INC     DPTR
002E E0                MOVX    A,@DPTR
002F FF                MOV     R7,A
0030 900000      R     MOV     DPTR,#sRxBuffer
0033 EE                MOV     A,R6
0034 F0                MOVX    @DPTR,A
0035 A3                INC     DPTR
0036 EF                MOV     A,R7
0037 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 316
0038 900000      R     MOV     DPTR,#length
003B E0                MOVX    A,@DPTR
003C FF                MOV     R7,A
003D 900000      R     MOV     DPTR,#sRxSize
0040 EF                MOV     A,R7
0041 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 317
0042 900000      R     MOV     DPTR,#sRxCount
0045 E4                CLR     A
0046 F0                MOVX    @DPTR,A
0047         ?C0111:
                                           ; SOURCE LINE # 318
0047 900000      R     MOV     DPTR,#savedPage
004A E0                MOVX    A,@DPTR
004B FF                MOV     R7,A
C51 COMPILER V9.56.0.0   I2C_0                                                             10/28/2016 17:37:02 PAGE 129 

004C 8FBF              MOV     SFRPAGE,R7
004E         ?C0109:
004E         ?C0110:
                                           ; SOURCE LINE # 319
004E         ?C0112:
004E 22                RET     
             ; FUNCTION _I2C0_initSlave (END)

             ; FUNCTION I2C0_getCommandLength (BEGIN)
                                           ; SOURCE LINE # 321
                                           ; SOURCE LINE # 322
0000 900000      R     MOV     DPTR,#sRxCount
0003 E0                MOVX    A,@DPTR
0004 FF                MOV     R7,A
                                           ; SOURCE LINE # 323
0005         ?C0113:
0005 22                RET     
             ; FUNCTION I2C0_getCommandLength (END)

             ; FUNCTION _I2C0_sendResponse (BEGIN)
                                           ; SOURCE LINE # 325
0000 900000      R     MOV     DPTR,#dataBuffer
0003 EE                MOV     A,R6
0004 F0                MOVX    @DPTR,A
0005 A3                INC     DPTR
0006 EF                MOV     A,R7
0007 F0                MOVX    @DPTR,A
0008 900000      R     MOV     DPTR,#length
000B ED                MOV     A,R5
000C F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 327
                                           ; SOURCE LINE # 328
000D 900000      R     MOV     DPTR,#dataBuffer
0010 E0                MOVX    A,@DPTR
0011 FE                MOV     R6,A
0012 A3                INC     DPTR
0013 E0                MOVX    A,@DPTR
0014 FF                MOV     R7,A
0015 900000      R     MOV     DPTR,#sTxBuffer
0018 EE                MOV     A,R6
0019 F0                MOVX    @DPTR,A
001A A3                INC     DPTR
001B EF                MOV     A,R7
001C F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 329
001D 900000      R     MOV     DPTR,#length
0020 E0                MOVX    A,@DPTR
0021 FF                MOV     R7,A
0022 900000      R     MOV     DPTR,#sTxCount
0025 EF                MOV     A,R7
0026 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 330
0027         ?C0114:
0027 22                RET     
             ; FUNCTION _I2C0_sendResponse (END)

             ; FUNCTION I2C0_ISR (BEGIN)
0000 C0E0              PUSH    ACC
0002 C0F0              PUSH    B
0004 C083              PUSH    DPH
0006 C082              PUSH    DPL
0008 C0D0              PUSH    PSW
C51 COMPILER V9.56.0.0   I2C_0                                                             10/28/2016 17:37:02 PAGE 130 

000A 75D000            MOV     PSW,#00H
000D C000              PUSH    AR0
000F C001              PUSH    AR1
0011 C002              PUSH    AR2
0013 C003              PUSH    AR3
0015 C004              PUSH    AR4
0017 C005              PUSH    AR5
0019 C006              PUSH    AR6
001B C007              PUSH    AR7
                                           ; SOURCE LINE # 334
001D         ?C0117:
                                           ; SOURCE LINE # 337
001D 900000      R     MOV     DPTR,#savedPage
0020 E5BF              MOV     A,SFRPAGE
0022 F0                MOVX    @DPTR,A
0023 75BF00            MOV     SFRPAGE,#00H
0026         ?C0115:
0026         ?C0116:
                                           ; SOURCE LINE # 340
0026 E5C0              MOV     A,SMB0CN0
0028 54F0              ANL     A,#0F0H
002A FF                MOV     R7,A
002B EF                MOV     A,R7
002C 120000      E     LCALL   ?C?CCASE
002F 0000        R     DW      ?C0147
0031 00                DB      00H
0032 0000        R     DW      ?C0150
0034 10                DB      010H
0035 0000        R     DW      ?C0139
0037 20                DB      020H
0038 0000        R     DW      ?C0135
003A 40                DB      040H
003B 0000        R     DW      ?C0150
003D 50                DB      050H
003E 0000        R     DW      ?C0131
0040 80                DB      080H
0041 0000        R     DW      ?C0121
0043 C0                DB      0C0H
0044 0000        R     DW      ?C0119
0046 E0                DB      0E0H
0047 0000              DW      00H
0049 0000        R     DW      ?C0152
                                           ; SOURCE LINE # 341
                                           ; SOURCE LINE # 343
004B         ?C0119:
                                           ; SOURCE LINE # 345
004B 900000      R     MOV     DPTR,#mAddress
004E E0                MOVX    A,@DPTR
004F FF                MOV     R7,A
0050 8FC2              MOV     SMB0DAT,R7
                                           ; SOURCE LINE # 346
0052 900000      R     MOV     DPTR,#mTxCount
0055 E0                MOVX    A,@DPTR
0056 FF                MOV     R7,A
0057 EF                MOV     A,R7
0058 7003              JNZ     ?C0120
                                           ; SOURCE LINE # 347
                                           ; SOURCE LINE # 348
005A 43C201            ORL     SMB0DAT,#01H
                                           ; SOURCE LINE # 349
005D         ?C0120:
                                           ; SOURCE LINE # 350
C51 COMPILER V9.56.0.0   I2C_0                                                             10/28/2016 17:37:02 PAGE 131 

005D E5C2              MOV     A,SMB0DAT
005F 13                RRC     A
0060 9200        R     MOV     i2cReceive,C
                                           ; SOURCE LINE # 354
0062 C2C5              CLR     SMB0CN0_STA
                                           ; SOURCE LINE # 355
0064 D200        R     SETB    i2cBusy
                                           ; SOURCE LINE # 356
0066 020000      R     LJMP    ?C0118
                                           ; SOURCE LINE # 359
0069         ?C0121:
                                           ; SOURCE LINE # 360
0069 30C158            JNB     SMB0CN0_ACK,?C0122
                                           ; SOURCE LINE # 361
                                           ; SOURCE LINE # 362
006C 300012            JNB     i2cReceive,?C0123
                                           ; SOURCE LINE # 363
                                           ; SOURCE LINE # 365
006F 900000      R     MOV     DPTR,#mRxCount
0072 E0                MOVX    A,@DPTR
0073 14                DEC     A
0074 FF                MOV     R7,A
0075 F0                MOVX    @DPTR,A
0076 EF                MOV     A,R7
0077 6003              JZ      $ + 5H
0079 020000      R     LJMP    ?C0118
                                           ; SOURCE LINE # 366
                                           ; SOURCE LINE # 367
007C C2C1              CLR     SMB0CN0_ACK
                                           ; SOURCE LINE # 368
007E         ?C0124:
                                           ; SOURCE LINE # 370
007E 020000      R     LJMP    ?C0118
0081         ?C0123:
                                           ; SOURCE LINE # 372
                                           ; SOURCE LINE # 374
0081 900000      R     MOV     DPTR,#mTxCount
0084 E0                MOVX    A,@DPTR
0085 FF                MOV     R7,A
0086 EF                MOV     A,R7
0087 601E              JZ      ?C0126
                                           ; SOURCE LINE # 375
                                           ; SOURCE LINE # 377
0089 900000      R     MOV     DPTR,#mTxBuffer
008C E4                CLR     A
008D 75F001            MOV     B,#01H
0090 120000      E     LCALL   ?C?ILDIX
0093 AFF0              MOV     R7,B
0095 FE                MOV     R6,A
0096 8F82              MOV     DPL,R7
0098 8E83              MOV     DPH,R6
009A E0                MOVX    A,@DPTR
009B FF                MOV     R7,A
009C 8FC2              MOV     SMB0DAT,R7
                                           ; SOURCE LINE # 378
009E 900000      R     MOV     DPTR,#mTxCount
00A1 E0                MOVX    A,@DPTR
00A2 14                DEC     A
00A3 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 379
00A4 020000      R     LJMP    ?C0118
00A7         ?C0126:
C51 COMPILER V9.56.0.0   I2C_0                                                             10/28/2016 17:37:02 PAGE 132 

                                           ; SOURCE LINE # 381
                                           ; SOURCE LINE # 383
00A7 900000      R     MOV     DPTR,#mRxCount
00AA E0                MOVX    A,@DPTR
00AB FF                MOV     R7,A
00AC EF                MOV     A,R7
00AD 6005              JZ      ?C0128
                                           ; SOURCE LINE # 384
                                           ; SOURCE LINE # 386
00AF D2C5              SETB    SMB0CN0_STA
                                           ; SOURCE LINE # 387
00B1 020000      R     LJMP    ?C0118
00B4         ?C0128:
                                           ; SOURCE LINE # 389
                                           ; SOURCE LINE # 392
00B4 120000      E     LCALL   I2C0_transferCompleteCb
                                           ; SOURCE LINE # 393
00B7 D2C4              SETB    SMB0CN0_STO
                                           ; SOURCE LINE # 394
00B9 A200        R     MOV     C,i2cReq
00BB 92C5              MOV     SMB0CN0_STA,C
                                           ; SOURCE LINE # 395
00BD C200        R     CLR     i2cReq
                                           ; SOURCE LINE # 396
00BF C200        R     CLR     i2cBusy
                                           ; SOURCE LINE # 397
00C1         ?C0129:
                                           ; SOURCE LINE # 398
00C1         ?C0127:
                                           ; SOURCE LINE # 399
00C1         ?C0125:
                                           ; SOURCE LINE # 400
00C1 020000      R     LJMP    ?C0118
00C4         ?C0122:
                                           ; SOURCE LINE # 402
                                           ; SOURCE LINE # 404
00C4 7F01              MOV     R7,#01H
00C6 120000      E     LCALL   _I2C0_errorCb
                                           ; SOURCE LINE # 407
00C9 D2C4              SETB    SMB0CN0_STO
                                           ; SOURCE LINE # 408
00CB A200        R     MOV     C,i2cReq
00CD 92C5              MOV     SMB0CN0_STA,C
                                           ; SOURCE LINE # 409
00CF C200        R     CLR     i2cReq
                                           ; SOURCE LINE # 410
00D1 C200        R     CLR     i2cBusy
                                           ; SOURCE LINE # 411
00D3         ?C0130:
                                           ; SOURCE LINE # 412
00D3 020000      R     LJMP    ?C0118
                                           ; SOURCE LINE # 415
00D6         ?C0131:
                                           ; SOURCE LINE # 417
00D6 900000      R     MOV     DPTR,#mRxBuffer
00D9 E4                CLR     A
00DA 75F001            MOV     B,#01H
00DD 120000      E     LCALL   ?C?ILDIX
00E0 AFF0              MOV     R7,B
00E2 FE                MOV     R6,A
00E3 8F82              MOV     DPL,R7
00E5 8E83              MOV     DPH,R6
C51 COMPILER V9.56.0.0   I2C_0                                                             10/28/2016 17:37:02 PAGE 133 

00E7 E5C2              MOV     A,SMB0DAT
00E9 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 420
00EA 900000      R     MOV     DPTR,#mRxCount
00ED E0                MOVX    A,@DPTR
00EE FF                MOV     R7,A
00EF EF                MOV     A,R7
00F0 6012              JZ      ?C0132
                                           ; SOURCE LINE # 421
                                           ; SOURCE LINE # 423
00F2 900000      R     MOV     DPTR,#mRxCount
00F5 E0                MOVX    A,@DPTR
00F6 14                DEC     A
00F7 FF                MOV     R7,A
00F8 F0                MOVX    @DPTR,A
00F9 EF                MOV     A,R7
00FA 6003              JZ      $ + 5H
00FC 020000      R     LJMP    ?C0118
                                           ; SOURCE LINE # 424
                                           ; SOURCE LINE # 425
00FF C2C1              CLR     SMB0CN0_ACK
                                           ; SOURCE LINE # 426
0101         ?C0133:
                                           ; SOURCE LINE # 428
0101 020000      R     LJMP    ?C0118
0104         ?C0132:
                                           ; SOURCE LINE # 430
                                           ; SOURCE LINE # 431
0104 C2C1              CLR     SMB0CN0_ACK
                                           ; SOURCE LINE # 435
0106 120000      E     LCALL   I2C0_transferCompleteCb
                                           ; SOURCE LINE # 436
0109 D2C4              SETB    SMB0CN0_STO
                                           ; SOURCE LINE # 437
010B A200        R     MOV     C,i2cReq
010D 92C5              MOV     SMB0CN0_STA,C
                                           ; SOURCE LINE # 438
010F C200        R     CLR     i2cReq
                                           ; SOURCE LINE # 439
0111 C200        R     CLR     i2cBusy
                                           ; SOURCE LINE # 440
0113         ?C0134:
                                           ; SOURCE LINE # 441
0113 020000      R     LJMP    ?C0118
                                           ; SOURCE LINE # 444
0116         ?C0135:
                                           ; SOURCE LINE # 445
0116 20C103            JB      SMB0CN0_ACK,$ + 6H
0119 020000      R     LJMP    ?C0118
                                           ; SOURCE LINE # 446
                                           ; SOURCE LINE # 447
011C 900000      R     MOV     DPTR,#sTxCount
011F E0                MOVX    A,@DPTR
0120 14                DEC     A
0121 FF                MOV     R7,A
0122 F0                MOVX    @DPTR,A
0123 EF                MOV     A,R7
0124 6018              JZ      ?C0137
                                           ; SOURCE LINE # 448
                                           ; SOURCE LINE # 449
0126 900000      R     MOV     DPTR,#sTxBuffer
0129 E4                CLR     A
C51 COMPILER V9.56.0.0   I2C_0                                                             10/28/2016 17:37:02 PAGE 134 

012A 75F001            MOV     B,#01H
012D 120000      E     LCALL   ?C?ILDIX
0130 AFF0              MOV     R7,B
0132 FE                MOV     R6,A
0133 8F82              MOV     DPL,R7
0135 8E83              MOV     DPH,R6
0137 E0                MOVX    A,@DPTR
0138 FF                MOV     R7,A
0139 8FC2              MOV     SMB0DAT,R7
                                           ; SOURCE LINE # 450
013B 020000      R     LJMP    ?C0118
013E         ?C0137:
                                           ; SOURCE LINE # 452
                                           ; SOURCE LINE # 453
013E 7F03              MOV     R7,#03H
0140 120000      E     LCALL   _I2C0_errorCb
                                           ; SOURCE LINE # 454
0143         ?C0138:
                                           ; SOURCE LINE # 455
0143         ?C0136:
                                           ; SOURCE LINE # 456
0143 020000      R     LJMP    ?C0118
                                           ; SOURCE LINE # 459
0146         ?C0139:
                                           ; SOURCE LINE # 460
0146 30C213            JNB     SMB0CN0_ARBLOST,?C0140
                                           ; SOURCE LINE # 461
                                           ; SOURCE LINE # 462
0149 900000      R     MOV     DPTR,#mRetries
014C E0                MOVX    A,@DPTR
014D FF                MOV     R7,A
014E 14                DEC     A
014F F0                MOVX    @DPTR,A
0150 EF                MOV     A,R7
0151 6004              JZ      ?C0141
                                           ; SOURCE LINE # 463
                                           ; SOURCE LINE # 464
0153 D200        R     SETB    i2cReq
                                           ; SOURCE LINE # 465
0155 8005              SJMP    ?C0140
0157         ?C0141:
                                           ; SOURCE LINE # 467
                                           ; SOURCE LINE # 468
0157 7F00              MOV     R7,#00H
0159 120000      E     LCALL   _I2C0_errorCb
                                           ; SOURCE LINE # 469
015C         ?C0142:
                                           ; SOURCE LINE # 470
015C         ?C0140:
                                           ; SOURCE LINE # 472
015C E5C2              MOV     A,SMB0DAT
015E 13                RRC     A
015F B3                CPL     C
0160 9200        R     MOV     i2cReceive,C
                                           ; SOURCE LINE # 478
0162 A200        R     MOV     C,i2cReceive
0164 A000        R     ORL     C,/i2cBusy
0166 5005              JNC     ?C0143
                                           ; SOURCE LINE # 479
                                           ; SOURCE LINE # 480
0168 900000      R     MOV     DPTR,#sRxCount
016B E4                CLR     A
C51 COMPILER V9.56.0.0   I2C_0                                                             10/28/2016 17:37:02 PAGE 135 

016C F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 481
016D         ?C0143:
                                           ; SOURCE LINE # 485
016D 200023            JB      i2cReceive,?C0144
                                           ; SOURCE LINE # 486
0170 900000      R     MOV     DPTR,#sRxCount
0173 E0                MOVX    A,@DPTR
0174 FF                MOV     R7,A
0175 EF                MOV     A,R7
0176 7003              JNZ     ?C0146
0178 200003            JB      i2cBusy,?C0145
017B         ?C0146:
                                           ; SOURCE LINE # 489
017B 120000      E     LCALL   I2C0_commandReceivedCb
                                           ; SOURCE LINE # 490
017E         ?C0145:
                                           ; SOURCE LINE # 492
017E 900000      R     MOV     DPTR,#sTxBuffer
0181 E4                CLR     A
0182 75F001            MOV     B,#01H
0185 120000      E     LCALL   ?C?ILDIX
0188 AFF0              MOV     R7,B
018A FE                MOV     R6,A
018B 8F82              MOV     DPL,R7
018D 8E83              MOV     DPH,R6
018F E0                MOVX    A,@DPTR
0190 FF                MOV     R7,A
0191 8FC2              MOV     SMB0DAT,R7
                                           ; SOURCE LINE # 494
0193         ?C0144:
                                           ; SOURCE LINE # 497
0193 C2C5              CLR     SMB0CN0_STA
                                           ; SOURCE LINE # 498
0195 D200        R     SETB    i2cBusy
                                           ; SOURCE LINE # 499
0197 8057              SJMP    ?C0118
                                           ; SOURCE LINE # 502
0199         ?C0147:
                                           ; SOURCE LINE # 504
0199 900000      R     MOV     DPTR,#sRxCount
019C E0                MOVX    A,@DPTR
019D FF                MOV     R7,A
019E 04                INC     A
019F F0                MOVX    @DPTR,A
01A0 900000      R     MOV     DPTR,#sRxBuffer
01A3 E0                MOVX    A,@DPTR
01A4 FC                MOV     R4,A
01A5 A3                INC     DPTR
01A6 E0                MOVX    A,@DPTR
01A7 FD                MOV     R5,A
01A8 8D82              MOV     DPL,R5
01AA 8C83              MOV     DPH,R4
01AC E582              MOV     A,DPL
01AE 2F                ADD     A,R7
01AF F582              MOV     DPL,A
01B1 E4                CLR     A
01B2 3583              ADDC    A,DPH
01B4 F583              MOV     DPH,A
01B6 E5C2              MOV     A,SMB0DAT
01B8 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 507
C51 COMPILER V9.56.0.0   I2C_0                                                             10/28/2016 17:37:02 PAGE 136 

01B9 900000      R     MOV     DPTR,#sRxSize
01BC E0                MOVX    A,@DPTR
01BD FF                MOV     R7,A
01BE 900000      R     MOV     DPTR,#sRxCount
01C1 E0                MOVX    A,@DPTR
01C2 FE                MOV     R6,A
01C3 EE                MOV     A,R6
01C4 6F                XRL     A,R7
01C5 7029              JNZ     ?C0118
                                           ; SOURCE LINE # 508
                                           ; SOURCE LINE # 509
01C7 120000      E     LCALL   I2C0_commandReceivedCb
                                           ; SOURCE LINE # 510
01CA 900000      R     MOV     DPTR,#sRxCount
01CD E4                CLR     A
01CE F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 511
01CF         ?C0148:
                                           ; SOURCE LINE # 514
01CF 801F              SJMP    ?C0118
                                           ; SOURCE LINE # 517
01D1         ?C0149:
                                           ; SOURCE LINE # 518
01D1         ?C0150:
                                           ; SOURCE LINE # 519
01D1 30000B            JNB     i2cReceive,?C0151
01D4 900000      R     MOV     DPTR,#sRxCount
01D7 E0                MOVX    A,@DPTR
01D8 FF                MOV     R7,A
01D9 EF                MOV     A,R7
01DA 6003              JZ      ?C0151
                                           ; SOURCE LINE # 520
                                           ; SOURCE LINE # 521
01DC 120000      E     LCALL   I2C0_commandReceivedCb
                                           ; SOURCE LINE # 522
01DF         ?C0151:
                                           ; SOURCE LINE # 525
01DF C2C4              CLR     SMB0CN0_STO
                                           ; SOURCE LINE # 529
01E1 A200        R     MOV     C,i2cReq
01E3 92C5              MOV     SMB0CN0_STA,C
                                           ; SOURCE LINE # 530
01E5 C200        R     CLR     i2cReq
                                           ; SOURCE LINE # 531
01E7 C200        R     CLR     i2cBusy
                                           ; SOURCE LINE # 532
01E9 8005              SJMP    ?C0118
                                           ; SOURCE LINE # 534
01EB         ?C0152:
                                           ; SOURCE LINE # 536
01EB 7F02              MOV     R7,#02H
01ED 120000      E     LCALL   _I2C0_errorCb
                                           ; SOURCE LINE # 538
01F0         ?C0118:
                                           ; SOURCE LINE # 541
01F0 C2C0              CLR     SMB0CN0_SI
01F2         ?C0155:
                                           ; SOURCE LINE # 542
01F2 900000      R     MOV     DPTR,#savedPage
01F5 E0                MOVX    A,@DPTR
01F6 FF                MOV     R7,A
01F7 8FBF              MOV     SFRPAGE,R7
C51 COMPILER V9.56.0.0   I2C_0                                                             10/28/2016 17:37:02 PAGE 137 

01F9         ?C0153:
01F9         ?C0154:
                                           ; SOURCE LINE # 543
01F9         ?C0156:
01F9 D007              POP     AR7
01FB D006              POP     AR6
01FD D005              POP     AR5
01FF D004              POP     AR4
0201 D003              POP     AR3
0203 D002              POP     AR2
0205 D001              POP     AR1
0207 D000              POP     AR0
0209 D0D0              POP     PSW
020B D082              POP     DPL
020D D083              POP     DPH
020F D0F0              POP     B
0211 D0E0              POP     ACC
0213 32                RETI    
             ; FUNCTION I2C0_ISR (END)

C51 COMPILER V9.56.0.0   I2C_0                                                             10/28/2016 17:37:02 PAGE 138 

NAME                                    CLASS   MSPACE  TYPE    OFFSET  SIZE
====                                    =====   ======  ====    ======  ====


SPI0CKR. . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00A2H  1
uint16_t . . . . . . . . . . . . . . .  TYPEDEF  -----  U_INT    -----  2
I2C0_ack . . . . . . . . . . . . . . .  PUBLIC   CODE   PROC     0000H  -----
  ack. . . . . . . . . . . . . . . . .  AUTO     DATA   BIT      0000H  1
  savedPage. . . . . . . . . . . . . .  AUTO     XDATA  U_CHAR   0000H  1
I2C0_SLAVE_RX_STOP . . . . . . . . . .  E_CONST  -----  U_CHAR   -----  1
P0 . . . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   0080H  1
I2C0_start . . . . . . . . . . . . . .  PUBLIC   CODE   PROC     0000H  -----
  savedPage. . . . . . . . . . . . . .  AUTO     XDATA  U_CHAR   0000H  1
PSW_OV . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00D2H  1
XOSC0CN. . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00B1H  1
P1 . . . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   0090H  1
I2C0_SLAVE_TX_STOP . . . . . . . . . .  E_CONST  -----  U_CHAR   -----  1
P2 . . . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00A0H  1
uint64_t . . . . . . . . . . . . . . .  TYPEDEF  -----  ARRAY    -----  8
I2C0_TIMER0. . . . . . . . . . . . . .  E_CONST  -----  U_CHAR   -----  1
P3 . . . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00B0H  1
ADC0CF . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00BCH  1
I2C0_TIMER1. . . . . . . . . . . . . .  E_CONST  -----  U_CHAR   -----  1
I2C0_clearIntFlag. . . . . . . . . . .  PUBLIC   CODE   PROC     0000H  -----
  savedPage. . . . . . . . . . . . . .  AUTO     XDATA  U_CHAR   0000H  1
TMR2CN0_T2XCLK . . . . . . . . . . . .  ABSBIT   -----  BIT      00C8H  1
P4 . . . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00C7H  1
SI_GEN_PTR_t . . . . . . . . . . . . .  TYPEDEF  -----  UNION    -----  3
  u8 . . . . . . . . . . . . . . . . .  MEMBER   -----  ARRAY    0000H  3
  gptr . . . . . . . . . . . . . . . .  MEMBER   -----  STRUCT   0000H  3
_I2C0_initSlave. . . . . . . . . . . .  PUBLIC   CODE   PROC     0000H  -----
  address. . . . . . . . . . . . . . .  AUTO     XDATA  U_CHAR   0000H  1
  commandBuffer. . . . . . . . . . . .  AUTO     XDATA  PTR      0001H  2
  length . . . . . . . . . . . . . . .  AUTO     XDATA  U_CHAR   0003H  1
  savedPage. . . . . . . . . . . . . .  AUTO     XDATA  U_CHAR   0004H  1
SMB0CN0_MASTER . . . . . . . . . . . .  ABSBIT   -----  BIT      00C7H  1
PCA0 . . . . . . . . . . . . . . . . .  SFR      DATA   U_INT    00F9H  2
EIE1 . . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00E6H  1
_I2C0_init . . . . . . . . . . . . . .  PUBLIC   CODE   PROC     0000H  -----
  timebase . . . . . . . . . . . . . .  AUTO     XDATA  U_CHAR   0000H  1
  sclLow . . . . . . . . . . . . . . .  AUTO     DATA   BIT      0000H  1
  savedPage. . . . . . . . . . . . . .  AUTO     XDATA  U_CHAR   0001H  1
SMB1CN0_MASTER . . . . . . . . . . . .  ABSBIT   -----  BIT      00C7H  1
SMB0CN0_ACK. . . . . . . . . . . . . .  ABSBIT   -----  BIT      00C1H  1
USB0XCN. . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00D7H  1
EIE2 . . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00E7H  1
I2C0_commandReceivedCb . . . . . . . .  EXTERN   CODE   PROC     -----  -----
I2C0_TIMER2_HIGH . . . . . . . . . . .  E_CONST  -----  U_CHAR   -----  1
SMB1CN0_ACK. . . . . . . . . . . . . .  ABSBIT   -----  BIT      00C1H  1
int32_t. . . . . . . . . . . . . . . .  TYPEDEF  -----  LONG     -----  4
PSCTL. . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   008FH  1
IT01CF . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00E4H  1
int16_t. . . . . . . . . . . . . . . .  TYPEDEF  -----  INT      -----  2
TMR5CN0_T5XCLK . . . . . . . . . . . .  ABSBIT   -----  BIT      00C8H  1
SMB0CN0_TXMODE . . . . . . . . . . . .  ABSBIT   -----  BIT      00C6H  1
_?I2C0_getStatusFlags. . . . . . . . .  PUBLIC   CODE   PROC     0000H  -----
  val. . . . . . . . . . . . . . . . .  AUTO     XDATA  U_CHAR   0000H  1
  savedPage. . . . . . . . . . . . . .  AUTO     XDATA  U_CHAR   0001H  1
SMB1CN0_TXMODE . . . . . . . . . . . .  ABSBIT   -----  BIT      00C6H  1
SFRPAGE. . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00BFH  1
P0MDOUT. . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00A4H  1
C51 COMPILER V9.56.0.0   I2C_0                                                             10/28/2016 17:37:02 PAGE 139 

NAME                                    CLASS   MSPACE  TYPE    OFFSET  SIZE
====                                    =====   ======  ====    ======  ====


int64_t. . . . . . . . . . . . . . . .  TYPEDEF  -----  ARRAY    -----  8
P1MDOUT. . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00A5H  1
SI_UU32. . . . . . . . . . . . . . . .  * TAG *  -----  UNION    -----  4
  u32. . . . . . . . . . . . . . . . .  MEMBER   -----  U_LONG   0000H  4
  s32. . . . . . . . . . . . . . . . .  MEMBER   -----  LONG     0000H  4
  uu16 . . . . . . . . . . . . . . . .  MEMBER   -----  ARRAY    0000H  4
  u16. . . . . . . . . . . . . . . . .  MEMBER   -----  ARRAY    0000H  4
  s16. . . . . . . . . . . . . . . . .  MEMBER   -----  ARRAY    0000H  4
  u8 . . . . . . . . . . . . . . . . .  MEMBER   -----  ARRAY    0000H  4
  s8 . . . . . . . . . . . . . . . . .  MEMBER   -----  ARRAY    0000H  4
ADC0CN0_ADINT. . . . . . . . . . . . .  ABSBIT   -----  BIT      00EDH  1
TMR2RLH. . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00CBH  1
P2MDOUT. . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00A6H  1
IE . . . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00A8H  1
false. . . . . . . . . . . . . . . . .  E_CONST  -----  U_CHAR   -----  1
I2C0_MASTER_START. . . . . . . . . . .  E_CONST  -----  U_CHAR   -----  1
TMR3RLH. . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   0093H  1
P3MDOUT. . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00A7H  1
SI_UU16. . . . . . . . . . . . . . . .  * TAG *  -----  UNION    -----  2
  u16. . . . . . . . . . . . . . . . .  MEMBER   -----  U_INT    0000H  2
  s16. . . . . . . . . . . . . . . . .  MEMBER   -----  INT      0000H  2
  u8 . . . . . . . . . . . . . . . . .  MEMBER   -----  ARRAY    0000H  2
  s8 . . . . . . . . . . . . . . . . .  MEMBER   -----  ARRAY    0000H  2
TMR4RLH. . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   0093H  1
P4MDOUT. . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00AEH  1
EIP1 . . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00F6H  1
TMR5RLH. . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00CBH  1
EIP2 . . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00F7H  1
size_t . . . . . . . . . . . . . . . .  TYPEDEF  -----  U_INT    -----  2
SCON0_RB8. . . . . . . . . . . . . . .  ABSBIT   -----  BIT      009AH  1
TMR2RLL. . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00CAH  1
PCA0CPH0 . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00FCH  1
TMR3RLL. . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   0092H  1
PCA0CPH1 . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00EAH  1
GPTR_t . . . . . . . . . . . . . . . .  TYPEDEF  -----  STRUCT   -----  3
  memtype. . . . . . . . . . . . . . .  MEMBER   -----  U_CHAR   0000H  1
  address. . . . . . . . . . . . . . .  MEMBER   -----  UNION    0001H  2
SCON0_TB8. . . . . . . . . . . . . . .  ABSBIT   -----  BIT      009BH  1
B_B0 . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00F0H  1
DP . . . . . . . . . . . . . . . . . .  SFR      DATA   U_INT    0082H  2
TMR4RLL. . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   0092H  1
PCA0CPH2 . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00ECH  1
B_B1 . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00F1H  1
ADC0GT . . . . . . . . . . . . . . . .  SFR      DATA   U_INT    00C3H  2
TMR5RLL. . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00CAH  1
PCA0CPH3 . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00EEH  1
B_B2 . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00F2H  1
PCA0CPL0 . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00FBH  1
PCA0CPH4 . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00FEH  1
EMI0CF . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   0085H  1
mRxBuffer. . . . . . . . . . . . . . .  PUBLIC   XDATA  PTR      0000H  2
B_B3 . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00F3H  1
PCA0MD . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00D9H  1
PCA0CPM0 . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00DAH  1
PCA0CPL1 . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00E9H  1
I2C0_stop. . . . . . . . . . . . . . .  PUBLIC   CODE   PROC     0000H  -----
  savedPage. . . . . . . . . . . . . .  AUTO     XDATA  U_CHAR   0000H  1
C51 COMPILER V9.56.0.0   I2C_0                                                             10/28/2016 17:37:02 PAGE 140 

NAME                                    CLASS   MSPACE  TYPE    OFFSET  SIZE
====                                    =====   ======  ====    ======  ====


B_B4 . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00F4H  1
PCA0CPM1 . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00DBH  1
PCA0CPL2 . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00EBH  1
mTxBuffer. . . . . . . . . . . . . . .  PUBLIC   XDATA  PTR      0002H  2
B_B5 . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00F5H  1
PCA0CPM2 . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00DCH  1
PCA0CPL3 . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00EDH  1
IP . . . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00B8H  1
B_B6 . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00F6H  1
ADC0LT . . . . . . . . . . . . . . . .  SFR      DATA   U_INT    00C5H  2
PCA0CPM3 . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00DDH  1
PCA0CPL4 . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00FDH  1
SCON0_MCE. . . . . . . . . . . . . . .  ABSBIT   -----  BIT      009DH  1
B_B7 . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00F7H  1
PCA0CPM4 . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00DEH  1
sRxBuffer. . . . . . . . . . . . . . .  PUBLIC   XDATA  PTR      0004H  2
XBR0 . . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00E1H  1
SMB0CF . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00C1H  1
XBR1 . . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00E2H  1
SMB1CF . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00C1H  1
PFE0CN . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00AFH  1
EMI0CN . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00AAH  1
sTxBuffer. . . . . . . . . . . . . . .  PUBLIC   XDATA  PTR      0006H  2
SMB0CN0_STA. . . . . . . . . . . . . .  ABSBIT   -----  BIT      00C5H  1
XBR2 . . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00E3H  1
I2C0_transferCompleteCb. . . . . . . .  EXTERN   CODE   PROC     -----  -----
SMB1CN0_STA. . . . . . . . . . . . . .  ABSBIT   -----  BIT      00C5H  1
ACC_ACC0 . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00E0H  1
REF0CN . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00D1H  1
HFO0CN . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00B2H  1
CKCON0 . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   008EH  1
ACC_ACC1 . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00E1H  1
CKCON1 . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00E4H  1
TMR2CN0_TR2. . . . . . . . . . . . . .  ABSBIT   -----  BIT      00CAH  1
ACC_ACC2 . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00E2H  1
_I2C0_errorCb. . . . . . . . . . . . .  EXTERN   CODE   PROC     -----  -----
_?I2C0_setStatusFlag . . . . . . . . .  PUBLIC   CODE   PROC     0000H  -----
  flag . . . . . . . . . . . . . . . .  AUTO     XDATA  U_CHAR   0001H  1
  state. . . . . . . . . . . . . . . .  AUTO     XDATA  U_CHAR   0002H  1
  savedPage. . . . . . . . . . . . . .  AUTO     XDATA  U_CHAR   0000H  1
ACC_ACC3 . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00E3H  1
SP . . . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   0081H  1
CMP0MD . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   009DH  1
ACC_ACC4 . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00E4H  1
LFO0CN . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   0086H  1
EMI0TC . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   0084H  1
CMP1MD . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   009CH  1
i2cBusy. . . . . . . . . . . . . . . .  PUBLIC   DATA   BIT      0000H  1
PCA0CN0_CCF0 . . . . . . . . . . . . .  ABSBIT   -----  BIT      00D8H  1
ACC_ACC5 . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00E5H  1
PCA0CN0_CCF1 . . . . . . . . . . . . .  ABSBIT   -----  BIT      00D9H  1
ACC_ACC6 . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00E6H  1
TMR2 . . . . . . . . . . . . . . . . .  SFR      DATA   U_INT    00CCH  2
PCA0CN0_CCF2 . . . . . . . . . . . . .  ABSBIT   -----  BIT      00DAH  1
ACC_ACC7 . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00E7H  1
TMR3 . . . . . . . . . . . . . . . . .  SFR      DATA   U_INT    0094H  2
I2C0_State_t . . . . . . . . . . . . .  TYPEDEF  -----  U_CHAR   -----  1
C51 COMPILER V9.56.0.0   I2C_0                                                             10/28/2016 17:37:02 PAGE 141 

NAME                                    CLASS   MSPACE  TYPE    OFFSET  SIZE
====                                    =====   ======  ====    ======  ====


TMR5CN0_TR5. . . . . . . . . . . . . .  ABSBIT   -----  BIT      00CAH  1
PCA0CN0_CCF3 . . . . . . . . . . . . .  ABSBIT   -----  BIT      00DBH  1
TMR4 . . . . . . . . . . . . . . . . .  SFR      DATA   U_INT    0094H  2
SBCON1 . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00ACH  1
i2cReq . . . . . . . . . . . . . . . .  PUBLIC   DATA   BIT      0001H  1
PCA0CN0_CCF4 . . . . . . . . . . . . .  ABSBIT   -----  BIT      00DCH  1
TMR5 . . . . . . . . . . . . . . . . .  SFR      DATA   U_INT    00CCH  2
SMB0CN0_ACKRQ. . . . . . . . . . . . .  ABSBIT   -----  BIT      00C3H  1
VDM0CN . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00FFH  1
P0MDIN . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00F1H  1
SMB1CN0_ACKRQ. . . . . . . . . . . . .  ABSBIT   -----  BIT      00C3H  1
SCON0_REN. . . . . . . . . . . . . . .  ABSBIT   -----  BIT      009CH  1
P1MDIN . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00F2H  1
P2MDIN . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00F3H  1
SMB0CN0_STO. . . . . . . . . . . . . .  ABSBIT   -----  BIT      00C4H  1
P3MDIN . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00F4H  1
SMB1CN0_STO. . . . . . . . . . . . . .  ABSBIT   -----  BIT      00C4H  1
SBRLH1 . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00B5H  1
P4MDIN . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00F5H  1
bool . . . . . . . . . . . . . . . . .  TYPEDEF  DATA   BIT      -----  1
SI_GEN_PTR . . . . . . . . . . . . . .  * TAG *  -----  UNION    -----  3
  u8 . . . . . . . . . . . . . . . . .  MEMBER   -----  ARRAY    0000H  3
  gptr . . . . . . . . . . . . . . . .  MEMBER   -----  STRUCT   0000H  3
PSW_RS0. . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00D3H  1
PCA0CN0_CF . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00DFH  1
SPI0CN0_RXOVRN . . . . . . . . . . . .  ABSBIT   -----  BIT      00FCH  1
PSW_RS1. . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00D4H  1
SBRLL1 . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00B4H  1
ADC0CN0_ADEN . . . . . . . . . . . . .  ABSBIT   -----  BIT      00EFH  1
TMOD . . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   0089H  1
TCON . . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   0088H  1
I2C0_abortTransfer . . . . . . . . . .  PUBLIC   CODE   PROC     0000H  -----
I2C0_SLAVE_ADDRESS . . . . . . . . . .  E_CONST  -----  U_CHAR   -----  1
PSW_PARITY . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00D0H  1
IE_ES0 . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00ACH  1
CMP0MX . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   009FH  1
mAddress . . . . . . . . . . . . . . .  PUBLIC   XDATA  U_CHAR   0008H  1
IE_ET0 . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00A9H  1
CMP1MX . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   009EH  1
IE_ET1 . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00ABH  1
P0SKIP . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00D4H  1
_I2C0_transfer . . . . . . . . . . . .  PUBLIC   CODE   PROC     0000H  -----
  address. . . . . . . . . . . . . . .  AUTO     XDATA  U_CHAR   0000H  1
  txBuffer . . . . . . . . . . . . . .  AUTO     XDATA  PTR      0001H  2
  rxBuffer . . . . . . . . . . . . . .  AUTO     XDATA  PTR      0003H  2
  tx_len . . . . . . . . . . . . . . .  AUTO     XDATA  U_CHAR   0005H  1
  rx_len . . . . . . . . . . . . . . .  AUTO     XDATA  U_CHAR   0006H  1
  savedPage. . . . . . . . . . . . . .  AUTO     XDATA  U_CHAR   0007H  1
TMR2CN0_T2CSS. . . . . . . . . . . . .  ABSBIT   -----  BIT      00C9H  1
IE_ET2 . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00ADH  1
P1SKIP . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00D5H  1
I2C0_getIntFlag. . . . . . . . . . . .  PUBLIC   CODE   PROC     0000H  -----
  val. . . . . . . . . . . . . . . . .  AUTO     DATA   BIT      0000H  1
  savedPage. . . . . . . . . . . . . .  AUTO     XDATA  U_CHAR   0000H  1
P2SKIP . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00D6H  1
ADC0CN0. . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00E8H  1
I2C0_getCommandLength. . . . . . . . .  PUBLIC   CODE   PROC     0000H  -----
C51 COMPILER V9.56.0.0   I2C_0                                                             10/28/2016 17:37:02 PAGE 142 

NAME                                    CLASS   MSPACE  TYPE    OFFSET  SIZE
====                                    =====   ======  ====    ======  ====


IE_EX0 . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00A8H  1
P3SKIP . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00DFH  1
PCA0CN0_CR . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00DEH  1
IE_EX1 . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00AAH  1
I2C0_ISR . . . . . . . . . . . . . . .  PUBLIC   CODE   PROC     0000H  -----
  savedPage. . . . . . . . . . . . . .  AUTO     XDATA  U_CHAR   0000H  1
SCON0_SMODE. . . . . . . . . . . . . .  ABSBIT   -----  BIT      009FH  1
CLKSEL . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00A9H  1
SPI0CN0_SPIEN. . . . . . . . . . . . .  ABSBIT   -----  BIT      00F8H  1
B. . . . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00F0H  1
ADC0H. . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00BEH  1
true . . . . . . . . . . . . . . . . .  E_CONST  -----  U_CHAR   -----  1
ADC0CN0_ADTM . . . . . . . . . . . . .  ABSBIT   -----  BIT      00EEH  1
mRxCount . . . . . . . . . . . . . . .  PUBLIC   XDATA  U_CHAR   0009H  1
I2C0_MASTER_RXDATA . . . . . . . . . .  E_CONST  -----  U_CHAR   -----  1
TMR2RL . . . . . . . . . . . . . . . .  SFR      DATA   U_INT    00CAH  2
ADC0L. . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00BDH  1
TMR3RL . . . . . . . . . . . . . . . .  SFR      DATA   U_INT    0092H  2
i2cReceive . . . . . . . . . . . . . .  PUBLIC   DATA   BIT      0002H  1
mTxCount . . . . . . . . . . . . . . .  PUBLIC   XDATA  U_CHAR   000AH  1
I2C0_MASTER_TXDATA . . . . . . . . . .  E_CONST  -----  U_CHAR   -----  1
TMR4RL . . . . . . . . . . . . . . . .  SFR      DATA   U_INT    0092H  2
PCA0CN0. . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00D8H  1
ACC. . . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00E0H  1
TMR5RL . . . . . . . . . . . . . . . .  SFR      DATA   U_INT    00CAH  2
PCA0CP0. . . . . . . . . . . . . . . .  SFR      DATA   U_INT    00FBH  2
PCA0CP1. . . . . . . . . . . . . . . .  SFR      DATA   U_INT    00E9H  2
sRxCount . . . . . . . . . . . . . . .  PUBLIC   XDATA  U_CHAR   000BH  1
PCA0CP2. . . . . . . . . . . . . . . .  SFR      DATA   U_INT    00EBH  2
PCA0CP3. . . . . . . . . . . . . . . .  SFR      DATA   U_INT    00EDH  2
TH0. . . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   008CH  1
sTxCount . . . . . . . . . . . . . . .  PUBLIC   XDATA  U_CHAR   000CH  1
IP_PS0 . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00BCH  1
PCA0CP4. . . . . . . . . . . . . . . .  SFR      DATA   U_INT    00FDH  2
TH1. . . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   008DH  1
PCA0H. . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00FAH  1
IP_PT0 . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00B9H  1
IP_PT1 . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00BBH  1
uint8_t. . . . . . . . . . . . . . . .  TYPEDEF  -----  U_CHAR   -----  1
mRetries . . . . . . . . . . . . . . .  PUBLIC   XDATA  U_CHAR   000DH  1
_I2C0_initSlaveAddress . . . . . . . .  PUBLIC   CODE   PROC     0000H  -----
  address. . . . . . . . . . . . . . .  AUTO     XDATA  U_CHAR   0000H  1
  mask . . . . . . . . . . . . . . . .  AUTO     XDATA  U_CHAR   0001H  1
  savedPage. . . . . . . . . . . . . .  AUTO     XDATA  U_CHAR   0002H  1
SMB0CN0_ARBLOST. . . . . . . . . . . .  ABSBIT   -----  BIT      00C2H  1
IP_PT2 . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00BDH  1
TL0. . . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   008AH  1
_I2C0_sendResponse . . . . . . . . . .  PUBLIC   CODE   PROC     0000H  -----
  dataBuffer . . . . . . . . . . . . .  AUTO     XDATA  PTR      0000H  2
  length . . . . . . . . . . . . . . .  AUTO     XDATA  U_CHAR   0002H  1
SPI0CN0_TXBMT. . . . . . . . . . . . .  ABSBIT   -----  BIT      00F9H  1
SMB1CN0_ARBLOST. . . . . . . . . . . .  ABSBIT   -----  BIT      00C2H  1
PSW_F0 . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00D5H  1
IE_ESPI0 . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00AEH  1
TL1. . . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   008BH  1
PCA0L. . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00F9H  1
SMB0CN0_SI . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00C0H  1
C51 COMPILER V9.56.0.0   I2C_0                                                             10/28/2016 17:37:02 PAGE 143 

NAME                                    CLASS   MSPACE  TYPE    OFFSET  SIZE
====                                    =====   ======  ====    ======  ====


PSW_F1 . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00D1H  1
P0_B0. . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      0080H  1
IP_PX0 . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00B8H  1
REG01CN. . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00C9H  1
I2C0_Timebase_t. . . . . . . . . . . .  TYPEDEF  -----  U_CHAR   -----  1
SMB1CN0_SI . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00C0H  1
P1_B0. . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      0090H  1
P0_B1. . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      0081H  1
IP_PX1 . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00BAH  1
CMP0CN0. . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   009BH  1
TCON_IE0 . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      0089H  1
P2_B0. . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00A0H  1
P1_B1. . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      0091H  1
P0_B2. . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      0082H  1
CMP1CN0. . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   009AH  1
TCON_IE1 . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      008BH  1
P3_B0. . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00B0H  1
P2_B1. . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00A1H  1
P1_B2. . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      0092H  1
P0_B3. . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      0083H  1
SMB0CN0. . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00C0H  1
I2C0_ARBLOST_ERROR . . . . . . . . . .  E_CONST  -----  U_CHAR   -----  1
P3_B1. . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00B1H  1
P2_B2. . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00A2H  1
P1_B3. . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      0093H  1
P0_B4. . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      0084H  1
SMB1CN0. . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00C0H  1
P3_B2. . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00B2H  1
P2_B3. . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00A3H  1
P1_B4. . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      0094H  1
P0_B5. . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      0085H  1
I2C0_TIMER2_LOW. . . . . . . . . . . .  E_CONST  -----  U_CHAR   -----  1
P3_B3. . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00B3H  1
P2_B4. . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00A4H  1
P1_B5. . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      0095H  1
P0_B6. . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      0086H  1
P3_B4. . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00B4H  1
P2_B5. . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00A5H  1
P1_B6. . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      0096H  1
P0_B7. . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      0087H  1
int8_t . . . . . . . . . . . . . . . .  TYPEDEF  -----  CHAR     -----  1
I2C0_NACK_ERROR. . . . . . . . . . . .  E_CONST  -----  U_CHAR   -----  1
P3_B5. . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00B5H  1
P2_B6. . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00A6H  1
P1_B7. . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      0097H  1
P3_B6. . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00B6H  1
P2_B7. . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00A7H  1
sRxSize. . . . . . . . . . . . . . . .  PUBLIC   XDATA  U_CHAR   000EH  1
P3_B7. . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00B7H  1
DPH. . . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   0083H  1
ADC0GTH. . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00C4H  1
TMR2CN0_TF2H . . . . . . . . . . . . .  ABSBIT   -----  BIT      00CFH  1
TMR2CN0_T2SPLIT. . . . . . . . . . . .  ABSBIT   -----  BIT      00CBH  1
PSW_AC . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00D6H  1
SPI0CN0. . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00F8H  1
HFO0CAL. . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00B3H  1
TCON_TF0 . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      008DH  1
C51 COMPILER V9.56.0.0   I2C_0                                                             10/28/2016 17:37:02 PAGE 144 

NAME                                    CLASS   MSPACE  TYPE    OFFSET  SIZE
====                                    =====   ======  ====    ======  ====


SCON0_RI . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      0098H  1
DPL. . . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   0082H  1
TCON_TF1 . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      008FH  1
SBUF0. . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   0099H  1
PCON0. . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   0087H  1
ADC0GTL. . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00C3H  1
SI_UU32_t. . . . . . . . . . . . . . .  TYPEDEF  -----  UNION    -----  4
  u32. . . . . . . . . . . . . . . . .  MEMBER   -----  U_LONG   0000H  4
  s32. . . . . . . . . . . . . . . . .  MEMBER   -----  LONG     0000H  4
  uu16 . . . . . . . . . . . . . . . .  MEMBER   -----  ARRAY    0000H  4
  u16. . . . . . . . . . . . . . . . .  MEMBER   -----  ARRAY    0000H  4
  s16. . . . . . . . . . . . . . . . .  MEMBER   -----  ARRAY    0000H  4
  u8 . . . . . . . . . . . . . . . . .  MEMBER   -----  ARRAY    0000H  4
  s8 . . . . . . . . . . . . . . . . .  MEMBER   -----  ARRAY    0000H  4
TMR2CN0_TF2L . . . . . . . . . . . . .  ABSBIT   -----  BIT      00CEH  1
SCON0_TI . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      0099H  1
ADC0CN0_ADCM0. . . . . . . . . . . . .  ABSBIT   -----  BIT      00E8H  1
SBUF1. . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00D3H  1
ADC0LTH. . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00C6H  1
TCON_IT0 . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      0088H  1
ADC0CN0_ADCM1. . . . . . . . . . . . .  ABSBIT   -----  BIT      00E9H  1
RSTSRC . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00EFH  1
SI_UU16_t. . . . . . . . . . . . . . .  TYPEDEF  -----  UNION    -----  2
  u16. . . . . . . . . . . . . . . . .  MEMBER   -----  U_INT    0000H  2
  s16. . . . . . . . . . . . . . . . .  MEMBER   -----  INT      0000H  2
  u8 . . . . . . . . . . . . . . . . .  MEMBER   -----  ARRAY    0000H  2
  s8 . . . . . . . . . . . . . . . . .  MEMBER   -----  ARRAY    0000H  2
TMR5CN0_TF5H . . . . . . . . . . . . .  ABSBIT   -----  BIT      00CFH  1
TMR5CN0_T5SPLIT. . . . . . . . . . . .  ABSBIT   -----  BIT      00CBH  1
TCON_IT1 . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      008AH  1
ADC0CN0_ADCM2. . . . . . . . . . . . .  ABSBIT   -----  BIT      00EAH  1
SCON0. . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   0098H  1
ADC0CN0_ADWINT . . . . . . . . . . . .  ABSBIT   -----  BIT      00EBH  1
SBRL1. . . . . . . . . . . . . . . . .  SFR      DATA   U_INT    00B4H  2
SMOD1. . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00E5H  1
SCON1. . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00D2H  1
AMX0N. . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00BAH  1
I2C0_rxBytesRemaining. . . . . . . . .  PUBLIC   CODE   PROC     0000H  -----
ADC0CN0_ADBUSY . . . . . . . . . . . .  ABSBIT   -----  BIT      00ECH  1
SMB0ADM. . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00CEH  1
ADC0LTL. . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00C5H  1
SPI0CN0_MODF . . . . . . . . . . . . .  ABSBIT   -----  BIT      00FDH  1
IP_PSPI0 . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00BEH  1
SMB1ADM. . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00CEH  1
AMX0P. . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00BBH  1
I2C0_txBytesRemaining. . . . . . . . .  PUBLIC   CODE   PROC     0000H  -----
TMR5CN0_TF5L . . . . . . . . . . . . .  ABSBIT   -----  BIT      00CEH  1
TMR2CN0. . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00C8H  1
I2C0_TXUNDER_ERROR . . . . . . . . . .  E_CONST  -----  U_CHAR   -----  1
TMR3CN0. . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   0091H  1
I2C0_abort . . . . . . . . . . . . . .  PUBLIC   CODE   PROC     0000H  -----
  savedPage. . . . . . . . . . . . . .  AUTO     XDATA  U_CHAR   0000H  1
TMR4CN0. . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   0091H  1
TMR5CN0. . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00C8H  1
SMB0ADR. . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00CFH  1
wchar_t. . . . . . . . . . . . . . . .  TYPEDEF  -----  CHAR     -----  1
TCON_TR0 . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      008CH  1
C51 COMPILER V9.56.0.0   I2C_0                                                             10/28/2016 17:37:02 PAGE 145 

NAME                                    CLASS   MSPACE  TYPE    OFFSET  SIZE
====                                    =====   ======  ====    ======  ====


SMB1ADR. . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00CFH  1
I2C0_read. . . . . . . . . . . . . . .  PUBLIC   CODE   PROC     0000H  -----
  val. . . . . . . . . . . . . . . . .  AUTO     XDATA  U_CHAR   0000H  1
  savedPage. . . . . . . . . . . . . .  AUTO     XDATA  U_CHAR   0001H  1
TMR2CN0_TF2CEN . . . . . . . . . . . .  ABSBIT   -----  BIT      00CCH  1
TCON_TR1 . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      008EH  1
SMB0DAT. . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00C2H  1
TMR2H. . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00CDH  1
SPI0CFG. . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00A1H  1
SMB1DAT. . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00C2H  1
I2C0_UNKNOWN_ERROR . . . . . . . . . .  E_CONST  -----  U_CHAR   -----  1
TMR3H. . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   0095H  1
TMR4H. . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   0095H  1
TMR5H. . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00CDH  1
TMR2L. . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00CCH  1
I2C0_SLAVE_RXDATA. . . . . . . . . . .  E_CONST  -----  U_CHAR   -----  1
SPI0CN0_SPIF . . . . . . . . . . . . .  ABSBIT   -----  BIT      00FFH  1
USB0ADR. . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   0096H  1
TMR3L. . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   0094H  1
IE_EA. . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00AFH  1
TMR4L. . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   0094H  1
I2C0_reset . . . . . . . . . . . . . .  PUBLIC   CODE   PROC     0000H  -----
  savedPage. . . . . . . . . . . . . .  AUTO     XDATA  U_CHAR   0000H  1
I2C0_SLAVE_TXDATA. . . . . . . . . . .  E_CONST  -----  U_CHAR   -----  1
USB0DAT. . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   0097H  1
TMR5L. . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00CCH  1
FLSCL. . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00B6H  1
TMR2CN0_TF2LEN . . . . . . . . . . . .  ABSBIT   -----  BIT      00CDH  1
SPI0CN0_WCOL . . . . . . . . . . . . .  ABSBIT   -----  BIT      00FEH  1
SPI0CN0_NSSMD0 . . . . . . . . . . . .  ABSBIT   -----  BIT      00FAH  1
PSW_CY . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00D7H  1
SPI0DAT. . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00A3H  1
SPI0CN0_NSSMD1 . . . . . . . . . . . .  ABSBIT   -----  BIT      00FBH  1
ADC0 . . . . . . . . . . . . . . . . .  SFR      DATA   U_INT    00BDH  2
SMBTC. . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00B9H  1
PSW. . . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00D0H  1
I2C0_TransferError_t . . . . . . . . .  TYPEDEF  -----  U_CHAR   -----  1
TMR5CN0_TF5LEN . . . . . . . . . . . .  ABSBIT   -----  BIT      00CDH  1
FLKEY. . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00B7H  1
uint32_t . . . . . . . . . . . . . . .  TYPEDEF  -----  U_LONG   -----  4
_I2C0_write. . . . . . . . . . . . . .  PUBLIC   CODE   PROC     0000H  -----
  value. . . . . . . . . . . . . . . .  AUTO     XDATA  U_CHAR   0000H  1
  savedPage. . . . . . . . . . . . . .  AUTO     XDATA  U_CHAR   0001H  1


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   1276    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =     48    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =      6    ----
   EDATA SIZE       =   ----    ----
   HDATA SIZE       =   ----    ----
   XDATA CONST SIZE =   ----    ----
   FAR CONST SIZE   =   ----    ----
END OF MODULE INFORMATION.

C51 COMPILER V9.56.0.0   I2C_0                                                             10/28/2016 17:37:02 PAGE 146 


C51 COMPILATION COMPLETE.  3 WARNING(S),  0 ERROR(S)
