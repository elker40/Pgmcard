C51 COMPILER V9.56.0.0   SPI_0                                                             10/28/2016 17:37:02 PAGE 1   


C51 COMPILER V9.56.0.0, COMPILATION OF MODULE SPI_0
OBJECT MODULE PLACED IN .\Objects\spi_0.obj
COMPILER INVOKED BY: D:\MyProKits\MucKits\Keil_C51_Rev956\C51\BIN\C51.EXE ..\..\SdkTool\EFM8UB2\Perip\Src\spi_0.c LARGE 
                    -OMF2 OPTIMIZE(0,SPEED) BROWSE INCDIR(..\..\SrcCode\Bsp\Inc;..\..\SrcCode\Logic\Inc;..\..\SrcCode\Middle\Gui\Inc;..\..\Sr
                    -cCode\Middle\Input\Inc;..\..\SdkTool\Si8051Base;..\..\SdkTool\EFM8UB2\Inc;..\..\SdkTool\EFM8UB2\Perip\Inc;..\..\SdkTool\
                    -EFM8UB2\Xpress\Inc) DEBUG CODE LISTINCLUDE SYMBOLS PRINT(.\Listings\spi_0.lst) TABS(2) PREPRINT(.\Listings\spi_0.i) OBJE
                    -CT(.\Objects\spi_0.obj)

line level    source

   1          /******************************************************************************
   2           * Copyright (c) 2015 by Silicon Laboratories Inc. All rights reserved.
   3           *
   4           * http://developer.silabs.com/legal/version/v11/Silicon_Labs_Software_License_Agreement.txt
   5           *****************************************************************************/
   6          
   7          #include "SI_EFM8UB2_Defs.h"
   1      =1  //------------------------------------------------------------------------------
   2      =1  // Copyright 2014 Silicon Laboratories, Inc.
   3      =1  // All rights reserved. This program and the accompanying materials
   4      =1  // are made available under the terms of the Silicon Laboratories End User
   5      =1  // License Agreement which accompanies this distribution, and is available at
   6      =1  // http://developer.silabs.com/legal/version/v11/Silicon_Labs_Software_License_Agreement.txt
   7      =1  // Original content and implementation provided by Silicon Laboratories.
   8      =1  //------------------------------------------------------------------------------
   9      =1  //Supported Devices:
  10      =1  //  EFM8UB20F32G_QFN32
  11      =1  //  EFM8UB20F32G_QFP32
  12      =1  //  EFM8UB20F32G_QFP48
  13      =1  //  EFM8UB20F64G_QFN32
  14      =1  //  EFM8UB20F64G_QFP32
  15      =1  //  EFM8UB20F64G_QFP48
  16      =1  
  17      =1  #ifndef SI_EFM8UB2_DEFS_H
  18      =1  #define SI_EFM8UB2_DEFS_H
  19      =1  
  20      =1  #include <si_toolchain.h>
   1      =2  /******************************************************************************
   2      =2   * Copyright (c) 2015 by Silicon Laboratories Inc. All rights reserved.
   3      =2   *
   4      =2   * http://developer.silabs.com/legal/version/v11/Silicon_Labs_Software_License_Agreement.txt
   5      =2   *****************************************************************************/
   6      =2  
   7      =2  #ifndef __SI_TOOLCHAIN_H__
   8      =2  #define __SI_TOOLCHAIN_H__
   9      =2  
  10      =2  #include <stdint.h>
   1      =3  /**************************************************************************//**
   2      =3   * Copyright (c) 2015 by Silicon Laboratories Inc. All rights reserved.
   3      =3   *
   4      =3   * http://developer.silabs.com/legal/version/v11/Silicon_Labs_Software_License_Agreement.txt
   5      =3   *****************************************************************************/
   6      =3  
   7      =3  #ifndef STDINT_H
   8      =3  #define STDINT_H
   9      =3  
  10      =3  #if defined __C51__
  11      =3  
  12      =3  typedef unsigned char     uint8_t;
  13      =3  typedef unsigned short    uint16_t;
  14      =3  typedef unsigned long     uint32_t;
C51 COMPILER V9.56.0.0   SPI_0                                                             10/28/2016 17:37:02 PAGE 2   

  15      =3  typedef uint32_t          uint64_t[2];
  16      =3  
  17      =3  typedef signed char       int8_t;
  18      =3  typedef short             int16_t;
  19      =3  typedef long              int32_t;
  20      =3  typedef int32_t           int64_t[2];
  21      =3  
  22      =3  #endif
  23      =3  
  24      =3  #endif
  11      =2  #include <stdbool.h>
   1      =3  /**************************************************************************//**
   2      =3   * Copyright (c) 2015 by Silicon Laboratories Inc. All rights reserved.
   3      =3   *
   4      =3   * http://developer.silabs.com/legal/version/v11/Silicon_Labs_Software_License_Agreement.txt
   5      =3   *****************************************************************************/
   6      =3  
   7      =3  #ifndef STDBOOL_H
   8      =3  #define STDBOOL_H
   9      =3  
  10      =3  #if defined __C51__
  11      =3  
  12      =3  typedef bit bool;
  13      =3  enum{
  14      =3    false = 0,
  15      =3    true = 1,
  16      =3  };
  17      =3  
  18      =3  #endif //__C51__
  19      =3  #endif //STDBOOL_H
  20      =3  
  12      =2  
  13      =2  /**************************************************************************//**
  14      =2   *
  15      =2   * @addtogroup toolchain_group Toolchain Abstraction
  16      =2   *
  17      =2   * @brief Macros for toolchain abstraction.
  18      =2   *
  19      =2   * # Introduction #
  20      =2   *
  21      =2   * This header file contains macros that are used to provide an abstraction
  22      =2   * for toolchain use in source code.  The 8051 compiler requires C-language
  23      =2   * extensions in order to fully use features of the 8051 architecture.  All
  24      =2   * compilers for 8051 implement a set of extensions but use different names
  25      =2   * and ways of implementing those extensions.  This header file provides
  26      =2   * macros that are defined for each supported toolchain and can be used in
  27      =2   * the source code.  This allows the source code to use 8051 extensions and
  28      =2   * remain independent of which toolchain is used for compilation.
  29      =2   *
  30      =2   * ## Variable and Pointer Declarations ##
  31      =2   *
  32      =2   * It is often useful to specify the memory area (or segment) of a variable,
  33      =2   * pointer, or pointer target.  For example, you may wish to place all
  34      =2   * variables in XDATA by default, but for variables used in time-sensitive
  35      =2   * code you use DATA for efficient access.  In this case you declare the
  36      =2   * XDATA variable in the normal C way, but declare the variables to be located
  37      =2   * in the DATA segment using @ref SI_SEGMENT_VARIABLE.
  38      =2   *
  39      =2   * Pointers are more complicated because there are two memory spaces
  40      =2   * associated with a pointer, the pointer target, and the pointer variable
  41      =2   * itself.  When using default memory segment for the pointer location and
  42      =2   * target, then no special macro is needed.  But if you wish to specify the
C51 COMPILER V9.56.0.0   SPI_0                                                             10/28/2016 17:37:02 PAGE 3   

  43      =2   * pointer variable location, or target memory segment, then you can use one
  44      =2   * of the following macros to do this in a toolchain-independent way.
  45      =2   *
  46      =2   * |Pointer segment|Target segment|Macro                                   |
  47      =2   * |---------------|--------------|----------------------------------------|
  48      =2   * |default        |generic       |None                                    |
  49      =2   * |default        |specific      |@ref SI_VARIABLE_SEGMENT_POINTER        |
  50      =2   * |specific       |generic       |@ref SI_SEGMENT_POINTER                 |
  51      =2   * |specific       |specific      |@ref SI_SEGMENT_VARIABLE_SEGMENT_POINTER|
  52      =2   *
  53      =2   * ## Prior Toolchain Abstraction Header File ##
  54      =2   *
  55      =2   * This file supercedes an earlier header file named `compiler_defs.h`.  We
  56      =2   * are deprecating the use of compiler_defs.h, however it will remain for
  57      =2   * backwards compatibility.  This file was created to normalize macro names,
  58      =2   * remove unused macros, and to provide documentation.
  59      =2   *
  60      =2   * ## Supported Toolchains ##
  61      =2   *
  62      =2   * - Keil/ARM C51
  63      =2   *
  64      =2   * @{
  65      =2   *
  66      =2   *****************************************************************************/
  67      =2  
  68      =2  // Make sure there is a NULL defined if the toolchain does not provide it.
  69      =2  #ifndef NULL
  70      =2  #define NULL ((void *)0)
  71      =2  #endif
  72      =2  
  73      =2  // -------------------------------
  74      =2  // Keil/ARM C51
  75      =2  //
  76      =2  #if defined(__C51__)
  77      =2  
  78      =2  /// Used with pointers, declares a generic pointer.  Generic pointers
  79      =2  /// work with any memory space but are inefficient.
  80      =2  #define SI_SEG_GENERIC
  81      =2  
  82      =2  /// Declares a variable to be located in 8051 DATA space.
  83      =2  #define SI_SEG_DATA data
  84      =2  
  85      =2  /// Declares a variable to be located in 8051 IDATA space.
  86      =2  #define SI_SEG_IDATA idata
  87      =2  
  88      =2  /// Declares a variable to be located in 8051 XDATA space.
  89      =2  #define SI_SEG_XDATA xdata
  90      =2  
  91      =2  /// Declares a variable to be located in 8051 PDATA space.
  92      =2  #define SI_SEG_PDATA pdata
  93      =2  
  94      =2  /// Declares a variable to be located in 8051 BDATA (bit-addressable) space.
  95      =2  #define SI_SEG_BDATA bdata
  96      =2  
  97      =2  /// Declares a variable to be located in 8051 CODE space.
  98      =2  #define SI_SEG_CODE code
  99      =2  
 100      =2  /**************************************************************************//**
 101      =2   * Declares a bit variable in a bit-addressable SFR or memory space.
 102      =2   *
 103      =2   * @param name The name of the bit variable.
 104      =2   * @param address The address of the byte containing the bit.
C51 COMPILER V9.56.0.0   SPI_0                                                             10/28/2016 17:37:02 PAGE 4   

 105      =2   * @param bitnum The bit number (0-7) within the byte.
 106      =2   *
 107      =2   * This cannot be used to make any arbitrary SFR or variable into
 108      =2   * a bit variable.  The underlying memory must support bit-addressability.
 109      =2   *****************************************************************************/
 110      =2  #define SI_SBIT(name, address, bitnum) sbit name = address^bitnum
 111      =2  
 112      =2  /**************************************************************************//**
 113      =2   * Declares an 8-bit special function register (SFR) variable.
 114      =2   *
 115      =2   * @param name The name of the SFR variable.
 116      =2   * @param address The address of the SFR.
 117      =2   *
 118      =2   * This creates a C variable (8-bit) that maps to a physical special function
 119      =2   * register of the 8051.  This cannot be used to make any arbitrary memory
 120      =2   * location into an SFR.  The _address_ must map to a real SFR in the memory
 121      =2   * map.
 122      =2   *****************************************************************************/
 123      =2  #define SI_SFR(name, address) sfr name = address
 124      =2  
 125      =2  /**************************************************************************//**
 126      =2   * Declares a 16-bit special function register (SFR) variable.
 127      =2   *
 128      =2   * @param name The name of the SFR variable.
 129      =2   * @param address The address of the 16-bit SFR.
 130      =2   *
 131      =2   * This creates a C variable (16-bit) that maps to a physical special function
 132      =2   * register of the 8051.  This cannot be used to make any arbitrary memory
 133      =2   * location into an SFR.  The _address_ must map to a real 16-bit SFR in the
 134      =2   * memory map.
 135      =2   *****************************************************************************/
 136      =2  #define SI_SFR16(name, address) sfr16 name = address
 137      =2  
 138      =2  #ifndef __SLS_IDE__
 139      =2  /**************************************************************************//**
 140      =2   * Define an interrupt handler function for an interrupt vector.
 141      =2   *
 142      =2   * @param name The name of the interrupt handler function.
 143      =2   * @param vector The interrupt vector number.
 144      =2   *
 145      =2   * This macro defines a function to be an interrupt handler.  The _vector_
 146      =2   * parameter is the 8051 interrupt vector number, not the address.  This
 147      =2   * will cause the compiler to treat the function as the interrupt handler
 148      =2   * and generate the appropriate prolog/epilog code.
 149      =2   *
 150      =2   * @note This macro is used to define the function implementation.  To declare
 151      =2   * the interrupt function prototype, use @ref SI_INTERRUPT_PROTO.
 152      =2   *****************************************************************************/
 153      =2  #define SI_INTERRUPT(name, vector) void name (void) interrupt vector
 154      =2  
 155      =2  /**************************************************************************//**
 156      =2   * Define an interrupt handler function using a specific register bank.
 157      =2   *
 158      =2   * @param name The name of the interrupt handler function.
 159      =2   * @param vector The interrupt vector number.
 160      =2   * @param regnum The register bank number (0-3).
 161      =2   *
 162      =2   * This macro defines a function to be an interrupt handler, using a specific
 163      =2   * register bank for the interrupt code.  The _vector_ parameter is the 8051
 164      =2   * interrupt vector number, not the address.  The _regnum_ parameter is the
 165      =2   * register bank number (0-3) that will be used as general purpose registers
 166      =2   * for the instructions in the compiled code.  Using dedicated register banks
C51 COMPILER V9.56.0.0   SPI_0                                                             10/28/2016 17:37:02 PAGE 5   

 167      =2   * for interrupt handlers allows the prolog code to just switch banks instead
 168      =2   * of saving and restoring all the general purpose registers.  This can make
 169      =2   * interrupt entry/exit faster but requires dedicating a register bank for
 170      =2   * the interrupt handler.
 171      =2   *
 172      =2   * @note This macro is used to define the function implementation.  To declare
 173      =2   * the interrupt function prototype, use @ref SI_INTERRUPT_PROTO_USING.
 174      =2   *****************************************************************************/
 175      =2  #define SI_INTERRUPT_USING(name, vector, regnum)                             \
 176      =2               void name (void) interrupt vector using regnum
 177      =2  
 178      =2  /**************************************************************************//**
 179      =2   * Declare an interrupt handler prototype for an interrupt vector.
 180      =2   *
 181      =2   * @param name The name of the interrupt handler function.
 182      =2   * @param vector The interrupt vector number.
 183      =2   *
 184      =2   * This macro declares a function prototype for an interrupt handler.  The
 185      =2   * _vector_ parameter is the 8051 interrupt vector number, not the address.
 186      =2   * Declaring the function prototype this way will cause the compiler to
 187      =2   * recognize that the function is an interrupt handler and not a normal C
 188      =2   * function.
 189      =2   *
 190      =2   * @note This macro is used to declare a prototype for the interrupt function.
 191      =2   * To define the interrupt function implementation, use @ref SI_INTERRUPT.
 192      =2   *****************************************************************************/
 193      =2  #define SI_INTERRUPT_PROTO(name, vector) void name (void)
 194      =2  
 195      =2  /**************************************************************************//**
 196      =2   * Declare an interrupt handler prototype using a specific register bank.
 197      =2   *
 198      =2   * @param name The name of the interrupt handler function.
 199      =2   * @param vector The interrupt vector number.
 200      =2   * @param regnum The register bank number (0-3).
 201      =2   *
 202      =2   * This macro declares a function prototype for an interrupt handler, for a
 203      =2   * function that uses a specific register bank for the interrupt code.  The
 204      =2   * _vector_ parameter is the 8051 interrupt vector number, not the address.
 205      =2   * The _regnum_ parameter is the register bank number (0-3) that will be used
 206      =2   * as general purpose registers in the function.  Declaring the function
 207      =2   * prototype this way will cause the compiler to recognize that the function
 208      =2   * is an interrupt handler and is not a normal C function.
 209      =2   *
 210      =2   * @note This macro is used to declare a prototype for the interrupt function.
 211      =2   * To define the interrupt function implementation,
 212      =2   * use @ref SI_INTERRUPT_USING.
 213      =2   *****************************************************************************/
 214      =2  #define SI_INTERRUPT_PROTO_USING(name, vector, regnum) void name (void)
 215      =2  
 216      =2  /**************************************************************************//**
 217      =2   * Define a function to use a specific register bank.
 218      =2   *
 219      =2   * @param name The name of the function.
 220      =2   * @param return_value The data type of the function return value
 221      =2   * (void, int, etc).
 222      =2   * @param parameter One C function parameter (or "void") (type and name).
 223      =2   * @param regnum The register bank number (0-3).
 224      =2   *
 225      =2   * This macro defines a function that uses a specific register bank.  The
 226      =2   * _regnum_ parameter is the register bank number (0-3) that will be used as
 227      =2   * general purpose registers for the instructions in the compiled function
 228      =2   * code.  Using dedicated register banks for a function can reduce the amount
C51 COMPILER V9.56.0.0   SPI_0                                                             10/28/2016 17:37:02 PAGE 6   

 229      =2   * of registers saving and restoring needed on entry and exit to the
 230      =2   * function.  However, this is an advanced feature and you should not use it
 231      =2   * unless you fully understand how and when to use register banking.
 232      =2   *
 233      =2   * You must specify the _return_value_ which is the type of the function.  It
 234      =2   * can be `void` or any other C type or typedef.  The _parameters_ argument
 235      =2   * is the list of function parameters.  It can be `void` or else it must be
 236      =2   * a parameter data type and name.  It can also be multiple parameters but
 237      =2   * they must be enclosed in parentheses and separated by commas.
 238      =2   *
 239      =2   * __Example__
 240      =2   *
 241      =2   * ~~~~~~~~.c
 242      =2   * // The following is used to implement a function with the following
 243      =2   * // signature, and that uses register bank 3 ...
 244      =2   * uint16_t myFunction(uint8_t parm1, uint8_t parm2);
 245      =2   *
 246      =2   * SI_FUNCTION_USING(myFunction, uint16_t, (uint8_t parm1, uint8_t parm2), 3)
 247      =2   * {
 248      =2   *   // Function implementation body
 249      =2   * }
 250      =2   * ~~~~~~~~
 251      =2   *
 252      =2   * @note This macro is used to define the function implementation.  To declare
 253      =2   * the function prototype, use @ref SI_FUNCTION_PROTO_USING.
 254      =2   *****************************************************************************/
 255      =2  #define SI_FUNCTION_USING(name, return_value, parameter, regnum)              \
 256      =2               return_value name (parameter) using regnum
 257      =2  
 258      =2  /**************************************************************************//**
 259      =2   * Declare a function that uses a specific register bank.
 260      =2   *
 261      =2   * @param name The name of the function.
 262      =2   * @param return_value The data type of the function return value
 263      =2   * (void, int, etc).
 264      =2   * @param parameter One C function parameter (or "void") (type and name).
 265      =2   * @param regnum The register bank number (0-3).
 266      =2   *
 267      =2   * This macro declares a function prototype for a C function that uses a
 268      =2   * specific register its working registers.  See the documentation for
 269      =2   * @ref SI_FUNCTION_USING for an explanation of the macro arguments.  This is
 270      =2   * an advanced feature.
 271      =2   *
 272      =2   * @note This macro is used to declare a prototype for the function.  To
 273      =2   * define the function implementation, use @ref SI_FUNCTION_USING.
 274      =2   *****************************************************************************/
 275      =2  #define SI_FUNCTION_PROTO_USING(name, return_value, parameter, regnum)        \
 276      =2               return_value name (parameter)
 277      =2  
 278      =2  /**************************************************************************//**
 279      =2   * Declare a variable to be located in a specific memory segment.
 280      =2   *
 281      =2   * @param name The variable name.
 282      =2   * @param vartype The variable data type.
 283      =2   * @param memseg The memory segment to use for the variable.
 284      =2   *
 285      =2   * This macro declares a variable to be located in a specific memory area
 286      =2   * (or segment) of the 8051 memory space.  It is only necessary to use this
 287      =2   * macro if you want to force the variable into a specific memory space instead
 288      =2   * of the default memory space used by the compiler.  The segment can be
 289      =2   * one of the following:
 290      =2   *
C51 COMPILER V9.56.0.0   SPI_0                                                             10/28/2016 17:37:02 PAGE 7   

 291      =2   * - @ref SI_SEG_DATA
 292      =2   * - @ref SI_SEG_IDATA
 293      =2   * - @ref SI_SEG_BDATA
 294      =2   * - @ref SI_SEG_PDATA
 295      =2   * - @ref SI_SEG_XDATA
 296      =2   * - @ref SI_SEG_CODE
 297      =2   *
 298      =2   * __Example__
 299      =2   *
 300      =2   * ~~~~~~~~.c
 301      =2   * // The following macro can be used to create a variable located in
 302      =2   * // XDATA with the following signature:
 303      =2   * uint8_t myVar;
 304      =2   *
 305      =2   * SI_SEGMENT_VARIABLE(myVar, uint8_t, SEG_XDATA);
 306      =2   * ~~~~~~~~
 307      =2   *****************************************************************************/
 308      =2  #define SI_SEGMENT_VARIABLE(name, vartype, memseg) vartype memseg name
 309      =2  
 310      =2  /**************************************************************************//**
 311      =2   * Declare a memory segment specific pointer variable.
 312      =2   *
 313      =2   * @param name The pointer variable name.
 314      =2   * @param vartype The pointer data type.
 315      =2   * @param targseg The target memory segment for the pointer.
 316      =2   *
 317      =2   * This macro declares a pointer that points at a specific memory area
 318      =2   * (or segment).  The memory segment of the pointer variable itself is not
 319      =2   * specified and the default is used.  The segment can be one of the following:
 320      =2   *
 321      =2   * - @ref SI_SEG_DATA
 322      =2   * - @ref SI_SEG_IDATA
 323      =2   * - @ref SI_SEG_BDATA
 324      =2   * - @ref SI_SEG_PDATA
 325      =2   * - @ref SI_SEG_XDATA
 326      =2   * - @ref SI_SEG_CODE
 327      =2   *
 328      =2   * __Example__
 329      =2   *
 330      =2   * ~~~~~~~~.c
 331      =2   * // The following macro can be used to create a pointer that points to
 332      =2   * // a location in XDATA with the following signature:
 333      =2   * uint8_t *pVar; // where pVar is pointing at XDATA
 334      =2   *
 335      =2   * SI_VARIABLE_SEGMENT_POINTER(pVar, uint8_t, SEG_XDATA);
 336      =2   * ~~~~~~~~
 337      =2   *****************************************************************************/
 338      =2  #define SI_VARIABLE_SEGMENT_POINTER(name, vartype, targseg)                  \
 339      =2               vartype targseg * name
 340      =2  
 341      =2  /**************************************************************************//**
 342      =2   * Declare a memory segment specific pointer variable, in a specific segment.
 343      =2   *
 344      =2   * @param name The pointer variable name.
 345      =2   * @param vartype The pointer data type.
 346      =2   * @param targseg The target memory segment for the pointer.
 347      =2   * @param memseg The memory segment to use for the pointer variable.
 348      =2   *
 349      =2   * This macro declares a pointer that points at a specific memory area
 350      =2   * (or segment).  The pointer variable itself is also located in a specified
 351      =2   * memory segment by _memseg_.  The arguments _targseg_ and _memseg_ can be
 352      =2   * one of the following:
C51 COMPILER V9.56.0.0   SPI_0                                                             10/28/2016 17:37:02 PAGE 8   

 353      =2   *
 354      =2   * - @ref SI_SEG_DATA
 355      =2   * - @ref SI_SEG_IDATA
 356      =2   * - @ref SI_SEG_BDATA
 357      =2   * - @ref SI_SEG_PDATA
 358      =2   * - @ref SI_SEG_XDATA
 359      =2   * - @ref SI_SEG_CODE
 360      =2   *
 361      =2   * __Example__
 362      =2   *
 363      =2   * ~~~~~~~~.c
 364      =2   * // The following macro can be used to create a pointer that points to
 365      =2   * // a location in XDATA while the pointer itself is located in DATA, with
 366      =2   * // the following signature:
 367      =2   * uint8_t *pVar; // where pVar is located in DATA and is pointing at XDATA
 368      =2   *
 369      =2   * SI_SEGMENT_VARIABLE_SEGMENT_POINTER(pVar, uint8_t, SEG_XDATA, SEG_DATA);
 370      =2   * ~~~~~~~~
 371      =2   *****************************************************************************/
 372      =2  #define SI_SEGMENT_VARIABLE_SEGMENT_POINTER(name, vartype, targseg, memseg)  \
 373      =2               vartype targseg * memseg name
 374      =2  
 375      =2  /**************************************************************************//**
 376      =2   * Declare a generic pointer variable that is located in a specific segment.
 377      =2   *
 378      =2   * @param name The pointer variable name.
 379      =2   * @param vartype The pointer data type.
 380      =2   * @param memseg The memory segment to use for the pointer variable.
 381      =2   *
 382      =2   * This macro declares a pointer that is a generic pointer.  This means it can
 383      =2   * point at any kind of memory location.  However the pointer variable itself
 384      =2   * is located in a specific memory segment by _memseg_, which can be one of
 385      =2   * the following:
 386      =2   *
 387      =2   * - @ref SI_SEG_DATA
 388      =2   * - @ref SI_SEG_IDATA
 389      =2   * - @ref SI_SEG_BDATA
 390      =2   * - @ref SI_SEG_PDATA
 391      =2   * - @ref SI_SEG_XDATA
 392      =2   * - @ref SI_SEG_CODE
 393      =2   *
 394      =2   * __Example__
 395      =2   *
 396      =2   * ~~~~~~~~.c
 397      =2   * // The following macro can be used to create a generic pointer that
 398      =2   * // is located in DATA and points at any memory type, with the
 399      =2   * // following signature:
 400      =2   * uint8_t *pVar; // where pVar is located in DATA and is a generic pointer
 401      =2   *
 402      =2   * SI_SEGMENT_POINTER(pVar, uint8_t, SEG_DATA);
 403      =2   * ~~~~~~~~
 404      =2   *****************************************************************************/
 405      =2  #define SI_SEGMENT_POINTER(name, vartype, memseg) vartype * memseg name
 406      =2  
 407      =2  /**************************************************************************//**
 408      =2   * Declare an uninitialized variable that is located at a specific address.
 409      =2   *
 410      =2   * @param name The variable name.
 411      =2   * @param vartype The variable data type.
 412      =2   * @param memseg The memory segment to use for the variable.
 413      =2   * @param address The memory address of the variable.
 414      =2   *
C51 COMPILER V9.56.0.0   SPI_0                                                             10/28/2016 17:37:02 PAGE 9   

 415      =2   * This macro allows declaring a variable that can be placed at a specific
 416      =2   * location in memory.  This can only be used for variables that do not need
 417      =2   * initializers.  The _address_ is the memory address within the specified
 418      =2   * segment.  The memory segment, _memseg_, can be one of the following:
 419      =2   *
 420      =2   * - @ref SI_SEG_DATA
 421      =2   * - @ref SI_SEG_IDATA
 422      =2   * - @ref SI_SEG_BDATA
 423      =2   * - @ref SI_SEG_PDATA
 424      =2   * - @ref SI_SEG_XDATA
 425      =2   * - @ref SI_SEG_CODE
 426      =2   *
 427      =2   * __Example__
 428      =2   *
 429      =2   * ~~~~~~~~.c
 430      =2   * // The following declares a variable located at 0x4000 in XDATA with
 431      =2   * // the following signature:
 432      =2   * uint8_t myMemVar;
 433      =2   *
 434      =2   * SI_LOCATED_VARIABLE_NO_INIT(myMemVar, uint8_t, SEG_DATA, 0x4000);
 435      =2   * ~~~~~~~~
 436      =2   *****************************************************************************/
 437      =2  #define SI_LOCATED_VARIABLE_NO_INIT(name, vartype, memseg, address)          \
 438      =2               vartype memseg name _at_ address
 439      =2  
 440      =2  
 441      =2  #else  // __SLS_IDE__ : Macros defined to remove syntax errors within Simplicity Studio
           =2 #define SI_INTERRUPT(name, vector) void name (void)
           =2 #define SI_INTERRUPT_USING(name, vector, regnum) void name (void)
           =2 #define SI_INTERRUPT_PROTO(name, vector) void name (void)
           =2 #define SI_INTERRUPT_PROTO_USING(name, vector, regnum) void name (void)
           =2 
           =2 #define SI_FUNCTION_USING(name, return_value, parameter, regnum) return_value name (parameter)
           =2 #define SI_FUNCTION_PROTO_USING(name, return_value, parameter, regnum) return_value name (parameter)
           =2 // Note: Parameter must be either 'void' or include a variable type and name. (Ex: char temp_variable)
           =2 
           =2 #define SI_SEGMENT_VARIABLE(name, vartype, locsegment) vartype name
           =2 #define SI_VARIABLE_SEGMENT_POINTER(name, vartype, targsegment) vartype * name
           =2 #define SI_SEGMENT_VARIABLE_SEGMENT_POINTER(name, vartype, targsegment, locsegment) vartype * name
           =2 #define SI_SEGMENT_POINTER(name, vartype, locsegment) vartype * name
           =2 #define SI_LOCATED_VARIABLE_NO_INIT(name, vartype, locsegment, addr) vartype name
           =2 #endif // __SLS_IDE__
 457      =2  
 458      =2  // The following are used for byte ordering when referring to individual
 459      =2  // bytes within a SI_UU32_t.  B0 is the least significant byte.
 460      =2  #define B0 3 ///< Least significant byte of a 4 byte word
 461      =2  #define B1 2 ///< Byte 1 of a 4-byte word, where byte 0 is LSB
 462      =2  #define B2 1 ///< Byte 2 of a 4-byte word, where byte 0 is LSB
 463      =2  #define B3 0 ///< Most significant byte of a 4-byte word
 464      =2  
 465      =2  #define LSB 1 ///< Index to least significant bit of a 2 byte word
 466      =2  #define MSB 0 ///< Index to most significant bit of a 2 byte word
 467      =2  
 468      =2  /// A union type to make it easier to access individual bytes of a 16-bit
 469      =2  /// word, and to use as signed or unsigned type.
 470      =2  typedef union SI_UU16
 471      =2  {
 472      =2    uint16_t u16;   ///< The two byte value as a 16-bit unsigned integer.
 473      =2    int16_t s16;    ///< The two byte value as a 16-bit signed integer.
 474      =2    uint8_t u8[2];  ///< The two byte value as two unsigned 8-bit integers.
 475      =2    int8_t s8[2];   ///< The two byte value as two signed 8-bit integers.
 476      =2  } SI_UU16_t;
C51 COMPILER V9.56.0.0   SPI_0                                                             10/28/2016 17:37:02 PAGE 10  

 477      =2  
 478      =2  /// A union type to make it easier to access individual bytes within a
 479      =2  /// 32-bit word, or to access it as variations of 16-bit words, or to
 480      =2  /// use as signed or unsigned type.
 481      =2  typedef union SI_UU32
 482      =2  {
 483      =2    uint32_t u32;       ///< The 4-byte value as a 32-bit unsigned integer.
 484      =2    int32_t s32;        ///< The 4-byte value as a 32-bit signed integer.
 485      =2    SI_UU16_t uu16[2];  ///< The 4-byte value as a SI_UU16_t.
 486      =2    uint16_t u16[2];    ///< The 4-byte value as two unsigned 16-bit integers.
 487      =2    int16_t s16[2];     ///< The 4-byte value as two signed 16-bit integers.
 488      =2    uint8_t u8[4];      ///< The 4-byte value as 4 unsigned 8-bit integers.
 489      =2    int8_t s8[4];       ///< The 4-byte value as 4 signed 8-bit integers.
 490      =2  } SI_UU32_t;
 491      =2  
 492      =2  // Generic pointer memory segment constants.
 493      =2  #define SI_GPTR                   ///< Generic pointer indeterminate type.
 494      =2  #define SI_GPTR_MTYPE_DATA  0x00  ///< Generic pointer for DATA segment.
 495      =2  #define SI_GPTR_MTYPE_IDATA 0x00  ///< Generic pointer for IDATA segment.
 496      =2  #define SI_GPTR_MTYPE_BDATA 0x00  ///< Generic pointer for BDATA segment.
 497      =2  #define SI_GPTR_MTYPE_PDATA 0xFE  ///< Generic pointer for PDATA segment.
 498      =2  #define SI_GPTR_MTYPE_XDATA 0x01  ///< Generic pointer for XDATA segment.
 499      =2  #define SI_GPTR_MTYPE_CODE  0xFF  ///< Generic pointer for CODE segment.
 500      =2  
 501      =2  /// Generic pointer structure containing the type and address.
 502      =2  typedef struct
 503      =2  {
 504      =2    uint8_t memtype;    ///< The type of memory of the generic pointer.
 505      =2    SI_UU16_t address;  ///< The address of the generic pointer.
 506      =2  } GPTR_t;
 507      =2  
 508      =2  /// A union type to allow access to the fields of a generic pointer.
 509      =2  /// A generic pointer has a field indicating the type of memory and an
 510      =2  /// address within the memory.
 511      =2  typedef union SI_GEN_PTR
 512      =2  {
 513      =2    uint8_t u8[3];    ///< 3-byte generic pointer as 3 unsigned 8-bit integers.
 514      =2    GPTR_t gptr;      ///< 3-byte generic pointer as pointer structure
 515      =2  } SI_GEN_PTR_t;
 516      =2  
 517      =2  // Declaration of Keil intrinisc
 518      =2  extern void _nop_(void);
 519      =2  /// Macro to insert a no-operation (NOP) instruction.
 520      =2  #define NOP() _nop_()
 521      =2  
 522      =2  // -------------------------------
 523      =2  // GCC for ARM Cortex-M
 524      =2  // Provides support for code that can be compiled for 8 or 32-bit
 525      =2  //
 526      =2  #elif defined (__GNUC__)
           =2 #if defined(__ARMEL__) && ((__ARMEL__ == 1) && ((__ARM_ARCH == 6) || (__ARM_ARCH == 7)))
           =2 
           =2 // these ignore any memory segment directives
           =2 #define SI_SEG_GENERIC
           =2 #define SI_SEG_DATA
           =2 #define SI_SEG_IDATA
           =2 #define SI_SEG_XDATA
           =2 #define SI_SEG_PDATA
           =2 #define SI_SEG_BDATA
           =2 #define SI_SEG_CODE
           =2 
           =2 // the following create a variable of the specified name but ignore the
C51 COMPILER V9.56.0.0   SPI_0                                                             10/28/2016 17:37:02 PAGE 11  

           =2 // address and bit number.  If the using-code cares about the actual
           =2 // address or bit number, this probably will break it
           =2 #define SI_SBIT(name, address, bitnum) uint8_t name
           =2 #define SI_SFR(name, address) uint8_t name
           =2 #define SI_SFR16(name, address) uint16_t name
           =2 
           =2 // the following create function and variable names of the specified types
           =2 // but the 8051-specific aspects (like memory segment) are ignored
           =2 #define SI_INTERRUPT(name, vector) void name (void)
           =2 #define SI_INTERRUPT_USING(name, vector, regnum) void name (void)
           =2 #define SI_INTERRUPT_PROTO(name, vector) void name (void)
           =2 #define SI_INTERRUPT_PROTO_USING(name, vector, regnum) void name (void)
           =2 #define SI_FUNCTION_USING(name, return_value, parameter, regnum)              \
           =2              return_value name (parameter)
           =2 #define SI_FUNCTION_PROTO_USING(name, return_value, parameter, regnum)        \
           =2              return_value name (parameter)
           =2 #define SI_SEGMENT_VARIABLE(name, vartype, memseg) vartype name
           =2 #define SI_VARIABLE_SEGMENT_POINTER(name, vartype, targseg)                  \
           =2              vartype * name
           =2 #define SI_SEGMENT_VARIABLE_SEGMENT_POINTER(name, vartype, targseg, memseg)  \
           =2              vartype * name
           =2 #define SI_SEGMENT_POINTER(name, vartype, memseg) vartype * name
           =2 #define SI_LOCATED_VARIABLE_NO_INIT(name, vartype, memseg, address)          \
           =2              vartype name
           =2 
           =2 #define B0 0
           =2 #define B1 1
           =2 #define B2 2
           =2 #define B3 3
           =2 #define LSB 0
           =2 #define MSB 1
           =2 typedef union SI_UU16
           =2 {
           =2   uint16_t u16;
           =2   int16_t s16;
           =2   uint8_t u8[2];
           =2   int8_t s8[2];
           =2 } SI_UU16_t;
           =2 
           =2 typedef union SI_UU32
           =2 {
           =2   uint32_t u32;
           =2   int32_t s32;
           =2   SI_UU16_t uu16[2];
           =2   uint16_t u16[2];
           =2   int16_t s16[2];
           =2   uint8_t u8[4];
           =2   int8_t s8[4];
           =2 } SI_UU32_t;
           =2 
           =2 // Generic pointer stuff is left out because if you are accessing
           =2 // generic pointer fields then it will need to be rewritten for 32-bit
           =2 
           =2 // __NOP should be declared in cmsis header core_cmInstr.h
           =2 extern void __NOP(void);
           =2 /// Macro to insert a no-operation (NOP) instruction.
           =2 #define NOP() __NOP()
           =2 
           =2 #else // ARM_ARCH 6 | 7
           =2 #error unsupported ARM arch
           =2 #endif
           =2 
C51 COMPILER V9.56.0.0   SPI_0                                                             10/28/2016 17:37:02 PAGE 12  

           =2 #else // unknown toolchain
           =2 #error Unrecognized toolchain in si_toolchain.h
           =2 #endif
 604      =2  
 605      =2  /** @} */
 606      =2  
 607      =2  #endif
  21      =1  
  22      =1  //-----------------------------------------------------------------------------
  23      =1  // Register Definitions
  24      =1  //-----------------------------------------------------------------------------
  25      =1  SI_SFR (ACC,      0xE0); ///< Accumulator                           
  26      =1  SI_SFR (ADC0CF,   0xBC); ///< ADC0 Configuration                    
  27      =1  SI_SFR (ADC0CN0,  0xE8); ///< ADC0 Control                          
  28      =1  SI_SFR (ADC0GTH,  0xC4); ///< ADC0 Greater-Than High Byte           
  29      =1  SI_SFR (ADC0GTL,  0xC3); ///< ADC0 Greater-Than Low Byte            
  30      =1  SI_SFR (ADC0H,    0xBE); ///< ADC0 Data Word High Byte              
  31      =1  SI_SFR (ADC0L,    0xBD); ///< ADC0 Data Word Low Byte               
  32      =1  SI_SFR (ADC0LTH,  0xC6); ///< ADC0 Less-Than High Byte              
  33      =1  SI_SFR (ADC0LTL,  0xC5); ///< ADC0 Less-Than Low Byte               
  34      =1  SI_SFR (AMX0N,    0xBA); ///< AMUX0 Negative Multiplexer Selection  
  35      =1  SI_SFR (AMX0P,    0xBB); ///< AMUX0 Positive Multiplexer Selection  
  36      =1  SI_SFR (B,        0xF0); ///< B Register                            
  37      =1  SI_SFR (CKCON0,   0x8E); ///< Clock Control 0                       
  38      =1  SI_SFR (CKCON1,   0xE4); ///< Clock Control 1                       
  39      =1  SI_SFR (CLKSEL,   0xA9); ///< Clock Select                          
  40      =1  SI_SFR (CMP0CN0,  0x9B); ///< Comparator 0 Control 0                
  41      =1  SI_SFR (CMP0MD,   0x9D); ///< Comparator 0 Mode                     
  42      =1  SI_SFR (CMP0MX,   0x9F); ///< Comparator 0 Multiplexer Selection    
  43      =1  SI_SFR (CMP1CN0,  0x9A); ///< Comparator 1 Control 0                
  44      =1  SI_SFR (CMP1MD,   0x9C); ///< Comparator 1 Mode                     
  45      =1  SI_SFR (CMP1MX,   0x9E); ///< Comparator 1 Multiplexer Selection    
  46      =1  SI_SFR (DPH,      0x83); ///< Data Pointer High                     
  47      =1  SI_SFR (DPL,      0x82); ///< Data Pointer Low                      
  48      =1  SI_SFR (EIE1,     0xE6); ///< Extended Interrupt Enable 1           
  49      =1  SI_SFR (EIE2,     0xE7); ///< Extended Interrupt Enable 2           
  50      =1  SI_SFR (EIP1,     0xF6); ///< Extended Interrupt Priority 1         
  51      =1  SI_SFR (EIP2,     0xF7); ///< Extended Interrupt Priority 2         
  52      =1  SI_SFR (EMI0CF,   0x85); ///< External Memory Configuration         
  53      =1  SI_SFR (EMI0CN,   0xAA); ///< External Memory Interface Control     
  54      =1  SI_SFR (EMI0TC,   0x84); ///< External Memory Timing Control        
  55      =1  SI_SFR (FLKEY,    0xB7); ///< Flash Lock and Key                    
  56      =1  SI_SFR (FLSCL,    0xB6); ///< Flash Scale                           
  57      =1  SI_SFR (HFO0CAL,  0xB3); ///< High Frequency Oscillator Calibration 
  58      =1  SI_SFR (HFO0CN,   0xB2); ///< High Frequency Oscillator Control     
  59      =1  SI_SFR (IE,       0xA8); ///< Interrupt Enable                      
  60      =1  SI_SFR (IP,       0xB8); ///< Interrupt Priority                    
  61      =1  SI_SFR (IT01CF,   0xE4); ///< INT0/INT1 Configuration               
  62      =1  SI_SFR (LFO0CN,   0x86); ///< Low Frequency Oscillator Control      
  63      =1  SI_SFR (P0,       0x80); ///< Port 0 Pin Latch                      
  64      =1  SI_SFR (P0MDIN,   0xF1); ///< Port 0 Input Mode                     
  65      =1  SI_SFR (P0MDOUT,  0xA4); ///< Port 0 Output Mode                    
  66      =1  SI_SFR (P0SKIP,   0xD4); ///< Port 0 Skip                           
  67      =1  SI_SFR (P1,       0x90); ///< Port 1 Pin Latch                      
  68      =1  SI_SFR (P1MDIN,   0xF2); ///< Port 1 Input Mode                     
  69      =1  SI_SFR (P1MDOUT,  0xA5); ///< Port 1 Output Mode                    
  70      =1  SI_SFR (P1SKIP,   0xD5); ///< Port 1 Skip                           
  71      =1  SI_SFR (P2,       0xA0); ///< Port 2 Pin Latch                      
  72      =1  SI_SFR (P2MDIN,   0xF3); ///< Port 2 Input Mode                     
  73      =1  SI_SFR (P2MDOUT,  0xA6); ///< Port 2 Output Mode                    
  74      =1  SI_SFR (P2SKIP,   0xD6); ///< Port 2 Skip                           
  75      =1  SI_SFR (P3,       0xB0); ///< Port 3 Pin Latch                      
C51 COMPILER V9.56.0.0   SPI_0                                                             10/28/2016 17:37:02 PAGE 13  

  76      =1  SI_SFR (P3MDIN,   0xF4); ///< Port 3 Input Mode                     
  77      =1  SI_SFR (P3MDOUT,  0xA7); ///< Port 3 Output Mode                    
  78      =1  SI_SFR (P3SKIP,   0xDF); ///< Port 3 Skip                           
  79      =1  SI_SFR (P4,       0xC7); ///< Port 4 Pin Latch                      
  80      =1  SI_SFR (P4MDIN,   0xF5); ///< Port 4 Input Mode                     
  81      =1  SI_SFR (P4MDOUT,  0xAE); ///< Port 4 Output Mode                    
  82      =1  SI_SFR (PCA0CN0,  0xD8); ///< PCA Control 0                         
  83      =1  SI_SFR (PCA0CPH0, 0xFC); ///< PCA Channel 0 Capture Module High Byte
  84      =1  SI_SFR (PCA0CPH1, 0xEA); ///< PCA Channel 1 Capture Module High Byte
  85      =1  SI_SFR (PCA0CPH2, 0xEC); ///< PCA Channel 2 Capture Module High Byte
  86      =1  SI_SFR (PCA0CPH3, 0xEE); ///< PCA Channel 3 Capture Module High Byte
  87      =1  SI_SFR (PCA0CPH4, 0xFE); ///< PCA Channel 4 Capture Module High Byte
  88      =1  SI_SFR (PCA0CPL0, 0xFB); ///< PCA Channel 0 Capture Module Low Byte 
  89      =1  SI_SFR (PCA0CPL1, 0xE9); ///< PCA Channel 1 Capture Module Low Byte 
  90      =1  SI_SFR (PCA0CPL2, 0xEB); ///< PCA Channel 2 Capture Module Low Byte 
  91      =1  SI_SFR (PCA0CPL3, 0xED); ///< PCA Channel 3 Capture Module Low Byte 
  92      =1  SI_SFR (PCA0CPL4, 0xFD); ///< PCA Channel 4 Capture Module Low Byte 
  93      =1  SI_SFR (PCA0CPM0, 0xDA); ///< PCA Channel 0 Capture/Compare Mode    
  94      =1  SI_SFR (PCA0CPM1, 0xDB); ///< PCA Channel 1 Capture/Compare Mode    
  95      =1  SI_SFR (PCA0CPM2, 0xDC); ///< PCA Channel 2 Capture/Compare Mode    
  96      =1  SI_SFR (PCA0CPM3, 0xDD); ///< PCA Channel 3 Capture/Compare Mode    
  97      =1  SI_SFR (PCA0CPM4, 0xDE); ///< PCA Channel 4 Capture/Compare Mode    
  98      =1  SI_SFR (PCA0H,    0xFA); ///< PCA Counter/Timer High Byte           
  99      =1  SI_SFR (PCA0L,    0xF9); ///< PCA Counter/Timer Low Byte            
 100      =1  SI_SFR (PCA0MD,   0xD9); ///< PCA Mode                              
 101      =1  SI_SFR (PCON0,    0x87); ///< Power Control                         
 102      =1  SI_SFR (PFE0CN,   0xAF); ///< Prefetch Engine Control               
 103      =1  SI_SFR (PSCTL,    0x8F); ///< Program Store Control                 
 104      =1  SI_SFR (PSW,      0xD0); ///< Program Status Word                   
 105      =1  SI_SFR (REF0CN,   0xD1); ///< Voltage Reference Control             
 106      =1  SI_SFR (REG01CN,  0xC9); ///< Voltage Regulator Control             
 107      =1  SI_SFR (RSTSRC,   0xEF); ///< Reset Source                          
 108      =1  SI_SFR (SBCON1,   0xAC); ///< UART1 Baud Rate Generator Control     
 109      =1  SI_SFR (SBRLH1,   0xB5); ///< UART1 Baud Rate Generator High Byte   
 110      =1  SI_SFR (SBRLL1,   0xB4); ///< UART1 Baud Rate Generator Low Byte    
 111      =1  SI_SFR (SBUF0,    0x99); ///< UART0 Serial Port Data Buffer         
 112      =1  SI_SFR (SBUF1,    0xD3); ///< UART1 Serial Port Data Buffer         
 113      =1  SI_SFR (SCON0,    0x98); ///< UART0 Serial Port Control             
 114      =1  SI_SFR (SCON1,    0xD2); ///< UART1 Serial Port Control             
 115      =1  SI_SFR (SFRPAGE,  0xBF); ///< SFR Page                              
 116      =1  SI_SFR (SMB0ADM,  0xCE); ///< SMBus 0 Slave Address Mask            
 117      =1  SI_SFR (SMB0ADR,  0xCF); ///< SMBus 0 Slave Address                 
 118      =1  SI_SFR (SMB0CF,   0xC1); ///< SMBus 0 Configuration                 
 119      =1  SI_SFR (SMB0CN0,  0xC0); ///< SMBus 0 Control                       
 120      =1  SI_SFR (SMB0DAT,  0xC2); ///< SMBus 0 Data                          
 121      =1  SI_SFR (SMB1ADM,  0xCE); ///< SMBus 1 Slave Address Mask            
 122      =1  SI_SFR (SMB1ADR,  0xCF); ///< SMBus 1 Slave Address                 
 123      =1  SI_SFR (SMB1CF,   0xC1); ///< SMBus 1 Configuration                 
 124      =1  SI_SFR (SMB1CN0,  0xC0); ///< SMBus 1 Control                       
 125      =1  SI_SFR (SMB1DAT,  0xC2); ///< SMBus 1 Data                          
 126      =1  SI_SFR (SMBTC,    0xB9); ///< SMBus Timing and Pin Control          
 127      =1  SI_SFR (SMOD1,    0xE5); ///< UART1 Mode                            
 128      =1  SI_SFR (SP,       0x81); ///< Stack Pointer                         
 129      =1  SI_SFR (SPI0CFG,  0xA1); ///< SPI0 Configuration                    
 130      =1  SI_SFR (SPI0CKR,  0xA2); ///< SPI0 Clock Rate                       
 131      =1  SI_SFR (SPI0CN0,  0xF8); ///< SPI0 Control                          
 132      =1  SI_SFR (SPI0DAT,  0xA3); ///< SPI0 Data                             
 133      =1  SI_SFR (TCON,     0x88); ///< Timer 0/1 Control                     
 134      =1  SI_SFR (TH0,      0x8C); ///< Timer 0 High Byte                     
 135      =1  SI_SFR (TH1,      0x8D); ///< Timer 1 High Byte                     
 136      =1  SI_SFR (TL0,      0x8A); ///< Timer 0 Low Byte                      
 137      =1  SI_SFR (TL1,      0x8B); ///< Timer 1 Low Byte                      
C51 COMPILER V9.56.0.0   SPI_0                                                             10/28/2016 17:37:02 PAGE 14  

 138      =1  SI_SFR (TMOD,     0x89); ///< Timer 0/1 Mode                        
 139      =1  SI_SFR (TMR2CN0,  0xC8); ///< Timer 2 Control 0                     
 140      =1  SI_SFR (TMR2H,    0xCD); ///< Timer 2 High Byte                     
 141      =1  SI_SFR (TMR2L,    0xCC); ///< Timer 2 Low Byte                      
 142      =1  SI_SFR (TMR2RLH,  0xCB); ///< Timer 2 Reload High Byte              
 143      =1  SI_SFR (TMR2RLL,  0xCA); ///< Timer 2 Reload Low Byte               
 144      =1  SI_SFR (TMR3CN0,  0x91); ///< Timer 3 Control 0                     
 145      =1  SI_SFR (TMR3H,    0x95); ///< Timer 3 High Byte                     
 146      =1  SI_SFR (TMR3L,    0x94); ///< Timer 3 Low Byte                      
 147      =1  SI_SFR (TMR3RLH,  0x93); ///< Timer 3 Reload High Byte              
 148      =1  SI_SFR (TMR3RLL,  0x92); ///< Timer 3 Reload Low Byte               
 149      =1  SI_SFR (TMR4CN0,  0x91); ///< Timer 4 Control 0                     
 150      =1  SI_SFR (TMR4H,    0x95); ///< Timer 4 High Byte                     
 151      =1  SI_SFR (TMR4L,    0x94); ///< Timer 4 Low Byte                      
 152      =1  SI_SFR (TMR4RLH,  0x93); ///< Timer 4 Reload High Byte              
 153      =1  SI_SFR (TMR4RLL,  0x92); ///< Timer 4 Reload Low Byte               
 154      =1  SI_SFR (TMR5CN0,  0xC8); ///< Timer 5 Control 0                     
 155      =1  SI_SFR (TMR5H,    0xCD); ///< Timer 5 High Byte                     
 156      =1  SI_SFR (TMR5L,    0xCC); ///< Timer 5 Low Byte                      
 157      =1  SI_SFR (TMR5RLH,  0xCB); ///< Timer 5 Reload High Byte              
 158      =1  SI_SFR (TMR5RLL,  0xCA); ///< Timer 5 Reload Low Byte               
 159      =1  SI_SFR (USB0ADR,  0x96); ///< USB0 Indirect Address                 
 160      =1  SI_SFR (USB0DAT,  0x97); ///< USB0 Data                             
 161      =1  SI_SFR (USB0XCN,  0xD7); ///< USB0 Transceiver Control              
 162      =1  SI_SFR (VDM0CN,   0xFF); ///< Supply Monitor Control                
 163      =1  SI_SFR (XBR0,     0xE1); ///< Port I/O Crossbar 0                   
 164      =1  SI_SFR (XBR1,     0xE2); ///< Port I/O Crossbar 1                   
 165      =1  SI_SFR (XBR2,     0xE3); ///< Port I/O Crossbar 2                   
 166      =1  SI_SFR (XOSC0CN,  0xB1); ///< External Oscillator Control           
 167      =1  
 168      =1  //------------------------------------------------------------------------------
 169      =1  // 16-bit Register Definitions (may not work on all compilers)
 170      =1  //------------------------------------------------------------------------------
 171      =1  SI_SFR16 (ADC0GT,  0xC3); ///< ADC0 Greater-Than            
 172      =1  SI_SFR16 (ADC0,    0xBD); ///< ADC0 Data Word               
 173      =1  SI_SFR16 (ADC0LT,  0xC5); ///< ADC0 Less-Than               
 174      =1  SI_SFR16 (DP,      0x82); ///< Data Pointer                 
 175      =1  SI_SFR16 (PCA0CP0, 0xFB); ///< PCA Channel 0 Capture Module 
 176      =1  SI_SFR16 (PCA0CP1, 0xE9); ///< PCA Channel 1 Capture Module 
 177      =1  SI_SFR16 (PCA0CP2, 0xEB); ///< PCA Channel 2 Capture Module 
 178      =1  SI_SFR16 (PCA0CP3, 0xED); ///< PCA Channel 3 Capture Module 
 179      =1  SI_SFR16 (PCA0CP4, 0xFD); ///< PCA Channel 4 Capture Module 
 180      =1  SI_SFR16 (PCA0,    0xF9); ///< PCA Counter/Timer            
 181      =1  SI_SFR16 (SBRL1,   0xB4); ///< UART1 Baud Rate Generator    
 182      =1  SI_SFR16 (TMR2,    0xCC); ///< Timer 2                      
 183      =1  SI_SFR16 (TMR2RL,  0xCA); ///< Timer 2 Reload               
 184      =1  SI_SFR16 (TMR3,    0x94); ///< Timer 3                      
 185      =1  SI_SFR16 (TMR3RL,  0x92); ///< Timer 3 Reload               
 186      =1  SI_SFR16 (TMR4,    0x94); ///< Timer 4                      
 187      =1  SI_SFR16 (TMR4RL,  0x92); ///< Timer 4 Reload               
 188      =1  SI_SFR16 (TMR5,    0xCC); ///< Timer 5                      
 189      =1  SI_SFR16 (TMR5RL,  0xCA); ///< Timer 5 Reload               
 190      =1  
 191      =1  //------------------------------------------------------------------------------
 192      =1  // Indirect Register Definitions
 193      =1  //------------------------------------------------------------------------------
 194      =1  #define CLKREC   0x0F ///< USB0 Clock Recovery Control       
 195      =1  #define CMIE     0x0B ///< USB0 Common Interrupt Enable      
 196      =1  #define CMINT    0x06 ///< USB0 Common Interrupt             
 197      =1  #define E0CNT    0x16 ///< USB0 Endpoint0 Data Count         
 198      =1  #define E0CSR    0x11 ///< USB0 Endpoint0 Control            
 199      =1  #define EENABLE  0x1E ///< USB0 Endpoint Enable              
C51 COMPILER V9.56.0.0   SPI_0                                                             10/28/2016 17:37:02 PAGE 15  

 200      =1  #define EINCSRH  0x12 ///< USB0 IN Endpoint Control High     
 201      =1  #define EINCSRL  0x11 ///< USB0 IN Endpoint Control          
 202      =1  #define EOUTCNTH 0x17 ///< USB0 OUT Endpoint Count High      
 203      =1  #define EOUTCNTL 0x16 ///< USB0 OUT Endpoint Count           
 204      =1  #define EOUTCSRH 0x15 ///< USB0 OUT Endpoint Control High    
 205      =1  #define EOUTCSRL 0x14 ///< USB0 OUT Endpoint Control         
 206      =1  #define FADDR    0x00 ///< USB0 Function Address             
 207      =1  #define FIFO0    0x20 ///< USB0 Endpoint 0 FIFO Access       
 208      =1  #define FIFO1    0x21 ///< USB0 Endpoint 1 FIFO Access       
 209      =1  #define FIFO2    0x22 ///< USB0 Endpoint 2 FIFO Access       
 210      =1  #define FIFO3    0x23 ///< USB0 Endpoint 3 FIFO Access       
 211      =1  #define FRAMEH   0x0D ///< USB0 Frame Number High            
 212      =1  #define FRAMEL   0x0C ///< USB0 Frame Number                 
 213      =1  #define IN1IE    0x07 ///< USB0 IN Endpoint Interrupt Enable 
 214      =1  #define IN1INT   0x02 ///< USB0 IN Endpoint Interrupt        
 215      =1  #define INDEX    0x0E ///< USB0 Endpoint Index               
 216      =1  #define OUT1IE   0x09 ///< USB0 OUT Endpoint Interrupt Enable
 217      =1  #define OUT1INT  0x04 ///< USB0 OUT Endpoint Interrupt       
 218      =1  #define POWER    0x01 ///< USB0 Power                        
 219      =1  
 220      =1  //------------------------------------------------------------------------------
 221      =1  // Bit Definitions
 222      =1  //------------------------------------------------------------------------------
 223      =1  
 224      =1  // ACC (Accumulator)
 225      =1  #define SFR_ACC 0xE0
 226      =1  SI_SBIT (ACC_ACC0, SFR_ACC, 0); ///< Accumulator Bit 0
 227      =1  SI_SBIT (ACC_ACC1, SFR_ACC, 1); ///< Accumulator Bit 1
 228      =1  SI_SBIT (ACC_ACC2, SFR_ACC, 2); ///< Accumulator Bit 2
 229      =1  SI_SBIT (ACC_ACC3, SFR_ACC, 3); ///< Accumulator Bit 3
 230      =1  SI_SBIT (ACC_ACC4, SFR_ACC, 4); ///< Accumulator Bit 4
 231      =1  SI_SBIT (ACC_ACC5, SFR_ACC, 5); ///< Accumulator Bit 5
 232      =1  SI_SBIT (ACC_ACC6, SFR_ACC, 6); ///< Accumulator Bit 6
 233      =1  SI_SBIT (ACC_ACC7, SFR_ACC, 7); ///< Accumulator Bit 7
 234      =1  
 235      =1  // ADC0CN0 (ADC0 Control)
 236      =1  #define SFR_ADC0CN0 0xE8
 237      =1  SI_SBIT (ADC0CN0_ADCM0,  SFR_ADC0CN0, 0); ///< Start of Conversion Mode Select Bit 0
 238      =1  SI_SBIT (ADC0CN0_ADCM1,  SFR_ADC0CN0, 1); ///< Start of Conversion Mode Select Bit 1
 239      =1  SI_SBIT (ADC0CN0_ADCM2,  SFR_ADC0CN0, 2); ///< Start of Conversion Mode Select Bit 2
 240      =1  SI_SBIT (ADC0CN0_ADWINT, SFR_ADC0CN0, 3); ///< Window Compare Interrupt Flag        
 241      =1  SI_SBIT (ADC0CN0_ADBUSY, SFR_ADC0CN0, 4); ///< ADC Busy                             
 242      =1  SI_SBIT (ADC0CN0_ADINT,  SFR_ADC0CN0, 5); ///< Conversion Complete Interrupt Flag   
 243      =1  SI_SBIT (ADC0CN0_ADTM,   SFR_ADC0CN0, 6); ///< Track Mode                           
 244      =1  SI_SBIT (ADC0CN0_ADEN,   SFR_ADC0CN0, 7); ///< ADC Enable                           
 245      =1  
 246      =1  // B (B Register)
 247      =1  #define SFR_B 0xF0
 248      =1  SI_SBIT (B_B0, SFR_B, 0); ///< B Register Bit 0
 249      =1  SI_SBIT (B_B1, SFR_B, 1); ///< B Register Bit 1
 250      =1  SI_SBIT (B_B2, SFR_B, 2); ///< B Register Bit 2
 251      =1  SI_SBIT (B_B3, SFR_B, 3); ///< B Register Bit 3
 252      =1  SI_SBIT (B_B4, SFR_B, 4); ///< B Register Bit 4
 253      =1  SI_SBIT (B_B5, SFR_B, 5); ///< B Register Bit 5
 254      =1  SI_SBIT (B_B6, SFR_B, 6); ///< B Register Bit 6
 255      =1  SI_SBIT (B_B7, SFR_B, 7); ///< B Register Bit 7
 256      =1  
 257      =1  // IE (Interrupt Enable)
 258      =1  #define SFR_IE 0xA8
 259      =1  SI_SBIT (IE_EX0,   SFR_IE, 0); ///< External Interrupt 0 Enable
 260      =1  SI_SBIT (IE_ET0,   SFR_IE, 1); ///< Timer 0 Interrupt Enable   
 261      =1  SI_SBIT (IE_EX1,   SFR_IE, 2); ///< External Interrupt 1 Enable
C51 COMPILER V9.56.0.0   SPI_0                                                             10/28/2016 17:37:02 PAGE 16  

 262      =1  SI_SBIT (IE_ET1,   SFR_IE, 3); ///< Timer 1 Interrupt Enable   
 263      =1  SI_SBIT (IE_ES0,   SFR_IE, 4); ///< UART0 Interrupt Enable     
 264      =1  SI_SBIT (IE_ET2,   SFR_IE, 5); ///< Timer 2 Interrupt Enable   
 265      =1  SI_SBIT (IE_ESPI0, SFR_IE, 6); ///< SPI0 Interrupt Enable      
 266      =1  SI_SBIT (IE_EA,    SFR_IE, 7); ///< All Interrupts Enable      
 267      =1  
 268      =1  // IP (Interrupt Priority)
 269      =1  #define SFR_IP 0xB8
 270      =1  SI_SBIT (IP_PX0,   SFR_IP, 0); ///< External Interrupt 0 Priority Control                        
 271      =1  SI_SBIT (IP_PT0,   SFR_IP, 1); ///< Timer 0 Interrupt Priority Control                           
 272      =1  SI_SBIT (IP_PX1,   SFR_IP, 2); ///< External Interrupt 1 Priority Control                        
 273      =1  SI_SBIT (IP_PT1,   SFR_IP, 3); ///< Timer 1 Interrupt Priority Control                           
 274      =1  SI_SBIT (IP_PS0,   SFR_IP, 4); ///< UART0 Interrupt Priority Control                             
 275      =1  SI_SBIT (IP_PT2,   SFR_IP, 5); ///< Timer 2 Interrupt Priority Control                           
 276      =1  SI_SBIT (IP_PSPI0, SFR_IP, 6); ///< Serial Peripheral Interface (SPI0) Interrupt Priority Control
 277      =1  
 278      =1  // P0 (Port 0 Pin Latch)
 279      =1  #define SFR_P0 0x80
 280      =1  SI_SBIT (P0_B0, SFR_P0, 0); ///< Port 0 Bit 0 Latch
 281      =1  SI_SBIT (P0_B1, SFR_P0, 1); ///< Port 0 Bit 1 Latch
 282      =1  SI_SBIT (P0_B2, SFR_P0, 2); ///< Port 0 Bit 2 Latch
 283      =1  SI_SBIT (P0_B3, SFR_P0, 3); ///< Port 0 Bit 3 Latch
 284      =1  SI_SBIT (P0_B4, SFR_P0, 4); ///< Port 0 Bit 4 Latch
 285      =1  SI_SBIT (P0_B5, SFR_P0, 5); ///< Port 0 Bit 5 Latch
 286      =1  SI_SBIT (P0_B6, SFR_P0, 6); ///< Port 0 Bit 6 Latch
 287      =1  SI_SBIT (P0_B7, SFR_P0, 7); ///< Port 0 Bit 7 Latch
 288      =1  
 289      =1  // P1 (Port 1 Pin Latch)
 290      =1  #define SFR_P1 0x90
 291      =1  SI_SBIT (P1_B0, SFR_P1, 0); ///< Port 1 Bit 0 Latch
 292      =1  SI_SBIT (P1_B1, SFR_P1, 1); ///< Port 1 Bit 1 Latch
 293      =1  SI_SBIT (P1_B2, SFR_P1, 2); ///< Port 1 Bit 2 Latch
 294      =1  SI_SBIT (P1_B3, SFR_P1, 3); ///< Port 1 Bit 3 Latch
 295      =1  SI_SBIT (P1_B4, SFR_P1, 4); ///< Port 1 Bit 4 Latch
 296      =1  SI_SBIT (P1_B5, SFR_P1, 5); ///< Port 1 Bit 5 Latch
 297      =1  SI_SBIT (P1_B6, SFR_P1, 6); ///< Port 1 Bit 6 Latch
 298      =1  SI_SBIT (P1_B7, SFR_P1, 7); ///< Port 1 Bit 7 Latch
 299      =1  
 300      =1  // P2 (Port 2 Pin Latch)
 301      =1  #define SFR_P2 0xA0
 302      =1  SI_SBIT (P2_B0, SFR_P2, 0); ///< Port 2 Bit 0 Latch
 303      =1  SI_SBIT (P2_B1, SFR_P2, 1); ///< Port 2 Bit 1 Latch
 304      =1  SI_SBIT (P2_B2, SFR_P2, 2); ///< Port 2 Bit 2 Latch
 305      =1  SI_SBIT (P2_B3, SFR_P2, 3); ///< Port 2 Bit 3 Latch
 306      =1  SI_SBIT (P2_B4, SFR_P2, 4); ///< Port 2 Bit 4 Latch
 307      =1  SI_SBIT (P2_B5, SFR_P2, 5); ///< Port 2 Bit 5 Latch
 308      =1  SI_SBIT (P2_B6, SFR_P2, 6); ///< Port 2 Bit 6 Latch
 309      =1  SI_SBIT (P2_B7, SFR_P2, 7); ///< Port 2 Bit 7 Latch
 310      =1  
 311      =1  // P3 (Port 3 Pin Latch)
 312      =1  #define SFR_P3 0xB0
 313      =1  SI_SBIT (P3_B0, SFR_P3, 0); ///< Port 3 Bit 0 Latch
 314      =1  SI_SBIT (P3_B1, SFR_P3, 1); ///< Port 3 Bit 1 Latch
 315      =1  SI_SBIT (P3_B2, SFR_P3, 2); ///< Port 3 Bit 2 Latch
 316      =1  SI_SBIT (P3_B3, SFR_P3, 3); ///< Port 3 Bit 3 Latch
 317      =1  SI_SBIT (P3_B4, SFR_P3, 4); ///< Port 3 Bit 4 Latch
 318      =1  SI_SBIT (P3_B5, SFR_P3, 5); ///< Port 3 Bit 5 Latch
 319      =1  SI_SBIT (P3_B6, SFR_P3, 6); ///< Port 3 Bit 6 Latch
 320      =1  SI_SBIT (P3_B7, SFR_P3, 7); ///< Port 3 Bit 7 Latch
 321      =1  
 322      =1  // PCA0CN0 (PCA Control 0)
 323      =1  #define SFR_PCA0CN0 0xD8
C51 COMPILER V9.56.0.0   SPI_0                                                             10/28/2016 17:37:02 PAGE 17  

 324      =1  SI_SBIT (PCA0CN0_CCF0, SFR_PCA0CN0, 0); ///< PCA Module 0 Capture/Compare Flag
 325      =1  SI_SBIT (PCA0CN0_CCF1, SFR_PCA0CN0, 1); ///< PCA Module 1 Capture/Compare Flag
 326      =1  SI_SBIT (PCA0CN0_CCF2, SFR_PCA0CN0, 2); ///< PCA Module 2 Capture/Compare Flag
 327      =1  SI_SBIT (PCA0CN0_CCF3, SFR_PCA0CN0, 3); ///< PCA Module 3 Capture/Compare Flag
 328      =1  SI_SBIT (PCA0CN0_CCF4, SFR_PCA0CN0, 4); ///< PCA Module 4 Capture/Compare Flag
 329      =1  SI_SBIT (PCA0CN0_CR,   SFR_PCA0CN0, 6); ///< PCA Counter/Timer Run Control    
 330      =1  SI_SBIT (PCA0CN0_CF,   SFR_PCA0CN0, 7); ///< PCA Counter/Timer Overflow Flag  
 331      =1  
 332      =1  // PSW (Program Status Word)
 333      =1  #define SFR_PSW 0xD0
 334      =1  SI_SBIT (PSW_PARITY, SFR_PSW, 0); ///< Parity Flag               
 335      =1  SI_SBIT (PSW_F1,     SFR_PSW, 1); ///< User Flag 1               
 336      =1  SI_SBIT (PSW_OV,     SFR_PSW, 2); ///< Overflow Flag             
 337      =1  SI_SBIT (PSW_RS0,    SFR_PSW, 3); ///< Register Bank Select Bit 0
 338      =1  SI_SBIT (PSW_RS1,    SFR_PSW, 4); ///< Register Bank Select Bit 1
 339      =1  SI_SBIT (PSW_F0,     SFR_PSW, 5); ///< User Flag 0               
 340      =1  SI_SBIT (PSW_AC,     SFR_PSW, 6); ///< Auxiliary Carry Flag      
 341      =1  SI_SBIT (PSW_CY,     SFR_PSW, 7); ///< Carry Flag                
 342      =1  
 343      =1  // SCON0 (UART0 Serial Port Control)
 344      =1  #define SFR_SCON0 0x98
 345      =1  SI_SBIT (SCON0_RI,    SFR_SCON0, 0); ///< Receive Interrupt Flag             
 346      =1  SI_SBIT (SCON0_TI,    SFR_SCON0, 1); ///< Transmit Interrupt Flag            
 347      =1  SI_SBIT (SCON0_RB8,   SFR_SCON0, 2); ///< Ninth Receive Bit                  
 348      =1  SI_SBIT (SCON0_TB8,   SFR_SCON0, 3); ///< Ninth Transmission Bit             
 349      =1  SI_SBIT (SCON0_REN,   SFR_SCON0, 4); ///< Receive Enable                     
 350      =1  SI_SBIT (SCON0_MCE,   SFR_SCON0, 5); ///< Multiprocessor Communication Enable
 351      =1  SI_SBIT (SCON0_SMODE, SFR_SCON0, 7); ///< Serial Port 0 Operation Mode       
 352      =1  
 353      =1  // SMB0CN0 (SMBus 0 Control)
 354      =1  #define SFR_SMB0CN0 0xC0
 355      =1  SI_SBIT (SMB0CN0_SI,      SFR_SMB0CN0, 0); ///< SMBus Interrupt Flag            
 356      =1  SI_SBIT (SMB0CN0_ACK,     SFR_SMB0CN0, 1); ///< SMBus Acknowledge               
 357      =1  SI_SBIT (SMB0CN0_ARBLOST, SFR_SMB0CN0, 2); ///< SMBus Arbitration Lost Indicator
 358      =1  SI_SBIT (SMB0CN0_ACKRQ,   SFR_SMB0CN0, 3); ///< SMBus Acknowledge Request       
 359      =1  SI_SBIT (SMB0CN0_STO,     SFR_SMB0CN0, 4); ///< SMBus Stop Flag                 
 360      =1  SI_SBIT (SMB0CN0_STA,     SFR_SMB0CN0, 5); ///< SMBus Start Flag                
 361      =1  SI_SBIT (SMB0CN0_TXMODE,  SFR_SMB0CN0, 6); ///< SMBus Transmit Mode Indicator   
 362      =1  SI_SBIT (SMB0CN0_MASTER,  SFR_SMB0CN0, 7); ///< SMBus Master/Slave Indicator    
 363      =1  
 364      =1  // SMB1CN0 (SMBus 1 Control)
 365      =1  #define SFR_SMB1CN0 0xC0
 366      =1  SI_SBIT (SMB1CN0_SI,      SFR_SMB1CN0, 0); ///< SMBus Interrupt Flag            
 367      =1  SI_SBIT (SMB1CN0_ACK,     SFR_SMB1CN0, 1); ///< SMBus Acknowledge               
 368      =1  SI_SBIT (SMB1CN0_ARBLOST, SFR_SMB1CN0, 2); ///< SMBus Arbitration Lost Indicator
 369      =1  SI_SBIT (SMB1CN0_ACKRQ,   SFR_SMB1CN0, 3); ///< SMBus Acknowledge Request       
 370      =1  SI_SBIT (SMB1CN0_STO,     SFR_SMB1CN0, 4); ///< SMBus Stop Flag                 
 371      =1  SI_SBIT (SMB1CN0_STA,     SFR_SMB1CN0, 5); ///< SMBus Start Flag                
 372      =1  SI_SBIT (SMB1CN0_TXMODE,  SFR_SMB1CN0, 6); ///< SMBus Transmit Mode Indicator   
 373      =1  SI_SBIT (SMB1CN0_MASTER,  SFR_SMB1CN0, 7); ///< SMBus Master/Slave Indicator    
 374      =1  
 375      =1  // SPI0CN0 (SPI0 Control)
 376      =1  #define SFR_SPI0CN0 0xF8
 377      =1  SI_SBIT (SPI0CN0_SPIEN,  SFR_SPI0CN0, 0); ///< SPI0 Enable            
 378      =1  SI_SBIT (SPI0CN0_TXBMT,  SFR_SPI0CN0, 1); ///< Transmit Buffer Empty  
 379      =1  SI_SBIT (SPI0CN0_NSSMD0, SFR_SPI0CN0, 2); ///< Slave Select Mode Bit 0
 380      =1  SI_SBIT (SPI0CN0_NSSMD1, SFR_SPI0CN0, 3); ///< Slave Select Mode Bit 1
 381      =1  SI_SBIT (SPI0CN0_RXOVRN, SFR_SPI0CN0, 4); ///< Receive Overrun Flag   
 382      =1  SI_SBIT (SPI0CN0_MODF,   SFR_SPI0CN0, 5); ///< Mode Fault Flag        
 383      =1  SI_SBIT (SPI0CN0_WCOL,   SFR_SPI0CN0, 6); ///< Write Collision Flag   
 384      =1  SI_SBIT (SPI0CN0_SPIF,   SFR_SPI0CN0, 7); ///< SPI0 Interrupt Flag    
 385      =1  
C51 COMPILER V9.56.0.0   SPI_0                                                             10/28/2016 17:37:02 PAGE 18  

 386      =1  // TCON (Timer 0/1 Control)
 387      =1  #define SFR_TCON 0x88
 388      =1  SI_SBIT (TCON_IT0, SFR_TCON, 0); ///< Interrupt 0 Type Select
 389      =1  SI_SBIT (TCON_IE0, SFR_TCON, 1); ///< External Interrupt 0   
 390      =1  SI_SBIT (TCON_IT1, SFR_TCON, 2); ///< Interrupt 1 Type Select
 391      =1  SI_SBIT (TCON_IE1, SFR_TCON, 3); ///< External Interrupt 1   
 392      =1  SI_SBIT (TCON_TR0, SFR_TCON, 4); ///< Timer 0 Run Control    
 393      =1  SI_SBIT (TCON_TF0, SFR_TCON, 5); ///< Timer 0 Overflow Flag  
 394      =1  SI_SBIT (TCON_TR1, SFR_TCON, 6); ///< Timer 1 Run Control    
 395      =1  SI_SBIT (TCON_TF1, SFR_TCON, 7); ///< Timer 1 Overflow Flag  
 396      =1  
 397      =1  // TMR2CN0 (Timer 2 Control 0)
 398      =1  #define SFR_TMR2CN0 0xC8
 399      =1  SI_SBIT (TMR2CN0_T2XCLK,  SFR_TMR2CN0, 0); ///< Timer 2 External Clock Select    
 400      =1  SI_SBIT (TMR2CN0_T2CSS,   SFR_TMR2CN0, 1); ///< Timer 2 Capture Source Select    
 401      =1  SI_SBIT (TMR2CN0_TR2,     SFR_TMR2CN0, 2); ///< Timer 2 Run Control              
 402      =1  SI_SBIT (TMR2CN0_T2SPLIT, SFR_TMR2CN0, 3); ///< Timer 2 Split Mode Enable        
 403      =1  SI_SBIT (TMR2CN0_TF2CEN,  SFR_TMR2CN0, 4); ///< Timer 2 Capture Enable           
 404      =1  SI_SBIT (TMR2CN0_TF2LEN,  SFR_TMR2CN0, 5); ///< Timer 2 Low Byte Interrupt Enable
 405      =1  SI_SBIT (TMR2CN0_TF2L,    SFR_TMR2CN0, 6); ///< Timer 2 Low Byte Overflow Flag   
 406      =1  SI_SBIT (TMR2CN0_TF2H,    SFR_TMR2CN0, 7); ///< Timer 2 High Byte Overflow Flag  
 407      =1  
 408      =1  // TMR5CN0 (Timer 5 Control 0)
 409      =1  #define SFR_TMR5CN0 0xC8
 410      =1  SI_SBIT (TMR5CN0_T5XCLK,  SFR_TMR5CN0, 0); ///< Timer 5 External Clock Select    
 411      =1  SI_SBIT (TMR5CN0_TR5,     SFR_TMR5CN0, 2); ///< Timer 5 Run Control              
 412      =1  SI_SBIT (TMR5CN0_T5SPLIT, SFR_TMR5CN0, 3); ///< Timer 5 Split Mode Enable        
 413      =1  SI_SBIT (TMR5CN0_TF5LEN,  SFR_TMR5CN0, 5); ///< Timer 5 Low Byte Interrupt Enable
 414      =1  SI_SBIT (TMR5CN0_TF5L,    SFR_TMR5CN0, 6); ///< Timer 5 Low Byte Overflow Flag   
 415      =1  SI_SBIT (TMR5CN0_TF5H,    SFR_TMR5CN0, 7); ///< Timer 5 High Byte Overflow Flag  
 416      =1  
 417      =1  //------------------------------------------------------------------------------
 418      =1  // Interrupt Definitions
 419      =1  //------------------------------------------------------------------------------
 420      =1  #define INT0_IRQn    0  ///< External Interrupt 0  
 421      =1  #define TIMER0_IRQn  1  ///< Timer 0 Overflow      
 422      =1  #define INT1_IRQn    2  ///< External Interrupt 1  
 423      =1  #define TIMER1_IRQn  3  ///< Timer 1 Overflow      
 424      =1  #define UART0_IRQn   4  ///< UART 0                
 425      =1  #define TIMER2_IRQn  5  ///< Timer 2 Overflow      
 426      =1  #define SPI0_IRQn    6  ///< SPI0                  
 427      =1  #define SMBUS0_IRQn  7  ///< SMBus 0               
 428      =1  #define USB0_IRQn    8  ///< USB0                  
 429      =1  #define ADC0WC_IRQn  9  ///< ADC0 Window Compare   
 430      =1  #define ADC0EOC_IRQn 10 ///< ADC0 End of Conversion
 431      =1  #define PCA0_IRQn    11 ///< PCA0                  
 432      =1  #define CMP0_IRQn    12 ///< Comparator 0          
 433      =1  #define CMP1_IRQn    13 ///< Comparator 1          
 434      =1  #define TIMER3_IRQn  14 ///< Timer 3 Overflow      
 435      =1  #define VBUSLVL_IRQn 15 ///< VBUS Level            
 436      =1  #define UART1_IRQn   16 ///< UART 1                
 437      =1  #define SMBUS1_IRQn  18 ///< SMBus 1               
 438      =1  #define TIMER4_IRQn  19 ///< Timer 4 Overflow      
 439      =1  #define TIMER5_IRQn  20 ///< Timer 5 Overflow      
 440      =1  
 441      =1  //------------------------------------------------------------------------------
 442      =1  // SFR Page Definitions
 443      =1  //------------------------------------------------------------------------------
 444      =1  #define LEGACY_PAGE 0x00 ///< Legacy SFR Page                   
 445      =1  #define CONFIG_PAGE 0x0F ///< System and Port Configuration Page
 446      =1  #define SMB1_PAGE   0x0F ///< SMBus 1 Page                      
 447      =1  
C51 COMPILER V9.56.0.0   SPI_0                                                             10/28/2016 17:37:02 PAGE 19  

 448      =1  //-----------------------------------------------------------------------------
 449      =1  // SDCC PDATA External Memory Paging Support
 450      =1  //-----------------------------------------------------------------------------
 451      =1  
 452      =1  #if defined SDCC
           =1 
           =1 SI_SFR(_XPAGE, 0xAA); // Point to the EMI0CN register
           =1 
           =1 #endif
 457      =1  
 458      =1  #endif // SI_EFM8UB2_DEFS_H
 459      =1  //-eof--------------------------------------------------------------------------
 460      =1  
   8          #include "SI_EFM8UB2_Register_Enums.h"
   1      =1  //------------------------------------------------------------------------------
   2      =1  // Copyright 2014 Silicon Laboratories, Inc.
   3      =1  // All rights reserved. This program and the accompanying materials
   4      =1  // are made available under the terms of the Silicon Laboratories End User
   5      =1  // License Agreement which accompanies this distribution, and is available at
   6      =1  // http://developer.silabs.com/legal/version/v11/Silicon_Labs_Software_License_Agreement.txt
   7      =1  // Original content and implementation provided by Silicon Laboratories.
   8      =1  //------------------------------------------------------------------------------
   9      =1  //Supported Devices:
  10      =1  //  EFM8UB20F32G_QFN32
  11      =1  //  EFM8UB20F32G_QFP32
  12      =1  //  EFM8UB20F32G_QFP48
  13      =1  //  EFM8UB20F64G_QFN32
  14      =1  //  EFM8UB20F64G_QFP32
  15      =1  //  EFM8UB20F64G_QFP48
  16      =1  
  17      =1  #ifndef SI_EFM8UB2_REGISTER_ENUMS_H
  18      =1  #define SI_EFM8UB2_REGISTER_ENUMS_H
  19      =1  
  20      =1  //Standard device includes
  21      =1  #include "SI_EFM8UB2_Defs.h"
   1      =2  //------------------------------------------------------------------------------
   2      =2  // Copyright 2014 Silicon Laboratories, Inc.
   3      =2  // All rights reserved. This program and the accompanying materials
   4      =2  // are made available under the terms of the Silicon Laboratories End User
   5      =2  // License Agreement which accompanies this distribution, and is available at
   6      =2  // http://developer.silabs.com/legal/version/v11/Silicon_Labs_Software_License_Agreement.txt
   7      =2  // Original content and implementation provided by Silicon Laboratories.
   8      =2  //------------------------------------------------------------------------------
   9      =2  //Supported Devices:
  10      =2  //  EFM8UB20F32G_QFN32
  11      =2  //  EFM8UB20F32G_QFP32
  12      =2  //  EFM8UB20F32G_QFP48
  13      =2  //  EFM8UB20F64G_QFN32
  14      =2  //  EFM8UB20F64G_QFP32
  15      =2  //  EFM8UB20F64G_QFP48
  16      =2  
  17      =2  #ifndef SI_EFM8UB2_DEFS_H
           =2 #define SI_EFM8UB2_DEFS_H
           =2 
           =2 #include <si_toolchain.h>
           =2 
           =2 //-----------------------------------------------------------------------------
           =2 // Register Definitions
           =2 //-----------------------------------------------------------------------------
           =2 SI_SFR (ACC,      0xE0); ///< Accumulator                           
           =2 SI_SFR (ADC0CF,   0xBC); ///< ADC0 Configuration                    
           =2 SI_SFR (ADC0CN0,  0xE8); ///< ADC0 Control                          
C51 COMPILER V9.56.0.0   SPI_0                                                             10/28/2016 17:37:02 PAGE 20  

           =2 SI_SFR (ADC0GTH,  0xC4); ///< ADC0 Greater-Than High Byte           
           =2 SI_SFR (ADC0GTL,  0xC3); ///< ADC0 Greater-Than Low Byte            
           =2 SI_SFR (ADC0H,    0xBE); ///< ADC0 Data Word High Byte              
           =2 SI_SFR (ADC0L,    0xBD); ///< ADC0 Data Word Low Byte               
           =2 SI_SFR (ADC0LTH,  0xC6); ///< ADC0 Less-Than High Byte              
           =2 SI_SFR (ADC0LTL,  0xC5); ///< ADC0 Less-Than Low Byte               
           =2 SI_SFR (AMX0N,    0xBA); ///< AMUX0 Negative Multiplexer Selection  
           =2 SI_SFR (AMX0P,    0xBB); ///< AMUX0 Positive Multiplexer Selection  
           =2 SI_SFR (B,        0xF0); ///< B Register                            
           =2 SI_SFR (CKCON0,   0x8E); ///< Clock Control 0                       
           =2 SI_SFR (CKCON1,   0xE4); ///< Clock Control 1                       
           =2 SI_SFR (CLKSEL,   0xA9); ///< Clock Select                          
           =2 SI_SFR (CMP0CN0,  0x9B); ///< Comparator 0 Control 0                
           =2 SI_SFR (CMP0MD,   0x9D); ///< Comparator 0 Mode                     
           =2 SI_SFR (CMP0MX,   0x9F); ///< Comparator 0 Multiplexer Selection    
           =2 SI_SFR (CMP1CN0,  0x9A); ///< Comparator 1 Control 0                
           =2 SI_SFR (CMP1MD,   0x9C); ///< Comparator 1 Mode                     
           =2 SI_SFR (CMP1MX,   0x9E); ///< Comparator 1 Multiplexer Selection    
           =2 SI_SFR (DPH,      0x83); ///< Data Pointer High                     
           =2 SI_SFR (DPL,      0x82); ///< Data Pointer Low                      
           =2 SI_SFR (EIE1,     0xE6); ///< Extended Interrupt Enable 1           
           =2 SI_SFR (EIE2,     0xE7); ///< Extended Interrupt Enable 2           
           =2 SI_SFR (EIP1,     0xF6); ///< Extended Interrupt Priority 1         
           =2 SI_SFR (EIP2,     0xF7); ///< Extended Interrupt Priority 2         
           =2 SI_SFR (EMI0CF,   0x85); ///< External Memory Configuration         
           =2 SI_SFR (EMI0CN,   0xAA); ///< External Memory Interface Control     
           =2 SI_SFR (EMI0TC,   0x84); ///< External Memory Timing Control        
           =2 SI_SFR (FLKEY,    0xB7); ///< Flash Lock and Key                    
           =2 SI_SFR (FLSCL,    0xB6); ///< Flash Scale                           
           =2 SI_SFR (HFO0CAL,  0xB3); ///< High Frequency Oscillator Calibration 
           =2 SI_SFR (HFO0CN,   0xB2); ///< High Frequency Oscillator Control     
           =2 SI_SFR (IE,       0xA8); ///< Interrupt Enable                      
           =2 SI_SFR (IP,       0xB8); ///< Interrupt Priority                    
           =2 SI_SFR (IT01CF,   0xE4); ///< INT0/INT1 Configuration               
           =2 SI_SFR (LFO0CN,   0x86); ///< Low Frequency Oscillator Control      
           =2 SI_SFR (P0,       0x80); ///< Port 0 Pin Latch                      
           =2 SI_SFR (P0MDIN,   0xF1); ///< Port 0 Input Mode                     
           =2 SI_SFR (P0MDOUT,  0xA4); ///< Port 0 Output Mode                    
           =2 SI_SFR (P0SKIP,   0xD4); ///< Port 0 Skip                           
           =2 SI_SFR (P1,       0x90); ///< Port 1 Pin Latch                      
           =2 SI_SFR (P1MDIN,   0xF2); ///< Port 1 Input Mode                     
           =2 SI_SFR (P1MDOUT,  0xA5); ///< Port 1 Output Mode                    
           =2 SI_SFR (P1SKIP,   0xD5); ///< Port 1 Skip                           
           =2 SI_SFR (P2,       0xA0); ///< Port 2 Pin Latch                      
           =2 SI_SFR (P2MDIN,   0xF3); ///< Port 2 Input Mode                     
           =2 SI_SFR (P2MDOUT,  0xA6); ///< Port 2 Output Mode                    
           =2 SI_SFR (P2SKIP,   0xD6); ///< Port 2 Skip                           
           =2 SI_SFR (P3,       0xB0); ///< Port 3 Pin Latch                      
           =2 SI_SFR (P3MDIN,   0xF4); ///< Port 3 Input Mode                     
           =2 SI_SFR (P3MDOUT,  0xA7); ///< Port 3 Output Mode                    
           =2 SI_SFR (P3SKIP,   0xDF); ///< Port 3 Skip                           
           =2 SI_SFR (P4,       0xC7); ///< Port 4 Pin Latch                      
           =2 SI_SFR (P4MDIN,   0xF5); ///< Port 4 Input Mode                     
           =2 SI_SFR (P4MDOUT,  0xAE); ///< Port 4 Output Mode                    
           =2 SI_SFR (PCA0CN0,  0xD8); ///< PCA Control 0                         
           =2 SI_SFR (PCA0CPH0, 0xFC); ///< PCA Channel 0 Capture Module High Byte
           =2 SI_SFR (PCA0CPH1, 0xEA); ///< PCA Channel 1 Capture Module High Byte
           =2 SI_SFR (PCA0CPH2, 0xEC); ///< PCA Channel 2 Capture Module High Byte
           =2 SI_SFR (PCA0CPH3, 0xEE); ///< PCA Channel 3 Capture Module High Byte
           =2 SI_SFR (PCA0CPH4, 0xFE); ///< PCA Channel 4 Capture Module High Byte
           =2 SI_SFR (PCA0CPL0, 0xFB); ///< PCA Channel 0 Capture Module Low Byte 
           =2 SI_SFR (PCA0CPL1, 0xE9); ///< PCA Channel 1 Capture Module Low Byte 
C51 COMPILER V9.56.0.0   SPI_0                                                             10/28/2016 17:37:02 PAGE 21  

           =2 SI_SFR (PCA0CPL2, 0xEB); ///< PCA Channel 2 Capture Module Low Byte 
           =2 SI_SFR (PCA0CPL3, 0xED); ///< PCA Channel 3 Capture Module Low Byte 
           =2 SI_SFR (PCA0CPL4, 0xFD); ///< PCA Channel 4 Capture Module Low Byte 
           =2 SI_SFR (PCA0CPM0, 0xDA); ///< PCA Channel 0 Capture/Compare Mode    
           =2 SI_SFR (PCA0CPM1, 0xDB); ///< PCA Channel 1 Capture/Compare Mode    
           =2 SI_SFR (PCA0CPM2, 0xDC); ///< PCA Channel 2 Capture/Compare Mode    
           =2 SI_SFR (PCA0CPM3, 0xDD); ///< PCA Channel 3 Capture/Compare Mode    
           =2 SI_SFR (PCA0CPM4, 0xDE); ///< PCA Channel 4 Capture/Compare Mode    
           =2 SI_SFR (PCA0H,    0xFA); ///< PCA Counter/Timer High Byte           
           =2 SI_SFR (PCA0L,    0xF9); ///< PCA Counter/Timer Low Byte            
           =2 SI_SFR (PCA0MD,   0xD9); ///< PCA Mode                              
           =2 SI_SFR (PCON0,    0x87); ///< Power Control                         
           =2 SI_SFR (PFE0CN,   0xAF); ///< Prefetch Engine Control               
           =2 SI_SFR (PSCTL,    0x8F); ///< Program Store Control                 
           =2 SI_SFR (PSW,      0xD0); ///< Program Status Word                   
           =2 SI_SFR (REF0CN,   0xD1); ///< Voltage Reference Control             
           =2 SI_SFR (REG01CN,  0xC9); ///< Voltage Regulator Control             
           =2 SI_SFR (RSTSRC,   0xEF); ///< Reset Source                          
           =2 SI_SFR (SBCON1,   0xAC); ///< UART1 Baud Rate Generator Control     
           =2 SI_SFR (SBRLH1,   0xB5); ///< UART1 Baud Rate Generator High Byte   
           =2 SI_SFR (SBRLL1,   0xB4); ///< UART1 Baud Rate Generator Low Byte    
           =2 SI_SFR (SBUF0,    0x99); ///< UART0 Serial Port Data Buffer         
           =2 SI_SFR (SBUF1,    0xD3); ///< UART1 Serial Port Data Buffer         
           =2 SI_SFR (SCON0,    0x98); ///< UART0 Serial Port Control             
           =2 SI_SFR (SCON1,    0xD2); ///< UART1 Serial Port Control             
           =2 SI_SFR (SFRPAGE,  0xBF); ///< SFR Page                              
           =2 SI_SFR (SMB0ADM,  0xCE); ///< SMBus 0 Slave Address Mask            
           =2 SI_SFR (SMB0ADR,  0xCF); ///< SMBus 0 Slave Address                 
           =2 SI_SFR (SMB0CF,   0xC1); ///< SMBus 0 Configuration                 
           =2 SI_SFR (SMB0CN0,  0xC0); ///< SMBus 0 Control                       
           =2 SI_SFR (SMB0DAT,  0xC2); ///< SMBus 0 Data                          
           =2 SI_SFR (SMB1ADM,  0xCE); ///< SMBus 1 Slave Address Mask            
           =2 SI_SFR (SMB1ADR,  0xCF); ///< SMBus 1 Slave Address                 
           =2 SI_SFR (SMB1CF,   0xC1); ///< SMBus 1 Configuration                 
           =2 SI_SFR (SMB1CN0,  0xC0); ///< SMBus 1 Control                       
           =2 SI_SFR (SMB1DAT,  0xC2); ///< SMBus 1 Data                          
           =2 SI_SFR (SMBTC,    0xB9); ///< SMBus Timing and Pin Control          
           =2 SI_SFR (SMOD1,    0xE5); ///< UART1 Mode                            
           =2 SI_SFR (SP,       0x81); ///< Stack Pointer                         
           =2 SI_SFR (SPI0CFG,  0xA1); ///< SPI0 Configuration                    
           =2 SI_SFR (SPI0CKR,  0xA2); ///< SPI0 Clock Rate                       
           =2 SI_SFR (SPI0CN0,  0xF8); ///< SPI0 Control                          
           =2 SI_SFR (SPI0DAT,  0xA3); ///< SPI0 Data                             
           =2 SI_SFR (TCON,     0x88); ///< Timer 0/1 Control                     
           =2 SI_SFR (TH0,      0x8C); ///< Timer 0 High Byte                     
           =2 SI_SFR (TH1,      0x8D); ///< Timer 1 High Byte                     
           =2 SI_SFR (TL0,      0x8A); ///< Timer 0 Low Byte                      
           =2 SI_SFR (TL1,      0x8B); ///< Timer 1 Low Byte                      
           =2 SI_SFR (TMOD,     0x89); ///< Timer 0/1 Mode                        
           =2 SI_SFR (TMR2CN0,  0xC8); ///< Timer 2 Control 0                     
           =2 SI_SFR (TMR2H,    0xCD); ///< Timer 2 High Byte                     
           =2 SI_SFR (TMR2L,    0xCC); ///< Timer 2 Low Byte                      
           =2 SI_SFR (TMR2RLH,  0xCB); ///< Timer 2 Reload High Byte              
           =2 SI_SFR (TMR2RLL,  0xCA); ///< Timer 2 Reload Low Byte               
           =2 SI_SFR (TMR3CN0,  0x91); ///< Timer 3 Control 0                     
           =2 SI_SFR (TMR3H,    0x95); ///< Timer 3 High Byte                     
           =2 SI_SFR (TMR3L,    0x94); ///< Timer 3 Low Byte                      
           =2 SI_SFR (TMR3RLH,  0x93); ///< Timer 3 Reload High Byte              
           =2 SI_SFR (TMR3RLL,  0x92); ///< Timer 3 Reload Low Byte               
           =2 SI_SFR (TMR4CN0,  0x91); ///< Timer 4 Control 0                     
           =2 SI_SFR (TMR4H,    0x95); ///< Timer 4 High Byte                     
           =2 SI_SFR (TMR4L,    0x94); ///< Timer 4 Low Byte                      
C51 COMPILER V9.56.0.0   SPI_0                                                             10/28/2016 17:37:02 PAGE 22  

           =2 SI_SFR (TMR4RLH,  0x93); ///< Timer 4 Reload High Byte              
           =2 SI_SFR (TMR4RLL,  0x92); ///< Timer 4 Reload Low Byte               
           =2 SI_SFR (TMR5CN0,  0xC8); ///< Timer 5 Control 0                     
           =2 SI_SFR (TMR5H,    0xCD); ///< Timer 5 High Byte                     
           =2 SI_SFR (TMR5L,    0xCC); ///< Timer 5 Low Byte                      
           =2 SI_SFR (TMR5RLH,  0xCB); ///< Timer 5 Reload High Byte              
           =2 SI_SFR (TMR5RLL,  0xCA); ///< Timer 5 Reload Low Byte               
           =2 SI_SFR (USB0ADR,  0x96); ///< USB0 Indirect Address                 
           =2 SI_SFR (USB0DAT,  0x97); ///< USB0 Data                             
           =2 SI_SFR (USB0XCN,  0xD7); ///< USB0 Transceiver Control              
           =2 SI_SFR (VDM0CN,   0xFF); ///< Supply Monitor Control                
           =2 SI_SFR (XBR0,     0xE1); ///< Port I/O Crossbar 0                   
           =2 SI_SFR (XBR1,     0xE2); ///< Port I/O Crossbar 1                   
           =2 SI_SFR (XBR2,     0xE3); ///< Port I/O Crossbar 2                   
           =2 SI_SFR (XOSC0CN,  0xB1); ///< External Oscillator Control           
           =2 
           =2 //------------------------------------------------------------------------------
           =2 // 16-bit Register Definitions (may not work on all compilers)
           =2 //------------------------------------------------------------------------------
           =2 SI_SFR16 (ADC0GT,  0xC3); ///< ADC0 Greater-Than            
           =2 SI_SFR16 (ADC0,    0xBD); ///< ADC0 Data Word               
           =2 SI_SFR16 (ADC0LT,  0xC5); ///< ADC0 Less-Than               
           =2 SI_SFR16 (DP,      0x82); ///< Data Pointer                 
           =2 SI_SFR16 (PCA0CP0, 0xFB); ///< PCA Channel 0 Capture Module 
           =2 SI_SFR16 (PCA0CP1, 0xE9); ///< PCA Channel 1 Capture Module 
           =2 SI_SFR16 (PCA0CP2, 0xEB); ///< PCA Channel 2 Capture Module 
           =2 SI_SFR16 (PCA0CP3, 0xED); ///< PCA Channel 3 Capture Module 
           =2 SI_SFR16 (PCA0CP4, 0xFD); ///< PCA Channel 4 Capture Module 
           =2 SI_SFR16 (PCA0,    0xF9); ///< PCA Counter/Timer            
           =2 SI_SFR16 (SBRL1,   0xB4); ///< UART1 Baud Rate Generator    
           =2 SI_SFR16 (TMR2,    0xCC); ///< Timer 2                      
           =2 SI_SFR16 (TMR2RL,  0xCA); ///< Timer 2 Reload               
           =2 SI_SFR16 (TMR3,    0x94); ///< Timer 3                      
           =2 SI_SFR16 (TMR3RL,  0x92); ///< Timer 3 Reload               
           =2 SI_SFR16 (TMR4,    0x94); ///< Timer 4                      
           =2 SI_SFR16 (TMR4RL,  0x92); ///< Timer 4 Reload               
           =2 SI_SFR16 (TMR5,    0xCC); ///< Timer 5                      
           =2 SI_SFR16 (TMR5RL,  0xCA); ///< Timer 5 Reload               
           =2 
           =2 //------------------------------------------------------------------------------
           =2 // Indirect Register Definitions
           =2 //------------------------------------------------------------------------------
           =2 #define CLKREC   0x0F ///< USB0 Clock Recovery Control       
           =2 #define CMIE     0x0B ///< USB0 Common Interrupt Enable      
           =2 #define CMINT    0x06 ///< USB0 Common Interrupt             
           =2 #define E0CNT    0x16 ///< USB0 Endpoint0 Data Count         
           =2 #define E0CSR    0x11 ///< USB0 Endpoint0 Control            
           =2 #define EENABLE  0x1E ///< USB0 Endpoint Enable              
           =2 #define EINCSRH  0x12 ///< USB0 IN Endpoint Control High     
           =2 #define EINCSRL  0x11 ///< USB0 IN Endpoint Control          
           =2 #define EOUTCNTH 0x17 ///< USB0 OUT Endpoint Count High      
           =2 #define EOUTCNTL 0x16 ///< USB0 OUT Endpoint Count           
           =2 #define EOUTCSRH 0x15 ///< USB0 OUT Endpoint Control High    
           =2 #define EOUTCSRL 0x14 ///< USB0 OUT Endpoint Control         
           =2 #define FADDR    0x00 ///< USB0 Function Address             
           =2 #define FIFO0    0x20 ///< USB0 Endpoint 0 FIFO Access       
           =2 #define FIFO1    0x21 ///< USB0 Endpoint 1 FIFO Access       
           =2 #define FIFO2    0x22 ///< USB0 Endpoint 2 FIFO Access       
           =2 #define FIFO3    0x23 ///< USB0 Endpoint 3 FIFO Access       
           =2 #define FRAMEH   0x0D ///< USB0 Frame Number High            
           =2 #define FRAMEL   0x0C ///< USB0 Frame Number                 
           =2 #define IN1IE    0x07 ///< USB0 IN Endpoint Interrupt Enable 
C51 COMPILER V9.56.0.0   SPI_0                                                             10/28/2016 17:37:02 PAGE 23  

           =2 #define IN1INT   0x02 ///< USB0 IN Endpoint Interrupt        
           =2 #define INDEX    0x0E ///< USB0 Endpoint Index               
           =2 #define OUT1IE   0x09 ///< USB0 OUT Endpoint Interrupt Enable
           =2 #define OUT1INT  0x04 ///< USB0 OUT Endpoint Interrupt       
           =2 #define POWER    0x01 ///< USB0 Power                        
           =2 
           =2 //------------------------------------------------------------------------------
           =2 // Bit Definitions
           =2 //------------------------------------------------------------------------------
           =2 
           =2 // ACC (Accumulator)
           =2 #define SFR_ACC 0xE0
           =2 SI_SBIT (ACC_ACC0, SFR_ACC, 0); ///< Accumulator Bit 0
           =2 SI_SBIT (ACC_ACC1, SFR_ACC, 1); ///< Accumulator Bit 1
           =2 SI_SBIT (ACC_ACC2, SFR_ACC, 2); ///< Accumulator Bit 2
           =2 SI_SBIT (ACC_ACC3, SFR_ACC, 3); ///< Accumulator Bit 3
           =2 SI_SBIT (ACC_ACC4, SFR_ACC, 4); ///< Accumulator Bit 4
           =2 SI_SBIT (ACC_ACC5, SFR_ACC, 5); ///< Accumulator Bit 5
           =2 SI_SBIT (ACC_ACC6, SFR_ACC, 6); ///< Accumulator Bit 6
           =2 SI_SBIT (ACC_ACC7, SFR_ACC, 7); ///< Accumulator Bit 7
           =2 
           =2 // ADC0CN0 (ADC0 Control)
           =2 #define SFR_ADC0CN0 0xE8
           =2 SI_SBIT (ADC0CN0_ADCM0,  SFR_ADC0CN0, 0); ///< Start of Conversion Mode Select Bit 0
           =2 SI_SBIT (ADC0CN0_ADCM1,  SFR_ADC0CN0, 1); ///< Start of Conversion Mode Select Bit 1
           =2 SI_SBIT (ADC0CN0_ADCM2,  SFR_ADC0CN0, 2); ///< Start of Conversion Mode Select Bit 2
           =2 SI_SBIT (ADC0CN0_ADWINT, SFR_ADC0CN0, 3); ///< Window Compare Interrupt Flag        
           =2 SI_SBIT (ADC0CN0_ADBUSY, SFR_ADC0CN0, 4); ///< ADC Busy                             
           =2 SI_SBIT (ADC0CN0_ADINT,  SFR_ADC0CN0, 5); ///< Conversion Complete Interrupt Flag   
           =2 SI_SBIT (ADC0CN0_ADTM,   SFR_ADC0CN0, 6); ///< Track Mode                           
           =2 SI_SBIT (ADC0CN0_ADEN,   SFR_ADC0CN0, 7); ///< ADC Enable                           
           =2 
           =2 // B (B Register)
           =2 #define SFR_B 0xF0
           =2 SI_SBIT (B_B0, SFR_B, 0); ///< B Register Bit 0
           =2 SI_SBIT (B_B1, SFR_B, 1); ///< B Register Bit 1
           =2 SI_SBIT (B_B2, SFR_B, 2); ///< B Register Bit 2
           =2 SI_SBIT (B_B3, SFR_B, 3); ///< B Register Bit 3
           =2 SI_SBIT (B_B4, SFR_B, 4); ///< B Register Bit 4
           =2 SI_SBIT (B_B5, SFR_B, 5); ///< B Register Bit 5
           =2 SI_SBIT (B_B6, SFR_B, 6); ///< B Register Bit 6
           =2 SI_SBIT (B_B7, SFR_B, 7); ///< B Register Bit 7
           =2 
           =2 // IE (Interrupt Enable)
           =2 #define SFR_IE 0xA8
           =2 SI_SBIT (IE_EX0,   SFR_IE, 0); ///< External Interrupt 0 Enable
           =2 SI_SBIT (IE_ET0,   SFR_IE, 1); ///< Timer 0 Interrupt Enable   
           =2 SI_SBIT (IE_EX1,   SFR_IE, 2); ///< External Interrupt 1 Enable
           =2 SI_SBIT (IE_ET1,   SFR_IE, 3); ///< Timer 1 Interrupt Enable   
           =2 SI_SBIT (IE_ES0,   SFR_IE, 4); ///< UART0 Interrupt Enable     
           =2 SI_SBIT (IE_ET2,   SFR_IE, 5); ///< Timer 2 Interrupt Enable   
           =2 SI_SBIT (IE_ESPI0, SFR_IE, 6); ///< SPI0 Interrupt Enable      
           =2 SI_SBIT (IE_EA,    SFR_IE, 7); ///< All Interrupts Enable      
           =2 
           =2 // IP (Interrupt Priority)
           =2 #define SFR_IP 0xB8
           =2 SI_SBIT (IP_PX0,   SFR_IP, 0); ///< External Interrupt 0 Priority Control                        
           =2 SI_SBIT (IP_PT0,   SFR_IP, 1); ///< Timer 0 Interrupt Priority Control                           
           =2 SI_SBIT (IP_PX1,   SFR_IP, 2); ///< External Interrupt 1 Priority Control                        
           =2 SI_SBIT (IP_PT1,   SFR_IP, 3); ///< Timer 1 Interrupt Priority Control                           
           =2 SI_SBIT (IP_PS0,   SFR_IP, 4); ///< UART0 Interrupt Priority Control                             
           =2 SI_SBIT (IP_PT2,   SFR_IP, 5); ///< Timer 2 Interrupt Priority Control                           
C51 COMPILER V9.56.0.0   SPI_0                                                             10/28/2016 17:37:02 PAGE 24  

           =2 SI_SBIT (IP_PSPI0, SFR_IP, 6); ///< Serial Peripheral Interface (SPI0) Interrupt Priority Control
           =2 
           =2 // P0 (Port 0 Pin Latch)
           =2 #define SFR_P0 0x80
           =2 SI_SBIT (P0_B0, SFR_P0, 0); ///< Port 0 Bit 0 Latch
           =2 SI_SBIT (P0_B1, SFR_P0, 1); ///< Port 0 Bit 1 Latch
           =2 SI_SBIT (P0_B2, SFR_P0, 2); ///< Port 0 Bit 2 Latch
           =2 SI_SBIT (P0_B3, SFR_P0, 3); ///< Port 0 Bit 3 Latch
           =2 SI_SBIT (P0_B4, SFR_P0, 4); ///< Port 0 Bit 4 Latch
           =2 SI_SBIT (P0_B5, SFR_P0, 5); ///< Port 0 Bit 5 Latch
           =2 SI_SBIT (P0_B6, SFR_P0, 6); ///< Port 0 Bit 6 Latch
           =2 SI_SBIT (P0_B7, SFR_P0, 7); ///< Port 0 Bit 7 Latch
           =2 
           =2 // P1 (Port 1 Pin Latch)
           =2 #define SFR_P1 0x90
           =2 SI_SBIT (P1_B0, SFR_P1, 0); ///< Port 1 Bit 0 Latch
           =2 SI_SBIT (P1_B1, SFR_P1, 1); ///< Port 1 Bit 1 Latch
           =2 SI_SBIT (P1_B2, SFR_P1, 2); ///< Port 1 Bit 2 Latch
           =2 SI_SBIT (P1_B3, SFR_P1, 3); ///< Port 1 Bit 3 Latch
           =2 SI_SBIT (P1_B4, SFR_P1, 4); ///< Port 1 Bit 4 Latch
           =2 SI_SBIT (P1_B5, SFR_P1, 5); ///< Port 1 Bit 5 Latch
           =2 SI_SBIT (P1_B6, SFR_P1, 6); ///< Port 1 Bit 6 Latch
           =2 SI_SBIT (P1_B7, SFR_P1, 7); ///< Port 1 Bit 7 Latch
           =2 
           =2 // P2 (Port 2 Pin Latch)
           =2 #define SFR_P2 0xA0
           =2 SI_SBIT (P2_B0, SFR_P2, 0); ///< Port 2 Bit 0 Latch
           =2 SI_SBIT (P2_B1, SFR_P2, 1); ///< Port 2 Bit 1 Latch
           =2 SI_SBIT (P2_B2, SFR_P2, 2); ///< Port 2 Bit 2 Latch
           =2 SI_SBIT (P2_B3, SFR_P2, 3); ///< Port 2 Bit 3 Latch
           =2 SI_SBIT (P2_B4, SFR_P2, 4); ///< Port 2 Bit 4 Latch
           =2 SI_SBIT (P2_B5, SFR_P2, 5); ///< Port 2 Bit 5 Latch
           =2 SI_SBIT (P2_B6, SFR_P2, 6); ///< Port 2 Bit 6 Latch
           =2 SI_SBIT (P2_B7, SFR_P2, 7); ///< Port 2 Bit 7 Latch
           =2 
           =2 // P3 (Port 3 Pin Latch)
           =2 #define SFR_P3 0xB0
           =2 SI_SBIT (P3_B0, SFR_P3, 0); ///< Port 3 Bit 0 Latch
           =2 SI_SBIT (P3_B1, SFR_P3, 1); ///< Port 3 Bit 1 Latch
           =2 SI_SBIT (P3_B2, SFR_P3, 2); ///< Port 3 Bit 2 Latch
           =2 SI_SBIT (P3_B3, SFR_P3, 3); ///< Port 3 Bit 3 Latch
           =2 SI_SBIT (P3_B4, SFR_P3, 4); ///< Port 3 Bit 4 Latch
           =2 SI_SBIT (P3_B5, SFR_P3, 5); ///< Port 3 Bit 5 Latch
           =2 SI_SBIT (P3_B6, SFR_P3, 6); ///< Port 3 Bit 6 Latch
           =2 SI_SBIT (P3_B7, SFR_P3, 7); ///< Port 3 Bit 7 Latch
           =2 
           =2 // PCA0CN0 (PCA Control 0)
           =2 #define SFR_PCA0CN0 0xD8
           =2 SI_SBIT (PCA0CN0_CCF0, SFR_PCA0CN0, 0); ///< PCA Module 0 Capture/Compare Flag
           =2 SI_SBIT (PCA0CN0_CCF1, SFR_PCA0CN0, 1); ///< PCA Module 1 Capture/Compare Flag
           =2 SI_SBIT (PCA0CN0_CCF2, SFR_PCA0CN0, 2); ///< PCA Module 2 Capture/Compare Flag
           =2 SI_SBIT (PCA0CN0_CCF3, SFR_PCA0CN0, 3); ///< PCA Module 3 Capture/Compare Flag
           =2 SI_SBIT (PCA0CN0_CCF4, SFR_PCA0CN0, 4); ///< PCA Module 4 Capture/Compare Flag
           =2 SI_SBIT (PCA0CN0_CR,   SFR_PCA0CN0, 6); ///< PCA Counter/Timer Run Control    
           =2 SI_SBIT (PCA0CN0_CF,   SFR_PCA0CN0, 7); ///< PCA Counter/Timer Overflow Flag  
           =2 
           =2 // PSW (Program Status Word)
           =2 #define SFR_PSW 0xD0
           =2 SI_SBIT (PSW_PARITY, SFR_PSW, 0); ///< Parity Flag               
           =2 SI_SBIT (PSW_F1,     SFR_PSW, 1); ///< User Flag 1               
           =2 SI_SBIT (PSW_OV,     SFR_PSW, 2); ///< Overflow Flag             
           =2 SI_SBIT (PSW_RS0,    SFR_PSW, 3); ///< Register Bank Select Bit 0
C51 COMPILER V9.56.0.0   SPI_0                                                             10/28/2016 17:37:02 PAGE 25  

           =2 SI_SBIT (PSW_RS1,    SFR_PSW, 4); ///< Register Bank Select Bit 1
           =2 SI_SBIT (PSW_F0,     SFR_PSW, 5); ///< User Flag 0               
           =2 SI_SBIT (PSW_AC,     SFR_PSW, 6); ///< Auxiliary Carry Flag      
           =2 SI_SBIT (PSW_CY,     SFR_PSW, 7); ///< Carry Flag                
           =2 
           =2 // SCON0 (UART0 Serial Port Control)
           =2 #define SFR_SCON0 0x98
           =2 SI_SBIT (SCON0_RI,    SFR_SCON0, 0); ///< Receive Interrupt Flag             
           =2 SI_SBIT (SCON0_TI,    SFR_SCON0, 1); ///< Transmit Interrupt Flag            
           =2 SI_SBIT (SCON0_RB8,   SFR_SCON0, 2); ///< Ninth Receive Bit                  
           =2 SI_SBIT (SCON0_TB8,   SFR_SCON0, 3); ///< Ninth Transmission Bit             
           =2 SI_SBIT (SCON0_REN,   SFR_SCON0, 4); ///< Receive Enable                     
           =2 SI_SBIT (SCON0_MCE,   SFR_SCON0, 5); ///< Multiprocessor Communication Enable
           =2 SI_SBIT (SCON0_SMODE, SFR_SCON0, 7); ///< Serial Port 0 Operation Mode       
           =2 
           =2 // SMB0CN0 (SMBus 0 Control)
           =2 #define SFR_SMB0CN0 0xC0
           =2 SI_SBIT (SMB0CN0_SI,      SFR_SMB0CN0, 0); ///< SMBus Interrupt Flag            
           =2 SI_SBIT (SMB0CN0_ACK,     SFR_SMB0CN0, 1); ///< SMBus Acknowledge               
           =2 SI_SBIT (SMB0CN0_ARBLOST, SFR_SMB0CN0, 2); ///< SMBus Arbitration Lost Indicator
           =2 SI_SBIT (SMB0CN0_ACKRQ,   SFR_SMB0CN0, 3); ///< SMBus Acknowledge Request       
           =2 SI_SBIT (SMB0CN0_STO,     SFR_SMB0CN0, 4); ///< SMBus Stop Flag                 
           =2 SI_SBIT (SMB0CN0_STA,     SFR_SMB0CN0, 5); ///< SMBus Start Flag                
           =2 SI_SBIT (SMB0CN0_TXMODE,  SFR_SMB0CN0, 6); ///< SMBus Transmit Mode Indicator   
           =2 SI_SBIT (SMB0CN0_MASTER,  SFR_SMB0CN0, 7); ///< SMBus Master/Slave Indicator    
           =2 
           =2 // SMB1CN0 (SMBus 1 Control)
           =2 #define SFR_SMB1CN0 0xC0
           =2 SI_SBIT (SMB1CN0_SI,      SFR_SMB1CN0, 0); ///< SMBus Interrupt Flag            
           =2 SI_SBIT (SMB1CN0_ACK,     SFR_SMB1CN0, 1); ///< SMBus Acknowledge               
           =2 SI_SBIT (SMB1CN0_ARBLOST, SFR_SMB1CN0, 2); ///< SMBus Arbitration Lost Indicator
           =2 SI_SBIT (SMB1CN0_ACKRQ,   SFR_SMB1CN0, 3); ///< SMBus Acknowledge Request       
           =2 SI_SBIT (SMB1CN0_STO,     SFR_SMB1CN0, 4); ///< SMBus Stop Flag                 
           =2 SI_SBIT (SMB1CN0_STA,     SFR_SMB1CN0, 5); ///< SMBus Start Flag                
           =2 SI_SBIT (SMB1CN0_TXMODE,  SFR_SMB1CN0, 6); ///< SMBus Transmit Mode Indicator   
           =2 SI_SBIT (SMB1CN0_MASTER,  SFR_SMB1CN0, 7); ///< SMBus Master/Slave Indicator    
           =2 
           =2 // SPI0CN0 (SPI0 Control)
           =2 #define SFR_SPI0CN0 0xF8
           =2 SI_SBIT (SPI0CN0_SPIEN,  SFR_SPI0CN0, 0); ///< SPI0 Enable            
           =2 SI_SBIT (SPI0CN0_TXBMT,  SFR_SPI0CN0, 1); ///< Transmit Buffer Empty  
           =2 SI_SBIT (SPI0CN0_NSSMD0, SFR_SPI0CN0, 2); ///< Slave Select Mode Bit 0
           =2 SI_SBIT (SPI0CN0_NSSMD1, SFR_SPI0CN0, 3); ///< Slave Select Mode Bit 1
           =2 SI_SBIT (SPI0CN0_RXOVRN, SFR_SPI0CN0, 4); ///< Receive Overrun Flag   
           =2 SI_SBIT (SPI0CN0_MODF,   SFR_SPI0CN0, 5); ///< Mode Fault Flag        
           =2 SI_SBIT (SPI0CN0_WCOL,   SFR_SPI0CN0, 6); ///< Write Collision Flag   
           =2 SI_SBIT (SPI0CN0_SPIF,   SFR_SPI0CN0, 7); ///< SPI0 Interrupt Flag    
           =2 
           =2 // TCON (Timer 0/1 Control)
           =2 #define SFR_TCON 0x88
           =2 SI_SBIT (TCON_IT0, SFR_TCON, 0); ///< Interrupt 0 Type Select
           =2 SI_SBIT (TCON_IE0, SFR_TCON, 1); ///< External Interrupt 0   
           =2 SI_SBIT (TCON_IT1, SFR_TCON, 2); ///< Interrupt 1 Type Select
           =2 SI_SBIT (TCON_IE1, SFR_TCON, 3); ///< External Interrupt 1   
           =2 SI_SBIT (TCON_TR0, SFR_TCON, 4); ///< Timer 0 Run Control    
           =2 SI_SBIT (TCON_TF0, SFR_TCON, 5); ///< Timer 0 Overflow Flag  
           =2 SI_SBIT (TCON_TR1, SFR_TCON, 6); ///< Timer 1 Run Control    
           =2 SI_SBIT (TCON_TF1, SFR_TCON, 7); ///< Timer 1 Overflow Flag  
           =2 
           =2 // TMR2CN0 (Timer 2 Control 0)
           =2 #define SFR_TMR2CN0 0xC8
           =2 SI_SBIT (TMR2CN0_T2XCLK,  SFR_TMR2CN0, 0); ///< Timer 2 External Clock Select    
C51 COMPILER V9.56.0.0   SPI_0                                                             10/28/2016 17:37:02 PAGE 26  

           =2 SI_SBIT (TMR2CN0_T2CSS,   SFR_TMR2CN0, 1); ///< Timer 2 Capture Source Select    
           =2 SI_SBIT (TMR2CN0_TR2,     SFR_TMR2CN0, 2); ///< Timer 2 Run Control              
           =2 SI_SBIT (TMR2CN0_T2SPLIT, SFR_TMR2CN0, 3); ///< Timer 2 Split Mode Enable        
           =2 SI_SBIT (TMR2CN0_TF2CEN,  SFR_TMR2CN0, 4); ///< Timer 2 Capture Enable           
           =2 SI_SBIT (TMR2CN0_TF2LEN,  SFR_TMR2CN0, 5); ///< Timer 2 Low Byte Interrupt Enable
           =2 SI_SBIT (TMR2CN0_TF2L,    SFR_TMR2CN0, 6); ///< Timer 2 Low Byte Overflow Flag   
           =2 SI_SBIT (TMR2CN0_TF2H,    SFR_TMR2CN0, 7); ///< Timer 2 High Byte Overflow Flag  
           =2 
           =2 // TMR5CN0 (Timer 5 Control 0)
           =2 #define SFR_TMR5CN0 0xC8
           =2 SI_SBIT (TMR5CN0_T5XCLK,  SFR_TMR5CN0, 0); ///< Timer 5 External Clock Select    
           =2 SI_SBIT (TMR5CN0_TR5,     SFR_TMR5CN0, 2); ///< Timer 5 Run Control              
           =2 SI_SBIT (TMR5CN0_T5SPLIT, SFR_TMR5CN0, 3); ///< Timer 5 Split Mode Enable        
           =2 SI_SBIT (TMR5CN0_TF5LEN,  SFR_TMR5CN0, 5); ///< Timer 5 Low Byte Interrupt Enable
           =2 SI_SBIT (TMR5CN0_TF5L,    SFR_TMR5CN0, 6); ///< Timer 5 Low Byte Overflow Flag   
           =2 SI_SBIT (TMR5CN0_TF5H,    SFR_TMR5CN0, 7); ///< Timer 5 High Byte Overflow Flag  
           =2 
           =2 //------------------------------------------------------------------------------
           =2 // Interrupt Definitions
           =2 //------------------------------------------------------------------------------
           =2 #define INT0_IRQn    0  ///< External Interrupt 0  
           =2 #define TIMER0_IRQn  1  ///< Timer 0 Overflow      
           =2 #define INT1_IRQn    2  ///< External Interrupt 1  
           =2 #define TIMER1_IRQn  3  ///< Timer 1 Overflow      
           =2 #define UART0_IRQn   4  ///< UART 0                
           =2 #define TIMER2_IRQn  5  ///< Timer 2 Overflow      
           =2 #define SPI0_IRQn    6  ///< SPI0                  
           =2 #define SMBUS0_IRQn  7  ///< SMBus 0               
           =2 #define USB0_IRQn    8  ///< USB0                  
           =2 #define ADC0WC_IRQn  9  ///< ADC0 Window Compare   
           =2 #define ADC0EOC_IRQn 10 ///< ADC0 End of Conversion
           =2 #define PCA0_IRQn    11 ///< PCA0                  
           =2 #define CMP0_IRQn    12 ///< Comparator 0          
           =2 #define CMP1_IRQn    13 ///< Comparator 1          
           =2 #define TIMER3_IRQn  14 ///< Timer 3 Overflow      
           =2 #define VBUSLVL_IRQn 15 ///< VBUS Level            
           =2 #define UART1_IRQn   16 ///< UART 1                
           =2 #define SMBUS1_IRQn  18 ///< SMBus 1               
           =2 #define TIMER4_IRQn  19 ///< Timer 4 Overflow      
           =2 #define TIMER5_IRQn  20 ///< Timer 5 Overflow      
           =2 
           =2 //------------------------------------------------------------------------------
           =2 // SFR Page Definitions
           =2 //------------------------------------------------------------------------------
           =2 #define LEGACY_PAGE 0x00 ///< Legacy SFR Page                   
           =2 #define CONFIG_PAGE 0x0F ///< System and Port Configuration Page
           =2 #define SMB1_PAGE   0x0F ///< SMBus 1 Page                      
           =2 
           =2 //-----------------------------------------------------------------------------
           =2 // SDCC PDATA External Memory Paging Support
           =2 //-----------------------------------------------------------------------------
           =2 
           =2 #if defined SDCC
           =2 
           =2 SI_SFR(_XPAGE, 0xAA); // Point to the EMI0CN register
           =2 
           =2 #endif
           =2 
           =2 #endif // SI_EFM8UB2_DEFS_H
 459      =2  //-eof--------------------------------------------------------------------------
 460      =2  
  22      =1  //------------------------------------------------------------------------------
C51 COMPILER V9.56.0.0   SPI_0                                                             10/28/2016 17:37:02 PAGE 27  

  23      =1  // ADC0CF Enums (ADC0 Configuration @ 0xBC)
  24      =1  //------------------------------------------------------------------------------
  25      =1  #define ADC0CF_ADLJST__BMASK           0x04 ///< ADC0 Left Justify Select                   
  26      =1  #define ADC0CF_ADLJST__SHIFT           0x02 ///< ADC0 Left Justify Select                   
  27      =1  #define ADC0CF_ADLJST__RIGHT_JUSTIFIED 0x00 ///< Data in the ADC0H:ADC0L registers is right-
  28      =1                                              ///< justified.                                 
  29      =1  #define ADC0CF_ADLJST__LEFT_JUSTIFIED  0x04 ///< Data in the ADC0H:ADC0L registers is left- 
  30      =1                                              ///< justified.                                 
  31      =1                                                                                              
  32      =1  #define ADC0CF_ADSC__FMASK             0xF8 ///< SAR Clock Divider                          
  33      =1  #define ADC0CF_ADSC__SHIFT             0x03 ///< SAR Clock Divider                          
  34      =1                                                                                              
  35      =1  //------------------------------------------------------------------------------
  36      =1  // ADC0CN0 Enums (ADC0 Control @ 0xE8)
  37      =1  //------------------------------------------------------------------------------
  38      =1  #define ADC0CN0_ADCM__FMASK         0x07 ///< Start of Conversion Mode Select                   
  39      =1  #define ADC0CN0_ADCM__SHIFT         0x00 ///< Start of Conversion Mode Select                   
  40      =1  #define ADC0CN0_ADCM__ADBUSY        0x00 ///< ADC0 conversion initiated on write of 1 to ADBUSY.
  41      =1  #define ADC0CN0_ADCM__TIMER0        0x01 ///< ADC0 conversion initiated on overflow of Timer 0. 
  42      =1  #define ADC0CN0_ADCM__TIMER2        0x02 ///< ADC0 conversion initiated on overflow of Timer 2. 
  43      =1  #define ADC0CN0_ADCM__TIMER1        0x03 ///< ADC0 conversion initiated on overflow of Timer 1. 
  44      =1  #define ADC0CN0_ADCM__CNVSTR        0x04 ///< ADC0 conversion initiated on rising edge of       
  45      =1                                           ///< CNVSTR.                                           
  46      =1  #define ADC0CN0_ADCM__TIMER3        0x05 ///< ADC0 conversion initiated on overflow of Timer 3. 
  47      =1  #define ADC0CN0_ADCM__TIMER4        0x06 ///< ADC0 conversion initiated on overflow of Timer 4. 
  48      =1  #define ADC0CN0_ADCM__TIMER5        0x07 ///< ADC0 conversion initiated on overflow of Timer 5. 
  49      =1                                                                                                  
  50      =1  #define ADC0CN0_ADWINT__BMASK       0x08 ///< Window Compare Interrupt Flag                     
  51      =1  #define ADC0CN0_ADWINT__SHIFT       0x03 ///< Window Compare Interrupt Flag                     
  52      =1  #define ADC0CN0_ADWINT__NOT_SET     0x00 ///< An ADC window compare event did not occur.        
  53      =1  #define ADC0CN0_ADWINT__SET         0x08 ///< An ADC window compare event occurred.             
  54      =1                                                                                                  
  55      =1  #define ADC0CN0_ADBUSY__BMASK       0x10 ///< ADC Busy                                          
  56      =1  #define ADC0CN0_ADBUSY__SHIFT       0x04 ///< ADC Busy                                          
  57      =1  #define ADC0CN0_ADBUSY__NOT_SET     0x00 ///< An ADC0 conversion is not currently in progress.  
  58      =1  #define ADC0CN0_ADBUSY__SET         0x10 ///< ADC0 conversion is in progress or start an ADC0   
  59      =1                                           ///< conversion.                                       
  60      =1                                                                                                  
  61      =1  #define ADC0CN0_ADINT__BMASK        0x20 ///< Conversion Complete Interrupt Flag                
  62      =1  #define ADC0CN0_ADINT__SHIFT        0x05 ///< Conversion Complete Interrupt Flag                
  63      =1  #define ADC0CN0_ADINT__NOT_SET      0x00 ///< ADC0 has not completed a conversion since the last
  64      =1                                           ///< time ADINT was cleared.                           
  65      =1  #define ADC0CN0_ADINT__SET          0x20 ///< ADC0 completed a data conversion.                 
  66      =1                                                                                                  
  67      =1  #define ADC0CN0_ADTM__BMASK         0x40 ///< Track Mode                                        
  68      =1  #define ADC0CN0_ADTM__SHIFT         0x06 ///< Track Mode                                        
  69      =1  #define ADC0CN0_ADTM__TRACK_NORMAL  0x00 ///< Normal Track Mode. When ADC0 is enabled,          
  70      =1                                           ///< conversion begins immediately following the start-
  71      =1                                           ///< of-conversion signal.                             
  72      =1  #define ADC0CN0_ADTM__TRACK_DELAYED 0x40 ///< Delayed Track Mode. When ADC0 is enabled,         
  73      =1                                           ///< conversion begins 3 SAR clock cycles following the
  74      =1                                           ///< start-of-conversion signal. The ADC is allowed to 
  75      =1                                           ///< track during this time. Note that there is not a  
  76      =1                                           ///< tracking delay when the external conversion start 
  77      =1                                           ///< (CNVSTR) is used as the start-of-conversion       
  78      =1                                           ///< source.                                           
  79      =1                                                                                                  
  80      =1  #define ADC0CN0_ADEN__BMASK         0x80 ///< ADC Enable                                        
  81      =1  #define ADC0CN0_ADEN__SHIFT         0x07 ///< ADC Enable                                        
  82      =1  #define ADC0CN0_ADEN__DISABLED      0x00 ///< ADC0 Disabled (low-power shutdown).               
  83      =1  #define ADC0CN0_ADEN__ENABLED       0x80 ///< ADC0 Enabled (active and ready for data           
  84      =1                                           ///< conversions).                                     
C51 COMPILER V9.56.0.0   SPI_0                                                             10/28/2016 17:37:02 PAGE 28  

  85      =1                                                                                                  
  86      =1  //------------------------------------------------------------------------------
  87      =1  // ADC0GTH Enums (ADC0 Greater-Than High Byte @ 0xC4)
  88      =1  //------------------------------------------------------------------------------
  89      =1  #define ADC0GTH_ADC0GTH__FMASK 0xFF ///< Greater-Than High Byte
  90      =1  #define ADC0GTH_ADC0GTH__SHIFT 0x00 ///< Greater-Than High Byte
  91      =1                                                                 
  92      =1  //------------------------------------------------------------------------------
  93      =1  // ADC0GTL Enums (ADC0 Greater-Than Low Byte @ 0xC3)
  94      =1  //------------------------------------------------------------------------------
  95      =1  #define ADC0GTL_ADC0GTL__FMASK 0xFF ///< Greater-Than Low Byte
  96      =1  #define ADC0GTL_ADC0GTL__SHIFT 0x00 ///< Greater-Than Low Byte
  97      =1                                                                
  98      =1  //------------------------------------------------------------------------------
  99      =1  // ADC0H Enums (ADC0 Data Word High Byte @ 0xBE)
 100      =1  //------------------------------------------------------------------------------
 101      =1  #define ADC0H_ADC0H__FMASK 0xFF ///< Data Word High Byte
 102      =1  #define ADC0H_ADC0H__SHIFT 0x00 ///< Data Word High Byte
 103      =1                                                          
 104      =1  //------------------------------------------------------------------------------
 105      =1  // ADC0L Enums (ADC0 Data Word Low Byte @ 0xBD)
 106      =1  //------------------------------------------------------------------------------
 107      =1  #define ADC0L_ADC0L__FMASK 0xFF ///< Data Word Low Byte
 108      =1  #define ADC0L_ADC0L__SHIFT 0x00 ///< Data Word Low Byte
 109      =1                                                         
 110      =1  //------------------------------------------------------------------------------
 111      =1  // ADC0LTH Enums (ADC0 Less-Than High Byte @ 0xC6)
 112      =1  //------------------------------------------------------------------------------
 113      =1  #define ADC0LTH_ADC0LTH__FMASK 0xFF ///< Less-Than High Byte
 114      =1  #define ADC0LTH_ADC0LTH__SHIFT 0x00 ///< Less-Than High Byte
 115      =1                                                              
 116      =1  //------------------------------------------------------------------------------
 117      =1  // ADC0LTL Enums (ADC0 Less-Than Low Byte @ 0xC5)
 118      =1  //------------------------------------------------------------------------------
 119      =1  #define ADC0LTL_ADC0LTL__FMASK 0xFF ///< Less-Than Low Byte
 120      =1  #define ADC0LTL_ADC0LTL__SHIFT 0x00 ///< Less-Than Low Byte
 121      =1                                                             
 122      =1  //------------------------------------------------------------------------------
 123      =1  // AMX0N Enums (AMUX0 Negative Multiplexer Selection @ 0xBA)
 124      =1  //------------------------------------------------------------------------------
 125      =1  #define AMX0N_AMX0N__FMASK   0x3F ///< AMUX0 Negative Input Selection
 126      =1  #define AMX0N_AMX0N__SHIFT   0x00 ///< AMUX0 Negative Input Selection
 127      =1  #define AMX0N_AMX0N__ADC0N0  0x00 ///< Select ADC0N.0.               
 128      =1  #define AMX0N_AMX0N__ADC0N1  0x01 ///< Select ADC0N.1.               
 129      =1  #define AMX0N_AMX0N__ADC0N2  0x02 ///< Select ADC0N.2.               
 130      =1  #define AMX0N_AMX0N__ADC0N3  0x03 ///< Select ADC0N.3.               
 131      =1  #define AMX0N_AMX0N__ADC0N4  0x04 ///< Select ADC0N.4.               
 132      =1  #define AMX0N_AMX0N__ADC0N5  0x05 ///< Select ADC0N.5.               
 133      =1  #define AMX0N_AMX0N__ADC0N6  0x06 ///< Select ADC0N.6.               
 134      =1  #define AMX0N_AMX0N__ADC0N7  0x07 ///< Select ADC0N.7.               
 135      =1  #define AMX0N_AMX0N__ADC0N8  0x08 ///< Select ADC0N.8.               
 136      =1  #define AMX0N_AMX0N__ADC0N9  0x09 ///< Select ADC0N.9.               
 137      =1  #define AMX0N_AMX0N__ADC0N10 0x0A ///< Select ADC0N.10.              
 138      =1  #define AMX0N_AMX0N__ADC0N11 0x0B ///< Select ADC0N.11.              
 139      =1  #define AMX0N_AMX0N__ADC0N12 0x0C ///< Select ADC0N.12.              
 140      =1  #define AMX0N_AMX0N__ADC0N13 0x0D ///< Select ADC0N.13.              
 141      =1  #define AMX0N_AMX0N__ADC0N14 0x0E ///< Select ADC0N.14.              
 142      =1  #define AMX0N_AMX0N__ADC0N15 0x0F ///< Select ADC0N.15.              
 143      =1  #define AMX0N_AMX0N__ADC0N16 0x10 ///< Select ADC0N.16.              
 144      =1  #define AMX0N_AMX0N__ADC0N17 0x11 ///< Select ADC0N.17.              
 145      =1  #define AMX0N_AMX0N__ADC0N18 0x12 ///< Select ADC0N.18.              
 146      =1  #define AMX0N_AMX0N__ADC0N19 0x13 ///< Select ADC0N.19.              
C51 COMPILER V9.56.0.0   SPI_0                                                             10/28/2016 17:37:02 PAGE 29  

 147      =1  #define AMX0N_AMX0N__ADC0N20 0x14 ///< Select ADC0N.20.              
 148      =1  #define AMX0N_AMX0N__ADC0N21 0x15 ///< Select ADC0N.21.              
 149      =1  #define AMX0N_AMX0N__ADC0N22 0x16 ///< Select ADC0N.22.              
 150      =1  #define AMX0N_AMX0N__ADC0N23 0x17 ///< Select ADC0N.23.              
 151      =1  #define AMX0N_AMX0N__ADC0N24 0x18 ///< Select ADC0N.24.              
 152      =1  #define AMX0N_AMX0N__ADC0N25 0x19 ///< Select ADC0N.25.              
 153      =1  #define AMX0N_AMX0N__ADC0N26 0x1A ///< Select ADC0N.26.              
 154      =1  #define AMX0N_AMX0N__ADC0N27 0x1B ///< Select ADC0N.27.              
 155      =1  #define AMX0N_AMX0N__ADC0N28 0x1C ///< Select ADC0N.28.              
 156      =1  #define AMX0N_AMX0N__ADC0N29 0x1D ///< Select ADC0N.29.              
 157      =1  #define AMX0N_AMX0N__VREF    0x1E ///< Internal Voltage Reference.   
 158      =1  #define AMX0N_AMX0N__GND     0x1F ///< Ground (single-ended mode).   
 159      =1  #define AMX0N_AMX0N__ADC0N32 0x20 ///< Select ADC0N.32.              
 160      =1  #define AMX0N_AMX0N__ADC0N33 0x21 ///< Select ADC0N.33.              
 161      =1  #define AMX0N_AMX0N__ADC0N34 0x22 ///< Select ADC0N.34.              
 162      =1                                                                       
 163      =1  //------------------------------------------------------------------------------
 164      =1  // AMX0P Enums (AMUX0 Positive Multiplexer Selection @ 0xBB)
 165      =1  //------------------------------------------------------------------------------
 166      =1  #define AMX0P_AMX0P__FMASK   0x3F ///< AMUX0 Positive Input Selection
 167      =1  #define AMX0P_AMX0P__SHIFT   0x00 ///< AMUX0 Positive Input Selection
 168      =1  #define AMX0P_AMX0P__ADC0P0  0x00 ///< Select ADC0P.0.               
 169      =1  #define AMX0P_AMX0P__ADC0P1  0x01 ///< Select ADC0P.1.               
 170      =1  #define AMX0P_AMX0P__ADC0P2  0x02 ///< Select ADC0P.2.               
 171      =1  #define AMX0P_AMX0P__ADC0P3  0x03 ///< Select ADC0P.3.               
 172      =1  #define AMX0P_AMX0P__ADC0P4  0x04 ///< Select ADC0P.4.               
 173      =1  #define AMX0P_AMX0P__ADC0P5  0x05 ///< Select ADC0P.5.               
 174      =1  #define AMX0P_AMX0P__ADC0P6  0x06 ///< Select ADC0P.6.               
 175      =1  #define AMX0P_AMX0P__ADC0P7  0x07 ///< Select ADC0P.7.               
 176      =1  #define AMX0P_AMX0P__ADC0P8  0x08 ///< Select ADC0P.8.               
 177      =1  #define AMX0P_AMX0P__ADC0P9  0x09 ///< Select ADC0P.9.               
 178      =1  #define AMX0P_AMX0P__ADC0P10 0x0A ///< Select ADC0P.10.              
 179      =1  #define AMX0P_AMX0P__ADC0P11 0x0B ///< Select ADC0P.11.              
 180      =1  #define AMX0P_AMX0P__ADC0P12 0x0C ///< Select ADC0P.12.              
 181      =1  #define AMX0P_AMX0P__ADC0P13 0x0D ///< Select ADC0P.13.              
 182      =1  #define AMX0P_AMX0P__ADC0P14 0x0E ///< Select ADC0P.14.              
 183      =1  #define AMX0P_AMX0P__ADC0P15 0x0F ///< Select ADC0P.15.              
 184      =1  #define AMX0P_AMX0P__ADC0P16 0x10 ///< Select ADC0P.16.              
 185      =1  #define AMX0P_AMX0P__ADC0P17 0x11 ///< Select ADC0P.17.              
 186      =1  #define AMX0P_AMX0P__ADC0P18 0x12 ///< Select ADC0P.18.              
 187      =1  #define AMX0P_AMX0P__ADC0P19 0x13 ///< Select ADC0P.19.              
 188      =1  #define AMX0P_AMX0P__ADC0P20 0x14 ///< Select ADC0P.20.              
 189      =1  #define AMX0P_AMX0P__ADC0P21 0x15 ///< Select ADC0P.21.              
 190      =1  #define AMX0P_AMX0P__ADC0P22 0x16 ///< Select ADC0P.22.              
 191      =1  #define AMX0P_AMX0P__ADC0P23 0x17 ///< Select ADC0P.23.              
 192      =1  #define AMX0P_AMX0P__ADC0P24 0x18 ///< Select ADC0P.24.              
 193      =1  #define AMX0P_AMX0P__ADC0P25 0x19 ///< Select ADC0P.25.              
 194      =1  #define AMX0P_AMX0P__ADC0P26 0x1A ///< Select ADC0P.26.              
 195      =1  #define AMX0P_AMX0P__ADC0P27 0x1B ///< Select ADC0P.27.              
 196      =1  #define AMX0P_AMX0P__ADC0P28 0x1C ///< Select ADC0P.28.              
 197      =1  #define AMX0P_AMX0P__ADC0P29 0x1D ///< Select ADC0P.29.              
 198      =1  #define AMX0P_AMX0P__TEMP    0x1E ///< Temperature sensor.           
 199      =1  #define AMX0P_AMX0P__VDD     0x1F ///< VDD Supply Voltage.           
 200      =1  #define AMX0P_AMX0P__ADC0P32 0x20 ///< Select ADC0P.32.              
 201      =1  #define AMX0P_AMX0P__ADC0P33 0x21 ///< Select ADC0P.33.              
 202      =1  #define AMX0P_AMX0P__ADC0P34 0x22 ///< Select ADC0P.34.              
 203      =1                                                                       
 204      =1  //------------------------------------------------------------------------------
 205      =1  // ACC Enums (Accumulator @ 0xE0)
 206      =1  //------------------------------------------------------------------------------
 207      =1  #define ACC_ACC__FMASK 0xFF ///< Accumulator
 208      =1  #define ACC_ACC__SHIFT 0x00 ///< Accumulator
C51 COMPILER V9.56.0.0   SPI_0                                                             10/28/2016 17:37:02 PAGE 30  

 209      =1                                              
 210      =1  //------------------------------------------------------------------------------
 211      =1  // B Enums (B Register @ 0xF0)
 212      =1  //------------------------------------------------------------------------------
 213      =1  #define B_B__FMASK 0xFF ///< B Register
 214      =1  #define B_B__SHIFT 0x00 ///< B Register
 215      =1                                         
 216      =1  //------------------------------------------------------------------------------
 217      =1  // DPH Enums (Data Pointer High @ 0x83)
 218      =1  //------------------------------------------------------------------------------
 219      =1  #define DPH_DPH__FMASK 0xFF ///< Data Pointer High
 220      =1  #define DPH_DPH__SHIFT 0x00 ///< Data Pointer High
 221      =1                                                    
 222      =1  //------------------------------------------------------------------------------
 223      =1  // DPL Enums (Data Pointer Low @ 0x82)
 224      =1  //------------------------------------------------------------------------------
 225      =1  #define DPL_DPL__FMASK 0xFF ///< Data Pointer Low
 226      =1  #define DPL_DPL__SHIFT 0x00 ///< Data Pointer Low
 227      =1                                                   
 228      =1  //------------------------------------------------------------------------------
 229      =1  // PFE0CN Enums (Prefetch Engine Control @ 0xAF)
 230      =1  //------------------------------------------------------------------------------
 231      =1  #define PFE0CN_FLBWE__BMASK                0x01 ///< Flash Block Write Enable                      
 232      =1  #define PFE0CN_FLBWE__SHIFT                0x00 ///< Flash Block Write Enable                      
 233      =1  #define PFE0CN_FLBWE__BLOCK_WRITE_DISABLED 0x00 ///< Each byte of a firmware flash write is written
 234      =1                                                  ///< individually.                                 
 235      =1  #define PFE0CN_FLBWE__BLOCK_WRITE_ENABLED  0x01 ///< Flash bytes are written in groups of two.     
 236      =1                                                                                                     
 237      =1  #define PFE0CN_PFEN__BMASK                 0x20 ///< Prefetch Enable                               
 238      =1  #define PFE0CN_PFEN__SHIFT                 0x05 ///< Prefetch Enable                               
 239      =1  #define PFE0CN_PFEN__DISABLED              0x00 ///< Disable the prefetch engine (SYSCLK < 25 MHz).
 240      =1  #define PFE0CN_PFEN__ENABLED               0x20 ///< Enable the prefetch engine (SYSCLK > 25 MHz). 
 241      =1                                                                                                     
 242      =1  //------------------------------------------------------------------------------
 243      =1  // PSW Enums (Program Status Word @ 0xD0)
 244      =1  //------------------------------------------------------------------------------
 245      =1  #define PSW_PARITY__BMASK   0x01 ///< Parity Flag                                       
 246      =1  #define PSW_PARITY__SHIFT   0x00 ///< Parity Flag                                       
 247      =1  #define PSW_PARITY__NOT_SET 0x00 ///< The sum of the 8 bits in the accumulator is even. 
 248      =1  #define PSW_PARITY__SET     0x01 ///< The sum of the 8 bits in the accumulator is odd.  
 249      =1                                                                                          
 250      =1  #define PSW_F1__BMASK       0x02 ///< User Flag 1                                       
 251      =1  #define PSW_F1__SHIFT       0x01 ///< User Flag 1                                       
 252      =1  #define PSW_F1__NOT_SET     0x00 ///< Flag is not set.                                  
 253      =1  #define PSW_F1__SET         0x02 ///< Flag is set.                                      
 254      =1                                                                                          
 255      =1  #define PSW_OV__BMASK       0x04 ///< Overflow Flag                                     
 256      =1  #define PSW_OV__SHIFT       0x02 ///< Overflow Flag                                     
 257      =1  #define PSW_OV__NOT_SET     0x00 ///< An overflow did not occur.                        
 258      =1  #define PSW_OV__SET         0x04 ///< An overflow occurred.                             
 259      =1                                                                                          
 260      =1  #define PSW_RS__FMASK       0x18 ///< Register Bank Select                              
 261      =1  #define PSW_RS__SHIFT       0x03 ///< Register Bank Select                              
 262      =1  #define PSW_RS__BANK0       0x00 ///< Bank 0, Addresses 0x00-0x07                       
 263      =1  #define PSW_RS__BANK1       0x08 ///< Bank 1, Addresses 0x08-0x0F                       
 264      =1  #define PSW_RS__BANK2       0x10 ///< Bank 2, Addresses 0x10-0x17                       
 265      =1  #define PSW_RS__BANK3       0x18 ///< Bank 3, Addresses 0x18-0x1F                       
 266      =1                                                                                          
 267      =1  #define PSW_F0__BMASK       0x20 ///< User Flag 0                                       
 268      =1  #define PSW_F0__SHIFT       0x05 ///< User Flag 0                                       
 269      =1  #define PSW_F0__NOT_SET     0x00 ///< Flag is not set.                                  
 270      =1  #define PSW_F0__SET         0x20 ///< Flag is set.                                      
C51 COMPILER V9.56.0.0   SPI_0                                                             10/28/2016 17:37:02 PAGE 31  

 271      =1                                                                                          
 272      =1  #define PSW_AC__BMASK       0x40 ///< Auxiliary Carry Flag                              
 273      =1  #define PSW_AC__SHIFT       0x06 ///< Auxiliary Carry Flag                              
 274      =1  #define PSW_AC__NOT_SET     0x00 ///< A carry into (addition) or borrow from            
 275      =1                                   ///< (subtraction) the high order nibble did not occur.
 276      =1  #define PSW_AC__SET         0x40 ///< A carry into (addition) or borrow from            
 277      =1                                   ///< (subtraction) the high order nibble occurred.     
 278      =1                                                                                          
 279      =1  #define PSW_CY__BMASK       0x80 ///< Carry Flag                                        
 280      =1  #define PSW_CY__SHIFT       0x07 ///< Carry Flag                                        
 281      =1  #define PSW_CY__NOT_SET     0x00 ///< A carry (addition) or borrow (subtraction) did not
 282      =1                                   ///< occur.                                            
 283      =1  #define PSW_CY__SET         0x80 ///< A carry (addition) or borrow (subtraction)        
 284      =1                                   ///< occurred.                                         
 285      =1                                                                                          
 286      =1  //------------------------------------------------------------------------------
 287      =1  // SP Enums (Stack Pointer @ 0x81)
 288      =1  //------------------------------------------------------------------------------
 289      =1  #define SP_SP__FMASK 0xFF ///< Stack Pointer
 290      =1  #define SP_SP__SHIFT 0x00 ///< Stack Pointer
 291      =1                                              
 292      =1  //------------------------------------------------------------------------------
 293      =1  // CLKSEL Enums (Clock Select @ 0xA9)
 294      =1  //------------------------------------------------------------------------------
 295      =1  #define CLKSEL_CLKSL__FMASK               0x07 ///< System Clock Source Select Bits                   
 296      =1  #define CLKSEL_CLKSL__SHIFT               0x00 ///< System Clock Source Select Bits                   
 297      =1  #define CLKSEL_CLKSL__DIVIDED_HFOSC_DIV_4 0x00 ///< Clock (SYSCLK) derived from the Internal High-    
 298      =1                                                 ///< Frequency Oscillator / 4 and scaled per the IFCN  
 299      =1                                                 ///< bits in register OSCICN.                          
 300      =1  #define CLKSEL_CLKSL__EXTOSC              0x01 ///< Clock (SYSCLK) derived from the External          
 301      =1                                                 ///< Oscillator circuit.                               
 302      =1  #define CLKSEL_CLKSL__HFOSC_DIV_2         0x02 ///< Clock (SYSCLK) derived from the Internal High-    
 303      =1                                                 ///< Frequency Oscillator / 2.                         
 304      =1  #define CLKSEL_CLKSL__HFOSC               0x03 ///< Clock (SYSCLK) derived from the Internal High-    
 305      =1                                                 ///< Frequency Oscillator.                             
 306      =1  #define CLKSEL_CLKSL__LFOSC               0x04 ///< Clock (SYSCLK) derived from the Internal Low-     
 307      =1                                                 ///< Frequency Oscillator and scaled per the OSCLD bits
 308      =1                                                 ///< in register OSCLCN.                               
 309      =1                                                                                                        
 310      =1  #define CLKSEL_OUTCLK__BMASK              0x08 ///< Crossbar Clock Out Select                         
 311      =1  #define CLKSEL_OUTCLK__SHIFT              0x03 ///< Crossbar Clock Out Select                         
 312      =1  #define CLKSEL_OUTCLK__SYSCLK             0x00 ///< Enabling the Crossbar SYSCLK signal outputs       
 313      =1                                                 ///< SYSCLK.                                           
 314      =1  #define CLKSEL_OUTCLK__SYSCLK_SYNC_IO     0x08 ///< Enabling the Crossbar SYSCLK signal outputs SYSCLK
 315      =1                                                 ///< synchronized with the Port I/O.                   
 316      =1                                                                                                        
 317      =1  #define CLKSEL_USBCLK__FMASK              0x70 ///< USB Clock Source Select Bits                      
 318      =1  #define CLKSEL_USBCLK__SHIFT              0x04 ///< USB Clock Source Select Bits                      
 319      =1  #define CLKSEL_USBCLK__HFOSC              0x00 ///< USB clock (USBCLK) derived from the Internal High-
 320      =1                                                 ///< Frequency Oscillator.                             
 321      =1  #define CLKSEL_USBCLK__HFOSC_DIV_8        0x10 ///< USB clock (USBCLK) derived from the Internal High-
 322      =1                                                 ///< Frequency Oscillator / 8.                         
 323      =1  #define CLKSEL_USBCLK__EXTOSC             0x20 ///< USB clock (USBCLK) derived from the External      
 324      =1                                                 ///< Oscillator.                                       
 325      =1  #define CLKSEL_USBCLK__EXTOSC_DIV_2       0x30 ///< USB clock (USBCLK) derived from the External      
 326      =1                                                 ///< Oscillator / 2.                                   
 327      =1  #define CLKSEL_USBCLK__EXTOSC_DIV_3       0x40 ///< USB clock (USBCLK) derived from the External      
 328      =1                                                 ///< Oscillator / 3.                                   
 329      =1  #define CLKSEL_USBCLK__EXTOSC_DIV_4       0x50 ///< USB clock (USBCLK) derived from the External      
 330      =1                                                 ///< Oscillator / 4.                                   
 331      =1  #define CLKSEL_USBCLK__LFOSC              0x60 ///< USB clock (USBCLK) derived from the Internal Low- 
 332      =1                                                 ///< Frequency Oscillator.                             
C51 COMPILER V9.56.0.0   SPI_0                                                             10/28/2016 17:37:02 PAGE 32  

 333      =1                                                                                                        
 334      =1  //------------------------------------------------------------------------------
 335      =1  // CMP0CN0 Enums (Comparator 0 Control 0 @ 0x9B)
 336      =1  //------------------------------------------------------------------------------
 337      =1  #define CMP0CN0_CPHYN__FMASK                0x03 ///< Comparator Negative Hysteresis Control            
 338      =1  #define CMP0CN0_CPHYN__SHIFT                0x00 ///< Comparator Negative Hysteresis Control            
 339      =1  #define CMP0CN0_CPHYN__DISABLED             0x00 ///< Negative Hysteresis disabled.                     
 340      =1  #define CMP0CN0_CPHYN__ENABLED_MODE1        0x01 ///< Negative Hysteresis = Hysteresis 1.               
 341      =1  #define CMP0CN0_CPHYN__ENABLED_MODE2        0x02 ///< Negative Hysteresis = Hysteresis 2.               
 342      =1  #define CMP0CN0_CPHYN__ENABLED_MODE3        0x03 ///< Negative Hysteresis = Hysteresis 3 (Maximum).     
 343      =1                                                                                                          
 344      =1  #define CMP0CN0_CPHYP__FMASK                0x0C ///< Comparator Positive Hysteresis Control            
 345      =1  #define CMP0CN0_CPHYP__SHIFT                0x02 ///< Comparator Positive Hysteresis Control            
 346      =1  #define CMP0CN0_CPHYP__DISABLED             0x00 ///< Positive Hysteresis disabled.                     
 347      =1  #define CMP0CN0_CPHYP__ENABLED_MODE1        0x04 ///< Positive Hysteresis = Hysteresis 1.               
 348      =1  #define CMP0CN0_CPHYP__ENABLED_MODE2        0x08 ///< Positive Hysteresis = Hysteresis 2.               
 349      =1  #define CMP0CN0_CPHYP__ENABLED_MODE3        0x0C ///< Positive Hysteresis = Hysteresis 3 (Maximum).     
 350      =1                                                                                                          
 351      =1  #define CMP0CN0_CPFIF__BMASK                0x10 ///< Comparator Falling-Edge Flag                      
 352      =1  #define CMP0CN0_CPFIF__SHIFT                0x04 ///< Comparator Falling-Edge Flag                      
 353      =1  #define CMP0CN0_CPFIF__NOT_SET              0x00 ///< No comparator falling edge has occurred since this
 354      =1                                                   ///< flag was last cleared.                            
 355      =1  #define CMP0CN0_CPFIF__FALLING_EDGE         0x10 ///< Comparator falling edge has occurred.             
 356      =1                                                                                                          
 357      =1  #define CMP0CN0_CPRIF__BMASK                0x20 ///< Comparator Rising-Edge Flag                       
 358      =1  #define CMP0CN0_CPRIF__SHIFT                0x05 ///< Comparator Rising-Edge Flag                       
 359      =1  #define CMP0CN0_CPRIF__NOT_SET              0x00 ///< No comparator rising edge has occurred since this 
 360      =1                                                   ///< flag was last cleared.                            
 361      =1  #define CMP0CN0_CPRIF__RISING_EDGE          0x20 ///< Comparator rising edge has occurred.              
 362      =1                                                                                                          
 363      =1  #define CMP0CN0_CPOUT__BMASK                0x40 ///< Comparator Output State Flag                      
 364      =1  #define CMP0CN0_CPOUT__SHIFT                0x06 ///< Comparator Output State Flag                      
 365      =1  #define CMP0CN0_CPOUT__POS_LESS_THAN_NEG    0x00 ///< Voltage on CP0P < CP0N.                           
 366      =1  #define CMP0CN0_CPOUT__POS_GREATER_THAN_NEG 0x40 ///< Voltage on CP0P > CP0N.                           
 367      =1                                                                                                          
 368      =1  #define CMP0CN0_CPEN__BMASK                 0x80 ///< Comparator Enable                                 
 369      =1  #define CMP0CN0_CPEN__SHIFT                 0x07 ///< Comparator Enable                                 
 370      =1  #define CMP0CN0_CPEN__DISABLED              0x00 ///< Comparator disabled.                              
 371      =1  #define CMP0CN0_CPEN__ENABLED               0x80 ///< Comparator enabled.                               
 372      =1                                                                                                          
 373      =1  //------------------------------------------------------------------------------
 374      =1  // CMP0MD Enums (Comparator 0 Mode @ 0x9D)
 375      =1  //------------------------------------------------------------------------------
 376      =1  #define CMP0MD_CPMD__FMASK              0x03 ///< Comparator Mode Select                      
 377      =1  #define CMP0MD_CPMD__SHIFT              0x00 ///< Comparator Mode Select                      
 378      =1  #define CMP0MD_CPMD__MODE0              0x00 ///< Mode 0 (Fastest Response Time, Highest Power
 379      =1                                               ///< Consumption)                                
 380      =1  #define CMP0MD_CPMD__MODE1              0x01 ///< Mode 1                                      
 381      =1  #define CMP0MD_CPMD__MODE2              0x02 ///< Mode 2                                      
 382      =1  #define CMP0MD_CPMD__MODE3              0x03 ///< Mode 3 (Slowest Response Time, Lowest Power 
 383      =1                                               ///< Consumption)                                
 384      =1                                                                                                
 385      =1  #define CMP0MD_CPFIE__BMASK             0x10 ///< Comparator Falling-Edge Interrupt Enable    
 386      =1  #define CMP0MD_CPFIE__SHIFT             0x04 ///< Comparator Falling-Edge Interrupt Enable    
 387      =1  #define CMP0MD_CPFIE__FALL_INT_DISABLED 0x00 ///< Comparator falling-edge interrupt disabled. 
 388      =1  #define CMP0MD_CPFIE__FALL_INT_ENABLED  0x10 ///< Comparator falling-edge interrupt enabled.  
 389      =1                                                                                                
 390      =1  #define CMP0MD_CPRIE__BMASK             0x20 ///< Comparator Rising-Edge Interrupt Enable     
 391      =1  #define CMP0MD_CPRIE__SHIFT             0x05 ///< Comparator Rising-Edge Interrupt Enable     
 392      =1  #define CMP0MD_CPRIE__RISE_INT_DISABLED 0x00 ///< Comparator rising-edge interrupt disabled.  
 393      =1  #define CMP0MD_CPRIE__RISE_INT_ENABLED  0x20 ///< Comparator rising-edge interrupt enabled.   
 394      =1                                                                                                
C51 COMPILER V9.56.0.0   SPI_0                                                             10/28/2016 17:37:02 PAGE 33  

 395      =1  //------------------------------------------------------------------------------
 396      =1  // CMP0MX Enums (Comparator 0 Multiplexer Selection @ 0x9F)
 397      =1  //------------------------------------------------------------------------------
 398      =1  #define CMP0MX_CMXP__FMASK  0x07 ///< Comparator Positive Input MUX Selection
 399      =1  #define CMP0MX_CMXP__SHIFT  0x00 ///< Comparator Positive Input MUX Selection
 400      =1  #define CMP0MX_CMXP__CMP0P0 0x00 ///< External pin CMP0P.0.                  
 401      =1  #define CMP0MX_CMXP__CMP0P1 0x01 ///< External pin CMP0P.1.                  
 402      =1  #define CMP0MX_CMXP__CMP0P2 0x02 ///< External pin CMP0P.2.                  
 403      =1  #define CMP0MX_CMXP__CMP0P3 0x03 ///< External pin CMP0P.3.                  
 404      =1  #define CMP0MX_CMXP__CMP0P4 0x04 ///< External pin CMP0P.4.                  
 405      =1                                                                               
 406      =1  #define CMP0MX_CMXN__FMASK  0x70 ///< Comparator Negative Input MUX Selection
 407      =1  #define CMP0MX_CMXN__SHIFT  0x04 ///< Comparator Negative Input MUX Selection
 408      =1  #define CMP0MX_CMXN__CMP0N0 0x00 ///< External pin CMP0N.0.                  
 409      =1  #define CMP0MX_CMXN__CMP0N1 0x10 ///< External pin CMP0N.1.                  
 410      =1  #define CMP0MX_CMXN__CMP0N2 0x20 ///< External pin CMP0N.2.                  
 411      =1  #define CMP0MX_CMXN__CMP0N3 0x30 ///< External pin CMP0N.3.                  
 412      =1  #define CMP0MX_CMXN__CMP0N4 0x40 ///< External pin CMP0N.4.                  
 413      =1                                                                               
 414      =1  //------------------------------------------------------------------------------
 415      =1  // CMP1CN0 Enums (Comparator 1 Control 0 @ 0x9A)
 416      =1  //------------------------------------------------------------------------------
 417      =1  #define CMP1CN0_CPHYN__FMASK                0x03 ///< Comparator Negative Hysteresis Control            
 418      =1  #define CMP1CN0_CPHYN__SHIFT                0x00 ///< Comparator Negative Hysteresis Control            
 419      =1  #define CMP1CN0_CPHYN__DISABLED             0x00 ///< Negative Hysteresis disabled.                     
 420      =1  #define CMP1CN0_CPHYN__ENABLED_MODE1        0x01 ///< Negative Hysteresis = Hysteresis 1.               
 421      =1  #define CMP1CN0_CPHYN__ENABLED_MODE2        0x02 ///< Negative Hysteresis = Hysteresis 2.               
 422      =1  #define CMP1CN0_CPHYN__ENABLED_MODE3        0x03 ///< Negative Hysteresis = Hysteresis 3 (Maximum).     
 423      =1                                                                                                          
 424      =1  #define CMP1CN0_CPHYP__FMASK                0x0C ///< Comparator Positive Hysteresis Control            
 425      =1  #define CMP1CN0_CPHYP__SHIFT                0x02 ///< Comparator Positive Hysteresis Control            
 426      =1  #define CMP1CN0_CPHYP__DISABLED             0x00 ///< Positive Hysteresis disabled.                     
 427      =1  #define CMP1CN0_CPHYP__ENABLED_MODE1        0x04 ///< Positive Hysteresis = Hysteresis 1.               
 428      =1  #define CMP1CN0_CPHYP__ENABLED_MODE2        0x08 ///< Positive Hysteresis = Hysteresis 2.               
 429      =1  #define CMP1CN0_CPHYP__ENABLED_MODE3        0x0C ///< Positive Hysteresis = Hysteresis 3 (Maximum).     
 430      =1                                                                                                          
 431      =1  #define CMP1CN0_CPFIF__BMASK                0x10 ///< Comparator Falling-Edge Flag                      
 432      =1  #define CMP1CN0_CPFIF__SHIFT                0x04 ///< Comparator Falling-Edge Flag                      
 433      =1  #define CMP1CN0_CPFIF__NOT_SET              0x00 ///< No comparator falling edge has occurred since this
 434      =1                                                   ///< flag was last cleared.                            
 435      =1  #define CMP1CN0_CPFIF__FALLING_EDGE         0x10 ///< Comparator falling edge has occurred.             
 436      =1                                                                                                          
 437      =1  #define CMP1CN0_CPRIF__BMASK                0x20 ///< Comparator Rising-Edge Flag                       
 438      =1  #define CMP1CN0_CPRIF__SHIFT                0x05 ///< Comparator Rising-Edge Flag                       
 439      =1  #define CMP1CN0_CPRIF__NOT_SET              0x00 ///< No comparator rising edge has occurred since this 
 440      =1                                                   ///< flag was last cleared.                            
 441      =1  #define CMP1CN0_CPRIF__RISING_EDGE          0x20 ///< Comparator rising edge has occurred.              
 442      =1                                                                                                          
 443      =1  #define CMP1CN0_CPOUT__BMASK                0x40 ///< Comparator Output State Flag                      
 444      =1  #define CMP1CN0_CPOUT__SHIFT                0x06 ///< Comparator Output State Flag                      
 445      =1  #define CMP1CN0_CPOUT__POS_LESS_THAN_NEG    0x00 ///< Voltage on CP1P < CP1N.                           
 446      =1  #define CMP1CN0_CPOUT__POS_GREATER_THAN_NEG 0x40 ///< Voltage on CP1P > CP1N.                           
 447      =1                                                                                                          
 448      =1  #define CMP1CN0_CPEN__BMASK                 0x80 ///< Comparator Enable                                 
 449      =1  #define CMP1CN0_CPEN__SHIFT                 0x07 ///< Comparator Enable                                 
 450      =1  #define CMP1CN0_CPEN__DISABLED              0x00 ///< Comparator disabled.                              
 451      =1  #define CMP1CN0_CPEN__ENABLED               0x80 ///< Comparator enabled.                               
 452      =1                                                                                                          
 453      =1  //------------------------------------------------------------------------------
 454      =1  // CMP1MD Enums (Comparator 1 Mode @ 0x9C)
 455      =1  //------------------------------------------------------------------------------
 456      =1  #define CMP1MD_CPMD__FMASK              0x03 ///< Comparator Mode Select                      
C51 COMPILER V9.56.0.0   SPI_0                                                             10/28/2016 17:37:02 PAGE 34  

 457      =1  #define CMP1MD_CPMD__SHIFT              0x00 ///< Comparator Mode Select                      
 458      =1  #define CMP1MD_CPMD__MODE0              0x00 ///< Mode 0 (Fastest Response Time, Highest Power
 459      =1                                               ///< Consumption)                                
 460      =1  #define CMP1MD_CPMD__MODE1              0x01 ///< Mode 1                                      
 461      =1  #define CMP1MD_CPMD__MODE2              0x02 ///< Mode 2                                      
 462      =1  #define CMP1MD_CPMD__MODE3              0x03 ///< Mode 3 (Slowest Response Time, Lowest Power 
 463      =1                                               ///< Consumption)                                
 464      =1                                                                                                
 465      =1  #define CMP1MD_CPFIE__BMASK             0x10 ///< Comparator Falling-Edge Interrupt Enable    
 466      =1  #define CMP1MD_CPFIE__SHIFT             0x04 ///< Comparator Falling-Edge Interrupt Enable    
 467      =1  #define CMP1MD_CPFIE__FALL_INT_DISABLED 0x00 ///< Comparator falling-edge interrupt disabled. 
 468      =1  #define CMP1MD_CPFIE__FALL_INT_ENABLED  0x10 ///< Comparator falling-edge interrupt enabled.  
 469      =1                                                                                                
 470      =1  #define CMP1MD_CPRIE__BMASK             0x20 ///< Comparator Rising-Edge Interrupt Enable     
 471      =1  #define CMP1MD_CPRIE__SHIFT             0x05 ///< Comparator Rising-Edge Interrupt Enable     
 472      =1  #define CMP1MD_CPRIE__RISE_INT_DISABLED 0x00 ///< Comparator rising-edge interrupt disabled.  
 473      =1  #define CMP1MD_CPRIE__RISE_INT_ENABLED  0x20 ///< Comparator rising-edge interrupt enabled.   
 474      =1                                                                                                
 475      =1  //------------------------------------------------------------------------------
 476      =1  // CMP1MX Enums (Comparator 1 Multiplexer Selection @ 0x9E)
 477      =1  //------------------------------------------------------------------------------
 478      =1  #define CMP1MX_CMXP__FMASK  0x07 ///< Comparator Positive Input MUX Selection
 479      =1  #define CMP1MX_CMXP__SHIFT  0x00 ///< Comparator Positive Input MUX Selection
 480      =1  #define CMP1MX_CMXP__CMP1P0 0x00 ///< External pin CMP1P.0.                  
 481      =1  #define CMP1MX_CMXP__CMP1P1 0x01 ///< External pin CMP1P.1.                  
 482      =1  #define CMP1MX_CMXP__CMP1P2 0x02 ///< External pin CMP1P.2.                  
 483      =1  #define CMP1MX_CMXP__CMP1P3 0x03 ///< External pin CMP1P.3.                  
 484      =1  #define CMP1MX_CMXP__CMP1P4 0x04 ///< External pin CMP1P.4.                  
 485      =1                                                                               
 486      =1  #define CMP1MX_CMXN__FMASK  0x70 ///< Comparator Negative Input MUX Selection
 487      =1  #define CMP1MX_CMXN__SHIFT  0x04 ///< Comparator Negative Input MUX Selection
 488      =1  #define CMP1MX_CMXN__CMP1N0 0x00 ///< External pin CMP1N.0.                  
 489      =1  #define CMP1MX_CMXN__CMP1N1 0x10 ///< External pin CMP1N.1.                  
 490      =1  #define CMP1MX_CMXN__CMP1N2 0x20 ///< External pin CMP1N.2.                  
 491      =1  #define CMP1MX_CMXN__CMP1N3 0x30 ///< External pin CMP1N.3.                  
 492      =1  #define CMP1MX_CMXN__CMP1N4 0x40 ///< External pin CMP1N.4.                  
 493      =1                                                                               
 494      =1  //------------------------------------------------------------------------------
 495      =1  // IT01CF Enums (INT0/INT1 Configuration @ 0xE4)
 496      =1  //------------------------------------------------------------------------------
 497      =1  #define IT01CF_IN0SL__FMASK       0x07 ///< INT0 Port Pin Selection   
 498      =1  #define IT01CF_IN0SL__SHIFT       0x00 ///< INT0 Port Pin Selection   
 499      =1  #define IT01CF_IN0SL__P0_0        0x00 ///< Select P0.0.              
 500      =1  #define IT01CF_IN0SL__P0_1        0x01 ///< Select P0.1.              
 501      =1  #define IT01CF_IN0SL__P0_2        0x02 ///< Select P0.2.              
 502      =1  #define IT01CF_IN0SL__P0_3        0x03 ///< Select P0.3.              
 503      =1  #define IT01CF_IN0SL__P0_4        0x04 ///< Select P0.4.              
 504      =1  #define IT01CF_IN0SL__P0_5        0x05 ///< Select P0.5.              
 505      =1  #define IT01CF_IN0SL__P0_6        0x06 ///< Select P0.6.              
 506      =1  #define IT01CF_IN0SL__P0_7        0x07 ///< Select P0.7.              
 507      =1                                                                        
 508      =1  #define IT01CF_IN0PL__BMASK       0x08 ///< INT0 Polarity             
 509      =1  #define IT01CF_IN0PL__SHIFT       0x03 ///< INT0 Polarity             
 510      =1  #define IT01CF_IN0PL__ACTIVE_LOW  0x00 ///< INT0 input is active low. 
 511      =1  #define IT01CF_IN0PL__ACTIVE_HIGH 0x08 ///< INT0 input is active high.
 512      =1                                                                        
 513      =1  #define IT01CF_IN1SL__FMASK       0x70 ///< INT1 Port Pin Selection   
 514      =1  #define IT01CF_IN1SL__SHIFT       0x04 ///< INT1 Port Pin Selection   
 515      =1  #define IT01CF_IN1SL__P0_0        0x00 ///< Select P0.0.              
 516      =1  #define IT01CF_IN1SL__P0_1        0x10 ///< Select P0.1.              
 517      =1  #define IT01CF_IN1SL__P0_2        0x20 ///< Select P0.2.              
 518      =1  #define IT01CF_IN1SL__P0_3        0x30 ///< Select P0.3.              
C51 COMPILER V9.56.0.0   SPI_0                                                             10/28/2016 17:37:02 PAGE 35  

 519      =1  #define IT01CF_IN1SL__P0_4        0x40 ///< Select P0.4.              
 520      =1  #define IT01CF_IN1SL__P0_5        0x50 ///< Select P0.5.              
 521      =1  #define IT01CF_IN1SL__P0_6        0x60 ///< Select P0.6.              
 522      =1  #define IT01CF_IN1SL__P0_7        0x70 ///< Select P0.7.              
 523      =1                                                                        
 524      =1  #define IT01CF_IN1PL__BMASK       0x80 ///< INT1 Polarity             
 525      =1  #define IT01CF_IN1PL__SHIFT       0x07 ///< INT1 Polarity             
 526      =1  #define IT01CF_IN1PL__ACTIVE_LOW  0x00 ///< INT1 input is active low. 
 527      =1  #define IT01CF_IN1PL__ACTIVE_HIGH 0x80 ///< INT1 input is active high.
 528      =1                                                                        
 529      =1  //------------------------------------------------------------------------------
 530      =1  // XOSC0CN Enums (External Oscillator Control @ 0xB1)
 531      =1  //------------------------------------------------------------------------------
 532      =1  #define XOSC0CN_XFCN__FMASK           0x07 ///< External Oscillator Frequency Control            
 533      =1  #define XOSC0CN_XFCN__SHIFT           0x00 ///< External Oscillator Frequency Control            
 534      =1  #define XOSC0CN_XFCN__MODE0           0x00 ///< Select external oscillator mode 0: Crystal       
 535      =1                                             ///< frequency <= 20 kHz, RC/C frequency <= 25 kHz, C 
 536      =1                                             ///< mode K factor = 0.87.                            
 537      =1  #define XOSC0CN_XFCN__MODE1           0x01 ///< Select external oscillator mode 1: 20 kHz <      
 538      =1                                             ///< Crystal frequency <= 58 kHz, 25 kHz < RC/C       
 539      =1                                             ///< frequency <= 50 kHz, C mode K factor = 2.6.      
 540      =1  #define XOSC0CN_XFCN__MODE2           0x02 ///< Select external oscillator mode 2: 58 kHz <      
 541      =1                                             ///< Crystal frequency <= 155 kHz, 50 kHz < RC/C      
 542      =1                                             ///< frequency <= 100 kHz, C mode K factor = 7.7.     
 543      =1  #define XOSC0CN_XFCN__MODE3           0x03 ///< Select external oscillator mode 3: 155 kHz <     
 544      =1                                             ///< Crystal frequency <= 415 kHz, 100 kHz < RC/C     
 545      =1                                             ///< frequency <= 200 kHz, C mode K factor = 22.      
 546      =1  #define XOSC0CN_XFCN__MODE4           0x04 ///< Select external oscillator mode 4: 415 kHz <     
 547      =1                                             ///< Crystal frequency <= 1.1 MHz, 200 kHz < RC/C     
 548      =1                                             ///< frequency <= 400 kHz, C mode K factor = 65.      
 549      =1  #define XOSC0CN_XFCN__MODE5           0x05 ///< Select external oscillator mode 5: 1.1 MHz <     
 550      =1                                             ///< Crystal frequency <= 3.1 MHz, 400 kHz < RC/C     
 551      =1                                             ///< frequency <= 800 kHz, C mode K factor = 180.     
 552      =1  #define XOSC0CN_XFCN__MODE6           0x06 ///< Select external oscillator mode 6: 3.1 MHz <     
 553      =1                                             ///< Crystal frequency <= 8.2 kHz, 800 kHz < RC/C     
 554      =1                                             ///< frequency <= 1.6 MHz, C mode K factor = 664.     
 555      =1  #define XOSC0CN_XFCN__MODE7           0x07 ///< Select external oscillator mode 7: 8.2 MHz <     
 556      =1                                             ///< Crystal frequency <= 25 MHz, 1.6 MHz < RC/C      
 557      =1                                             ///< frequency <= 3.2 MHz, C mode K factor = 1590.    
 558      =1                                                                                                   
 559      =1  #define XOSC0CN_XOSCMD__FMASK         0x70 ///< External Oscillator Mode                         
 560      =1  #define XOSC0CN_XOSCMD__SHIFT         0x04 ///< External Oscillator Mode                         
 561      =1  #define XOSC0CN_XOSCMD__DISABLED      0x00 ///< External Oscillator circuit disabled.            
 562      =1  #define XOSC0CN_XOSCMD__CMOS          0x20 ///< External CMOS Clock Mode.                        
 563      =1  #define XOSC0CN_XOSCMD__CMOS_DIV_2    0x30 ///< External CMOS Clock Mode with divide by 2 stage. 
 564      =1  #define XOSC0CN_XOSCMD__RC_DIV_2      0x40 ///< RC Oscillator Mode with divide by 2 stage.       
 565      =1  #define XOSC0CN_XOSCMD__C_DIV_2       0x50 ///< Capacitor Oscillator Mode with divide by 2 stage.
 566      =1  #define XOSC0CN_XOSCMD__CRYSTAL       0x60 ///< Crystal Oscillator Mode.                         
 567      =1  #define XOSC0CN_XOSCMD__CRYSTAL_DIV_2 0x70 ///< Crystal Oscillator Mode with divide by 2 stage.  
 568      =1                                                                                                   
 569      =1  #define XOSC0CN_XCLKVLD__BMASK        0x80 ///< External Oscillator Valid Flag                   
 570      =1  #define XOSC0CN_XCLKVLD__SHIFT        0x07 ///< External Oscillator Valid Flag                   
 571      =1  #define XOSC0CN_XCLKVLD__NOT_SET      0x00 ///< External Oscillator is unused or not yet stable. 
 572      =1  #define XOSC0CN_XCLKVLD__SET          0x80 ///< External Oscillator is running and stable.       
 573      =1                                                                                                   
 574      =1  //------------------------------------------------------------------------------
 575      =1  // FLKEY Enums (Flash Lock and Key @ 0xB7)
 576      =1  //------------------------------------------------------------------------------
 577      =1  #define FLKEY_FLKEY__FMASK    0xFF ///< Flash Lock and Key                             
 578      =1  #define FLKEY_FLKEY__SHIFT    0x00 ///< Flash Lock and Key                             
 579      =1  #define FLKEY_FLKEY__LOCKED   0x00 ///< Flash is write/erase locked.                   
 580      =1  #define FLKEY_FLKEY__FIRST    0x01 ///< The first key code has been written (0xA5).    
C51 COMPILER V9.56.0.0   SPI_0                                                             10/28/2016 17:37:02 PAGE 36  

 581      =1  #define FLKEY_FLKEY__UNLOCKED 0x02 ///< Flash is unlocked (writes/erases allowed).     
 582      =1  #define FLKEY_FLKEY__DISABLED 0x03 ///< Flash writes/erases are disabled until the next
 583      =1                                     ///< reset.                                         
 584      =1  #define FLKEY_FLKEY__KEY1     0xA5 ///< Flash writes and erases are enabled by writing 
 585      =1                                     ///< 0xA5 followed by 0xF1 to the FLKEY register.   
 586      =1  #define FLKEY_FLKEY__KEY2     0xF1 ///< Flash writes and erases are enabled by writing 
 587      =1                                     ///< 0xA5 followed by 0xF1 to the FLKEY register.   
 588      =1                                                                                         
 589      =1  //------------------------------------------------------------------------------
 590      =1  // FLSCL Enums (Flash Scale @ 0xB6)
 591      =1  //------------------------------------------------------------------------------
 592      =1  #define FLSCL_FLRT__BMASK               0x10 ///< Flash Read Timing                       
 593      =1  #define FLSCL_FLRT__SHIFT               0x04 ///< Flash Read Timing                       
 594      =1  #define FLSCL_FLRT__SYSCLK_BELOW_25_MHZ 0x00 ///< SYSCLK <= 25 MHz.                       
 595      =1  #define FLSCL_FLRT__SYSCLK_BELOW_48_MHZ 0x10 ///< SYSCLK <= 48 MHz.                       
 596      =1                                                                                            
 597      =1  #define FLSCL_FOSE__BMASK               0x80 ///< Flash One-Shot Enable                   
 598      =1  #define FLSCL_FOSE__SHIFT               0x07 ///< Flash One-Shot Enable                   
 599      =1  #define FLSCL_FOSE__DISABLED            0x00 ///< Disable the flash one-shot.             
 600      =1  #define FLSCL_FOSE__ENABLED             0x80 ///< Enable the flash one-shot (recommended).
 601      =1                                                                                            
 602      =1  //------------------------------------------------------------------------------
 603      =1  // PSCTL Enums (Program Store Control @ 0x8F)
 604      =1  //------------------------------------------------------------------------------
 605      =1  #define PSCTL_PSWE__BMASK          0x01 ///< Program Store Write Enable                      
 606      =1  #define PSCTL_PSWE__SHIFT          0x00 ///< Program Store Write Enable                      
 607      =1  #define PSCTL_PSWE__WRITE_DISABLED 0x00 ///< Writes to flash program memory disabled.        
 608      =1  #define PSCTL_PSWE__WRITE_ENABLED  0x01 ///< Writes to flash program memory enabled; the MOVX
 609      =1                                          ///< write instruction targets flash memory.         
 610      =1                                                                                               
 611      =1  #define PSCTL_PSEE__BMASK          0x02 ///< Program Store Erase Enable                      
 612      =1  #define PSCTL_PSEE__SHIFT          0x01 ///< Program Store Erase Enable                      
 613      =1  #define PSCTL_PSEE__ERASE_DISABLED 0x00 ///< Flash program memory erasure disabled.          
 614      =1  #define PSCTL_PSEE__ERASE_ENABLED  0x02 ///< Flash program memory erasure enabled.           
 615      =1                                                                                               
 616      =1  //------------------------------------------------------------------------------
 617      =1  // HFO0CAL Enums (High Frequency Oscillator Calibration @ 0xB3)
 618      =1  //------------------------------------------------------------------------------
 619      =1  #define HFO0CAL_OSCICL__FMASK 0x7F ///< Internal Oscillator Calibration
 620      =1  #define HFO0CAL_OSCICL__SHIFT 0x00 ///< Internal Oscillator Calibration
 621      =1                                                                         
 622      =1  //------------------------------------------------------------------------------
 623      =1  // HFO0CN Enums (High Frequency Oscillator Control @ 0xB2)
 624      =1  //------------------------------------------------------------------------------
 625      =1  #define HFO0CN_IFCN__FMASK        0x03 ///< Oscillator Frequency Divider Control              
 626      =1  #define HFO0CN_IFCN__SHIFT        0x00 ///< Oscillator Frequency Divider Control              
 627      =1  #define HFO0CN_IFCN__SYSCLK_DIV_8 0x00 ///< SYSCLK can be derived from Internal H-F Oscillator
 628      =1                                         ///< divided by 8 (1.5 MHz).                           
 629      =1  #define HFO0CN_IFCN__SYSCLK_DIV_4 0x01 ///< SYSCLK can be derived from Internal H-F Oscillator
 630      =1                                         ///< divided by 4 (3 MHz).                             
 631      =1  #define HFO0CN_IFCN__SYSCLK_DIV_2 0x02 ///< SYSCLK can be derived from Internal H-F Oscillator
 632      =1                                         ///< divided by 2 (6 MHz).                             
 633      =1  #define HFO0CN_IFCN__SYSCLK_DIV_1 0x03 ///< SYSCLK can be derived from Internal H-F Oscillator
 634      =1                                         ///< divided by 1 (12 MHz).                            
 635      =1                                                                                                
 636      =1  #define HFO0CN_SUSPEND__BMASK     0x20 ///< Oscillator Suspend Enable                         
 637      =1  #define HFO0CN_SUSPEND__SHIFT     0x05 ///< Oscillator Suspend Enable                         
 638      =1  #define HFO0CN_SUSPEND__DISABLED  0x00 ///< The internal oscillator is not in suspend mode.   
 639      =1  #define HFO0CN_SUSPEND__ENABLED   0x20 ///< Place the internal oscillator in suspend mode.    
 640      =1                                                                                                
 641      =1  #define HFO0CN_IFRDY__BMASK       0x40 ///< Oscillator Frequency Ready Flag                   
 642      =1  #define HFO0CN_IFRDY__SHIFT       0x06 ///< Oscillator Frequency Ready Flag                   
C51 COMPILER V9.56.0.0   SPI_0                                                             10/28/2016 17:37:02 PAGE 37  

 643      =1  #define HFO0CN_IFRDY__NOT_SET     0x00 ///< The Internal High Frequency Oscillator is not     
 644      =1                                         ///< running at the programmed frequency.              
 645      =1  #define HFO0CN_IFRDY__SET         0x40 ///< The Internal High Frequency Oscillator is running 
 646      =1                                         ///< at the programmed frequency.                      
 647      =1                                                                                                
 648      =1  #define HFO0CN_IOSCEN__BMASK      0x80 ///< Oscillator Enable                                 
 649      =1  #define HFO0CN_IOSCEN__SHIFT      0x07 ///< Oscillator Enable                                 
 650      =1  #define HFO0CN_IOSCEN__DISABLED   0x00 ///< Disable the High Frequency Oscillator.            
 651      =1  #define HFO0CN_IOSCEN__ENABLED    0x80 ///< Enable the High Frequency Oscillator.             
 652      =1                                                                                                
 653      =1  //------------------------------------------------------------------------------
 654      =1  // EIE1 Enums (Extended Interrupt Enable 1 @ 0xE6)
 655      =1  //------------------------------------------------------------------------------
 656      =1  #define EIE1_ESMB0__BMASK     0x01 ///< SMBus (SMB0) Interrupt Enable                     
 657      =1  #define EIE1_ESMB0__SHIFT     0x00 ///< SMBus (SMB0) Interrupt Enable                     
 658      =1  #define EIE1_ESMB0__DISABLED  0x00 ///< Disable all SMB0 interrupts.                      
 659      =1  #define EIE1_ESMB0__ENABLED   0x01 ///< Enable interrupt requests generated by SMB0.      
 660      =1                                                                                            
 661      =1  #define EIE1_EUSB0__BMASK     0x02 ///< USB (USB0) Interrupt Enable                       
 662      =1  #define EIE1_EUSB0__SHIFT     0x01 ///< USB (USB0) Interrupt Enable                       
 663      =1  #define EIE1_EUSB0__DISABLED  0x00 ///< Disable all USB0 interrupts.                      
 664      =1  #define EIE1_EUSB0__ENABLED   0x02 ///< Enable interrupt requests generated by USB0.      
 665      =1                                                                                            
 666      =1  #define EIE1_EWADC0__BMASK    0x04 ///< ADC0 Window Comparison Interrupt Enable           
 667      =1  #define EIE1_EWADC0__SHIFT    0x02 ///< ADC0 Window Comparison Interrupt Enable           
 668      =1  #define EIE1_EWADC0__DISABLED 0x00 ///< Disable ADC0 Window Comparison interrupt.         
 669      =1  #define EIE1_EWADC0__ENABLED  0x04 ///< Enable interrupt requests generated by ADC0 Window
 670      =1                                     ///< Compare flag (ADWINT).                            
 671      =1                                                                                            
 672      =1  #define EIE1_EADC0__BMASK     0x08 ///< ADC0 Conversion Complete Interrupt Enable         
 673      =1  #define EIE1_EADC0__SHIFT     0x03 ///< ADC0 Conversion Complete Interrupt Enable         
 674      =1  #define EIE1_EADC0__DISABLED  0x00 ///< Disable ADC0 Conversion Complete interrupt.       
 675      =1  #define EIE1_EADC0__ENABLED   0x08 ///< Enable interrupt requests generated by the ADINT  
 676      =1                                     ///< flag.                                             
 677      =1                                                                                            
 678      =1  #define EIE1_EPCA0__BMASK     0x10 ///< Programmable Counter Array (PCA0) Interrupt Enable
 679      =1  #define EIE1_EPCA0__SHIFT     0x04 ///< Programmable Counter Array (PCA0) Interrupt Enable
 680      =1  #define EIE1_EPCA0__DISABLED  0x00 ///< Disable all PCA0 interrupts.                      
 681      =1  #define EIE1_EPCA0__ENABLED   0x10 ///< Enable interrupt requests generated by PCA0.      
 682      =1                                                                                            
 683      =1  #define EIE1_ECP0__BMASK      0x20 ///< Comparator0 (CP0) Interrupt Enable                
 684      =1  #define EIE1_ECP0__SHIFT      0x05 ///< Comparator0 (CP0) Interrupt Enable                
 685      =1  #define EIE1_ECP0__DISABLED   0x00 ///< Disable CP0 interrupts.                           
 686      =1  #define EIE1_ECP0__ENABLED    0x20 ///< Enable interrupt requests generated by the        
 687      =1                                     ///< comparator 0 CPRIF or CPFIF flags.                
 688      =1                                                                                            
 689      =1  #define EIE1_ECP1__BMASK      0x40 ///< Comparator1 (CP1) Interrupt Enable                
 690      =1  #define EIE1_ECP1__SHIFT      0x06 ///< Comparator1 (CP1) Interrupt Enable                
 691      =1  #define EIE1_ECP1__DISABLED   0x00 ///< Disable CP1 interrupts.                           
 692      =1  #define EIE1_ECP1__ENABLED    0x40 ///< Enable interrupt requests generated by the        
 693      =1                                     ///< comparator 1 CPRIF or CPFIF flags.                
 694      =1                                                                                            
 695      =1  #define EIE1_ET3__BMASK       0x80 ///< Timer 3 Interrupt Enable                          
 696      =1  #define EIE1_ET3__SHIFT       0x07 ///< Timer 3 Interrupt Enable                          
 697      =1  #define EIE1_ET3__DISABLED    0x00 ///< Disable Timer 3 interrupts.                       
 698      =1  #define EIE1_ET3__ENABLED     0x80 ///< Enable interrupt requests generated by the TF3L or
 699      =1                                     ///< TF3H flags.                                       
 700      =1                                                                                            
 701      =1  //------------------------------------------------------------------------------
 702      =1  // EIE2 Enums (Extended Interrupt Enable 2 @ 0xE7)
 703      =1  //------------------------------------------------------------------------------
 704      =1  #define EIE2_EVBUS__BMASK    0x01 ///< VBUS Level Interrupt Enable                       
C51 COMPILER V9.56.0.0   SPI_0                                                             10/28/2016 17:37:02 PAGE 38  

 705      =1  #define EIE2_EVBUS__SHIFT    0x00 ///< VBUS Level Interrupt Enable                       
 706      =1  #define EIE2_EVBUS__DISABLED 0x00 ///< Disable all VBUS interrupts.                      
 707      =1  #define EIE2_EVBUS__ENABLED  0x01 ///< Enable interrupt requests generated by VBUS level 
 708      =1                                    ///< sense.                                            
 709      =1                                                                                           
 710      =1  #define EIE2_ES1__BMASK      0x02 ///< UART1 Interrupt Enable                            
 711      =1  #define EIE2_ES1__SHIFT      0x01 ///< UART1 Interrupt Enable                            
 712      =1  #define EIE2_ES1__DISABLED   0x00 ///< Disable UART1 interrupt.                          
 713      =1  #define EIE2_ES1__ENABLED    0x02 ///< Enable UART1 interrupt.                           
 714      =1                                                                                           
 715      =1  #define EIE2_ESMB1__BMASK    0x08 ///< SMBus1 Interrupt Enable                           
 716      =1  #define EIE2_ESMB1__SHIFT    0x03 ///< SMBus1 Interrupt Enable                           
 717      =1  #define EIE2_ESMB1__DISABLED 0x00 ///< Disable all SMB1 interrupts.                      
 718      =1  #define EIE2_ESMB1__ENABLED  0x08 ///< Enable interrupt requests generated by SMB1.      
 719      =1                                                                                           
 720      =1  #define EIE2_ET4__BMASK      0x10 ///< Timer 4 Interrupt Enable                          
 721      =1  #define EIE2_ET4__SHIFT      0x04 ///< Timer 4 Interrupt Enable                          
 722      =1  #define EIE2_ET4__DISABLED   0x00 ///< Disable Timer 4interrupts.                        
 723      =1  #define EIE2_ET4__ENABLED    0x10 ///< Enable interrupt requests generated by the TF4L or
 724      =1                                    ///< TF4H flags.                                       
 725      =1                                                                                           
 726      =1  #define EIE2_ET5__BMASK      0x20 ///< Timer 5 Interrupt Enable                          
 727      =1  #define EIE2_ET5__SHIFT      0x05 ///< Timer 5 Interrupt Enable                          
 728      =1  #define EIE2_ET5__DISABLED   0x00 ///< Disable Timer 5 interrupts.                       
 729      =1  #define EIE2_ET5__ENABLED    0x20 ///< Enable interrupt requests generated by the TF5L or
 730      =1                                    ///< TF5H flags.                                       
 731      =1                                                                                           
 732      =1  //------------------------------------------------------------------------------
 733      =1  // EIP1 Enums (Extended Interrupt Priority 1 @ 0xF6)
 734      =1  //------------------------------------------------------------------------------
 735      =1  #define EIP1_PSMB0__BMASK  0x01 ///< SMBus (SMB0) Interrupt Priority Control                     
 736      =1  #define EIP1_PSMB0__SHIFT  0x00 ///< SMBus (SMB0) Interrupt Priority Control                     
 737      =1  #define EIP1_PSMB0__LOW    0x00 ///< SMB0 interrupt set to low priority level.                   
 738      =1  #define EIP1_PSMB0__HIGH   0x01 ///< SMB0 interrupt set to high priority level.                  
 739      =1                                                                                                   
 740      =1  #define EIP1_PUSB0__BMASK  0x02 ///< USB (USB0) Interrupt Priority Control                       
 741      =1  #define EIP1_PUSB0__SHIFT  0x01 ///< USB (USB0) Interrupt Priority Control                       
 742      =1  #define EIP1_PUSB0__LOW    0x00 ///< USB0 interrupt set to low priority level.                   
 743      =1  #define EIP1_PUSB0__HIGH   0x02 ///< USB0 interrupt set to high priority level.                  
 744      =1                                                                                                   
 745      =1  #define EIP1_PWADC0__BMASK 0x04 ///< ADC0 Window Comparator Interrupt Priority Control           
 746      =1  #define EIP1_PWADC0__SHIFT 0x02 ///< ADC0 Window Comparator Interrupt Priority Control           
 747      =1  #define EIP1_PWADC0__LOW   0x00 ///< ADC0 Window interrupt set to low priority level.            
 748      =1  #define EIP1_PWADC0__HIGH  0x04 ///< ADC0 Window interrupt set to high priority level.           
 749      =1                                                                                                   
 750      =1  #define EIP1_PADC0__BMASK  0x08 ///< ADC0 Conversion Complete Interrupt Priority Control         
 751      =1  #define EIP1_PADC0__SHIFT  0x03 ///< ADC0 Conversion Complete Interrupt Priority Control         
 752      =1  #define EIP1_PADC0__LOW    0x00 ///< ADC0 Conversion Complete interrupt set to low               
 753      =1                                  ///< priority level.                                             
 754      =1  #define EIP1_PADC0__HIGH   0x08 ///< ADC0 Conversion Complete interrupt set to high              
 755      =1                                  ///< priority level.                                             
 756      =1                                                                                                   
 757      =1  #define EIP1_PPCA0__BMASK  0x10 ///< Programmable Counter Array (PCA0) Interrupt Priority Control
 758      =1  #define EIP1_PPCA0__SHIFT  0x04 ///< Programmable Counter Array (PCA0) Interrupt Priority Control
 759      =1  #define EIP1_PPCA0__LOW    0x00 ///< PCA0 interrupt set to low priority level.                   
 760      =1  #define EIP1_PPCA0__HIGH   0x10 ///< PCA0 interrupt set to high priority level.                  
 761      =1                                                                                                   
 762      =1  #define EIP1_PCP0__BMASK   0x20 ///< Comparator0 (CP0) Interrupt Priority Control                
 763      =1  #define EIP1_PCP0__SHIFT   0x05 ///< Comparator0 (CP0) Interrupt Priority Control                
 764      =1  #define EIP1_PCP0__LOW     0x00 ///< CP0 interrupt set to low priority level.                    
 765      =1  #define EIP1_PCP0__HIGH    0x20 ///< CP0 interrupt set to high priority level.                   
 766      =1                                                                                                   
C51 COMPILER V9.56.0.0   SPI_0                                                             10/28/2016 17:37:02 PAGE 39  

 767      =1  #define EIP1_PCP1__BMASK   0x40 ///< Comparator1 (CP1) Interrupt Priority Control                
 768      =1  #define EIP1_PCP1__SHIFT   0x06 ///< Comparator1 (CP1) Interrupt Priority Control                
 769      =1  #define EIP1_PCP1__LOW     0x00 ///< CP1 interrupt set to low priority level.                    
 770      =1  #define EIP1_PCP1__HIGH    0x40 ///< CP1 interrupt set to high priority level.                   
 771      =1                                                                                                   
 772      =1  #define EIP1_PT3__BMASK    0x80 ///< Timer 3 Interrupt Priority Control                          
 773      =1  #define EIP1_PT3__SHIFT    0x07 ///< Timer 3 Interrupt Priority Control                          
 774      =1  #define EIP1_PT3__LOW      0x00 ///< Timer 3 interrupts set to low priority level.               
 775      =1  #define EIP1_PT3__HIGH     0x80 ///< Timer 3 interrupts set to high priority level.              
 776      =1                                                                                                   
 777      =1  //------------------------------------------------------------------------------
 778      =1  // EIP2 Enums (Extended Interrupt Priority 2 @ 0xF7)
 779      =1  //------------------------------------------------------------------------------
 780      =1  #define EIP2_PVBUS__BMASK 0x01 ///< VBUS Level Interrupt Priority Control        
 781      =1  #define EIP2_PVBUS__SHIFT 0x00 ///< VBUS Level Interrupt Priority Control        
 782      =1  #define EIP2_PVBUS__LOW   0x00 ///< VBUS interrupt set to low priority level.    
 783      =1  #define EIP2_PVBUS__HIGH  0x01 ///< VBUS interrupt set to high priority level.   
 784      =1                                                                                   
 785      =1  #define EIP2_PS1__BMASK   0x02 ///< UART1 Interrupt Priority Control             
 786      =1  #define EIP2_PS1__SHIFT   0x01 ///< UART1 Interrupt Priority Control             
 787      =1  #define EIP2_PS1__LOW     0x00 ///< UART1 interrupt set to low priority level.   
 788      =1  #define EIP2_PS1__HIGH    0x02 ///< UART1 interrupt set to high priority level.  
 789      =1                                                                                   
 790      =1  #define EIP2_PSMB1__BMASK 0x08 ///< SMBus1 Interrupt Priority Control            
 791      =1  #define EIP2_PSMB1__SHIFT 0x03 ///< SMBus1 Interrupt Priority Control            
 792      =1  #define EIP2_PSMB1__LOW   0x00 ///< SMB1 interrupt set to low priority level.    
 793      =1  #define EIP2_PSMB1__HIGH  0x08 ///< SMB1 interrupt set to high priority level.   
 794      =1                                                                                   
 795      =1  #define EIP2_PT4__BMASK   0x10 ///< Timer 4 Interrupt Priority Control           
 796      =1  #define EIP2_PT4__SHIFT   0x04 ///< Timer 4 Interrupt Priority Control           
 797      =1  #define EIP2_PT4__LOW     0x00 ///< Timer 4 interrupt set to low priority level. 
 798      =1  #define EIP2_PT4__HIGH    0x10 ///< Timer 4 interrupt set to high priority level.
 799      =1                                                                                   
 800      =1  #define EIP2_PT5__BMASK   0x20 ///< Timer 5 Interrupt Priority Control           
 801      =1  #define EIP2_PT5__SHIFT   0x05 ///< Timer 5 Interrupt Priority Control           
 802      =1  #define EIP2_PT5__LOW     0x00 ///< Timer 5 interrupt set to low priority level. 
 803      =1  #define EIP2_PT5__HIGH    0x20 ///< Timer 5 interrupt set to high priority level.
 804      =1                                                                                   
 805      =1  //------------------------------------------------------------------------------
 806      =1  // IE Enums (Interrupt Enable @ 0xA8)
 807      =1  //------------------------------------------------------------------------------
 808      =1  #define IE_EX0__BMASK      0x01 ///< External Interrupt 0 Enable                       
 809      =1  #define IE_EX0__SHIFT      0x00 ///< External Interrupt 0 Enable                       
 810      =1  #define IE_EX0__DISABLED   0x00 ///< Disable external interrupt 0.                     
 811      =1  #define IE_EX0__ENABLED    0x01 ///< Enable interrupt requests generated by the INT0   
 812      =1                                  ///< input.                                            
 813      =1                                                                                         
 814      =1  #define IE_ET0__BMASK      0x02 ///< Timer 0 Interrupt Enable                          
 815      =1  #define IE_ET0__SHIFT      0x01 ///< Timer 0 Interrupt Enable                          
 816      =1  #define IE_ET0__DISABLED   0x00 ///< Disable all Timer 0 interrupt.                    
 817      =1  #define IE_ET0__ENABLED    0x02 ///< Enable interrupt requests generated by the TF0    
 818      =1                                  ///< flag.                                             
 819      =1                                                                                         
 820      =1  #define IE_EX1__BMASK      0x04 ///< External Interrupt 1 Enable                       
 821      =1  #define IE_EX1__SHIFT      0x02 ///< External Interrupt 1 Enable                       
 822      =1  #define IE_EX1__DISABLED   0x00 ///< Disable external interrupt 1.                     
 823      =1  #define IE_EX1__ENABLED    0x04 ///< Enable interrupt requests generated by the INT1   
 824      =1                                  ///< input.                                            
 825      =1                                                                                         
 826      =1  #define IE_ET1__BMASK      0x08 ///< Timer 1 Interrupt Enable                          
 827      =1  #define IE_ET1__SHIFT      0x03 ///< Timer 1 Interrupt Enable                          
 828      =1  #define IE_ET1__DISABLED   0x00 ///< Disable all Timer 1 interrupt.                    
C51 COMPILER V9.56.0.0   SPI_0                                                             10/28/2016 17:37:02 PAGE 40  

 829      =1  #define IE_ET1__ENABLED    0x08 ///< Enable interrupt requests generated by the TF1    
 830      =1                                  ///< flag.                                             
 831      =1                                                                                         
 832      =1  #define IE_ES0__BMASK      0x10 ///< UART0 Interrupt Enable                            
 833      =1  #define IE_ES0__SHIFT      0x04 ///< UART0 Interrupt Enable                            
 834      =1  #define IE_ES0__DISABLED   0x00 ///< Disable UART0 interrupt.                          
 835      =1  #define IE_ES0__ENABLED    0x10 ///< Enable UART0 interrupt.                           
 836      =1                                                                                         
 837      =1  #define IE_ET2__BMASK      0x20 ///< Timer 2 Interrupt Enable                          
 838      =1  #define IE_ET2__SHIFT      0x05 ///< Timer 2 Interrupt Enable                          
 839      =1  #define IE_ET2__DISABLED   0x00 ///< Disable Timer 2 interrupt.                        
 840      =1  #define IE_ET2__ENABLED    0x20 ///< Enable interrupt requests generated by the TF2L or
 841      =1                                  ///< TF2H flags.                                       
 842      =1                                                                                         
 843      =1  #define IE_ESPI0__BMASK    0x40 ///< SPI0 Interrupt Enable                             
 844      =1  #define IE_ESPI0__SHIFT    0x06 ///< SPI0 Interrupt Enable                             
 845      =1  #define IE_ESPI0__DISABLED 0x00 ///< Disable all SPI0 interrupts.                      
 846      =1  #define IE_ESPI0__ENABLED  0x40 ///< Enable interrupt requests generated by SPI0.      
 847      =1                                                                                         
 848      =1  #define IE_EA__BMASK       0x80 ///< All Interrupts Enable                             
 849      =1  #define IE_EA__SHIFT       0x07 ///< All Interrupts Enable                             
 850      =1  #define IE_EA__DISABLED    0x00 ///< Disable all interrupt sources.                    
 851      =1  #define IE_EA__ENABLED     0x80 ///< Enable each interrupt according to its individual 
 852      =1                                  ///< mask setting.                                     
 853      =1                                                                                         
 854      =1  //------------------------------------------------------------------------------
 855      =1  // IP Enums (Interrupt Priority @ 0xB8)
 856      =1  //------------------------------------------------------------------------------
 857      =1  #define IP_PX0__BMASK   0x01 ///< External Interrupt 0 Priority Control                        
 858      =1  #define IP_PX0__SHIFT   0x00 ///< External Interrupt 0 Priority Control                        
 859      =1  #define IP_PX0__LOW     0x00 ///< External Interrupt 0 set to low priority level.              
 860      =1  #define IP_PX0__HIGH    0x01 ///< External Interrupt 0 set to high priority level.             
 861      =1                                                                                                 
 862      =1  #define IP_PT0__BMASK   0x02 ///< Timer 0 Interrupt Priority Control                           
 863      =1  #define IP_PT0__SHIFT   0x01 ///< Timer 0 Interrupt Priority Control                           
 864      =1  #define IP_PT0__LOW     0x00 ///< Timer 0 interrupt set to low priority level.                 
 865      =1  #define IP_PT0__HIGH    0x02 ///< Timer 0 interrupt set to high priority level.                
 866      =1                                                                                                 
 867      =1  #define IP_PX1__BMASK   0x04 ///< External Interrupt 1 Priority Control                        
 868      =1  #define IP_PX1__SHIFT   0x02 ///< External Interrupt 1 Priority Control                        
 869      =1  #define IP_PX1__LOW     0x00 ///< External Interrupt 1 set to low priority level.              
 870      =1  #define IP_PX1__HIGH    0x04 ///< External Interrupt 1 set to high priority level.             
 871      =1                                                                                                 
 872      =1  #define IP_PT1__BMASK   0x08 ///< Timer 1 Interrupt Priority Control                           
 873      =1  #define IP_PT1__SHIFT   0x03 ///< Timer 1 Interrupt Priority Control                           
 874      =1  #define IP_PT1__LOW     0x00 ///< Timer 1 interrupt set to low priority level.                 
 875      =1  #define IP_PT1__HIGH    0x08 ///< Timer 1 interrupt set to high priority level.                
 876      =1                                                                                                 
 877      =1  #define IP_PS0__BMASK   0x10 ///< UART0 Interrupt Priority Control                             
 878      =1  #define IP_PS0__SHIFT   0x04 ///< UART0 Interrupt Priority Control                             
 879      =1  #define IP_PS0__LOW     0x00 ///< UART0 interrupt set to low priority level.                   
 880      =1  #define IP_PS0__HIGH    0x10 ///< UART0 interrupt set to high priority level.                  
 881      =1                                                                                                 
 882      =1  #define IP_PT2__BMASK   0x20 ///< Timer 2 Interrupt Priority Control                           
 883      =1  #define IP_PT2__SHIFT   0x05 ///< Timer 2 Interrupt Priority Control                           
 884      =1  #define IP_PT2__LOW     0x00 ///< Timer 2 interrupt set to low priority level.                 
 885      =1  #define IP_PT2__HIGH    0x20 ///< Timer 2 interrupt set to high priority level.                
 886      =1                                                                                                 
 887      =1  #define IP_PSPI0__BMASK 0x40 ///< Serial Peripheral Interface (SPI0) Interrupt Priority Control
 888      =1  #define IP_PSPI0__SHIFT 0x06 ///< Serial Peripheral Interface (SPI0) Interrupt Priority Control
 889      =1  #define IP_PSPI0__LOW   0x00 ///< SPI0 interrupt set to low priority level.                    
 890      =1  #define IP_PSPI0__HIGH  0x40 ///< SPI0 interrupt set to high priority level.                   
C51 COMPILER V9.56.0.0   SPI_0                                                             10/28/2016 17:37:02 PAGE 41  

 891      =1                                                                                                 
 892      =1  //------------------------------------------------------------------------------
 893      =1  // LFO0CN Enums (Low Frequency Oscillator Control @ 0x86)
 894      =1  //------------------------------------------------------------------------------
 895      =1  #define LFO0CN_OSCLD__FMASK       0x03 ///< Internal L-F Oscillator Divider Select           
 896      =1  #define LFO0CN_OSCLD__SHIFT       0x00 ///< Internal L-F Oscillator Divider Select           
 897      =1  #define LFO0CN_OSCLD__DIVIDE_BY_8 0x00 ///< Divide by 8 selected.                            
 898      =1  #define LFO0CN_OSCLD__DIVIDE_BY_4 0x01 ///< Divide by 4 selected.                            
 899      =1  #define LFO0CN_OSCLD__DIVIDE_BY_2 0x02 ///< Divide by 2 selected.                            
 900      =1  #define LFO0CN_OSCLD__DIVIDE_BY_1 0x03 ///< Divide by 1 selected.                            
 901      =1                                                                                               
 902      =1  #define LFO0CN_OSCLF__FMASK       0x3C ///< Internal L-F Oscillator Frequency Control        
 903      =1  #define LFO0CN_OSCLF__SHIFT       0x02 ///< Internal L-F Oscillator Frequency Control        
 904      =1                                                                                               
 905      =1  #define LFO0CN_OSCLRDY__BMASK     0x40 ///< Internal L-F Oscillator Ready                    
 906      =1  #define LFO0CN_OSCLRDY__SHIFT     0x06 ///< Internal L-F Oscillator Ready                    
 907      =1  #define LFO0CN_OSCLRDY__NOT_SET   0x00 ///< Internal L-F Oscillator frequency not stabilized.
 908      =1  #define LFO0CN_OSCLRDY__SET       0x40 ///< Internal L-F Oscillator frequency stabilized.    
 909      =1                                                                                               
 910      =1  #define LFO0CN_OSCLEN__BMASK      0x80 ///< Internal L-F Oscillator Enable                   
 911      =1  #define LFO0CN_OSCLEN__SHIFT      0x07 ///< Internal L-F Oscillator Enable                   
 912      =1  #define LFO0CN_OSCLEN__DISABLED   0x00 ///< Internal L-F Oscillator Disabled.                
 913      =1  #define LFO0CN_OSCLEN__ENABLED    0x80 ///< Internal L-F Oscillator Enabled.                 
 914      =1                                                                                               
 915      =1  //------------------------------------------------------------------------------
 916      =1  // XBR0 Enums (Port I/O Crossbar 0 @ 0xE1)
 917      =1  //------------------------------------------------------------------------------
 918      =1  #define XBR0_URT0E__BMASK     0x01 ///< UART0 I/O Output Enable                        
 919      =1  #define XBR0_URT0E__SHIFT     0x00 ///< UART0 I/O Output Enable                        
 920      =1  #define XBR0_URT0E__DISABLED  0x00 ///< UART0 I/O unavailable at Port pin.             
 921      =1  #define XBR0_URT0E__ENABLED   0x01 ///< UART0 TX, RX routed to Port pins P0.4 and P0.5.
 922      =1                                                                                         
 923      =1  #define XBR0_SPI0E__BMASK     0x02 ///< SPI I/O Enable                                 
 924      =1  #define XBR0_SPI0E__SHIFT     0x01 ///< SPI I/O Enable                                 
 925      =1  #define XBR0_SPI0E__DISABLED  0x00 ///< SPI I/O unavailable at Port pins.              
 926      =1  #define XBR0_SPI0E__ENABLED   0x02 ///< SPI I/O routed to Port pins. The SPI can be    
 927      =1                                     ///< assigned either 3 or 4 GPIO pins.              
 928      =1                                                                                         
 929      =1  #define XBR0_SMB0E__BMASK     0x04 ///< SMB0 I/O Enable                                
 930      =1  #define XBR0_SMB0E__SHIFT     0x02 ///< SMB0 I/O Enable                                
 931      =1  #define XBR0_SMB0E__DISABLED  0x00 ///< SMBus 0 I/O unavailable at Port pins.          
 932      =1  #define XBR0_SMB0E__ENABLED   0x04 ///< SMBus 0 I/O routed to Port pins.               
 933      =1                                                                                         
 934      =1  #define XBR0_SYSCKE__BMASK    0x08 ///< SYSCLK Output Enable                           
 935      =1  #define XBR0_SYSCKE__SHIFT    0x03 ///< SYSCLK Output Enable                           
 936      =1  #define XBR0_SYSCKE__DISABLED 0x00 ///< SYSCLK unavailable at Port pin.                
 937      =1  #define XBR0_SYSCKE__ENABLED  0x08 ///< SYSCLK output routed to Port pin.              
 938      =1                                                                                         
 939      =1  #define XBR0_CP0E__BMASK      0x10 ///< Comparator0 Output Enable                      
 940      =1  #define XBR0_CP0E__SHIFT      0x04 ///< Comparator0 Output Enable                      
 941      =1  #define XBR0_CP0E__DISABLED   0x00 ///< CP0 unavailable at Port pin.                   
 942      =1  #define XBR0_CP0E__ENABLED    0x10 ///< CP0 routed to Port pin.                        
 943      =1                                                                                         
 944      =1  #define XBR0_CP0AE__BMASK     0x20 ///< Comparator0 Asynchronous Output Enable         
 945      =1  #define XBR0_CP0AE__SHIFT     0x05 ///< Comparator0 Asynchronous Output Enable         
 946      =1  #define XBR0_CP0AE__DISABLED  0x00 ///< Asynchronous CP0 unavailable at Port pin.      
 947      =1  #define XBR0_CP0AE__ENABLED   0x20 ///< Asynchronous CP0 routed to Port pin.           
 948      =1                                                                                         
 949      =1  #define XBR0_CP1E__BMASK      0x40 ///< Comparator1 Output Enable                      
 950      =1  #define XBR0_CP1E__SHIFT      0x06 ///< Comparator1 Output Enable                      
 951      =1  #define XBR0_CP1E__DISABLED   0x00 ///< CP1 unavailable at Port pin.                   
 952      =1  #define XBR0_CP1E__ENABLED    0x40 ///< CP1 routed to Port pin.                        
C51 COMPILER V9.56.0.0   SPI_0                                                             10/28/2016 17:37:02 PAGE 42  

 953      =1                                                                                         
 954      =1  #define XBR0_CP1AE__BMASK     0x80 ///< Comparator1 Asynchronous Output Enable         
 955      =1  #define XBR0_CP1AE__SHIFT     0x07 ///< Comparator1 Asynchronous Output Enable         
 956      =1  #define XBR0_CP1AE__DISABLED  0x00 ///< Asynchronous CP1 unavailable at Port pin.      
 957      =1  #define XBR0_CP1AE__ENABLED   0x80 ///< Asynchronous CP1 routed to Port pin.           
 958      =1                                                                                         
 959      =1  //------------------------------------------------------------------------------
 960      =1  // XBR1 Enums (Port I/O Crossbar 1 @ 0xE2)
 961      =1  //------------------------------------------------------------------------------
 962      =1  #define XBR1_PCA0ME__FMASK                    0x07 ///< PCA Module I/O Enable                            
 963      =1  #define XBR1_PCA0ME__SHIFT                    0x00 ///< PCA Module I/O Enable                            
 964      =1  #define XBR1_PCA0ME__DISABLED                 0x00 ///< All PCA I/O unavailable at Port pins.            
 965      =1  #define XBR1_PCA0ME__CEX0                     0x01 ///< CEX0 routed to Port pin.                         
 966      =1  #define XBR1_PCA0ME__CEX0_CEX1                0x02 ///< CEX0, CEX1 routed to Port pins.                  
 967      =1  #define XBR1_PCA0ME__CEX0_CEX1_CEX2           0x03 ///< CEX0, CEX1, CEX2 routed to Port pins.            
 968      =1  #define XBR1_PCA0ME__CEX0_CEX1_CEX2_CEX3      0x04 ///< CEX0, CEX1, CEX2, CEX3 routed to Port pins.      
 969      =1  #define XBR1_PCA0ME__CEX0_CEX1_CEX2_CEX3_CEX4 0x05 ///< CEX0, CEX1, CEX2, CEX3, CEX4 routed to Port pins.
 970      =1                                                                                                           
 971      =1  #define XBR1_ECIE__BMASK                      0x08 ///< PCA0 External Counter Input Enable               
 972      =1  #define XBR1_ECIE__SHIFT                      0x03 ///< PCA0 External Counter Input Enable               
 973      =1  #define XBR1_ECIE__DISABLED                   0x00 ///< ECI unavailable at Port pin.                     
 974      =1  #define XBR1_ECIE__ENABLED                    0x08 ///< ECI routed to Port pin.                          
 975      =1                                                                                                           
 976      =1  #define XBR1_T0E__BMASK                       0x10 ///< T0 Enable                                        
 977      =1  #define XBR1_T0E__SHIFT                       0x04 ///< T0 Enable                                        
 978      =1  #define XBR1_T0E__DISABLED                    0x00 ///< T0 unavailable at Port pin.                      
 979      =1  #define XBR1_T0E__ENABLED                     0x10 ///< T0 routed to Port pin.                           
 980      =1                                                                                                           
 981      =1  #define XBR1_T1E__BMASK                       0x20 ///< T1 Enable                                        
 982      =1  #define XBR1_T1E__SHIFT                       0x05 ///< T1 Enable                                        
 983      =1  #define XBR1_T1E__DISABLED                    0x00 ///< T1 unavailable at Port pin.                      
 984      =1  #define XBR1_T1E__ENABLED                     0x20 ///< T1 routed to Port pin.                           
 985      =1                                                                                                           
 986      =1  #define XBR1_XBARE__BMASK                     0x40 ///< Crossbar Enable                                  
 987      =1  #define XBR1_XBARE__SHIFT                     0x06 ///< Crossbar Enable                                  
 988      =1  #define XBR1_XBARE__DISABLED                  0x00 ///< Crossbar disabled.                               
 989      =1  #define XBR1_XBARE__ENABLED                   0x40 ///< Crossbar enabled.                                
 990      =1                                                                                                           
 991      =1  #define XBR1_WEAKPUD__BMASK                   0x80 ///< Port I/O Weak Pullup Disable                     
 992      =1  #define XBR1_WEAKPUD__SHIFT                   0x07 ///< Port I/O Weak Pullup Disable                     
 993      =1  #define XBR1_WEAKPUD__PULL_UPS_ENABLED        0x00 ///< Weak Pullups enabled (except for Ports whose I/O 
 994      =1                                                     ///< are configured for analog mode).                 
 995      =1  #define XBR1_WEAKPUD__PULL_UPS_DISABLED       0x80 ///< Weak Pullups disabled.                           
 996      =1                                                                                                           
 997      =1  //------------------------------------------------------------------------------
 998      =1  // XBR2 Enums (Port I/O Crossbar 2 @ 0xE3)
 999      =1  //------------------------------------------------------------------------------
1000      =1  #define XBR2_URT1E__BMASK    0x01 ///< UART1 I/O Output Enable             
1001      =1  #define XBR2_URT1E__SHIFT    0x00 ///< UART1 I/O Output Enable             
1002      =1  #define XBR2_URT1E__DISABLED 0x00 ///< UART1 I/O unavailable at Port pin.  
1003      =1  #define XBR2_URT1E__ENABLED  0x01 ///< UART1 TX, RX routed to Port pins.   
1004      =1                                                                             
1005      =1  #define XBR2_SMB1E__BMASK    0x02 ///< SMBus1 I/O Enable                   
1006      =1  #define XBR2_SMB1E__SHIFT    0x01 ///< SMBus1 I/O Enable                   
1007      =1  #define XBR2_SMB1E__DISABLED 0x00 ///< SMBus1 I/O unavailable at Port pins.
1008      =1  #define XBR2_SMB1E__ENABLED  0x02 ///< SMBus1 I/O routed to Port pins.     
1009      =1                                                                             
1010      =1  //------------------------------------------------------------------------------
1011      =1  // PCA0CPH0 Enums (PCA Channel 0 Capture Module High Byte @ 0xFC)
1012      =1  //------------------------------------------------------------------------------
1013      =1  #define PCA0CPH0_PCA0CPH0__FMASK 0xFF ///< PCA Channel 0 Capture Module High Byte
1014      =1  #define PCA0CPH0_PCA0CPH0__SHIFT 0x00 ///< PCA Channel 0 Capture Module High Byte
C51 COMPILER V9.56.0.0   SPI_0                                                             10/28/2016 17:37:02 PAGE 43  

1015      =1                                                                                   
1016      =1  //------------------------------------------------------------------------------
1017      =1  // PCA0CPL0 Enums (PCA Channel 0 Capture Module Low Byte @ 0xFB)
1018      =1  //------------------------------------------------------------------------------
1019      =1  #define PCA0CPL0_PCA0CPL0__FMASK 0xFF ///< PCA Channel 0 Capture Module Low Byte
1020      =1  #define PCA0CPL0_PCA0CPL0__SHIFT 0x00 ///< PCA Channel 0 Capture Module Low Byte
1021      =1                                                                                  
1022      =1  //------------------------------------------------------------------------------
1023      =1  // PCA0CPM0 Enums (PCA Channel 0 Capture/Compare Mode @ 0xDA)
1024      =1  //------------------------------------------------------------------------------
1025      =1  #define PCA0CPM0_ECCF__BMASK    0x01 ///< Channel 0 Capture/Compare Flag Interrupt Enable
1026      =1  #define PCA0CPM0_ECCF__SHIFT    0x00 ///< Channel 0 Capture/Compare Flag Interrupt Enable
1027      =1  #define PCA0CPM0_ECCF__DISABLED 0x00 ///< Disable CCF0 interrupts.                       
1028      =1  #define PCA0CPM0_ECCF__ENABLED  0x01 ///< Enable a Capture/Compare Flag interrupt request
1029      =1                                       ///< when CCF0 is set.                              
1030      =1                                                                                           
1031      =1  #define PCA0CPM0_PWM__BMASK     0x02 ///< Channel 0 Pulse Width Modulation Mode Enable   
1032      =1  #define PCA0CPM0_PWM__SHIFT     0x01 ///< Channel 0 Pulse Width Modulation Mode Enable   
1033      =1  #define PCA0CPM0_PWM__DISABLED  0x00 ///< Disable PWM function.                          
1034      =1  #define PCA0CPM0_PWM__ENABLED   0x02 ///< Enable PWM function.                           
1035      =1                                                                                           
1036      =1  #define PCA0CPM0_TOG__BMASK     0x04 ///< Channel 0 Toggle Function Enable               
1037      =1  #define PCA0CPM0_TOG__SHIFT     0x02 ///< Channel 0 Toggle Function Enable               
1038      =1  #define PCA0CPM0_TOG__DISABLED  0x00 ///< Disable toggle function.                       
1039      =1  #define PCA0CPM0_TOG__ENABLED   0x04 ///< Enable toggle function.                        
1040      =1                                                                                           
1041      =1  #define PCA0CPM0_MAT__BMASK     0x08 ///< Channel 0 Match Function Enable                
1042      =1  #define PCA0CPM0_MAT__SHIFT     0x03 ///< Channel 0 Match Function Enable                
1043      =1  #define PCA0CPM0_MAT__DISABLED  0x00 ///< Disable match function.                        
1044      =1  #define PCA0CPM0_MAT__ENABLED   0x08 ///< Enable match function.                         
1045      =1                                                                                           
1046      =1  #define PCA0CPM0_CAPN__BMASK    0x10 ///< Channel 0 Capture Negative Function Enable     
1047      =1  #define PCA0CPM0_CAPN__SHIFT    0x04 ///< Channel 0 Capture Negative Function Enable     
1048      =1  #define PCA0CPM0_CAPN__DISABLED 0x00 ///< Disable negative edge capture.                 
1049      =1  #define PCA0CPM0_CAPN__ENABLED  0x10 ///< Enable negative edge capture.                  
1050      =1                                                                                           
1051      =1  #define PCA0CPM0_CAPP__BMASK    0x20 ///< Channel 0 Capture Positive Function Enable     
1052      =1  #define PCA0CPM0_CAPP__SHIFT    0x05 ///< Channel 0 Capture Positive Function Enable     
1053      =1  #define PCA0CPM0_CAPP__DISABLED 0x00 ///< Disable positive edge capture.                 
1054      =1  #define PCA0CPM0_CAPP__ENABLED  0x20 ///< Enable positive edge capture.                  
1055      =1                                                                                           
1056      =1  #define PCA0CPM0_ECOM__BMASK    0x40 ///< Channel 0 Comparator Function Enable           
1057      =1  #define PCA0CPM0_ECOM__SHIFT    0x06 ///< Channel 0 Comparator Function Enable           
1058      =1  #define PCA0CPM0_ECOM__DISABLED 0x00 ///< Disable comparator function.                   
1059      =1  #define PCA0CPM0_ECOM__ENABLED  0x40 ///< Enable comparator function.                    
1060      =1                                                                                           
1061      =1  #define PCA0CPM0_PWM16__BMASK   0x80 ///< Channel 0 16-bit Pulse Width Modulation Enable 
1062      =1  #define PCA0CPM0_PWM16__SHIFT   0x07 ///< Channel 0 16-bit Pulse Width Modulation Enable 
1063      =1  #define PCA0CPM0_PWM16__8_BIT   0x00 ///< 8-bit PWM selected.                            
1064      =1  #define PCA0CPM0_PWM16__16_BIT  0x80 ///< 16-bit PWM selected.                           
1065      =1                                                                                           
1066      =1  //------------------------------------------------------------------------------
1067      =1  // PCA0CPH1 Enums (PCA Channel 1 Capture Module High Byte @ 0xEA)
1068      =1  //------------------------------------------------------------------------------
1069      =1  #define PCA0CPH1_PCA0CPH1__FMASK 0xFF ///< PCA Channel 1 Capture Module High Byte
1070      =1  #define PCA0CPH1_PCA0CPH1__SHIFT 0x00 ///< PCA Channel 1 Capture Module High Byte
1071      =1                                                                                   
1072      =1  //------------------------------------------------------------------------------
1073      =1  // PCA0CPL1 Enums (PCA Channel 1 Capture Module Low Byte @ 0xE9)
1074      =1  //------------------------------------------------------------------------------
1075      =1  #define PCA0CPL1_PCA0CPL1__FMASK 0xFF ///< PCA Channel 1 Capture Module Low Byte
1076      =1  #define PCA0CPL1_PCA0CPL1__SHIFT 0x00 ///< PCA Channel 1 Capture Module Low Byte
C51 COMPILER V9.56.0.0   SPI_0                                                             10/28/2016 17:37:02 PAGE 44  

1077      =1                                                                                  
1078      =1  //------------------------------------------------------------------------------
1079      =1  // PCA0CPM1 Enums (PCA Channel 1 Capture/Compare Mode @ 0xDB)
1080      =1  //------------------------------------------------------------------------------
1081      =1  #define PCA0CPM1_ECCF__BMASK    0x01 ///< Channel 1 Capture/Compare Flag Interrupt Enable
1082      =1  #define PCA0CPM1_ECCF__SHIFT    0x00 ///< Channel 1 Capture/Compare Flag Interrupt Enable
1083      =1  #define PCA0CPM1_ECCF__DISABLED 0x00 ///< Disable CCF1 interrupts.                       
1084      =1  #define PCA0CPM1_ECCF__ENABLED  0x01 ///< Enable a Capture/Compare Flag interrupt request
1085      =1                                       ///< when CCF1 is set.                              
1086      =1                                                                                           
1087      =1  #define PCA0CPM1_PWM__BMASK     0x02 ///< Channel 1 Pulse Width Modulation Mode Enable   
1088      =1  #define PCA0CPM1_PWM__SHIFT     0x01 ///< Channel 1 Pulse Width Modulation Mode Enable   
1089      =1  #define PCA0CPM1_PWM__DISABLED  0x00 ///< Disable PWM function.                          
1090      =1  #define PCA0CPM1_PWM__ENABLED   0x02 ///< Enable PWM function.                           
1091      =1                                                                                           
1092      =1  #define PCA0CPM1_TOG__BMASK     0x04 ///< Channel 1 Toggle Function Enable               
1093      =1  #define PCA0CPM1_TOG__SHIFT     0x02 ///< Channel 1 Toggle Function Enable               
1094      =1  #define PCA0CPM1_TOG__DISABLED  0x00 ///< Disable toggle function.                       
1095      =1  #define PCA0CPM1_TOG__ENABLED   0x04 ///< Enable toggle function.                        
1096      =1                                                                                           
1097      =1  #define PCA0CPM1_MAT__BMASK     0x08 ///< Channel 1 Match Function Enable                
1098      =1  #define PCA0CPM1_MAT__SHIFT     0x03 ///< Channel 1 Match Function Enable                
1099      =1  #define PCA0CPM1_MAT__DISABLED  0x00 ///< Disable match function.                        
1100      =1  #define PCA0CPM1_MAT__ENABLED   0x08 ///< Enable match function.                         
1101      =1                                                                                           
1102      =1  #define PCA0CPM1_CAPN__BMASK    0x10 ///< Channel 1 Capture Negative Function Enable     
1103      =1  #define PCA0CPM1_CAPN__SHIFT    0x04 ///< Channel 1 Capture Negative Function Enable     
1104      =1  #define PCA0CPM1_CAPN__DISABLED 0x00 ///< Disable negative edge capture.                 
1105      =1  #define PCA0CPM1_CAPN__ENABLED  0x10 ///< Enable negative edge capture.                  
1106      =1                                                                                           
1107      =1  #define PCA0CPM1_CAPP__BMASK    0x20 ///< Channel 1 Capture Positive Function Enable     
1108      =1  #define PCA0CPM1_CAPP__SHIFT    0x05 ///< Channel 1 Capture Positive Function Enable     
1109      =1  #define PCA0CPM1_CAPP__DISABLED 0x00 ///< Disable positive edge capture.                 
1110      =1  #define PCA0CPM1_CAPP__ENABLED  0x20 ///< Enable positive edge capture.                  
1111      =1                                                                                           
1112      =1  #define PCA0CPM1_ECOM__BMASK    0x40 ///< Channel 1 Comparator Function Enable           
1113      =1  #define PCA0CPM1_ECOM__SHIFT    0x06 ///< Channel 1 Comparator Function Enable           
1114      =1  #define PCA0CPM1_ECOM__DISABLED 0x00 ///< Disable comparator function.                   
1115      =1  #define PCA0CPM1_ECOM__ENABLED  0x40 ///< Enable comparator function.                    
1116      =1                                                                                           
1117      =1  #define PCA0CPM1_PWM16__BMASK   0x80 ///< Channel 1 16-bit Pulse Width Modulation Enable 
1118      =1  #define PCA0CPM1_PWM16__SHIFT   0x07 ///< Channel 1 16-bit Pulse Width Modulation Enable 
1119      =1  #define PCA0CPM1_PWM16__8_BIT   0x00 ///< 8-bit PWM selected.                            
1120      =1  #define PCA0CPM1_PWM16__16_BIT  0x80 ///< 16-bit PWM selected.                           
1121      =1                                                                                           
1122      =1  //------------------------------------------------------------------------------
1123      =1  // PCA0CPH2 Enums (PCA Channel 2 Capture Module High Byte @ 0xEC)
1124      =1  //------------------------------------------------------------------------------
1125      =1  #define PCA0CPH2_PCA0CPH2__FMASK 0xFF ///< PCA Channel 2 Capture Module High Byte
1126      =1  #define PCA0CPH2_PCA0CPH2__SHIFT 0x00 ///< PCA Channel 2 Capture Module High Byte
1127      =1                                                                                   
1128      =1  //------------------------------------------------------------------------------
1129      =1  // PCA0CPL2 Enums (PCA Channel 2 Capture Module Low Byte @ 0xEB)
1130      =1  //------------------------------------------------------------------------------
1131      =1  #define PCA0CPL2_PCA0CPL2__FMASK 0xFF ///< PCA Channel 2 Capture Module Low Byte
1132      =1  #define PCA0CPL2_PCA0CPL2__SHIFT 0x00 ///< PCA Channel 2 Capture Module Low Byte
1133      =1                                                                                  
1134      =1  //------------------------------------------------------------------------------
1135      =1  // PCA0CPM2 Enums (PCA Channel 2 Capture/Compare Mode @ 0xDC)
1136      =1  //------------------------------------------------------------------------------
1137      =1  #define PCA0CPM2_ECCF__BMASK    0x01 ///< Channel 2 Capture/Compare Flag Interrupt Enable
1138      =1  #define PCA0CPM2_ECCF__SHIFT    0x00 ///< Channel 2 Capture/Compare Flag Interrupt Enable
C51 COMPILER V9.56.0.0   SPI_0                                                             10/28/2016 17:37:02 PAGE 45  

1139      =1  #define PCA0CPM2_ECCF__DISABLED 0x00 ///< Disable CCF2 interrupts.                       
1140      =1  #define PCA0CPM2_ECCF__ENABLED  0x01 ///< Enable a Capture/Compare Flag interrupt request
1141      =1                                       ///< when CCF2 is set.                              
1142      =1                                                                                           
1143      =1  #define PCA0CPM2_PWM__BMASK     0x02 ///< Channel 2 Pulse Width Modulation Mode Enable   
1144      =1  #define PCA0CPM2_PWM__SHIFT     0x01 ///< Channel 2 Pulse Width Modulation Mode Enable   
1145      =1  #define PCA0CPM2_PWM__DISABLED  0x00 ///< Disable PWM function.                          
1146      =1  #define PCA0CPM2_PWM__ENABLED   0x02 ///< Enable PWM function.                           
1147      =1                                                                                           
1148      =1  #define PCA0CPM2_TOG__BMASK     0x04 ///< Channel 2 Toggle Function Enable               
1149      =1  #define PCA0CPM2_TOG__SHIFT     0x02 ///< Channel 2 Toggle Function Enable               
1150      =1  #define PCA0CPM2_TOG__DISABLED  0x00 ///< Disable toggle function.                       
1151      =1  #define PCA0CPM2_TOG__ENABLED   0x04 ///< Enable toggle function.                        
1152      =1                                                                                           
1153      =1  #define PCA0CPM2_MAT__BMASK     0x08 ///< Channel 2 Match Function Enable                
1154      =1  #define PCA0CPM2_MAT__SHIFT     0x03 ///< Channel 2 Match Function Enable                
1155      =1  #define PCA0CPM2_MAT__DISABLED  0x00 ///< Disable match function.                        
1156      =1  #define PCA0CPM2_MAT__ENABLED   0x08 ///< Enable match function.                         
1157      =1                                                                                           
1158      =1  #define PCA0CPM2_CAPN__BMASK    0x10 ///< Channel 2 Capture Negative Function Enable     
1159      =1  #define PCA0CPM2_CAPN__SHIFT    0x04 ///< Channel 2 Capture Negative Function Enable     
1160      =1  #define PCA0CPM2_CAPN__DISABLED 0x00 ///< Disable negative edge capture.                 
1161      =1  #define PCA0CPM2_CAPN__ENABLED  0x10 ///< Enable negative edge capture.                  
1162      =1                                                                                           
1163      =1  #define PCA0CPM2_CAPP__BMASK    0x20 ///< Channel 2 Capture Positive Function Enable     
1164      =1  #define PCA0CPM2_CAPP__SHIFT    0x05 ///< Channel 2 Capture Positive Function Enable     
1165      =1  #define PCA0CPM2_CAPP__DISABLED 0x00 ///< Disable positive edge capture.                 
1166      =1  #define PCA0CPM2_CAPP__ENABLED  0x20 ///< Enable positive edge capture.                  
1167      =1                                                                                           
1168      =1  #define PCA0CPM2_ECOM__BMASK    0x40 ///< Channel 2 Comparator Function Enable           
1169      =1  #define PCA0CPM2_ECOM__SHIFT    0x06 ///< Channel 2 Comparator Function Enable           
1170      =1  #define PCA0CPM2_ECOM__DISABLED 0x00 ///< Disable comparator function.                   
1171      =1  #define PCA0CPM2_ECOM__ENABLED  0x40 ///< Enable comparator function.                    
1172      =1                                                                                           
1173      =1  #define PCA0CPM2_PWM16__BMASK   0x80 ///< Channel 2 16-bit Pulse Width Modulation Enable 
1174      =1  #define PCA0CPM2_PWM16__SHIFT   0x07 ///< Channel 2 16-bit Pulse Width Modulation Enable 
1175      =1  #define PCA0CPM2_PWM16__8_BIT   0x00 ///< 8-bit PWM selected.                            
1176      =1  #define PCA0CPM2_PWM16__16_BIT  0x80 ///< 16-bit PWM selected.                           
1177      =1                                                                                           
1178      =1  //------------------------------------------------------------------------------
1179      =1  // PCA0CPH3 Enums (PCA Channel 3 Capture Module High Byte @ 0xEE)
1180      =1  //------------------------------------------------------------------------------
1181      =1  #define PCA0CPH3_PCA0CPH3__FMASK 0xFF ///< PCA Channel 3 Capture Module High Byte
1182      =1  #define PCA0CPH3_PCA0CPH3__SHIFT 0x00 ///< PCA Channel 3 Capture Module High Byte
1183      =1                                                                                   
1184      =1  //------------------------------------------------------------------------------
1185      =1  // PCA0CPL3 Enums (PCA Channel 3 Capture Module Low Byte @ 0xED)
1186      =1  //------------------------------------------------------------------------------
1187      =1  #define PCA0CPL3_PCA0CPL3__FMASK 0xFF ///< PCA Channel 3 Capture Module Low Byte
1188      =1  #define PCA0CPL3_PCA0CPL3__SHIFT 0x00 ///< PCA Channel 3 Capture Module Low Byte
1189      =1                                                                                  
1190      =1  //------------------------------------------------------------------------------
1191      =1  // PCA0CPM3 Enums (PCA Channel 3 Capture/Compare Mode @ 0xDD)
1192      =1  //------------------------------------------------------------------------------
1193      =1  #define PCA0CPM3_ECCF__BMASK    0x01 ///< Channel 3 Capture/Compare Flag Interrupt Enable
1194      =1  #define PCA0CPM3_ECCF__SHIFT    0x00 ///< Channel 3 Capture/Compare Flag Interrupt Enable
1195      =1  #define PCA0CPM3_ECCF__DISABLED 0x00 ///< Disable CCF3 interrupts.                       
1196      =1  #define PCA0CPM3_ECCF__ENABLED  0x01 ///< Enable a Capture/Compare Flag interrupt request
1197      =1                                       ///< when CCF3 is set.                              
1198      =1                                                                                           
1199      =1  #define PCA0CPM3_PWM__BMASK     0x02 ///< Channel 3 Pulse Width Modulation Mode Enable   
1200      =1  #define PCA0CPM3_PWM__SHIFT     0x01 ///< Channel 3 Pulse Width Modulation Mode Enable   
C51 COMPILER V9.56.0.0   SPI_0                                                             10/28/2016 17:37:02 PAGE 46  

1201      =1  #define PCA0CPM3_PWM__DISABLED  0x00 ///< Disable PWM function.                          
1202      =1  #define PCA0CPM3_PWM__ENABLED   0x02 ///< Enable PWM function.                           
1203      =1                                                                                           
1204      =1  #define PCA0CPM3_TOG__BMASK     0x04 ///< Channel 3 Toggle Function Enable               
1205      =1  #define PCA0CPM3_TOG__SHIFT     0x02 ///< Channel 3 Toggle Function Enable               
1206      =1  #define PCA0CPM3_TOG__DISABLED  0x00 ///< Disable toggle function.                       
1207      =1  #define PCA0CPM3_TOG__ENABLED   0x04 ///< Enable toggle function.                        
1208      =1                                                                                           
1209      =1  #define PCA0CPM3_MAT__BMASK     0x08 ///< Channel 3 Match Function Enable                
1210      =1  #define PCA0CPM3_MAT__SHIFT     0x03 ///< Channel 3 Match Function Enable                
1211      =1  #define PCA0CPM3_MAT__DISABLED  0x00 ///< Disable match function.                        
1212      =1  #define PCA0CPM3_MAT__ENABLED   0x08 ///< Enable match function.                         
1213      =1                                                                                           
1214      =1  #define PCA0CPM3_CAPN__BMASK    0x10 ///< Channel 3 Capture Negative Function Enable     
1215      =1  #define PCA0CPM3_CAPN__SHIFT    0x04 ///< Channel 3 Capture Negative Function Enable     
1216      =1  #define PCA0CPM3_CAPN__DISABLED 0x00 ///< Disable negative edge capture.                 
1217      =1  #define PCA0CPM3_CAPN__ENABLED  0x10 ///< Enable negative edge capture.                  
1218      =1                                                                                           
1219      =1  #define PCA0CPM3_CAPP__BMASK    0x20 ///< Channel 3 Capture Positive Function Enable     
1220      =1  #define PCA0CPM3_CAPP__SHIFT    0x05 ///< Channel 3 Capture Positive Function Enable     
1221      =1  #define PCA0CPM3_CAPP__DISABLED 0x00 ///< Disable positive edge capture.                 
1222      =1  #define PCA0CPM3_CAPP__ENABLED  0x20 ///< Enable positive edge capture.                  
1223      =1                                                                                           
1224      =1  #define PCA0CPM3_ECOM__BMASK    0x40 ///< Channel 3 Comparator Function Enable           
1225      =1  #define PCA0CPM3_ECOM__SHIFT    0x06 ///< Channel 3 Comparator Function Enable           
1226      =1  #define PCA0CPM3_ECOM__DISABLED 0x00 ///< Disable comparator function.                   
1227      =1  #define PCA0CPM3_ECOM__ENABLED  0x40 ///< Enable comparator function.                    
1228      =1                                                                                           
1229      =1  #define PCA0CPM3_PWM16__BMASK   0x80 ///< Channel 3 16-bit Pulse Width Modulation Enable 
1230      =1  #define PCA0CPM3_PWM16__SHIFT   0x07 ///< Channel 3 16-bit Pulse Width Modulation Enable 
1231      =1  #define PCA0CPM3_PWM16__8_BIT   0x00 ///< 8-bit PWM selected.                            
1232      =1  #define PCA0CPM3_PWM16__16_BIT  0x80 ///< 16-bit PWM selected.                           
1233      =1                                                                                           
1234      =1  //------------------------------------------------------------------------------
1235      =1  // PCA0CPH4 Enums (PCA Channel 4 Capture Module High Byte @ 0xFE)
1236      =1  //------------------------------------------------------------------------------
1237      =1  #define PCA0CPH4_PCA0CPH4__FMASK 0xFF ///< PCA Channel 4 Capture Module High Byte
1238      =1  #define PCA0CPH4_PCA0CPH4__SHIFT 0x00 ///< PCA Channel 4 Capture Module High Byte
1239      =1                                                                                   
1240      =1  //------------------------------------------------------------------------------
1241      =1  // PCA0CPL4 Enums (PCA Channel 4 Capture Module Low Byte @ 0xFD)
1242      =1  //------------------------------------------------------------------------------
1243      =1  #define PCA0CPL4_PCA0CPL4__FMASK 0xFF ///< PCA Channel 4 Capture Module Low Byte
1244      =1  #define PCA0CPL4_PCA0CPL4__SHIFT 0x00 ///< PCA Channel 4 Capture Module Low Byte
1245      =1                                                                                  
1246      =1  //------------------------------------------------------------------------------
1247      =1  // PCA0CPM4 Enums (PCA Channel 4 Capture/Compare Mode @ 0xDE)
1248      =1  //------------------------------------------------------------------------------
1249      =1  #define PCA0CPM4_ECCF__BMASK    0x01 ///< Channel 4 Capture/Compare Flag Interrupt Enable
1250      =1  #define PCA0CPM4_ECCF__SHIFT    0x00 ///< Channel 4 Capture/Compare Flag Interrupt Enable
1251      =1  #define PCA0CPM4_ECCF__DISABLED 0x00 ///< Disable CCF4 interrupts.                       
1252      =1  #define PCA0CPM4_ECCF__ENABLED  0x01 ///< Enable a Capture/Compare Flag interrupt request
1253      =1                                       ///< when CCF4 is set.                              
1254      =1                                                                                           
1255      =1  #define PCA0CPM4_PWM__BMASK     0x02 ///< Channel 4 Pulse Width Modulation Mode Enable   
1256      =1  #define PCA0CPM4_PWM__SHIFT     0x01 ///< Channel 4 Pulse Width Modulation Mode Enable   
1257      =1  #define PCA0CPM4_PWM__DISABLED  0x00 ///< Disable PWM function.                          
1258      =1  #define PCA0CPM4_PWM__ENABLED   0x02 ///< Enable PWM function.                           
1259      =1                                                                                           
1260      =1  #define PCA0CPM4_TOG__BMASK     0x04 ///< Channel 4 Toggle Function Enable               
1261      =1  #define PCA0CPM4_TOG__SHIFT     0x02 ///< Channel 4 Toggle Function Enable               
1262      =1  #define PCA0CPM4_TOG__DISABLED  0x00 ///< Disable toggle function.                       
C51 COMPILER V9.56.0.0   SPI_0                                                             10/28/2016 17:37:02 PAGE 47  

1263      =1  #define PCA0CPM4_TOG__ENABLED   0x04 ///< Enable toggle function.                        
1264      =1                                                                                           
1265      =1  #define PCA0CPM4_MAT__BMASK     0x08 ///< Channel 4 Match Function Enable                
1266      =1  #define PCA0CPM4_MAT__SHIFT     0x03 ///< Channel 4 Match Function Enable                
1267      =1  #define PCA0CPM4_MAT__DISABLED  0x00 ///< Disable match function.                        
1268      =1  #define PCA0CPM4_MAT__ENABLED   0x08 ///< Enable match function.                         
1269      =1                                                                                           
1270      =1  #define PCA0CPM4_CAPN__BMASK    0x10 ///< Channel 4 Capture Negative Function Enable     
1271      =1  #define PCA0CPM4_CAPN__SHIFT    0x04 ///< Channel 4 Capture Negative Function Enable     
1272      =1  #define PCA0CPM4_CAPN__DISABLED 0x00 ///< Disable negative edge capture.                 
1273      =1  #define PCA0CPM4_CAPN__ENABLED  0x10 ///< Enable negative edge capture.                  
1274      =1                                                                                           
1275      =1  #define PCA0CPM4_CAPP__BMASK    0x20 ///< Channel 4 Capture Positive Function Enable     
1276      =1  #define PCA0CPM4_CAPP__SHIFT    0x05 ///< Channel 4 Capture Positive Function Enable     
1277      =1  #define PCA0CPM4_CAPP__DISABLED 0x00 ///< Disable positive edge capture.                 
1278      =1  #define PCA0CPM4_CAPP__ENABLED  0x20 ///< Enable positive edge capture.                  
1279      =1                                                                                           
1280      =1  #define PCA0CPM4_ECOM__BMASK    0x40 ///< Channel 4 Comparator Function Enable           
1281      =1  #define PCA0CPM4_ECOM__SHIFT    0x06 ///< Channel 4 Comparator Function Enable           
1282      =1  #define PCA0CPM4_ECOM__DISABLED 0x00 ///< Disable comparator function.                   
1283      =1  #define PCA0CPM4_ECOM__ENABLED  0x40 ///< Enable comparator function.                    
1284      =1                                                                                           
1285      =1  #define PCA0CPM4_PWM16__BMASK   0x80 ///< Channel 4 16-bit Pulse Width Modulation Enable 
1286      =1  #define PCA0CPM4_PWM16__SHIFT   0x07 ///< Channel 4 16-bit Pulse Width Modulation Enable 
1287      =1  #define PCA0CPM4_PWM16__8_BIT   0x00 ///< 8-bit PWM selected.                            
1288      =1  #define PCA0CPM4_PWM16__16_BIT  0x80 ///< 16-bit PWM selected.                           
1289      =1                                                                                           
1290      =1  //------------------------------------------------------------------------------
1291      =1  // PCA0CN0 Enums (PCA Control 0 @ 0xD8)
1292      =1  //------------------------------------------------------------------------------
1293      =1  #define PCA0CN0_CCF0__BMASK   0x01 ///< PCA Module 0 Capture/Compare Flag             
1294      =1  #define PCA0CN0_CCF0__SHIFT   0x00 ///< PCA Module 0 Capture/Compare Flag             
1295      =1  #define PCA0CN0_CCF0__NOT_SET 0x00 ///< A match or capture did not occur on channel 0.
1296      =1  #define PCA0CN0_CCF0__SET     0x01 ///< A match or capture occurred on channel 0.     
1297      =1                                                                                        
1298      =1  #define PCA0CN0_CCF1__BMASK   0x02 ///< PCA Module 1 Capture/Compare Flag             
1299      =1  #define PCA0CN0_CCF1__SHIFT   0x01 ///< PCA Module 1 Capture/Compare Flag             
1300      =1  #define PCA0CN0_CCF1__NOT_SET 0x00 ///< A match or capture did not occur on channel 1.
1301      =1  #define PCA0CN0_CCF1__SET     0x02 ///< A match or capture occurred on channel 1.     
1302      =1                                                                                        
1303      =1  #define PCA0CN0_CCF2__BMASK   0x04 ///< PCA Module 2 Capture/Compare Flag             
1304      =1  #define PCA0CN0_CCF2__SHIFT   0x02 ///< PCA Module 2 Capture/Compare Flag             
1305      =1  #define PCA0CN0_CCF2__NOT_SET 0x00 ///< A match or capture did not occur on channel 2.
1306      =1  #define PCA0CN0_CCF2__SET     0x04 ///< A match or capture occurred on channel 2.     
1307      =1                                                                                        
1308      =1  #define PCA0CN0_CCF3__BMASK   0x08 ///< PCA Module 3 Capture/Compare Flag             
1309      =1  #define PCA0CN0_CCF3__SHIFT   0x03 ///< PCA Module 3 Capture/Compare Flag             
1310      =1  #define PCA0CN0_CCF3__NOT_SET 0x00 ///< A match or capture did not occur on channel 3.
1311      =1  #define PCA0CN0_CCF3__SET     0x08 ///< A match or capture occurred on channel 3.     
1312      =1                                                                                        
1313      =1  #define PCA0CN0_CCF4__BMASK   0x10 ///< PCA Module 4 Capture/Compare Flag             
1314      =1  #define PCA0CN0_CCF4__SHIFT   0x04 ///< PCA Module 4 Capture/Compare Flag             
1315      =1  #define PCA0CN0_CCF4__NOT_SET 0x00 ///< A match or capture did not occur on channel 4.
1316      =1  #define PCA0CN0_CCF4__SET     0x10 ///< A match or capture occurred on channel 4.     
1317      =1                                                                                        
1318      =1  #define PCA0CN0_CR__BMASK     0x40 ///< PCA Counter/Timer Run Control                 
1319      =1  #define PCA0CN0_CR__SHIFT     0x06 ///< PCA Counter/Timer Run Control                 
1320      =1  #define PCA0CN0_CR__STOP      0x00 ///< Stop the PCA Counter/Timer.                   
1321      =1  #define PCA0CN0_CR__RUN       0x40 ///< Start the PCA Counter/Timer running.          
1322      =1                                                                                        
1323      =1  #define PCA0CN0_CF__BMASK     0x80 ///< PCA Counter/Timer Overflow Flag               
1324      =1  #define PCA0CN0_CF__SHIFT     0x07 ///< PCA Counter/Timer Overflow Flag               
C51 COMPILER V9.56.0.0   SPI_0                                                             10/28/2016 17:37:02 PAGE 48  

1325      =1  #define PCA0CN0_CF__NOT_SET   0x00 ///< The PCA counter/timer did not overflow.       
1326      =1  #define PCA0CN0_CF__SET       0x80 ///< The PCA counter/timer overflowed.             
1327      =1                                                                                        
1328      =1  //------------------------------------------------------------------------------
1329      =1  // PCA0H Enums (PCA Counter/Timer High Byte @ 0xFA)
1330      =1  //------------------------------------------------------------------------------
1331      =1  #define PCA0H_PCA0H__FMASK 0xFF ///< PCA Counter/Timer High Byte
1332      =1  #define PCA0H_PCA0H__SHIFT 0x00 ///< PCA Counter/Timer High Byte
1333      =1                                                                  
1334      =1  //------------------------------------------------------------------------------
1335      =1  // PCA0L Enums (PCA Counter/Timer Low Byte @ 0xF9)
1336      =1  //------------------------------------------------------------------------------
1337      =1  #define PCA0L_PCA0L__FMASK 0xFF ///< PCA Counter/Timer Low Byte
1338      =1  #define PCA0L_PCA0L__SHIFT 0x00 ///< PCA Counter/Timer Low Byte
1339      =1                                                                 
1340      =1  //------------------------------------------------------------------------------
1341      =1  // PCA0MD Enums (PCA Mode @ 0xD9)
1342      =1  //------------------------------------------------------------------------------
1343      =1  #define PCA0MD_ECF__BMASK            0x01 ///< PCA Counter/Timer Overflow Interrupt Enable       
1344      =1  #define PCA0MD_ECF__SHIFT            0x00 ///< PCA Counter/Timer Overflow Interrupt Enable       
1345      =1  #define PCA0MD_ECF__OVF_INT_DISABLED 0x00 ///< Disable the CF interrupt.                         
1346      =1  #define PCA0MD_ECF__OVF_INT_ENABLED  0x01 ///< Enable a PCA Counter/Timer Overflow interrupt     
1347      =1                                            ///< request when CF is set.                           
1348      =1                                                                                                   
1349      =1  #define PCA0MD_CPS__FMASK            0x0E ///< PCA Counter/Timer Pulse Select                    
1350      =1  #define PCA0MD_CPS__SHIFT            0x01 ///< PCA Counter/Timer Pulse Select                    
1351      =1  #define PCA0MD_CPS__SYSCLK_DIV_12    0x00 ///< System clock divided by 12.                       
1352      =1  #define PCA0MD_CPS__SYSCLK_DIV_4     0x02 ///< System clock divided by 4.                        
1353      =1  #define PCA0MD_CPS__T0_OVERFLOW      0x04 ///< Timer 0 overflow.                                 
1354      =1  #define PCA0MD_CPS__ECI              0x06 ///< High-to-low transitions on ECI (max rate = system 
1355      =1                                            ///< clock divided by 4).                              
1356      =1  #define PCA0MD_CPS__SYSCLK           0x08 ///< System clock.                                     
1357      =1  #define PCA0MD_CPS__EXTOSC_DIV_8     0x0A ///< External clock divided by 8 (synchronized with the
1358      =1                                            ///< system clock).                                    
1359      =1                                                                                                   
1360      =1  #define PCA0MD_WDLCK__BMASK          0x20 ///< Watchdog Timer Lock                               
1361      =1  #define PCA0MD_WDLCK__SHIFT          0x05 ///< Watchdog Timer Lock                               
1362      =1  #define PCA0MD_WDLCK__UNLOCKED       0x00 ///< Watchdog Timer Enable unlocked.                   
1363      =1  #define PCA0MD_WDLCK__LOCKED         0x20 ///< Watchdog Timer Enable locked.                     
1364      =1                                                                                                   
1365      =1  #define PCA0MD_WDTE__BMASK           0x40 ///< Watchdog Timer Enable                             
1366      =1  #define PCA0MD_WDTE__SHIFT           0x06 ///< Watchdog Timer Enable                             
1367      =1  #define PCA0MD_WDTE__DISABLED        0x00 ///< Disable Watchdog Timer.                           
1368      =1  #define PCA0MD_WDTE__ENABLED         0x40 ///< Enable PCA Module 4 as the Watchdog Timer.        
1369      =1                                                                                                   
1370      =1  #define PCA0MD_CIDL__BMASK           0x80 ///< PCA Counter/Timer Idle Control                    
1371      =1  #define PCA0MD_CIDL__SHIFT           0x07 ///< PCA Counter/Timer Idle Control                    
1372      =1  #define PCA0MD_CIDL__NORMAL          0x00 ///< PCA continues to function normally while the      
1373      =1                                            ///< system controller is in Idle Mode.                
1374      =1  #define PCA0MD_CIDL__SUSPEND         0x80 ///< PCA operation is suspended while the system       
1375      =1                                            ///< controller is in Idle Mode.                       
1376      =1                                                                                                   
1377      =1  //------------------------------------------------------------------------------
1378      =1  // PCON0 Enums (Power Control @ 0x87)
1379      =1  //------------------------------------------------------------------------------
1380      =1  #define PCON0_IDLE__BMASK  0x01 ///< Idle Mode Select                                
1381      =1  #define PCON0_IDLE__SHIFT  0x00 ///< Idle Mode Select                                
1382      =1  #define PCON0_IDLE__NORMAL 0x00 ///< Idle mode not activated.                        
1383      =1  #define PCON0_IDLE__IDLE   0x01 ///< CPU goes into Idle mode (shuts off clock to CPU,
1384      =1                                  ///< but clocks to enabled peripherals are still     
1385      =1                                  ///< active).                                        
1386      =1                                                                                       
C51 COMPILER V9.56.0.0   SPI_0                                                             10/28/2016 17:37:02 PAGE 49  

1387      =1  #define PCON0_STOP__BMASK  0x02 ///< Stop Mode Select                                
1388      =1  #define PCON0_STOP__SHIFT  0x01 ///< Stop Mode Select                                
1389      =1  #define PCON0_STOP__NORMAL 0x00 ///< Stop mode not activated.                        
1390      =1  #define PCON0_STOP__STOP   0x02 ///< CPU goes into Stop mode (internal oscillator    
1391      =1                                  ///< stopped).                                       
1392      =1                                                                                       
1393      =1  #define PCON0_GF0__BMASK   0x04 ///< General Purpose Flag 0                          
1394      =1  #define PCON0_GF0__SHIFT   0x02 ///< General Purpose Flag 0                          
1395      =1  #define PCON0_GF0__NOT_SET 0x00 ///< The GF0 flag is not set. Clear the GF0 flag.    
1396      =1  #define PCON0_GF0__SET     0x04 ///< The GF0 flag is set. Set the GF0 flag.          
1397      =1                                                                                       
1398      =1  #define PCON0_GF1__BMASK   0x08 ///< General Purpose Flag 1                          
1399      =1  #define PCON0_GF1__SHIFT   0x03 ///< General Purpose Flag 1                          
1400      =1  #define PCON0_GF1__NOT_SET 0x00 ///< The GF1 flag is not set. Clear the GF1 flag.    
1401      =1  #define PCON0_GF1__SET     0x08 ///< The GF1 flag is set. Set the GF1 flag.          
1402      =1                                                                                       
1403      =1  #define PCON0_GF2__BMASK   0x10 ///< General Purpose Flag 2                          
1404      =1  #define PCON0_GF2__SHIFT   0x04 ///< General Purpose Flag 2                          
1405      =1  #define PCON0_GF2__NOT_SET 0x00 ///< The GF2 flag is not set. Clear the GF2 flag.    
1406      =1  #define PCON0_GF2__SET     0x10 ///< The GF2 flag is set. Set the GF2 flag.          
1407      =1                                                                                       
1408      =1  #define PCON0_GF3__BMASK   0x20 ///< General Purpose Flag 3                          
1409      =1  #define PCON0_GF3__SHIFT   0x05 ///< General Purpose Flag 3                          
1410      =1  #define PCON0_GF3__NOT_SET 0x00 ///< The GF3 flag is not set. Clear the GF3 flag.    
1411      =1  #define PCON0_GF3__SET     0x20 ///< The GF3 flag is set. Set the GF3 flag.          
1412      =1                                                                                       
1413      =1  #define PCON0_GF4__BMASK   0x40 ///< General Purpose Flag 4                          
1414      =1  #define PCON0_GF4__SHIFT   0x06 ///< General Purpose Flag 4                          
1415      =1  #define PCON0_GF4__NOT_SET 0x00 ///< The GF4 flag is not set. Clear the GF4 flag.    
1416      =1  #define PCON0_GF4__SET     0x40 ///< The GF4 flag is set. Set the GF4 flag.          
1417      =1                                                                                       
1418      =1  #define PCON0_GF5__BMASK   0x80 ///< General Purpose Flag 5                          
1419      =1  #define PCON0_GF5__SHIFT   0x07 ///< General Purpose Flag 5                          
1420      =1  #define PCON0_GF5__NOT_SET 0x00 ///< The GF5 flag is not set. Clear the GF5 flag.    
1421      =1  #define PCON0_GF5__SET     0x80 ///< The GF5 flag is set. Set the GF5 flag.          
1422      =1                                                                                       
1423      =1  //------------------------------------------------------------------------------
1424      =1  // P0 Enums (Port 0 Pin Latch @ 0x80)
1425      =1  //------------------------------------------------------------------------------
1426      =1  #define P0_B0__BMASK 0x01 ///< Port 0 Bit 0 Latch                            
1427      =1  #define P0_B0__SHIFT 0x00 ///< Port 0 Bit 0 Latch                            
1428      =1  #define P0_B0__LOW   0x00 ///< P0.0 is low. Set P0.0 to drive low.           
1429      =1  #define P0_B0__HIGH  0x01 ///< P0.0 is high. Set P0.0 to drive or float high.
1430      =1                                                                               
1431      =1  #define P0_B1__BMASK 0x02 ///< Port 0 Bit 1 Latch                            
1432      =1  #define P0_B1__SHIFT 0x01 ///< Port 0 Bit 1 Latch                            
1433      =1  #define P0_B1__LOW   0x00 ///< P0.1 is low. Set P0.1 to drive low.           
1434      =1  #define P0_B1__HIGH  0x02 ///< P0.1 is high. Set P0.1 to drive or float high.
1435      =1                                                                               
1436      =1  #define P0_B2__BMASK 0x04 ///< Port 0 Bit 2 Latch                            
1437      =1  #define P0_B2__SHIFT 0x02 ///< Port 0 Bit 2 Latch                            
1438      =1  #define P0_B2__LOW   0x00 ///< P0.2 is low. Set P0.2 to drive low.           
1439      =1  #define P0_B2__HIGH  0x04 ///< P0.2 is high. Set P0.2 to drive or float high.
1440      =1                                                                               
1441      =1  #define P0_B3__BMASK 0x08 ///< Port 0 Bit 3 Latch                            
1442      =1  #define P0_B3__SHIFT 0x03 ///< Port 0 Bit 3 Latch                            
1443      =1  #define P0_B3__LOW   0x00 ///< P0.3 is low. Set P0.3 to drive low.           
1444      =1  #define P0_B3__HIGH  0x08 ///< P0.3 is high. Set P0.3 to drive or float high.
1445      =1                                                                               
1446      =1  #define P0_B4__BMASK 0x10 ///< Port 0 Bit 4 Latch                            
1447      =1  #define P0_B4__SHIFT 0x04 ///< Port 0 Bit 4 Latch                            
1448      =1  #define P0_B4__LOW   0x00 ///< P0.4 is low. Set P0.4 to drive low.           
C51 COMPILER V9.56.0.0   SPI_0                                                             10/28/2016 17:37:02 PAGE 50  

1449      =1  #define P0_B4__HIGH  0x10 ///< P0.4 is high. Set P0.4 to drive or float high.
1450      =1                                                                               
1451      =1  #define P0_B5__BMASK 0x20 ///< Port 0 Bit 5 Latch                            
1452      =1  #define P0_B5__SHIFT 0x05 ///< Port 0 Bit 5 Latch                            
1453      =1  #define P0_B5__LOW   0x00 ///< P0.5 is low. Set P0.5 to drive low.           
1454      =1  #define P0_B5__HIGH  0x20 ///< P0.5 is high. Set P0.5 to drive or float high.
1455      =1                                                                               
1456      =1  #define P0_B6__BMASK 0x40 ///< Port 0 Bit 6 Latch                            
1457      =1  #define P0_B6__SHIFT 0x06 ///< Port 0 Bit 6 Latch                            
1458      =1  #define P0_B6__LOW   0x00 ///< P0.6 is low. Set P0.6 to drive low.           
1459      =1  #define P0_B6__HIGH  0x40 ///< P0.6 is high. Set P0.6 to drive or float high.
1460      =1                                                                               
1461      =1  #define P0_B7__BMASK 0x80 ///< Port 0 Bit 7 Latch                            
1462      =1  #define P0_B7__SHIFT 0x07 ///< Port 0 Bit 7 Latch                            
1463      =1  #define P0_B7__LOW   0x00 ///< P0.7 is low. Set P0.7 to drive low.           
1464      =1  #define P0_B7__HIGH  0x80 ///< P0.7 is high. Set P0.7 to drive or float high.
1465      =1                                                                               
1466      =1  //------------------------------------------------------------------------------
1467      =1  // P0MDIN Enums (Port 0 Input Mode @ 0xF1)
1468      =1  //------------------------------------------------------------------------------
1469      =1  #define P0MDIN_B0__BMASK   0x01 ///< Port 0 Bit 0 Input Mode                 
1470      =1  #define P0MDIN_B0__SHIFT   0x00 ///< Port 0 Bit 0 Input Mode                 
1471      =1  #define P0MDIN_B0__ANALOG  0x00 ///< P0.0 pin is configured for analog mode. 
1472      =1  #define P0MDIN_B0__DIGITAL 0x01 ///< P0.0 pin is configured for digital mode.
1473      =1                                                                               
1474      =1  #define P0MDIN_B1__BMASK   0x02 ///< Port 0 Bit 1 Input Mode                 
1475      =1  #define P0MDIN_B1__SHIFT   0x01 ///< Port 0 Bit 1 Input Mode                 
1476      =1  #define P0MDIN_B1__ANALOG  0x00 ///< P0.1 pin is configured for analog mode. 
1477      =1  #define P0MDIN_B1__DIGITAL 0x02 ///< P0.1 pin is configured for digital mode.
1478      =1                                                                               
1479      =1  #define P0MDIN_B2__BMASK   0x04 ///< Port 0 Bit 2 Input Mode                 
1480      =1  #define P0MDIN_B2__SHIFT   0x02 ///< Port 0 Bit 2 Input Mode                 
1481      =1  #define P0MDIN_B2__ANALOG  0x00 ///< P0.2 pin is configured for analog mode. 
1482      =1  #define P0MDIN_B2__DIGITAL 0x04 ///< P0.2 pin is configured for digital mode.
1483      =1                                                                               
1484      =1  #define P0MDIN_B3__BMASK   0x08 ///< Port 0 Bit 3 Input Mode                 
1485      =1  #define P0MDIN_B3__SHIFT   0x03 ///< Port 0 Bit 3 Input Mode                 
1486      =1  #define P0MDIN_B3__ANALOG  0x00 ///< P0.3 pin is configured for analog mode. 
1487      =1  #define P0MDIN_B3__DIGITAL 0x08 ///< P0.3 pin is configured for digital mode.
1488      =1                                                                               
1489      =1  #define P0MDIN_B4__BMASK   0x10 ///< Port 0 Bit 4 Input Mode                 
1490      =1  #define P0MDIN_B4__SHIFT   0x04 ///< Port 0 Bit 4 Input Mode                 
1491      =1  #define P0MDIN_B4__ANALOG  0x00 ///< P0.4 pin is configured for analog mode. 
1492      =1  #define P0MDIN_B4__DIGITAL 0x10 ///< P0.4 pin is configured for digital mode.
1493      =1                                                                               
1494      =1  #define P0MDIN_B5__BMASK   0x20 ///< Port 0 Bit 5 Input Mode                 
1495      =1  #define P0MDIN_B5__SHIFT   0x05 ///< Port 0 Bit 5 Input Mode                 
1496      =1  #define P0MDIN_B5__ANALOG  0x00 ///< P0.5 pin is configured for analog mode. 
1497      =1  #define P0MDIN_B5__DIGITAL 0x20 ///< P0.5 pin is configured for digital mode.
1498      =1                                                                               
1499      =1  #define P0MDIN_B6__BMASK   0x40 ///< Port 0 Bit 6 Input Mode                 
1500      =1  #define P0MDIN_B6__SHIFT   0x06 ///< Port 0 Bit 6 Input Mode                 
1501      =1  #define P0MDIN_B6__ANALOG  0x00 ///< P0.6 pin is configured for analog mode. 
1502      =1  #define P0MDIN_B6__DIGITAL 0x40 ///< P0.6 pin is configured for digital mode.
1503      =1                                                                               
1504      =1  #define P0MDIN_B7__BMASK   0x80 ///< Port 0 Bit 7 Input Mode                 
1505      =1  #define P0MDIN_B7__SHIFT   0x07 ///< Port 0 Bit 7 Input Mode                 
1506      =1  #define P0MDIN_B7__ANALOG  0x00 ///< P0.7 pin is configured for analog mode. 
1507      =1  #define P0MDIN_B7__DIGITAL 0x80 ///< P0.7 pin is configured for digital mode.
1508      =1                                                                               
1509      =1  //------------------------------------------------------------------------------
1510      =1  // P0MDOUT Enums (Port 0 Output Mode @ 0xA4)
C51 COMPILER V9.56.0.0   SPI_0                                                             10/28/2016 17:37:02 PAGE 51  

1511      =1  //------------------------------------------------------------------------------
1512      =1  #define P0MDOUT_B0__BMASK      0x01 ///< Port 0 Bit 0 Output Mode  
1513      =1  #define P0MDOUT_B0__SHIFT      0x00 ///< Port 0 Bit 0 Output Mode  
1514      =1  #define P0MDOUT_B0__OPEN_DRAIN 0x00 ///< P0.0 output is open-drain.
1515      =1  #define P0MDOUT_B0__PUSH_PULL  0x01 ///< P0.0 output is push-pull. 
1516      =1                                                                     
1517      =1  #define P0MDOUT_B1__BMASK      0x02 ///< Port 0 Bit 1 Output Mode  
1518      =1  #define P0MDOUT_B1__SHIFT      0x01 ///< Port 0 Bit 1 Output Mode  
1519      =1  #define P0MDOUT_B1__OPEN_DRAIN 0x00 ///< P0.1 output is open-drain.
1520      =1  #define P0MDOUT_B1__PUSH_PULL  0x02 ///< P0.1 output is push-pull. 
1521      =1                                                                     
1522      =1  #define P0MDOUT_B2__BMASK      0x04 ///< Port 0 Bit 2 Output Mode  
1523      =1  #define P0MDOUT_B2__SHIFT      0x02 ///< Port 0 Bit 2 Output Mode  
1524      =1  #define P0MDOUT_B2__OPEN_DRAIN 0x00 ///< P0.2 output is open-drain.
1525      =1  #define P0MDOUT_B2__PUSH_PULL  0x04 ///< P0.2 output is push-pull. 
1526      =1                                                                     
1527      =1  #define P0MDOUT_B3__BMASK      0x08 ///< Port 0 Bit 3 Output Mode  
1528      =1  #define P0MDOUT_B3__SHIFT      0x03 ///< Port 0 Bit 3 Output Mode  
1529      =1  #define P0MDOUT_B3__OPEN_DRAIN 0x00 ///< P0.3 output is open-drain.
1530      =1  #define P0MDOUT_B3__PUSH_PULL  0x08 ///< P0.3 output is push-pull. 
1531      =1                                                                     
1532      =1  #define P0MDOUT_B4__BMASK      0x10 ///< Port 0 Bit 4 Output Mode  
1533      =1  #define P0MDOUT_B4__SHIFT      0x04 ///< Port 0 Bit 4 Output Mode  
1534      =1  #define P0MDOUT_B4__OPEN_DRAIN 0x00 ///< P0.4 output is open-drain.
1535      =1  #define P0MDOUT_B4__PUSH_PULL  0x10 ///< P0.4 output is push-pull. 
1536      =1                                                                     
1537      =1  #define P0MDOUT_B5__BMASK      0x20 ///< Port 0 Bit 5 Output Mode  
1538      =1  #define P0MDOUT_B5__SHIFT      0x05 ///< Port 0 Bit 5 Output Mode  
1539      =1  #define P0MDOUT_B5__OPEN_DRAIN 0x00 ///< P0.5 output is open-drain.
1540      =1  #define P0MDOUT_B5__PUSH_PULL  0x20 ///< P0.5 output is push-pull. 
1541      =1                                                                     
1542      =1  #define P0MDOUT_B6__BMASK      0x40 ///< Port 0 Bit 6 Output Mode  
1543      =1  #define P0MDOUT_B6__SHIFT      0x06 ///< Port 0 Bit 6 Output Mode  
1544      =1  #define P0MDOUT_B6__OPEN_DRAIN 0x00 ///< P0.6 output is open-drain.
1545      =1  #define P0MDOUT_B6__PUSH_PULL  0x40 ///< P0.6 output is push-pull. 
1546      =1                                                                     
1547      =1  #define P0MDOUT_B7__BMASK      0x80 ///< Port 0 Bit 7 Output Mode  
1548      =1  #define P0MDOUT_B7__SHIFT      0x07 ///< Port 0 Bit 7 Output Mode  
1549      =1  #define P0MDOUT_B7__OPEN_DRAIN 0x00 ///< P0.7 output is open-drain.
1550      =1  #define P0MDOUT_B7__PUSH_PULL  0x80 ///< P0.7 output is push-pull. 
1551      =1                                                                     
1552      =1  //------------------------------------------------------------------------------
1553      =1  // P0SKIP Enums (Port 0 Skip @ 0xD4)
1554      =1  //------------------------------------------------------------------------------
1555      =1  #define P0SKIP_B0__BMASK       0x01 ///< Port 0 Bit 0 Skip                       
1556      =1  #define P0SKIP_B0__SHIFT       0x00 ///< Port 0 Bit 0 Skip                       
1557      =1  #define P0SKIP_B0__NOT_SKIPPED 0x00 ///< P0.0 pin is not skipped by the crossbar.
1558      =1  #define P0SKIP_B0__SKIPPED     0x01 ///< P0.0 pin is skipped by the crossbar.    
1559      =1                                                                                   
1560      =1  #define P0SKIP_B1__BMASK       0x02 ///< Port 0 Bit 1 Skip                       
1561      =1  #define P0SKIP_B1__SHIFT       0x01 ///< Port 0 Bit 1 Skip                       
1562      =1  #define P0SKIP_B1__NOT_SKIPPED 0x00 ///< P0.1 pin is not skipped by the crossbar.
1563      =1  #define P0SKIP_B1__SKIPPED     0x02 ///< P0.1 pin is skipped by the crossbar.    
1564      =1                                                                                   
1565      =1  #define P0SKIP_B2__BMASK       0x04 ///< Port 0 Bit 2 Skip                       
1566      =1  #define P0SKIP_B2__SHIFT       0x02 ///< Port 0 Bit 2 Skip                       
1567      =1  #define P0SKIP_B2__NOT_SKIPPED 0x00 ///< P0.2 pin is not skipped by the crossbar.
1568      =1  #define P0SKIP_B2__SKIPPED     0x04 ///< P0.2 pin is skipped by the crossbar.    
1569      =1                                                                                   
1570      =1  #define P0SKIP_B3__BMASK       0x08 ///< Port 0 Bit 3 Skip                       
1571      =1  #define P0SKIP_B3__SHIFT       0x03 ///< Port 0 Bit 3 Skip                       
1572      =1  #define P0SKIP_B3__NOT_SKIPPED 0x00 ///< P0.3 pin is not skipped by the crossbar.
C51 COMPILER V9.56.0.0   SPI_0                                                             10/28/2016 17:37:02 PAGE 52  

1573      =1  #define P0SKIP_B3__SKIPPED     0x08 ///< P0.3 pin is skipped by the crossbar.    
1574      =1                                                                                   
1575      =1  #define P0SKIP_B4__BMASK       0x10 ///< Port 0 Bit 4 Skip                       
1576      =1  #define P0SKIP_B4__SHIFT       0x04 ///< Port 0 Bit 4 Skip                       
1577      =1  #define P0SKIP_B4__NOT_SKIPPED 0x00 ///< P0.4 pin is not skipped by the crossbar.
1578      =1  #define P0SKIP_B4__SKIPPED     0x10 ///< P0.4 pin is skipped by the crossbar.    
1579      =1                                                                                   
1580      =1  #define P0SKIP_B5__BMASK       0x20 ///< Port 0 Bit 5 Skip                       
1581      =1  #define P0SKIP_B5__SHIFT       0x05 ///< Port 0 Bit 5 Skip                       
1582      =1  #define P0SKIP_B5__NOT_SKIPPED 0x00 ///< P0.5 pin is not skipped by the crossbar.
1583      =1  #define P0SKIP_B5__SKIPPED     0x20 ///< P0.5 pin is skipped by the crossbar.    
1584      =1                                                                                   
1585      =1  #define P0SKIP_B6__BMASK       0x40 ///< Port 0 Bit 6 Skip                       
1586      =1  #define P0SKIP_B6__SHIFT       0x06 ///< Port 0 Bit 6 Skip                       
1587      =1  #define P0SKIP_B6__NOT_SKIPPED 0x00 ///< P0.6 pin is not skipped by the crossbar.
1588      =1  #define P0SKIP_B6__SKIPPED     0x40 ///< P0.6 pin is skipped by the crossbar.    
1589      =1                                                                                   
1590      =1  #define P0SKIP_B7__BMASK       0x80 ///< Port 0 Bit 7 Skip                       
1591      =1  #define P0SKIP_B7__SHIFT       0x07 ///< Port 0 Bit 7 Skip                       
1592      =1  #define P0SKIP_B7__NOT_SKIPPED 0x00 ///< P0.7 pin is not skipped by the crossbar.
1593      =1  #define P0SKIP_B7__SKIPPED     0x80 ///< P0.7 pin is skipped by the crossbar.    
1594      =1                                                                                   
1595      =1  //------------------------------------------------------------------------------
1596      =1  // P1 Enums (Port 1 Pin Latch @ 0x90)
1597      =1  //------------------------------------------------------------------------------
1598      =1  #define P1_B0__BMASK 0x01 ///< Port 1 Bit 0 Latch                            
1599      =1  #define P1_B0__SHIFT 0x00 ///< Port 1 Bit 0 Latch                            
1600      =1  #define P1_B0__LOW   0x00 ///< P1.0 is low. Set P1.0 to drive low.           
1601      =1  #define P1_B0__HIGH  0x01 ///< P1.0 is high. Set P1.0 to drive or float high.
1602      =1                                                                               
1603      =1  #define P1_B1__BMASK 0x02 ///< Port 1 Bit 1 Latch                            
1604      =1  #define P1_B1__SHIFT 0x01 ///< Port 1 Bit 1 Latch                            
1605      =1  #define P1_B1__LOW   0x00 ///< P1.1 is low. Set P1.1 to drive low.           
1606      =1  #define P1_B1__HIGH  0x02 ///< P1.1 is high. Set P1.1 to drive or float high.
1607      =1                                                                               
1608      =1  #define P1_B2__BMASK 0x04 ///< Port 1 Bit 2 Latch                            
1609      =1  #define P1_B2__SHIFT 0x02 ///< Port 1 Bit 2 Latch                            
1610      =1  #define P1_B2__LOW   0x00 ///< P1.2 is low. Set P1.2 to drive low.           
1611      =1  #define P1_B2__HIGH  0x04 ///< P1.2 is high. Set P1.2 to drive or float high.
1612      =1                                                                               
1613      =1  #define P1_B3__BMASK 0x08 ///< Port 1 Bit 3 Latch                            
1614      =1  #define P1_B3__SHIFT 0x03 ///< Port 1 Bit 3 Latch                            
1615      =1  #define P1_B3__LOW   0x00 ///< P1.3 is low. Set P1.3 to drive low.           
1616      =1  #define P1_B3__HIGH  0x08 ///< P1.3 is high. Set P1.3 to drive or float high.
1617      =1                                                                               
1618      =1  #define P1_B4__BMASK 0x10 ///< Port 1 Bit 4 Latch                            
1619      =1  #define P1_B4__SHIFT 0x04 ///< Port 1 Bit 4 Latch                            
1620      =1  #define P1_B4__LOW   0x00 ///< P1.4 is low. Set P1.4 to drive low.           
1621      =1  #define P1_B4__HIGH  0x10 ///< P1.4 is high. Set P1.4 to drive or float high.
1622      =1                                                                               
1623      =1  #define P1_B5__BMASK 0x20 ///< Port 1 Bit 5 Latch                            
1624      =1  #define P1_B5__SHIFT 0x05 ///< Port 1 Bit 5 Latch                            
1625      =1  #define P1_B5__LOW   0x00 ///< P1.5 is low. Set P1.5 to drive low.           
1626      =1  #define P1_B5__HIGH  0x20 ///< P1.5 is high. Set P1.5 to drive or float high.
1627      =1                                                                               
1628      =1  #define P1_B6__BMASK 0x40 ///< Port 1 Bit 6 Latch                            
1629      =1  #define P1_B6__SHIFT 0x06 ///< Port 1 Bit 6 Latch                            
1630      =1  #define P1_B6__LOW   0x00 ///< P1.6 is low. Set P1.6 to drive low.           
1631      =1  #define P1_B6__HIGH  0x40 ///< P1.6 is high. Set P1.6 to drive or float high.
1632      =1                                                                               
1633      =1  #define P1_B7__BMASK 0x80 ///< Port 1 Bit 7 Latch                            
1634      =1  #define P1_B7__SHIFT 0x07 ///< Port 1 Bit 7 Latch                            
C51 COMPILER V9.56.0.0   SPI_0                                                             10/28/2016 17:37:02 PAGE 53  

1635      =1  #define P1_B7__LOW   0x00 ///< P1.7 is low. Set P1.7 to drive low.           
1636      =1  #define P1_B7__HIGH  0x80 ///< P1.7 is high. Set P1.7 to drive or float high.
1637      =1                                                                               
1638      =1  //------------------------------------------------------------------------------
1639      =1  // P1MDIN Enums (Port 1 Input Mode @ 0xF2)
1640      =1  //------------------------------------------------------------------------------
1641      =1  #define P1MDIN_B0__BMASK   0x01 ///< Port 1 Bit 0 Input Mode                 
1642      =1  #define P1MDIN_B0__SHIFT   0x00 ///< Port 1 Bit 0 Input Mode                 
1643      =1  #define P1MDIN_B0__ANALOG  0x00 ///< P1.0 pin is configured for analog mode. 
1644      =1  #define P1MDIN_B0__DIGITAL 0x01 ///< P1.0 pin is configured for digital mode.
1645      =1                                                                               
1646      =1  #define P1MDIN_B1__BMASK   0x02 ///< Port 1 Bit 1 Input Mode                 
1647      =1  #define P1MDIN_B1__SHIFT   0x01 ///< Port 1 Bit 1 Input Mode                 
1648      =1  #define P1MDIN_B1__ANALOG  0x00 ///< P1.1 pin is configured for analog mode. 
1649      =1  #define P1MDIN_B1__DIGITAL 0x02 ///< P1.1 pin is configured for digital mode.
1650      =1                                                                               
1651      =1  #define P1MDIN_B2__BMASK   0x04 ///< Port 1 Bit 2 Input Mode                 
1652      =1  #define P1MDIN_B2__SHIFT   0x02 ///< Port 1 Bit 2 Input Mode                 
1653      =1  #define P1MDIN_B2__ANALOG  0x00 ///< P1.2 pin is configured for analog mode. 
1654      =1  #define P1MDIN_B2__DIGITAL 0x04 ///< P1.2 pin is configured for digital mode.
1655      =1                                                                               
1656      =1  #define P1MDIN_B3__BMASK   0x08 ///< Port 1 Bit 3 Input Mode                 
1657      =1  #define P1MDIN_B3__SHIFT   0x03 ///< Port 1 Bit 3 Input Mode                 
1658      =1  #define P1MDIN_B3__ANALOG  0x00 ///< P1.3 pin is configured for analog mode. 
1659      =1  #define P1MDIN_B3__DIGITAL 0x08 ///< P1.3 pin is configured for digital mode.
1660      =1                                                                               
1661      =1  #define P1MDIN_B4__BMASK   0x10 ///< Port 1 Bit 4 Input Mode                 
1662      =1  #define P1MDIN_B4__SHIFT   0x04 ///< Port 1 Bit 4 Input Mode                 
1663      =1  #define P1MDIN_B4__ANALOG  0x00 ///< P1.4 pin is configured for analog mode. 
1664      =1  #define P1MDIN_B4__DIGITAL 0x10 ///< P1.4 pin is configured for digital mode.
1665      =1                                                                               
1666      =1  #define P1MDIN_B5__BMASK   0x20 ///< Port 1 Bit 5 Input Mode                 
1667      =1  #define P1MDIN_B5__SHIFT   0x05 ///< Port 1 Bit 5 Input Mode                 
1668      =1  #define P1MDIN_B5__ANALOG  0x00 ///< P1.5 pin is configured for analog mode. 
1669      =1  #define P1MDIN_B5__DIGITAL 0x20 ///< P1.5 pin is configured for digital mode.
1670      =1                                                                               
1671      =1  #define P1MDIN_B6__BMASK   0x40 ///< Port 1 Bit 6 Input Mode                 
1672      =1  #define P1MDIN_B6__SHIFT   0x06 ///< Port 1 Bit 6 Input Mode                 
1673      =1  #define P1MDIN_B6__ANALOG  0x00 ///< P1.6 pin is configured for analog mode. 
1674      =1  #define P1MDIN_B6__DIGITAL 0x40 ///< P1.6 pin is configured for digital mode.
1675      =1                                                                               
1676      =1  #define P1MDIN_B7__BMASK   0x80 ///< Port 1 Bit 7 Input Mode                 
1677      =1  #define P1MDIN_B7__SHIFT   0x07 ///< Port 1 Bit 7 Input Mode                 
1678      =1  #define P1MDIN_B7__ANALOG  0x00 ///< P1.7 pin is configured for analog mode. 
1679      =1  #define P1MDIN_B7__DIGITAL 0x80 ///< P1.7 pin is configured for digital mode.
1680      =1                                                                               
1681      =1  //------------------------------------------------------------------------------
1682      =1  // P1MDOUT Enums (Port 1 Output Mode @ 0xA5)
1683      =1  //------------------------------------------------------------------------------
1684      =1  #define P1MDOUT_B0__BMASK      0x01 ///< Port 1 Bit 0 Output Mode  
1685      =1  #define P1MDOUT_B0__SHIFT      0x00 ///< Port 1 Bit 0 Output Mode  
1686      =1  #define P1MDOUT_B0__OPEN_DRAIN 0x00 ///< P1.0 output is open-drain.
1687      =1  #define P1MDOUT_B0__PUSH_PULL  0x01 ///< P1.0 output is push-pull. 
1688      =1                                                                     
1689      =1  #define P1MDOUT_B1__BMASK      0x02 ///< Port 1 Bit 1 Output Mode  
1690      =1  #define P1MDOUT_B1__SHIFT      0x01 ///< Port 1 Bit 1 Output Mode  
1691      =1  #define P1MDOUT_B1__OPEN_DRAIN 0x00 ///< P1.1 output is open-drain.
1692      =1  #define P1MDOUT_B1__PUSH_PULL  0x02 ///< P1.1 output is push-pull. 
1693      =1                                                                     
1694      =1  #define P1MDOUT_B2__BMASK      0x04 ///< Port 1 Bit 2 Output Mode  
1695      =1  #define P1MDOUT_B2__SHIFT      0x02 ///< Port 1 Bit 2 Output Mode  
1696      =1  #define P1MDOUT_B2__OPEN_DRAIN 0x00 ///< P1.2 output is open-drain.
C51 COMPILER V9.56.0.0   SPI_0                                                             10/28/2016 17:37:02 PAGE 54  

1697      =1  #define P1MDOUT_B2__PUSH_PULL  0x04 ///< P1.2 output is push-pull. 
1698      =1                                                                     
1699      =1  #define P1MDOUT_B3__BMASK      0x08 ///< Port 1 Bit 3 Output Mode  
1700      =1  #define P1MDOUT_B3__SHIFT      0x03 ///< Port 1 Bit 3 Output Mode  
1701      =1  #define P1MDOUT_B3__OPEN_DRAIN 0x00 ///< P1.3 output is open-drain.
1702      =1  #define P1MDOUT_B3__PUSH_PULL  0x08 ///< P1.3 output is push-pull. 
1703      =1                                                                     
1704      =1  #define P1MDOUT_B4__BMASK      0x10 ///< Port 1 Bit 4 Output Mode  
1705      =1  #define P1MDOUT_B4__SHIFT      0x04 ///< Port 1 Bit 4 Output Mode  
1706      =1  #define P1MDOUT_B4__OPEN_DRAIN 0x00 ///< P1.4 output is open-drain.
1707      =1  #define P1MDOUT_B4__PUSH_PULL  0x10 ///< P1.4 output is push-pull. 
1708      =1                                                                     
1709      =1  #define P1MDOUT_B5__BMASK      0x20 ///< Port 1 Bit 5 Output Mode  
1710      =1  #define P1MDOUT_B5__SHIFT      0x05 ///< Port 1 Bit 5 Output Mode  
1711      =1  #define P1MDOUT_B5__OPEN_DRAIN 0x00 ///< P1.5 output is open-drain.
1712      =1  #define P1MDOUT_B5__PUSH_PULL  0x20 ///< P1.5 output is push-pull. 
1713      =1                                                                     
1714      =1  #define P1MDOUT_B6__BMASK      0x40 ///< Port 1 Bit 6 Output Mode  
1715      =1  #define P1MDOUT_B6__SHIFT      0x06 ///< Port 1 Bit 6 Output Mode  
1716      =1  #define P1MDOUT_B6__OPEN_DRAIN 0x00 ///< P1.6 output is open-drain.
1717      =1  #define P1MDOUT_B6__PUSH_PULL  0x40 ///< P1.6 output is push-pull. 
1718      =1                                                                     
1719      =1  #define P1MDOUT_B7__BMASK      0x80 ///< Port 1 Bit 7 Output Mode  
1720      =1  #define P1MDOUT_B7__SHIFT      0x07 ///< Port 1 Bit 7 Output Mode  
1721      =1  #define P1MDOUT_B7__OPEN_DRAIN 0x00 ///< P1.7 output is open-drain.
1722      =1  #define P1MDOUT_B7__PUSH_PULL  0x80 ///< P1.7 output is push-pull. 
1723      =1                                                                     
1724      =1  //------------------------------------------------------------------------------
1725      =1  // P1SKIP Enums (Port 1 Skip @ 0xD5)
1726      =1  //------------------------------------------------------------------------------
1727      =1  #define P1SKIP_B0__BMASK       0x01 ///< Port 1 Bit 0 Skip                       
1728      =1  #define P1SKIP_B0__SHIFT       0x00 ///< Port 1 Bit 0 Skip                       
1729      =1  #define P1SKIP_B0__NOT_SKIPPED 0x00 ///< P1.0 pin is not skipped by the crossbar.
1730      =1  #define P1SKIP_B0__SKIPPED     0x01 ///< P1.0 pin is skipped by the crossbar.    
1731      =1                                                                                   
1732      =1  #define P1SKIP_B1__BMASK       0x02 ///< Port 1 Bit 1 Skip                       
1733      =1  #define P1SKIP_B1__SHIFT       0x01 ///< Port 1 Bit 1 Skip                       
1734      =1  #define P1SKIP_B1__NOT_SKIPPED 0x00 ///< P1.1 pin is not skipped by the crossbar.
1735      =1  #define P1SKIP_B1__SKIPPED     0x02 ///< P1.1 pin is skipped by the crossbar.    
1736      =1                                                                                   
1737      =1  #define P1SKIP_B2__BMASK       0x04 ///< Port 1 Bit 2 Skip                       
1738      =1  #define P1SKIP_B2__SHIFT       0x02 ///< Port 1 Bit 2 Skip                       
1739      =1  #define P1SKIP_B2__NOT_SKIPPED 0x00 ///< P1.2 pin is not skipped by the crossbar.
1740      =1  #define P1SKIP_B2__SKIPPED     0x04 ///< P1.2 pin is skipped by the crossbar.    
1741      =1                                                                                   
1742      =1  #define P1SKIP_B3__BMASK       0x08 ///< Port 1 Bit 3 Skip                       
1743      =1  #define P1SKIP_B3__SHIFT       0x03 ///< Port 1 Bit 3 Skip                       
1744      =1  #define P1SKIP_B3__NOT_SKIPPED 0x00 ///< P1.3 pin is not skipped by the crossbar.
1745      =1  #define P1SKIP_B3__SKIPPED     0x08 ///< P1.3 pin is skipped by the crossbar.    
1746      =1                                                                                   
1747      =1  #define P1SKIP_B4__BMASK       0x10 ///< Port 1 Bit 4 Skip                       
1748      =1  #define P1SKIP_B4__SHIFT       0x04 ///< Port 1 Bit 4 Skip                       
1749      =1  #define P1SKIP_B4__NOT_SKIPPED 0x00 ///< P1.4 pin is not skipped by the crossbar.
1750      =1  #define P1SKIP_B4__SKIPPED     0x10 ///< P1.4 pin is skipped by the crossbar.    
1751      =1                                                                                   
1752      =1  #define P1SKIP_B5__BMASK       0x20 ///< Port 1 Bit 5 Skip                       
1753      =1  #define P1SKIP_B5__SHIFT       0x05 ///< Port 1 Bit 5 Skip                       
1754      =1  #define P1SKIP_B5__NOT_SKIPPED 0x00 ///< P1.5 pin is not skipped by the crossbar.
1755      =1  #define P1SKIP_B5__SKIPPED     0x20 ///< P1.5 pin is skipped by the crossbar.    
1756      =1                                                                                   
1757      =1  #define P1SKIP_B6__BMASK       0x40 ///< Port 1 Bit 6 Skip                       
1758      =1  #define P1SKIP_B6__SHIFT       0x06 ///< Port 1 Bit 6 Skip                       
C51 COMPILER V9.56.0.0   SPI_0                                                             10/28/2016 17:37:02 PAGE 55  

1759      =1  #define P1SKIP_B6__NOT_SKIPPED 0x00 ///< P1.6 pin is not skipped by the crossbar.
1760      =1  #define P1SKIP_B6__SKIPPED     0x40 ///< P1.6 pin is skipped by the crossbar.    
1761      =1                                                                                   
1762      =1  #define P1SKIP_B7__BMASK       0x80 ///< Port 1 Bit 7 Skip                       
1763      =1  #define P1SKIP_B7__SHIFT       0x07 ///< Port 1 Bit 7 Skip                       
1764      =1  #define P1SKIP_B7__NOT_SKIPPED 0x00 ///< P1.7 pin is not skipped by the crossbar.
1765      =1  #define P1SKIP_B7__SKIPPED     0x80 ///< P1.7 pin is skipped by the crossbar.    
1766      =1                                                                                   
1767      =1  //------------------------------------------------------------------------------
1768      =1  // P2 Enums (Port 2 Pin Latch @ 0xA0)
1769      =1  //------------------------------------------------------------------------------
1770      =1  #define P2_B0__BMASK 0x01 ///< Port 2 Bit 0 Latch                            
1771      =1  #define P2_B0__SHIFT 0x00 ///< Port 2 Bit 0 Latch                            
1772      =1  #define P2_B0__LOW   0x00 ///< P2.0 is low. Set P2.0 to drive low.           
1773      =1  #define P2_B0__HIGH  0x01 ///< P2.0 is high. Set P2.0 to drive or float high.
1774      =1                                                                               
1775      =1  #define P2_B1__BMASK 0x02 ///< Port 2 Bit 1 Latch                            
1776      =1  #define P2_B1__SHIFT 0x01 ///< Port 2 Bit 1 Latch                            
1777      =1  #define P2_B1__LOW   0x00 ///< P2.1 is low. Set P2.1 to drive low.           
1778      =1  #define P2_B1__HIGH  0x02 ///< P2.1 is high. Set P2.1 to drive or float high.
1779      =1                                                                               
1780      =1  #define P2_B2__BMASK 0x04 ///< Port 2 Bit 2 Latch                            
1781      =1  #define P2_B2__SHIFT 0x02 ///< Port 2 Bit 2 Latch                            
1782      =1  #define P2_B2__LOW   0x00 ///< P2.2 is low. Set P2.2 to drive low.           
1783      =1  #define P2_B2__HIGH  0x04 ///< P2.2 is high. Set P2.2 to drive or float high.
1784      =1                                                                               
1785      =1  #define P2_B3__BMASK 0x08 ///< Port 2 Bit 3 Latch                            
1786      =1  #define P2_B3__SHIFT 0x03 ///< Port 2 Bit 3 Latch                            
1787      =1  #define P2_B3__LOW   0x00 ///< P2.3 is low. Set P2.3 to drive low.           
1788      =1  #define P2_B3__HIGH  0x08 ///< P2.3 is high. Set P2.3 to drive or float high.
1789      =1                                                                               
1790      =1  #define P2_B4__BMASK 0x10 ///< Port 2 Bit 4 Latch                            
1791      =1  #define P2_B4__SHIFT 0x04 ///< Port 2 Bit 4 Latch                            
1792      =1  #define P2_B4__LOW   0x00 ///< P2.4 is low. Set P2.4 to drive low.           
1793      =1  #define P2_B4__HIGH  0x10 ///< P2.4 is high. Set P2.4 to drive or float high.
1794      =1                                                                               
1795      =1  #define P2_B5__BMASK 0x20 ///< Port 2 Bit 5 Latch                            
1796      =1  #define P2_B5__SHIFT 0x05 ///< Port 2 Bit 5 Latch                            
1797      =1  #define P2_B5__LOW   0x00 ///< P2.5 is low. Set P2.5 to drive low.           
1798      =1  #define P2_B5__HIGH  0x20 ///< P2.5 is high. Set P2.5 to drive or float high.
1799      =1                                                                               
1800      =1  #define P2_B6__BMASK 0x40 ///< Port 2 Bit 6 Latch                            
1801      =1  #define P2_B6__SHIFT 0x06 ///< Port 2 Bit 6 Latch                            
1802      =1  #define P2_B6__LOW   0x00 ///< P2.6 is low. Set P2.6 to drive low.           
1803      =1  #define P2_B6__HIGH  0x40 ///< P2.6 is high. Set P2.6 to drive or float high.
1804      =1                                                                               
1805      =1  #define P2_B7__BMASK 0x80 ///< Port 2 Bit 7 Latch                            
1806      =1  #define P2_B7__SHIFT 0x07 ///< Port 2 Bit 7 Latch                            
1807      =1  #define P2_B7__LOW   0x00 ///< P2.7 is low. Set P2.7 to drive low.           
1808      =1  #define P2_B7__HIGH  0x80 ///< P2.7 is high. Set P2.7 to drive or float high.
1809      =1                                                                               
1810      =1  //------------------------------------------------------------------------------
1811      =1  // P2MDIN Enums (Port 2 Input Mode @ 0xF3)
1812      =1  //------------------------------------------------------------------------------
1813      =1  #define P2MDIN_B0__BMASK   0x01 ///< Port 2 Bit 0 Input Mode                 
1814      =1  #define P2MDIN_B0__SHIFT   0x00 ///< Port 2 Bit 0 Input Mode                 
1815      =1  #define P2MDIN_B0__ANALOG  0x00 ///< P2.0 pin is configured for analog mode. 
1816      =1  #define P2MDIN_B0__DIGITAL 0x01 ///< P2.0 pin is configured for digital mode.
1817      =1                                                                               
1818      =1  #define P2MDIN_B1__BMASK   0x02 ///< Port 2 Bit 1 Input Mode                 
1819      =1  #define P2MDIN_B1__SHIFT   0x01 ///< Port 2 Bit 1 Input Mode                 
1820      =1  #define P2MDIN_B1__ANALOG  0x00 ///< P2.1 pin is configured for analog mode. 
C51 COMPILER V9.56.0.0   SPI_0                                                             10/28/2016 17:37:02 PAGE 56  

1821      =1  #define P2MDIN_B1__DIGITAL 0x02 ///< P2.1 pin is configured for digital mode.
1822      =1                                                                               
1823      =1  #define P2MDIN_B2__BMASK   0x04 ///< Port 2 Bit 2 Input Mode                 
1824      =1  #define P2MDIN_B2__SHIFT   0x02 ///< Port 2 Bit 2 Input Mode                 
1825      =1  #define P2MDIN_B2__ANALOG  0x00 ///< P2.2 pin is configured for analog mode. 
1826      =1  #define P2MDIN_B2__DIGITAL 0x04 ///< P2.2 pin is configured for digital mode.
1827      =1                                                                               
1828      =1  #define P2MDIN_B3__BMASK   0x08 ///< Port 2 Bit 3 Input Mode                 
1829      =1  #define P2MDIN_B3__SHIFT   0x03 ///< Port 2 Bit 3 Input Mode                 
1830      =1  #define P2MDIN_B3__ANALOG  0x00 ///< P2.3 pin is configured for analog mode. 
1831      =1  #define P2MDIN_B3__DIGITAL 0x08 ///< P2.3 pin is configured for digital mode.
1832      =1                                                                               
1833      =1  #define P2MDIN_B4__BMASK   0x10 ///< Port 2 Bit 4 Input Mode                 
1834      =1  #define P2MDIN_B4__SHIFT   0x04 ///< Port 2 Bit 4 Input Mode                 
1835      =1  #define P2MDIN_B4__ANALOG  0x00 ///< P2.4 pin is configured for analog mode. 
1836      =1  #define P2MDIN_B4__DIGITAL 0x10 ///< P2.4 pin is configured for digital mode.
1837      =1                                                                               
1838      =1  #define P2MDIN_B5__BMASK   0x20 ///< Port 2 Bit 5 Input Mode                 
1839      =1  #define P2MDIN_B5__SHIFT   0x05 ///< Port 2 Bit 5 Input Mode                 
1840      =1  #define P2MDIN_B5__ANALOG  0x00 ///< P2.5 pin is configured for analog mode. 
1841      =1  #define P2MDIN_B5__DIGITAL 0x20 ///< P2.5 pin is configured for digital mode.
1842      =1                                                                               
1843      =1  #define P2MDIN_B6__BMASK   0x40 ///< Port 2 Bit 6 Input Mode                 
1844      =1  #define P2MDIN_B6__SHIFT   0x06 ///< Port 2 Bit 6 Input Mode                 
1845      =1  #define P2MDIN_B6__ANALOG  0x00 ///< P2.6 pin is configured for analog mode. 
1846      =1  #define P2MDIN_B6__DIGITAL 0x40 ///< P2.6 pin is configured for digital mode.
1847      =1                                                                               
1848      =1  #define P2MDIN_B7__BMASK   0x80 ///< Port 2 Bit 7 Input Mode                 
1849      =1  #define P2MDIN_B7__SHIFT   0x07 ///< Port 2 Bit 7 Input Mode                 
1850      =1  #define P2MDIN_B7__ANALOG  0x00 ///< P2.7 pin is configured for analog mode. 
1851      =1  #define P2MDIN_B7__DIGITAL 0x80 ///< P2.7 pin is configured for digital mode.
1852      =1                                                                               
1853      =1  //------------------------------------------------------------------------------
1854      =1  // P2MDOUT Enums (Port 2 Output Mode @ 0xA6)
1855      =1  //------------------------------------------------------------------------------
1856      =1  #define P2MDOUT_B0__BMASK      0x01 ///< Port 2 Bit 0 Output Mode  
1857      =1  #define P2MDOUT_B0__SHIFT      0x00 ///< Port 2 Bit 0 Output Mode  
1858      =1  #define P2MDOUT_B0__OPEN_DRAIN 0x00 ///< P2.0 output is open-drain.
1859      =1  #define P2MDOUT_B0__PUSH_PULL  0x01 ///< P2.0 output is push-pull. 
1860      =1                                                                     
1861      =1  #define P2MDOUT_B1__BMASK      0x02 ///< Port 2 Bit 1 Output Mode  
1862      =1  #define P2MDOUT_B1__SHIFT      0x01 ///< Port 2 Bit 1 Output Mode  
1863      =1  #define P2MDOUT_B1__OPEN_DRAIN 0x00 ///< P2.1 output is open-drain.
1864      =1  #define P2MDOUT_B1__PUSH_PULL  0x02 ///< P2.1 output is push-pull. 
1865      =1                                                                     
1866      =1  #define P2MDOUT_B2__BMASK      0x04 ///< Port 2 Bit 2 Output Mode  
1867      =1  #define P2MDOUT_B2__SHIFT      0x02 ///< Port 2 Bit 2 Output Mode  
1868      =1  #define P2MDOUT_B2__OPEN_DRAIN 0x00 ///< P2.2 output is open-drain.
1869      =1  #define P2MDOUT_B2__PUSH_PULL  0x04 ///< P2.2 output is push-pull. 
1870      =1                                                                     
1871      =1  #define P2MDOUT_B3__BMASK      0x08 ///< Port 2 Bit 3 Output Mode  
1872      =1  #define P2MDOUT_B3__SHIFT      0x03 ///< Port 2 Bit 3 Output Mode  
1873      =1  #define P2MDOUT_B3__OPEN_DRAIN 0x00 ///< P2.3 output is open-drain.
1874      =1  #define P2MDOUT_B3__PUSH_PULL  0x08 ///< P2.3 output is push-pull. 
1875      =1                                                                     
1876      =1  #define P2MDOUT_B4__BMASK      0x10 ///< Port 2 Bit 4 Output Mode  
1877      =1  #define P2MDOUT_B4__SHIFT      0x04 ///< Port 2 Bit 4 Output Mode  
1878      =1  #define P2MDOUT_B4__OPEN_DRAIN 0x00 ///< P2.4 output is open-drain.
1879      =1  #define P2MDOUT_B4__PUSH_PULL  0x10 ///< P2.4 output is push-pull. 
1880      =1                                                                     
1881      =1  #define P2MDOUT_B5__BMASK      0x20 ///< Port 2 Bit 5 Output Mode  
1882      =1  #define P2MDOUT_B5__SHIFT      0x05 ///< Port 2 Bit 5 Output Mode  
C51 COMPILER V9.56.0.0   SPI_0                                                             10/28/2016 17:37:02 PAGE 57  

1883      =1  #define P2MDOUT_B5__OPEN_DRAIN 0x00 ///< P2.5 output is open-drain.
1884      =1  #define P2MDOUT_B5__PUSH_PULL  0x20 ///< P2.5 output is push-pull. 
1885      =1                                                                     
1886      =1  #define P2MDOUT_B6__BMASK      0x40 ///< Port 2 Bit 6 Output Mode  
1887      =1  #define P2MDOUT_B6__SHIFT      0x06 ///< Port 2 Bit 6 Output Mode  
1888      =1  #define P2MDOUT_B6__OPEN_DRAIN 0x00 ///< P2.6 output is open-drain.
1889      =1  #define P2MDOUT_B6__PUSH_PULL  0x40 ///< P2.6 output is push-pull. 
1890      =1                                                                     
1891      =1  #define P2MDOUT_B7__BMASK      0x80 ///< Port 2 Bit 7 Output Mode  
1892      =1  #define P2MDOUT_B7__SHIFT      0x07 ///< Port 2 Bit 7 Output Mode  
1893      =1  #define P2MDOUT_B7__OPEN_DRAIN 0x00 ///< P2.7 output is open-drain.
1894      =1  #define P2MDOUT_B7__PUSH_PULL  0x80 ///< P2.7 output is push-pull. 
1895      =1                                                                     
1896      =1  //------------------------------------------------------------------------------
1897      =1  // P2SKIP Enums (Port 2 Skip @ 0xD6)
1898      =1  //------------------------------------------------------------------------------
1899      =1  #define P2SKIP_B0__BMASK       0x01 ///< Port 2 Bit 0 Skip                       
1900      =1  #define P2SKIP_B0__SHIFT       0x00 ///< Port 2 Bit 0 Skip                       
1901      =1  #define P2SKIP_B0__NOT_SKIPPED 0x00 ///< P2.0 pin is not skipped by the crossbar.
1902      =1  #define P2SKIP_B0__SKIPPED     0x01 ///< P2.0 pin is skipped by the crossbar.    
1903      =1                                                                                   
1904      =1  #define P2SKIP_B1__BMASK       0x02 ///< Port 2 Bit 1 Skip                       
1905      =1  #define P2SKIP_B1__SHIFT       0x01 ///< Port 2 Bit 1 Skip                       
1906      =1  #define P2SKIP_B1__NOT_SKIPPED 0x00 ///< P2.1 pin is not skipped by the crossbar.
1907      =1  #define P2SKIP_B1__SKIPPED     0x02 ///< P2.1 pin is skipped by the crossbar.    
1908      =1                                                                                   
1909      =1  #define P2SKIP_B2__BMASK       0x04 ///< Port 2 Bit 2 Skip                       
1910      =1  #define P2SKIP_B2__SHIFT       0x02 ///< Port 2 Bit 2 Skip                       
1911      =1  #define P2SKIP_B2__NOT_SKIPPED 0x00 ///< P2.2 pin is not skipped by the crossbar.
1912      =1  #define P2SKIP_B2__SKIPPED     0x04 ///< P2.2 pin is skipped by the crossbar.    
1913      =1                                                                                   
1914      =1  #define P2SKIP_B3__BMASK       0x08 ///< Port 2 Bit 3 Skip                       
1915      =1  #define P2SKIP_B3__SHIFT       0x03 ///< Port 2 Bit 3 Skip                       
1916      =1  #define P2SKIP_B3__NOT_SKIPPED 0x00 ///< P2.3 pin is not skipped by the crossbar.
1917      =1  #define P2SKIP_B3__SKIPPED     0x08 ///< P2.3 pin is skipped by the crossbar.    
1918      =1                                                                                   
1919      =1  #define P2SKIP_B4__BMASK       0x10 ///< Port 2 Bit 4 Skip                       
1920      =1  #define P2SKIP_B4__SHIFT       0x04 ///< Port 2 Bit 4 Skip                       
1921      =1  #define P2SKIP_B4__NOT_SKIPPED 0x00 ///< P2.4 pin is not skipped by the crossbar.
1922      =1  #define P2SKIP_B4__SKIPPED     0x10 ///< P2.4 pin is skipped by the crossbar.    
1923      =1                                                                                   
1924      =1  #define P2SKIP_B5__BMASK       0x20 ///< Port 2 Bit 5 Skip                       
1925      =1  #define P2SKIP_B5__SHIFT       0x05 ///< Port 2 Bit 5 Skip                       
1926      =1  #define P2SKIP_B5__NOT_SKIPPED 0x00 ///< P2.5 pin is not skipped by the crossbar.
1927      =1  #define P2SKIP_B5__SKIPPED     0x20 ///< P2.5 pin is skipped by the crossbar.    
1928      =1                                                                                   
1929      =1  #define P2SKIP_B6__BMASK       0x40 ///< Port 2 Bit 6 Skip                       
1930      =1  #define P2SKIP_B6__SHIFT       0x06 ///< Port 2 Bit 6 Skip                       
1931      =1  #define P2SKIP_B6__NOT_SKIPPED 0x00 ///< P2.6 pin is not skipped by the crossbar.
1932      =1  #define P2SKIP_B6__SKIPPED     0x40 ///< P2.6 pin is skipped by the crossbar.    
1933      =1                                                                                   
1934      =1  #define P2SKIP_B7__BMASK       0x80 ///< Port 2 Bit 7 Skip                       
1935      =1  #define P2SKIP_B7__SHIFT       0x07 ///< Port 2 Bit 7 Skip                       
1936      =1  #define P2SKIP_B7__NOT_SKIPPED 0x00 ///< P2.7 pin is not skipped by the crossbar.
1937      =1  #define P2SKIP_B7__SKIPPED     0x80 ///< P2.7 pin is skipped by the crossbar.    
1938      =1                                                                                   
1939      =1  //------------------------------------------------------------------------------
1940      =1  // P3 Enums (Port 3 Pin Latch @ 0xB0)
1941      =1  //------------------------------------------------------------------------------
1942      =1  #define P3_B0__BMASK 0x01 ///< Port 3 Bit 0 Latch                            
1943      =1  #define P3_B0__SHIFT 0x00 ///< Port 3 Bit 0 Latch                            
1944      =1  #define P3_B0__LOW   0x00 ///< P3.0 is low. Set P3.0 to drive low.           
C51 COMPILER V9.56.0.0   SPI_0                                                             10/28/2016 17:37:02 PAGE 58  

1945      =1  #define P3_B0__HIGH  0x01 ///< P3.0 is high. Set P3.0 to drive or float high.
1946      =1                                                                               
1947      =1  #define P3_B1__BMASK 0x02 ///< Port 3 Bit 1 Latch                            
1948      =1  #define P3_B1__SHIFT 0x01 ///< Port 3 Bit 1 Latch                            
1949      =1  #define P3_B1__LOW   0x00 ///< P3.1 is low. Set P3.1 to drive low.           
1950      =1  #define P3_B1__HIGH  0x02 ///< P3.1 is high. Set P3.1 to drive or float high.
1951      =1                                                                               
1952      =1  #define P3_B2__BMASK 0x04 ///< Port 3 Bit 2 Latch                            
1953      =1  #define P3_B2__SHIFT 0x02 ///< Port 3 Bit 2 Latch                            
1954      =1  #define P3_B2__LOW   0x00 ///< P3.2 is low. Set P3.2 to drive low.           
1955      =1  #define P3_B2__HIGH  0x04 ///< P3.2 is high. Set P3.2 to drive or float high.
1956      =1                                                                               
1957      =1  #define P3_B3__BMASK 0x08 ///< Port 3 Bit 3 Latch                            
1958      =1  #define P3_B3__SHIFT 0x03 ///< Port 3 Bit 3 Latch                            
1959      =1  #define P3_B3__LOW   0x00 ///< P3.3 is low. Set P3.3 to drive low.           
1960      =1  #define P3_B3__HIGH  0x08 ///< P3.3 is high. Set P3.3 to drive or float high.
1961      =1                                                                               
1962      =1  #define P3_B4__BMASK 0x10 ///< Port 3 Bit 4 Latch                            
1963      =1  #define P3_B4__SHIFT 0x04 ///< Port 3 Bit 4 Latch                            
1964      =1  #define P3_B4__LOW   0x00 ///< P3.4 is low. Set P3.4 to drive low.           
1965      =1  #define P3_B4__HIGH  0x10 ///< P3.4 is high. Set P3.4 to drive or float high.
1966      =1                                                                               
1967      =1  #define P3_B5__BMASK 0x20 ///< Port 3 Bit 5 Latch                            
1968      =1  #define P3_B5__SHIFT 0x05 ///< Port 3 Bit 5 Latch                            
1969      =1  #define P3_B5__LOW   0x00 ///< P3.5 is low. Set P3.5 to drive low.           
1970      =1  #define P3_B5__HIGH  0x20 ///< P3.5 is high. Set P3.5 to drive or float high.
1971      =1                                                                               
1972      =1  #define P3_B6__BMASK 0x40 ///< Port 3 Bit 6 Latch                            
1973      =1  #define P3_B6__SHIFT 0x06 ///< Port 3 Bit 6 Latch                            
1974      =1  #define P3_B6__LOW   0x00 ///< P3.6 is low. Set P3.6 to drive low.           
1975      =1  #define P3_B6__HIGH  0x40 ///< P3.6 is high. Set P3.6 to drive or float high.
1976      =1                                                                               
1977      =1  #define P3_B7__BMASK 0x80 ///< Port 3 Bit 7 Latch                            
1978      =1  #define P3_B7__SHIFT 0x07 ///< Port 3 Bit 7 Latch                            
1979      =1  #define P3_B7__LOW   0x00 ///< P3.7 is low. Set P3.7 to drive low.           
1980      =1  #define P3_B7__HIGH  0x80 ///< P3.7 is high. Set P3.7 to drive or float high.
1981      =1                                                                               
1982      =1  //------------------------------------------------------------------------------
1983      =1  // P3MDIN Enums (Port 3 Input Mode @ 0xF4)
1984      =1  //------------------------------------------------------------------------------
1985      =1  #define P3MDIN_B0__BMASK   0x01 ///< Port 3 Bit 0 Input Mode                 
1986      =1  #define P3MDIN_B0__SHIFT   0x00 ///< Port 3 Bit 0 Input Mode                 
1987      =1  #define P3MDIN_B0__ANALOG  0x00 ///< P3.0 pin is configured for analog mode. 
1988      =1  #define P3MDIN_B0__DIGITAL 0x01 ///< P3.0 pin is configured for digital mode.
1989      =1                                                                               
1990      =1  #define P3MDIN_B1__BMASK   0x02 ///< Port 3 Bit 1 Input Mode                 
1991      =1  #define P3MDIN_B1__SHIFT   0x01 ///< Port 3 Bit 1 Input Mode                 
1992      =1  #define P3MDIN_B1__ANALOG  0x00 ///< P3.1 pin is configured for analog mode. 
1993      =1  #define P3MDIN_B1__DIGITAL 0x02 ///< P3.1 pin is configured for digital mode.
1994      =1                                                                               
1995      =1  #define P3MDIN_B2__BMASK   0x04 ///< Port 3 Bit 2 Input Mode                 
1996      =1  #define P3MDIN_B2__SHIFT   0x02 ///< Port 3 Bit 2 Input Mode                 
1997      =1  #define P3MDIN_B2__ANALOG  0x00 ///< P3.2 pin is configured for analog mode. 
1998      =1  #define P3MDIN_B2__DIGITAL 0x04 ///< P3.2 pin is configured for digital mode.
1999      =1                                                                               
2000      =1  #define P3MDIN_B3__BMASK   0x08 ///< Port 3 Bit 3 Input Mode                 
2001      =1  #define P3MDIN_B3__SHIFT   0x03 ///< Port 3 Bit 3 Input Mode                 
2002      =1  #define P3MDIN_B3__ANALOG  0x00 ///< P3.3 pin is configured for analog mode. 
2003      =1  #define P3MDIN_B3__DIGITAL 0x08 ///< P3.3 pin is configured for digital mode.
2004      =1                                                                               
2005      =1  #define P3MDIN_B4__BMASK   0x10 ///< Port 3 Bit 4 Input Mode                 
2006      =1  #define P3MDIN_B4__SHIFT   0x04 ///< Port 3 Bit 4 Input Mode                 
C51 COMPILER V9.56.0.0   SPI_0                                                             10/28/2016 17:37:02 PAGE 59  

2007      =1  #define P3MDIN_B4__ANALOG  0x00 ///< P3.4 pin is configured for analog mode. 
2008      =1  #define P3MDIN_B4__DIGITAL 0x10 ///< P3.4 pin is configured for digital mode.
2009      =1                                                                               
2010      =1  #define P3MDIN_B5__BMASK   0x20 ///< Port 3 Bit 5 Input Mode                 
2011      =1  #define P3MDIN_B5__SHIFT   0x05 ///< Port 3 Bit 5 Input Mode                 
2012      =1  #define P3MDIN_B5__ANALOG  0x00 ///< P3.5 pin is configured for analog mode. 
2013      =1  #define P3MDIN_B5__DIGITAL 0x20 ///< P3.5 pin is configured for digital mode.
2014      =1                                                                               
2015      =1  #define P3MDIN_B6__BMASK   0x40 ///< Port 3 Bit 6 Input Mode                 
2016      =1  #define P3MDIN_B6__SHIFT   0x06 ///< Port 3 Bit 6 Input Mode                 
2017      =1  #define P3MDIN_B6__ANALOG  0x00 ///< P3.6 pin is configured for analog mode. 
2018      =1  #define P3MDIN_B6__DIGITAL 0x40 ///< P3.6 pin is configured for digital mode.
2019      =1                                                                               
2020      =1  #define P3MDIN_B7__BMASK   0x80 ///< Port 3 Bit 7 Input Mode                 
2021      =1  #define P3MDIN_B7__SHIFT   0x07 ///< Port 3 Bit 7 Input Mode                 
2022      =1  #define P3MDIN_B7__ANALOG  0x00 ///< P3.7 pin is configured for analog mode. 
2023      =1  #define P3MDIN_B7__DIGITAL 0x80 ///< P3.7 pin is configured for digital mode.
2024      =1                                                                               
2025      =1  //------------------------------------------------------------------------------
2026      =1  // P3MDOUT Enums (Port 3 Output Mode @ 0xA7)
2027      =1  //------------------------------------------------------------------------------
2028      =1  #define P3MDOUT_B0__BMASK      0x01 ///< Port 3 Bit 0 Output Mode  
2029      =1  #define P3MDOUT_B0__SHIFT      0x00 ///< Port 3 Bit 0 Output Mode  
2030      =1  #define P3MDOUT_B0__OPEN_DRAIN 0x00 ///< P3.0 output is open-drain.
2031      =1  #define P3MDOUT_B0__PUSH_PULL  0x01 ///< P3.0 output is push-pull. 
2032      =1                                                                     
2033      =1  #define P3MDOUT_B1__BMASK      0x02 ///< Port 3 Bit 1 Output Mode  
2034      =1  #define P3MDOUT_B1__SHIFT      0x01 ///< Port 3 Bit 1 Output Mode  
2035      =1  #define P3MDOUT_B1__OPEN_DRAIN 0x00 ///< P3.1 output is open-drain.
2036      =1  #define P3MDOUT_B1__PUSH_PULL  0x02 ///< P3.1 output is push-pull. 
2037      =1                                                                     
2038      =1  #define P3MDOUT_B2__BMASK      0x04 ///< Port 3 Bit 2 Output Mode  
2039      =1  #define P3MDOUT_B2__SHIFT      0x02 ///< Port 3 Bit 2 Output Mode  
2040      =1  #define P3MDOUT_B2__OPEN_DRAIN 0x00 ///< P3.2 output is open-drain.
2041      =1  #define P3MDOUT_B2__PUSH_PULL  0x04 ///< P3.2 output is push-pull. 
2042      =1                                                                     
2043      =1  #define P3MDOUT_B3__BMASK      0x08 ///< Port 3 Bit 3 Output Mode  
2044      =1  #define P3MDOUT_B3__SHIFT      0x03 ///< Port 3 Bit 3 Output Mode  
2045      =1  #define P3MDOUT_B3__OPEN_DRAIN 0x00 ///< P3.3 output is open-drain.
2046      =1  #define P3MDOUT_B3__PUSH_PULL  0x08 ///< P3.3 output is push-pull. 
2047      =1                                                                     
2048      =1  #define P3MDOUT_B4__BMASK      0x10 ///< Port 3 Bit 4 Output Mode  
2049      =1  #define P3MDOUT_B4__SHIFT      0x04 ///< Port 3 Bit 4 Output Mode  
2050      =1  #define P3MDOUT_B4__OPEN_DRAIN 0x00 ///< P3.4 output is open-drain.
2051      =1  #define P3MDOUT_B4__PUSH_PULL  0x10 ///< P3.4 output is push-pull. 
2052      =1                                                                     
2053      =1  #define P3MDOUT_B5__BMASK      0x20 ///< Port 3 Bit 5 Output Mode  
2054      =1  #define P3MDOUT_B5__SHIFT      0x05 ///< Port 3 Bit 5 Output Mode  
2055      =1  #define P3MDOUT_B5__OPEN_DRAIN 0x00 ///< P3.5 output is open-drain.
2056      =1  #define P3MDOUT_B5__PUSH_PULL  0x20 ///< P3.5 output is push-pull. 
2057      =1                                                                     
2058      =1  #define P3MDOUT_B6__BMASK      0x40 ///< Port 3 Bit 6 Output Mode  
2059      =1  #define P3MDOUT_B6__SHIFT      0x06 ///< Port 3 Bit 6 Output Mode  
2060      =1  #define P3MDOUT_B6__OPEN_DRAIN 0x00 ///< P3.6 output is open-drain.
2061      =1  #define P3MDOUT_B6__PUSH_PULL  0x40 ///< P3.6 output is push-pull. 
2062      =1                                                                     
2063      =1  #define P3MDOUT_B7__BMASK      0x80 ///< Port 3 Bit 7 Output Mode  
2064      =1  #define P3MDOUT_B7__SHIFT      0x07 ///< Port 3 Bit 7 Output Mode  
2065      =1  #define P3MDOUT_B7__OPEN_DRAIN 0x00 ///< P3.7 output is open-drain.
2066      =1  #define P3MDOUT_B7__PUSH_PULL  0x80 ///< P3.7 output is push-pull. 
2067      =1                                                                     
2068      =1  //------------------------------------------------------------------------------
C51 COMPILER V9.56.0.0   SPI_0                                                             10/28/2016 17:37:02 PAGE 60  

2069      =1  // P3SKIP Enums (Port 3 Skip @ 0xDF)
2070      =1  //------------------------------------------------------------------------------
2071      =1  #define P3SKIP_B0__BMASK       0x01 ///< Port 3 Bit 0 Skip                       
2072      =1  #define P3SKIP_B0__SHIFT       0x00 ///< Port 3 Bit 0 Skip                       
2073      =1  #define P3SKIP_B0__NOT_SKIPPED 0x00 ///< P3.0 pin is not skipped by the crossbar.
2074      =1  #define P3SKIP_B0__SKIPPED     0x01 ///< P3.0 pin is skipped by the crossbar.    
2075      =1                                                                                   
2076      =1  #define P3SKIP_B1__BMASK       0x02 ///< Port 3 Bit 1 Skip                       
2077      =1  #define P3SKIP_B1__SHIFT       0x01 ///< Port 3 Bit 1 Skip                       
2078      =1  #define P3SKIP_B1__NOT_SKIPPED 0x00 ///< P3.1 pin is not skipped by the crossbar.
2079      =1  #define P3SKIP_B1__SKIPPED     0x02 ///< P3.1 pin is skipped by the crossbar.    
2080      =1                                                                                   
2081      =1  #define P3SKIP_B2__BMASK       0x04 ///< Port 3 Bit 2 Skip                       
2082      =1  #define P3SKIP_B2__SHIFT       0x02 ///< Port 3 Bit 2 Skip                       
2083      =1  #define P3SKIP_B2__NOT_SKIPPED 0x00 ///< P3.2 pin is not skipped by the crossbar.
2084      =1  #define P3SKIP_B2__SKIPPED     0x04 ///< P3.2 pin is skipped by the crossbar.    
2085      =1                                                                                   
2086      =1  #define P3SKIP_B3__BMASK       0x08 ///< Port 3 Bit 3 Skip                       
2087      =1  #define P3SKIP_B3__SHIFT       0x03 ///< Port 3 Bit 3 Skip                       
2088      =1  #define P3SKIP_B3__NOT_SKIPPED 0x00 ///< P3.3 pin is not skipped by the crossbar.
2089      =1  #define P3SKIP_B3__SKIPPED     0x08 ///< P3.3 pin is skipped by the crossbar.    
2090      =1                                                                                   
2091      =1  #define P3SKIP_B4__BMASK       0x10 ///< Port 3 Bit 4 Skip                       
2092      =1  #define P3SKIP_B4__SHIFT       0x04 ///< Port 3 Bit 4 Skip                       
2093      =1  #define P3SKIP_B4__NOT_SKIPPED 0x00 ///< P3.4 pin is not skipped by the crossbar.
2094      =1  #define P3SKIP_B4__SKIPPED     0x10 ///< P3.4 pin is skipped by the crossbar.    
2095      =1                                                                                   
2096      =1  #define P3SKIP_B5__BMASK       0x20 ///< Port 3 Bit 5 Skip                       
2097      =1  #define P3SKIP_B5__SHIFT       0x05 ///< Port 3 Bit 5 Skip                       
2098      =1  #define P3SKIP_B5__NOT_SKIPPED 0x00 ///< P3.5 pin is not skipped by the crossbar.
2099      =1  #define P3SKIP_B5__SKIPPED     0x20 ///< P3.5 pin is skipped by the crossbar.    
2100      =1                                                                                   
2101      =1  #define P3SKIP_B6__BMASK       0x40 ///< Port 3 Bit 6 Skip                       
2102      =1  #define P3SKIP_B6__SHIFT       0x06 ///< Port 3 Bit 6 Skip                       
2103      =1  #define P3SKIP_B6__NOT_SKIPPED 0x00 ///< P3.6 pin is not skipped by the crossbar.
2104      =1  #define P3SKIP_B6__SKIPPED     0x40 ///< P3.6 pin is skipped by the crossbar.    
2105      =1                                                                                   
2106      =1  #define P3SKIP_B7__BMASK       0x80 ///< Port 3 Bit 7 Skip                       
2107      =1  #define P3SKIP_B7__SHIFT       0x07 ///< Port 3 Bit 7 Skip                       
2108      =1  #define P3SKIP_B7__NOT_SKIPPED 0x00 ///< P3.7 pin is not skipped by the crossbar.
2109      =1  #define P3SKIP_B7__SKIPPED     0x80 ///< P3.7 pin is skipped by the crossbar.    
2110      =1                                                                                   
2111      =1  //------------------------------------------------------------------------------
2112      =1  // P4 Enums (Port 4 Pin Latch @ 0xC7)
2113      =1  //------------------------------------------------------------------------------
2114      =1  #define P4_B0__BMASK 0x01 ///< Port 4 Bit 0 Latch                            
2115      =1  #define P4_B0__SHIFT 0x00 ///< Port 4 Bit 0 Latch                            
2116      =1  #define P4_B0__LOW   0x00 ///< P4.0 is low. Set P4.0 to drive low.           
2117      =1  #define P4_B0__HIGH  0x01 ///< P4.0 is high. Set P4.0 to drive or float high.
2118      =1                                                                               
2119      =1  #define P4_B1__BMASK 0x02 ///< Port 4 Bit 1 Latch                            
2120      =1  #define P4_B1__SHIFT 0x01 ///< Port 4 Bit 1 Latch                            
2121      =1  #define P4_B1__LOW   0x00 ///< P4.1 is low. Set P4.1 to drive low.           
2122      =1  #define P4_B1__HIGH  0x02 ///< P4.1 is high. Set P4.1 to drive or float high.
2123      =1                                                                               
2124      =1  #define P4_B2__BMASK 0x04 ///< Port 4 Bit 2 Latch                            
2125      =1  #define P4_B2__SHIFT 0x02 ///< Port 4 Bit 2 Latch                            
2126      =1  #define P4_B2__LOW   0x00 ///< P4.2 is low. Set P4.2 to drive low.           
2127      =1  #define P4_B2__HIGH  0x04 ///< P4.2 is high. Set P4.2 to drive or float high.
2128      =1                                                                               
2129      =1  #define P4_B3__BMASK 0x08 ///< Port 4 Bit 3 Latch                            
2130      =1  #define P4_B3__SHIFT 0x03 ///< Port 4 Bit 3 Latch                            
C51 COMPILER V9.56.0.0   SPI_0                                                             10/28/2016 17:37:02 PAGE 61  

2131      =1  #define P4_B3__LOW   0x00 ///< P4.3 is low. Set P4.3 to drive low.           
2132      =1  #define P4_B3__HIGH  0x08 ///< P4.3 is high. Set P4.3 to drive or float high.
2133      =1                                                                               
2134      =1  #define P4_B4__BMASK 0x10 ///< Port 4 Bit 4 Latch                            
2135      =1  #define P4_B4__SHIFT 0x04 ///< Port 4 Bit 4 Latch                            
2136      =1  #define P4_B4__LOW   0x00 ///< P4.4 is low. Set P4.4 to drive low.           
2137      =1  #define P4_B4__HIGH  0x10 ///< P4.4 is high. Set P4.4 to drive or float high.
2138      =1                                                                               
2139      =1  #define P4_B5__BMASK 0x20 ///< Port 4 Bit 5 Latch                            
2140      =1  #define P4_B5__SHIFT 0x05 ///< Port 4 Bit 5 Latch                            
2141      =1  #define P4_B5__LOW   0x00 ///< P4.5 is low. Set P4.5 to drive low.           
2142      =1  #define P4_B5__HIGH  0x20 ///< P4.5 is high. Set P4.5 to drive or float high.
2143      =1                                                                               
2144      =1  #define P4_B6__BMASK 0x40 ///< Port 4 Bit 6 Latch                            
2145      =1  #define P4_B6__SHIFT 0x06 ///< Port 4 Bit 6 Latch                            
2146      =1  #define P4_B6__LOW   0x00 ///< P4.6 is low. Set P4.6 to drive low.           
2147      =1  #define P4_B6__HIGH  0x40 ///< P4.6 is high. Set P4.6 to drive or float high.
2148      =1                                                                               
2149      =1  #define P4_B7__BMASK 0x80 ///< Port 4 Bit 7 Latch                            
2150      =1  #define P4_B7__SHIFT 0x07 ///< Port 4 Bit 7 Latch                            
2151      =1  #define P4_B7__LOW   0x00 ///< P4.7 is low. Set P4.7 to drive low.           
2152      =1  #define P4_B7__HIGH  0x80 ///< P4.7 is high. Set P4.7 to drive or float high.
2153      =1                                                                               
2154      =1  //------------------------------------------------------------------------------
2155      =1  // P4MDIN Enums (Port 4 Input Mode @ 0xF5)
2156      =1  //------------------------------------------------------------------------------
2157      =1  #define P4MDIN_B0__BMASK   0x01 ///< Port 4 Bit 0 Input Mode                 
2158      =1  #define P4MDIN_B0__SHIFT   0x00 ///< Port 4 Bit 0 Input Mode                 
2159      =1  #define P4MDIN_B0__ANALOG  0x00 ///< P4.0 pin is configured for analog mode. 
2160      =1  #define P4MDIN_B0__DIGITAL 0x01 ///< P4.0 pin is configured for digital mode.
2161      =1                                                                               
2162      =1  #define P4MDIN_B1__BMASK   0x02 ///< Port 4 Bit 1 Input Mode                 
2163      =1  #define P4MDIN_B1__SHIFT   0x01 ///< Port 4 Bit 1 Input Mode                 
2164      =1  #define P4MDIN_B1__ANALOG  0x00 ///< P4.1 pin is configured for analog mode. 
2165      =1  #define P4MDIN_B1__DIGITAL 0x02 ///< P4.1 pin is configured for digital mode.
2166      =1                                                                               
2167      =1  #define P4MDIN_B2__BMASK   0x04 ///< Port 4 Bit 2 Input Mode                 
2168      =1  #define P4MDIN_B2__SHIFT   0x02 ///< Port 4 Bit 2 Input Mode                 
2169      =1  #define P4MDIN_B2__ANALOG  0x00 ///< P4.2 pin is configured for analog mode. 
2170      =1  #define P4MDIN_B2__DIGITAL 0x04 ///< P4.2 pin is configured for digital mode.
2171      =1                                                                               
2172      =1  #define P4MDIN_B3__BMASK   0x08 ///< Port 4 Bit 3 Input Mode                 
2173      =1  #define P4MDIN_B3__SHIFT   0x03 ///< Port 4 Bit 3 Input Mode                 
2174      =1  #define P4MDIN_B3__ANALOG  0x00 ///< P4.3 pin is configured for analog mode. 
2175      =1  #define P4MDIN_B3__DIGITAL 0x08 ///< P4.3 pin is configured for digital mode.
2176      =1                                                                               
2177      =1  #define P4MDIN_B4__BMASK   0x10 ///< Port 4 Bit 4 Input Mode                 
2178      =1  #define P4MDIN_B4__SHIFT   0x04 ///< Port 4 Bit 4 Input Mode                 
2179      =1  #define P4MDIN_B4__ANALOG  0x00 ///< P4.4 pin is configured for analog mode. 
2180      =1  #define P4MDIN_B4__DIGITAL 0x10 ///< P4.4 pin is configured for digital mode.
2181      =1                                                                               
2182      =1  #define P4MDIN_B5__BMASK   0x20 ///< Port 4 Bit 5 Input Mode                 
2183      =1  #define P4MDIN_B5__SHIFT   0x05 ///< Port 4 Bit 5 Input Mode                 
2184      =1  #define P4MDIN_B5__ANALOG  0x00 ///< P4.5 pin is configured for analog mode. 
2185      =1  #define P4MDIN_B5__DIGITAL 0x20 ///< P4.5 pin is configured for digital mode.
2186      =1                                                                               
2187      =1  #define P4MDIN_B6__BMASK   0x40 ///< Port 4 Bit 6 Input Mode                 
2188      =1  #define P4MDIN_B6__SHIFT   0x06 ///< Port 4 Bit 6 Input Mode                 
2189      =1  #define P4MDIN_B6__ANALOG  0x00 ///< P4.6 pin is configured for analog mode. 
2190      =1  #define P4MDIN_B6__DIGITAL 0x40 ///< P4.6 pin is configured for digital mode.
2191      =1                                                                               
2192      =1  #define P4MDIN_B7__BMASK   0x80 ///< Port 4 Bit 7 Input Mode                 
C51 COMPILER V9.56.0.0   SPI_0                                                             10/28/2016 17:37:02 PAGE 62  

2193      =1  #define P4MDIN_B7__SHIFT   0x07 ///< Port 4 Bit 7 Input Mode                 
2194      =1  #define P4MDIN_B7__ANALOG  0x00 ///< P4.7 pin is configured for analog mode. 
2195      =1  #define P4MDIN_B7__DIGITAL 0x80 ///< P4.7 pin is configured for digital mode.
2196      =1                                                                               
2197      =1  //------------------------------------------------------------------------------
2198      =1  // P4MDOUT Enums (Port 4 Output Mode @ 0xAE)
2199      =1  //------------------------------------------------------------------------------
2200      =1  #define P4MDOUT_B0__BMASK      0x01 ///< Port 4 Bit 0 Output Mode  
2201      =1  #define P4MDOUT_B0__SHIFT      0x00 ///< Port 4 Bit 0 Output Mode  
2202      =1  #define P4MDOUT_B0__OPEN_DRAIN 0x00 ///< P4.0 output is open-drain.
2203      =1  #define P4MDOUT_B0__PUSH_PULL  0x01 ///< P4.0 output is push-pull. 
2204      =1                                                                     
2205      =1  #define P4MDOUT_B1__BMASK      0x02 ///< Port 4 Bit 1 Output Mode  
2206      =1  #define P4MDOUT_B1__SHIFT      0x01 ///< Port 4 Bit 1 Output Mode  
2207      =1  #define P4MDOUT_B1__OPEN_DRAIN 0x00 ///< P4.1 output is open-drain.
2208      =1  #define P4MDOUT_B1__PUSH_PULL  0x02 ///< P4.1 output is push-pull. 
2209      =1                                                                     
2210      =1  #define P4MDOUT_B2__BMASK      0x04 ///< Port 4 Bit 2 Output Mode  
2211      =1  #define P4MDOUT_B2__SHIFT      0x02 ///< Port 4 Bit 2 Output Mode  
2212      =1  #define P4MDOUT_B2__OPEN_DRAIN 0x00 ///< P4.2 output is open-drain.
2213      =1  #define P4MDOUT_B2__PUSH_PULL  0x04 ///< P4.2 output is push-pull. 
2214      =1                                                                     
2215      =1  #define P4MDOUT_B3__BMASK      0x08 ///< Port 4 Bit 3 Output Mode  
2216      =1  #define P4MDOUT_B3__SHIFT      0x03 ///< Port 4 Bit 3 Output Mode  
2217      =1  #define P4MDOUT_B3__OPEN_DRAIN 0x00 ///< P4.3 output is open-drain.
2218      =1  #define P4MDOUT_B3__PUSH_PULL  0x08 ///< P4.3 output is push-pull. 
2219      =1                                                                     
2220      =1  #define P4MDOUT_B4__BMASK      0x10 ///< Port 4 Bit 4 Output Mode  
2221      =1  #define P4MDOUT_B4__SHIFT      0x04 ///< Port 4 Bit 4 Output Mode  
2222      =1  #define P4MDOUT_B4__OPEN_DRAIN 0x00 ///< P4.4 output is open-drain.
2223      =1  #define P4MDOUT_B4__PUSH_PULL  0x10 ///< P4.4 output is push-pull. 
2224      =1                                                                     
2225      =1  #define P4MDOUT_B5__BMASK      0x20 ///< Port 4 Bit 5 Output Mode  
2226      =1  #define P4MDOUT_B5__SHIFT      0x05 ///< Port 4 Bit 5 Output Mode  
2227      =1  #define P4MDOUT_B5__OPEN_DRAIN 0x00 ///< P4.5 output is open-drain.
2228      =1  #define P4MDOUT_B5__PUSH_PULL  0x20 ///< P4.5 output is push-pull. 
2229      =1                                                                     
2230      =1  #define P4MDOUT_B6__BMASK      0x40 ///< Port 4 Bit 6 Output Mode  
2231      =1  #define P4MDOUT_B6__SHIFT      0x06 ///< Port 4 Bit 6 Output Mode  
2232      =1  #define P4MDOUT_B6__OPEN_DRAIN 0x00 ///< P4.6 output is open-drain.
2233      =1  #define P4MDOUT_B6__PUSH_PULL  0x40 ///< P4.6 output is push-pull. 
2234      =1                                                                     
2235      =1  #define P4MDOUT_B7__BMASK      0x80 ///< Port 4 Bit 7 Output Mode  
2236      =1  #define P4MDOUT_B7__SHIFT      0x07 ///< Port 4 Bit 7 Output Mode  
2237      =1  #define P4MDOUT_B7__OPEN_DRAIN 0x00 ///< P4.7 output is open-drain.
2238      =1  #define P4MDOUT_B7__PUSH_PULL  0x80 ///< P4.7 output is push-pull. 
2239      =1                                                                     
2240      =1  //------------------------------------------------------------------------------
2241      =1  // RSTSRC Enums (Reset Source @ 0xEF)
2242      =1  //------------------------------------------------------------------------------
2243      =1  #define RSTSRC_PINRSF__BMASK   0x01 ///< HW Pin Reset Flag                                                
             -    
2244      =1  #define RSTSRC_PINRSF__SHIFT   0x00 ///< HW Pin Reset Flag                                                
             -    
2245      =1  #define RSTSRC_PINRSF__NOT_SET 0x00 ///< The RSTb pin did not cause the last reset.                       
             -    
2246      =1  #define RSTSRC_PINRSF__SET     0x01 ///< The RSTb pin caused the last reset.                              
             -    
2247      =1                                                                                                            
             -    
2248      =1  #define RSTSRC_PORSF__BMASK    0x02 ///< Power-On / Supply Monitor Reset Flag, and Supply Monitor Reset En
             -able
C51 COMPILER V9.56.0.0   SPI_0                                                             10/28/2016 17:37:02 PAGE 63  

2249      =1  #define RSTSRC_PORSF__SHIFT    0x01 ///< Power-On / Supply Monitor Reset Flag, and Supply Monitor Reset En
             -able
2250      =1  #define RSTSRC_PORSF__NOT_SET  0x00 ///< A power-on or supply monitor reset did not occur.                
             -    
2251      =1  #define RSTSRC_PORSF__SET      0x02 ///< A power-on or supply monitor reset occurred.                     
             -    
2252      =1                                                                                                            
             -    
2253      =1  #define RSTSRC_MCDRSF__BMASK   0x04 ///< Missing Clock Detector Enable and Flag                           
             -    
2254      =1  #define RSTSRC_MCDRSF__SHIFT   0x02 ///< Missing Clock Detector Enable and Flag                           
             -    
2255      =1  #define RSTSRC_MCDRSF__NOT_SET 0x00 ///< A missing clock detector reset did not occur.                    
             -    
2256      =1  #define RSTSRC_MCDRSF__SET     0x04 ///< A missing clock detector reset occurred.                         
             -    
2257      =1                                                                                                            
             -    
2258      =1  #define RSTSRC_WDTRSF__BMASK   0x08 ///< Watchdog Timer Reset Flag                                        
             -    
2259      =1  #define RSTSRC_WDTRSF__SHIFT   0x03 ///< Watchdog Timer Reset Flag                                        
             -    
2260      =1  #define RSTSRC_WDTRSF__NOT_SET 0x00 ///< A watchdog timer overflow reset did not occur.                   
             -    
2261      =1  #define RSTSRC_WDTRSF__SET     0x08 ///< A watchdog timer overflow reset occurred.                        
             -    
2262      =1                                                                                                            
             -    
2263      =1  #define RSTSRC_SWRSF__BMASK    0x10 ///< Software Reset Force and Flag                                    
             -    
2264      =1  #define RSTSRC_SWRSF__SHIFT    0x04 ///< Software Reset Force and Flag                                    
             -    
2265      =1  #define RSTSRC_SWRSF__NOT_SET  0x00 ///< A software reset did not occur.                                  
             -    
2266      =1  #define RSTSRC_SWRSF__SET      0x10 ///< A software reset occurred.                                       
             -    
2267      =1                                                                                                            
             -    
2268      =1  #define RSTSRC_C0RSEF__BMASK   0x20 ///< Comparator0 Reset Enable and Flag                                
             -    
2269      =1  #define RSTSRC_C0RSEF__SHIFT   0x05 ///< Comparator0 Reset Enable and Flag                                
             -    
2270      =1  #define RSTSRC_C0RSEF__NOT_SET 0x00 ///< A Comparator 0 reset did not occur.                              
             -    
2271      =1  #define RSTSRC_C0RSEF__SET     0x20 ///< A Comparator 0 reset occurred.                                   
             -    
2272      =1                                                                                                            
             -    
2273      =1  #define RSTSRC_FERROR__BMASK   0x40 ///< Flash Error Reset Flag                                           
             -    
2274      =1  #define RSTSRC_FERROR__SHIFT   0x06 ///< Flash Error Reset Flag                                           
             -    
2275      =1  #define RSTSRC_FERROR__NOT_SET 0x00 ///< A flash error reset did not occur.                               
             -    
2276      =1  #define RSTSRC_FERROR__SET     0x40 ///< A flash error reset occurred.                                    
             -    
2277      =1                                                                                                            
             -    
2278      =1  #define RSTSRC_USBRSF__BMASK   0x80 ///< USB Reset Enable and Flag                                        
             -    
2279      =1  #define RSTSRC_USBRSF__SHIFT   0x07 ///< USB Reset Enable and Flag                                        
             -    
C51 COMPILER V9.56.0.0   SPI_0                                                             10/28/2016 17:37:02 PAGE 64  

2280      =1  #define RSTSRC_USBRSF__NOT_SET 0x00 ///< A USB0 reset did not occur.                                      
             -    
2281      =1  #define RSTSRC_USBRSF__SET     0x80 ///< A USB0 reset occurred.                                           
             -    
2282      =1                                                                                                            
             -    
2283      =1  //------------------------------------------------------------------------------
2284      =1  // SFRPAGE Enums (SFR Page @ 0xBF)
2285      =1  //------------------------------------------------------------------------------
2286      =1  #define SFRPAGE_SFRPAGE__FMASK 0xFF ///< SFR Page
2287      =1  #define SFRPAGE_SFRPAGE__SHIFT 0x00 ///< SFR Page
2288      =1                                                   
2289      =1  //------------------------------------------------------------------------------
2290      =1  // SMB0ADM Enums (SMBus 0 Slave Address Mask @ 0xCE)
2291      =1  //------------------------------------------------------------------------------
2292      =1  #define SMB0ADM_EHACK__BMASK             0x01 ///< Hardware Acknowledge Enable                     
2293      =1  #define SMB0ADM_EHACK__SHIFT             0x00 ///< Hardware Acknowledge Enable                     
2294      =1  #define SMB0ADM_EHACK__ADR_ACK_MANUAL    0x00 ///< Firmware must manually acknowledge all incoming 
2295      =1                                                ///< address and data bytes.                         
2296      =1  #define SMB0ADM_EHACK__ADR_ACK_AUTOMATIC 0x01 ///< Automatic slave address recognition and hardware
2297      =1                                                ///< acknowledge is enabled.                         
2298      =1                                                                                                     
2299      =1  #define SMB0ADM_SLVM__FMASK              0xFE ///< SMBus Slave Address Mask                        
2300      =1  #define SMB0ADM_SLVM__SHIFT              0x01 ///< SMBus Slave Address Mask                        
2301      =1                                                                                                     
2302      =1  //------------------------------------------------------------------------------
2303      =1  // SMB0ADR Enums (SMBus 0 Slave Address @ 0xCF)
2304      =1  //------------------------------------------------------------------------------
2305      =1  #define SMB0ADR_GC__BMASK      0x01 ///< General Call Address Enable        
2306      =1  #define SMB0ADR_GC__SHIFT      0x00 ///< General Call Address Enable        
2307      =1  #define SMB0ADR_GC__IGNORED    0x00 ///< General Call Address is ignored.   
2308      =1  #define SMB0ADR_GC__RECOGNIZED 0x01 ///< General Call Address is recognized.
2309      =1                                                                              
2310      =1  #define SMB0ADR_SLV__FMASK     0xFE ///< SMBus Hardware Slave Address       
2311      =1  #define SMB0ADR_SLV__SHIFT     0x01 ///< SMBus Hardware Slave Address       
2312      =1                                                                              
2313      =1  //------------------------------------------------------------------------------
2314      =1  // SMB0CF Enums (SMBus 0 Configuration @ 0xC1)
2315      =1  //------------------------------------------------------------------------------
2316      =1  #define SMB0CF_SMBCS__FMASK             0x03 ///< SMBus Clock Source Selection                     
2317      =1  #define SMB0CF_SMBCS__SHIFT             0x00 ///< SMBus Clock Source Selection                     
2318      =1  #define SMB0CF_SMBCS__TIMER0            0x00 ///< Timer 0 Overflow.                                
2319      =1  #define SMB0CF_SMBCS__TIMER1            0x01 ///< Timer 1 Overflow.                                
2320      =1  #define SMB0CF_SMBCS__TIMER2_HIGH       0x02 ///< Timer 2 High Byte Overflow.                      
2321      =1  #define SMB0CF_SMBCS__TIMER2_LOW        0x03 ///< Timer 2 Low Byte Overflow.                       
2322      =1                                                                                                     
2323      =1  #define SMB0CF_SMBFTE__BMASK            0x04 ///< SMBus Free Timeout Detection Enable              
2324      =1  #define SMB0CF_SMBFTE__SHIFT            0x02 ///< SMBus Free Timeout Detection Enable              
2325      =1  #define SMB0CF_SMBFTE__FREE_TO_DISABLED 0x00 ///< Disable bus free timeouts.                       
2326      =1  #define SMB0CF_SMBFTE__FREE_TO_ENABLED  0x04 ///< Enable bus free timeouts. The bus the bus will be
2327      =1                                               ///< considered free if SCL and SDA remain high for   
2328      =1                                               ///< more than 10 SMBus clock source periods.         
2329      =1                                                                                                     
2330      =1  #define SMB0CF_SMBTOE__BMASK            0x08 ///< SMBus SCL Timeout Detection Enable               
2331      =1  #define SMB0CF_SMBTOE__SHIFT            0x03 ///< SMBus SCL Timeout Detection Enable               
2332      =1  #define SMB0CF_SMBTOE__SCL_TO_DISABLED  0x00 ///< Disable SCL low timeouts.                        
2333      =1  #define SMB0CF_SMBTOE__SCL_TO_ENABLED   0x08 ///< Enable SCL low timeouts.                         
2334      =1                                                                                                     
2335      =1  #define SMB0CF_EXTHOLD__BMASK           0x10 ///< SMBus Setup and Hold Time Extension Enable       
2336      =1  #define SMB0CF_EXTHOLD__SHIFT           0x04 ///< SMBus Setup and Hold Time Extension Enable       
2337      =1  #define SMB0CF_EXTHOLD__DISABLED        0x00 ///< Disable SDA extended setup and hold times.       
2338      =1  #define SMB0CF_EXTHOLD__ENABLED         0x10 ///< Enable SDA extended setup and hold times.        
C51 COMPILER V9.56.0.0   SPI_0                                                             10/28/2016 17:37:02 PAGE 65  

2339      =1                                                                                                     
2340      =1  #define SMB0CF_BUSY__BMASK              0x20 ///< SMBus Busy Indicator                             
2341      =1  #define SMB0CF_BUSY__SHIFT              0x05 ///< SMBus Busy Indicator                             
2342      =1  #define SMB0CF_BUSY__NOT_SET            0x00 ///< The bus is not busy.                             
2343      =1  #define SMB0CF_BUSY__SET                0x20 ///< The bus is busy and a transfer is currently in   
2344      =1                                               ///< progress.                                        
2345      =1                                                                                                     
2346      =1  #define SMB0CF_INH__BMASK               0x40 ///< SMBus Slave Inhibit                              
2347      =1  #define SMB0CF_INH__SHIFT               0x06 ///< SMBus Slave Inhibit                              
2348      =1  #define SMB0CF_INH__SLAVE_ENABLED       0x00 ///< Slave states are enabled.                        
2349      =1  #define SMB0CF_INH__SLAVE_DISABLED      0x40 ///< Slave states are inhibited.                      
2350      =1                                                                                                     
2351      =1  #define SMB0CF_ENSMB__BMASK             0x80 ///< SMBus Enable                                     
2352      =1  #define SMB0CF_ENSMB__SHIFT             0x07 ///< SMBus Enable                                     
2353      =1  #define SMB0CF_ENSMB__DISABLED          0x00 ///< Disable the SMBus module.                        
2354      =1  #define SMB0CF_ENSMB__ENABLED           0x80 ///< Enable the SMBus module.                         
2355      =1                                                                                                     
2356      =1  //------------------------------------------------------------------------------
2357      =1  // SMB0CN0 Enums (SMBus 0 Control @ 0xC0)
2358      =1  //------------------------------------------------------------------------------
2359      =1  #define SMB0CN0_SI__BMASK           0x01 ///< SMBus Interrupt Flag                           
2360      =1  #define SMB0CN0_SI__SHIFT           0x00 ///< SMBus Interrupt Flag                           
2361      =1  #define SMB0CN0_SI__NOT_SET         0x00 ///<                                                
2362      =1  #define SMB0CN0_SI__SET             0x01 ///<                                                
2363      =1                                                                                               
2364      =1  #define SMB0CN0_ACK__BMASK          0x02 ///< SMBus Acknowledge                              
2365      =1  #define SMB0CN0_ACK__SHIFT          0x01 ///< SMBus Acknowledge                              
2366      =1  #define SMB0CN0_ACK__NOT_SET        0x00 ///< Generate a NACK, or the response was a NACK.   
2367      =1  #define SMB0CN0_ACK__SET            0x02 ///< Generate an ACK, or the response was an ACK.   
2368      =1                                                                                               
2369      =1  #define SMB0CN0_ARBLOST__BMASK      0x04 ///< SMBus Arbitration Lost Indicator               
2370      =1  #define SMB0CN0_ARBLOST__SHIFT      0x02 ///< SMBus Arbitration Lost Indicator               
2371      =1  #define SMB0CN0_ARBLOST__NOT_SET    0x00 ///< No arbitration error.                          
2372      =1  #define SMB0CN0_ARBLOST__ERROR      0x04 ///< Arbitration error occurred.                    
2373      =1                                                                                               
2374      =1  #define SMB0CN0_ACKRQ__BMASK        0x08 ///< SMBus Acknowledge Request                      
2375      =1  #define SMB0CN0_ACKRQ__SHIFT        0x03 ///< SMBus Acknowledge Request                      
2376      =1  #define SMB0CN0_ACKRQ__NOT_SET      0x00 ///< No ACK requested.                              
2377      =1  #define SMB0CN0_ACKRQ__REQUESTED    0x08 ///< ACK requested.                                 
2378      =1                                                                                               
2379      =1  #define SMB0CN0_STO__BMASK          0x10 ///< SMBus Stop Flag                                
2380      =1  #define SMB0CN0_STO__SHIFT          0x04 ///< SMBus Stop Flag                                
2381      =1  #define SMB0CN0_STO__NOT_SET        0x00 ///< A STOP is not pending.                         
2382      =1  #define SMB0CN0_STO__SET            0x10 ///< Generate a STOP or a STOP is currently pending.
2383      =1                                                                                               
2384      =1  #define SMB0CN0_STA__BMASK          0x20 ///< SMBus Start Flag                               
2385      =1  #define SMB0CN0_STA__SHIFT          0x05 ///< SMBus Start Flag                               
2386      =1  #define SMB0CN0_STA__NOT_SET        0x00 ///< A START was not detected.                      
2387      =1  #define SMB0CN0_STA__SET            0x20 ///< Generate a START, repeated START, or a START is
2388      =1                                           ///< currently pending.                             
2389      =1                                                                                               
2390      =1  #define SMB0CN0_TXMODE__BMASK       0x40 ///< SMBus Transmit Mode Indicator                  
2391      =1  #define SMB0CN0_TXMODE__SHIFT       0x06 ///< SMBus Transmit Mode Indicator                  
2392      =1  #define SMB0CN0_TXMODE__RECEIVER    0x00 ///< SMBus in Receiver Mode.                        
2393      =1  #define SMB0CN0_TXMODE__TRANSMITTER 0x40 ///< SMBus in Transmitter Mode.                     
2394      =1                                                                                               
2395      =1  #define SMB0CN0_MASTER__BMASK       0x80 ///< SMBus Master/Slave Indicator                   
2396      =1  #define SMB0CN0_MASTER__SHIFT       0x07 ///< SMBus Master/Slave Indicator                   
2397      =1  #define SMB0CN0_MASTER__SLAVE       0x00 ///< SMBus operating in slave mode.                 
2398      =1  #define SMB0CN0_MASTER__MASTER      0x80 ///< SMBus operating in master mode.                
2399      =1                                                                                               
2400      =1  //------------------------------------------------------------------------------
C51 COMPILER V9.56.0.0   SPI_0                                                             10/28/2016 17:37:02 PAGE 66  

2401      =1  // SMB0DAT Enums (SMBus 0 Data @ 0xC2)
2402      =1  //------------------------------------------------------------------------------
2403      =1  #define SMB0DAT_SMB0DAT__FMASK 0xFF ///< SMBus 0 Data
2404      =1  #define SMB0DAT_SMB0DAT__SHIFT 0x00 ///< SMBus 0 Data
2405      =1                                                       
2406      =1  //------------------------------------------------------------------------------
2407      =1  // SMB1ADM Enums (SMBus 1 Slave Address Mask @ 0xCE)
2408      =1  //------------------------------------------------------------------------------
2409      =1  #define SMB1ADM_EHACK__BMASK             0x01 ///< Hardware Acknowledge Enable                     
2410      =1  #define SMB1ADM_EHACK__SHIFT             0x00 ///< Hardware Acknowledge Enable                     
2411      =1  #define SMB1ADM_EHACK__ADR_ACK_MANUAL    0x00 ///< Firmware must manually acknowledge all incoming 
2412      =1                                                ///< address and data bytes.                         
2413      =1  #define SMB1ADM_EHACK__ADR_ACK_AUTOMATIC 0x01 ///< Automatic slave address recognition and hardware
2414      =1                                                ///< acknowledge is enabled.                         
2415      =1                                                                                                     
2416      =1  #define SMB1ADM_SLVM__FMASK              0xFE ///< SMBus Slave Address Mask                        
2417      =1  #define SMB1ADM_SLVM__SHIFT              0x01 ///< SMBus Slave Address Mask                        
2418      =1                                                                                                     
2419      =1  //------------------------------------------------------------------------------
2420      =1  // SMB1ADR Enums (SMBus 1 Slave Address @ 0xCF)
2421      =1  //------------------------------------------------------------------------------
2422      =1  #define SMB1ADR_GC__BMASK      0x01 ///< General Call Address Enable        
2423      =1  #define SMB1ADR_GC__SHIFT      0x00 ///< General Call Address Enable        
2424      =1  #define SMB1ADR_GC__IGNORED    0x00 ///< General Call Address is ignored.   
2425      =1  #define SMB1ADR_GC__RECOGNIZED 0x01 ///< General Call Address is recognized.
2426      =1                                                                              
2427      =1  #define SMB1ADR_SLV__FMASK     0xFE ///< SMBus Hardware Slave Address       
2428      =1  #define SMB1ADR_SLV__SHIFT     0x01 ///< SMBus Hardware Slave Address       
2429      =1                                                                              
2430      =1  //------------------------------------------------------------------------------
2431      =1  // SMB1CF Enums (SMBus 1 Configuration @ 0xC1)
2432      =1  //------------------------------------------------------------------------------
2433      =1  #define SMB1CF_SMBCS__FMASK             0x03 ///< SMBus Clock Source Selection                     
2434      =1  #define SMB1CF_SMBCS__SHIFT             0x00 ///< SMBus Clock Source Selection                     
2435      =1  #define SMB1CF_SMBCS__TIMER0            0x00 ///< Timer 0 Overflow.                                
2436      =1  #define SMB1CF_SMBCS__TIMER5            0x01 ///< Timer 5 Overflow.                                
2437      =1  #define SMB1CF_SMBCS__TIMER2_HIGH       0x02 ///< Timer 2 High Byte Overflow.                      
2438      =1  #define SMB1CF_SMBCS__TIMER2_LOW        0x03 ///< Timer 2 Low Byte Overflow.                       
2439      =1                                                                                                     
2440      =1  #define SMB1CF_SMBFTE__BMASK            0x04 ///< SMBus Free Timeout Detection Enable              
2441      =1  #define SMB1CF_SMBFTE__SHIFT            0x02 ///< SMBus Free Timeout Detection Enable              
2442      =1  #define SMB1CF_SMBFTE__FREE_TO_DISABLED 0x00 ///< Disable bus free timeouts.                       
2443      =1  #define SMB1CF_SMBFTE__FREE_TO_ENABLED  0x04 ///< Enable bus free timeouts. The bus the bus will be
2444      =1                                               ///< considered free if SCL and SDA remain high for   
2445      =1                                               ///< more than 10 SMBus clock source periods.         
2446      =1                                                                                                     
2447      =1  #define SMB1CF_SMBTOE__BMASK            0x08 ///< SMBus SCL Timeout Detection Enable               
2448      =1  #define SMB1CF_SMBTOE__SHIFT            0x03 ///< SMBus SCL Timeout Detection Enable               
2449      =1  #define SMB1CF_SMBTOE__SCL_TO_DISABLED  0x00 ///< Disable SCL low timeouts.                        
2450      =1  #define SMB1CF_SMBTOE__SCL_TO_ENABLED   0x08 ///< Enable SCL low timeouts.                         
2451      =1                                                                                                     
2452      =1  #define SMB1CF_EXTHOLD__BMASK           0x10 ///< SMBus Setup and Hold Time Extension Enable       
2453      =1  #define SMB1CF_EXTHOLD__SHIFT           0x04 ///< SMBus Setup and Hold Time Extension Enable       
2454      =1  #define SMB1CF_EXTHOLD__DISABLED        0x00 ///< Disable SDA extended setup and hold times.       
2455      =1  #define SMB1CF_EXTHOLD__ENABLED         0x10 ///< Enable SDA extended setup and hold times.        
2456      =1                                                                                                     
2457      =1  #define SMB1CF_BUSY__BMASK              0x20 ///< SMBus Busy Indicator                             
2458      =1  #define SMB1CF_BUSY__SHIFT              0x05 ///< SMBus Busy Indicator                             
2459      =1  #define SMB1CF_BUSY__NOT_SET            0x00 ///< The bus is not busy.                             
2460      =1  #define SMB1CF_BUSY__SET                0x20 ///< The bus is busy and a transfer is currently in   
2461      =1                                               ///< progress.                                        
2462      =1                                                                                                     
C51 COMPILER V9.56.0.0   SPI_0                                                             10/28/2016 17:37:02 PAGE 67  

2463      =1  #define SMB1CF_INH__BMASK               0x40 ///< SMBus Slave Inhibit                              
2464      =1  #define SMB1CF_INH__SHIFT               0x06 ///< SMBus Slave Inhibit                              
2465      =1  #define SMB1CF_INH__SLAVE_ENABLED       0x00 ///< Slave states are enabled.                        
2466      =1  #define SMB1CF_INH__SLAVE_DISABLED      0x40 ///< Slave states are inhibited.                      
2467      =1                                                                                                     
2468      =1  #define SMB1CF_ENSMB__BMASK             0x80 ///< SMBus Enable                                     
2469      =1  #define SMB1CF_ENSMB__SHIFT             0x07 ///< SMBus Enable                                     
2470      =1  #define SMB1CF_ENSMB__DISABLED          0x00 ///< Disable the SMBus module.                        
2471      =1  #define SMB1CF_ENSMB__ENABLED           0x80 ///< Enable the SMBus module.                         
2472      =1                                                                                                     
2473      =1  //------------------------------------------------------------------------------
2474      =1  // SMB1CN0 Enums (SMBus 1 Control @ 0xC0)
2475      =1  //------------------------------------------------------------------------------
2476      =1  #define SMB1CN0_SI__BMASK           0x01 ///< SMBus Interrupt Flag                           
2477      =1  #define SMB1CN0_SI__SHIFT           0x00 ///< SMBus Interrupt Flag                           
2478      =1  #define SMB1CN0_SI__NOT_SET         0x00 ///<                                                
2479      =1  #define SMB1CN0_SI__SET             0x01 ///<                                                
2480      =1                                                                                               
2481      =1  #define SMB1CN0_ACK__BMASK          0x02 ///< SMBus Acknowledge                              
2482      =1  #define SMB1CN0_ACK__SHIFT          0x01 ///< SMBus Acknowledge                              
2483      =1  #define SMB1CN0_ACK__NOT_SET        0x00 ///< Generate a NACK, or the response was a NACK.   
2484      =1  #define SMB1CN0_ACK__SET            0x02 ///< Generate an ACK, or the response was an ACK.   
2485      =1                                                                                               
2486      =1  #define SMB1CN0_ARBLOST__BMASK      0x04 ///< SMBus Arbitration Lost Indicator               
2487      =1  #define SMB1CN0_ARBLOST__SHIFT      0x02 ///< SMBus Arbitration Lost Indicator               
2488      =1  #define SMB1CN0_ARBLOST__NOT_SET    0x00 ///< No arbitration error.                          
2489      =1  #define SMB1CN0_ARBLOST__ERROR      0x04 ///< Arbitration error occurred.                    
2490      =1                                                                                               
2491      =1  #define SMB1CN0_ACKRQ__BMASK        0x08 ///< SMBus Acknowledge Request                      
2492      =1  #define SMB1CN0_ACKRQ__SHIFT        0x03 ///< SMBus Acknowledge Request                      
2493      =1  #define SMB1CN0_ACKRQ__NOT_SET      0x00 ///< No ACK requested.                              
2494      =1  #define SMB1CN0_ACKRQ__REQUESTED    0x08 ///< ACK requested.                                 
2495      =1                                                                                               
2496      =1  #define SMB1CN0_STO__BMASK          0x10 ///< SMBus Stop Flag                                
2497      =1  #define SMB1CN0_STO__SHIFT          0x04 ///< SMBus Stop Flag                                
2498      =1  #define SMB1CN0_STO__NOT_SET        0x00 ///< A STOP is not pending.                         
2499      =1  #define SMB1CN0_STO__SET            0x10 ///< Generate a STOP or a STOP is currently pending.
2500      =1                                                                                               
2501      =1  #define SMB1CN0_STA__BMASK          0x20 ///< SMBus Start Flag                               
2502      =1  #define SMB1CN0_STA__SHIFT          0x05 ///< SMBus Start Flag                               
2503      =1  #define SMB1CN0_STA__NOT_SET        0x00 ///< A START was not detected.                      
2504      =1  #define SMB1CN0_STA__SET            0x20 ///< Generate a START, repeated START, or a START is
2505      =1                                           ///< currently pending.                             
2506      =1                                                                                               
2507      =1  #define SMB1CN0_TXMODE__BMASK       0x40 ///< SMBus Transmit Mode Indicator                  
2508      =1  #define SMB1CN0_TXMODE__SHIFT       0x06 ///< SMBus Transmit Mode Indicator                  
2509      =1  #define SMB1CN0_TXMODE__RECEIVER    0x00 ///< SMBus in Receiver Mode.                        
2510      =1  #define SMB1CN0_TXMODE__TRANSMITTER 0x40 ///< SMBus in Transmitter Mode.                     
2511      =1                                                                                               
2512      =1  #define SMB1CN0_MASTER__BMASK       0x80 ///< SMBus Master/Slave Indicator                   
2513      =1  #define SMB1CN0_MASTER__SHIFT       0x07 ///< SMBus Master/Slave Indicator                   
2514      =1  #define SMB1CN0_MASTER__SLAVE       0x00 ///< SMBus operating in slave mode.                 
2515      =1  #define SMB1CN0_MASTER__MASTER      0x80 ///< SMBus operating in master mode.                
2516      =1                                                                                               
2517      =1  //------------------------------------------------------------------------------
2518      =1  // SMB1DAT Enums (SMBus 1 Data @ 0xC2)
2519      =1  //------------------------------------------------------------------------------
2520      =1  #define SMB1DAT_SMB1DAT__FMASK 0xFF ///< SMBus 1 Data
2521      =1  #define SMB1DAT_SMB1DAT__SHIFT 0x00 ///< SMBus 1 Data
2522      =1                                                       
2523      =1  //------------------------------------------------------------------------------
2524      =1  // SMBTC Enums (SMBus Timing and Pin Control @ 0xB9)
C51 COMPILER V9.56.0.0   SPI_0                                                             10/28/2016 17:37:02 PAGE 68  

2525      =1  //------------------------------------------------------------------------------
2526      =1  #define SMBTC_SMB0SDD__FMASK         0x03 ///< SMBus 0 Start Detection Window                   
2527      =1  #define SMBTC_SMB0SDD__SHIFT         0x00 ///< SMBus 0 Start Detection Window                   
2528      =1  #define SMBTC_SMB0SDD__NONE          0x00 ///< No additional hold time window (0-1 SYSCLK).     
2529      =1  #define SMBTC_SMB0SDD__ADD_2_SYSCLKS 0x01 ///< Increase hold time window to 2-3 SYSCLKs.        
2530      =1  #define SMBTC_SMB0SDD__ADD_4_SYSCLKS 0x02 ///< Increase hold time window to 4-5 SYSCLKs.        
2531      =1  #define SMBTC_SMB0SDD__ADD_8_SYSCLKS 0x03 ///< Increase hold time window to 8-9 SYSCLKs.        
2532      =1                                                                                                  
2533      =1  #define SMBTC_SMB1SDD__FMASK         0x0C ///< SMBus 1 Start Detection Window                   
2534      =1  #define SMBTC_SMB1SDD__SHIFT         0x02 ///< SMBus 1 Start Detection Window                   
2535      =1  #define SMBTC_SMB1SDD__NONE          0x00 ///< No additional hold time requirement (0-1 SYSCLK).
2536      =1  #define SMBTC_SMB1SDD__ADD_2_SYSCLKS 0x04 ///< Increase hold time window to 2-3 SYSCLKs.        
2537      =1  #define SMBTC_SMB1SDD__ADD_4_SYSCLKS 0x08 ///< Increase hold time window to 4-5 SYSCLKs.        
2538      =1  #define SMBTC_SMB1SDD__ADD_8_SYSCLKS 0x0C ///< Increase hold time window to 8-9 SYSCLKs.        
2539      =1                                                                                                  
2540      =1  //------------------------------------------------------------------------------
2541      =1  // SPI0CFG Enums (SPI0 Configuration @ 0xA1)
2542      =1  //------------------------------------------------------------------------------
2543      =1  #define SPI0CFG_RXBMT__BMASK                0x01 ///< Receive Buffer Empty                              
2544      =1  #define SPI0CFG_RXBMT__SHIFT                0x00 ///< Receive Buffer Empty                              
2545      =1  #define SPI0CFG_RXBMT__NOT_SET              0x00 ///< New data is available in the receive buffer (Slave
2546      =1                                                   ///< mode).                                            
2547      =1  #define SPI0CFG_RXBMT__SET                  0x01 ///< No new data in the receive buffer (Slave mode).   
2548      =1                                                                                                          
2549      =1  #define SPI0CFG_SRMT__BMASK                 0x02 ///< Shift Register Empty                              
2550      =1  #define SPI0CFG_SRMT__SHIFT                 0x01 ///< Shift Register Empty                              
2551      =1  #define SPI0CFG_SRMT__NOT_SET               0x00 ///< The shift register is not empty.                  
2552      =1  #define SPI0CFG_SRMT__SET                   0x02 ///< The shift register is empty.                      
2553      =1                                                                                                          
2554      =1  #define SPI0CFG_NSSIN__BMASK                0x04 ///< NSS Instantaneous Pin Input                       
2555      =1  #define SPI0CFG_NSSIN__SHIFT                0x02 ///< NSS Instantaneous Pin Input                       
2556      =1  #define SPI0CFG_NSSIN__LOW                  0x00 ///< The NSS pin is low.                               
2557      =1  #define SPI0CFG_NSSIN__HIGH                 0x04 ///< The NSS pin is high.                              
2558      =1                                                                                                          
2559      =1  #define SPI0CFG_SLVSEL__BMASK               0x08 ///< Slave Selected Flag                               
2560      =1  #define SPI0CFG_SLVSEL__SHIFT               0x03 ///< Slave Selected Flag                               
2561      =1  #define SPI0CFG_SLVSEL__NOT_SELECTED        0x00 ///< The Slave is not selected (NSS is high).          
2562      =1  #define SPI0CFG_SLVSEL__SELECTED            0x08 ///< The Slave is selected (NSS is low).               
2563      =1                                                                                                          
2564      =1  #define SPI0CFG_CKPOL__BMASK                0x10 ///< SPI0 Clock Polarity                               
2565      =1  #define SPI0CFG_CKPOL__SHIFT                0x04 ///< SPI0 Clock Polarity                               
2566      =1  #define SPI0CFG_CKPOL__IDLE_LOW             0x00 ///< SCK line low in idle state.                       
2567      =1  #define SPI0CFG_CKPOL__IDLE_HIGH            0x10 ///< SCK line high in idle state.                      
2568      =1                                                                                                          
2569      =1  #define SPI0CFG_CKPHA__BMASK                0x20 ///< SPI0 Clock Phase                                  
2570      =1  #define SPI0CFG_CKPHA__SHIFT                0x05 ///< SPI0 Clock Phase                                  
2571      =1  #define SPI0CFG_CKPHA__DATA_CENTERED_FIRST  0x00 ///< Data centered on first edge of SCK period.        
2572      =1  #define SPI0CFG_CKPHA__DATA_CENTERED_SECOND 0x20 ///< Data centered on second edge of SCK period.       
2573      =1                                                                                                          
2574      =1  #define SPI0CFG_MSTEN__BMASK                0x40 ///< Master Mode Enable                                
2575      =1  #define SPI0CFG_MSTEN__SHIFT                0x06 ///< Master Mode Enable                                
2576      =1  #define SPI0CFG_MSTEN__MASTER_DISABLED      0x00 ///< Disable master mode. Operate in slave mode.       
2577      =1  #define SPI0CFG_MSTEN__MASTER_ENABLED       0x40 ///< Enable master mode. Operate as a master.          
2578      =1                                                                                                          
2579      =1  #define SPI0CFG_SPIBSY__BMASK               0x80 ///< SPI Busy                                          
2580      =1  #define SPI0CFG_SPIBSY__SHIFT               0x07 ///< SPI Busy                                          
2581      =1  #define SPI0CFG_SPIBSY__NOT_SET             0x00 ///< A SPI transfer is not in progress.                
2582      =1  #define SPI0CFG_SPIBSY__SET                 0x80 ///< A SPI transfer is in progress.                    
2583      =1                                                                                                          
2584      =1  //------------------------------------------------------------------------------
2585      =1  // SPI0CKR Enums (SPI0 Clock Rate @ 0xA2)
2586      =1  //------------------------------------------------------------------------------
C51 COMPILER V9.56.0.0   SPI_0                                                             10/28/2016 17:37:02 PAGE 69  

2587      =1  #define SPI0CKR_SPI0CKR__FMASK 0xFF ///< SPI0 Clock Rate
2588      =1  #define SPI0CKR_SPI0CKR__SHIFT 0x00 ///< SPI0 Clock Rate
2589      =1                                                          
2590      =1  //------------------------------------------------------------------------------
2591      =1  // SPI0CN0 Enums (SPI0 Control @ 0xF8)
2592      =1  //------------------------------------------------------------------------------
2593      =1  #define SPI0CN0_SPIEN__BMASK                  0x01 ///< SPI0 Enable                                       
2594      =1  #define SPI0CN0_SPIEN__SHIFT                  0x00 ///< SPI0 Enable                                       
2595      =1  #define SPI0CN0_SPIEN__DISABLED               0x00 ///< Disable the SPI module.                           
2596      =1  #define SPI0CN0_SPIEN__ENABLED                0x01 ///< Enable the SPI module.                            
2597      =1                                                                                                            
2598      =1  #define SPI0CN0_TXBMT__BMASK                  0x02 ///< Transmit Buffer Empty                             
2599      =1  #define SPI0CN0_TXBMT__SHIFT                  0x01 ///< Transmit Buffer Empty                             
2600      =1  #define SPI0CN0_TXBMT__NOT_SET                0x00 ///< The transmit buffer is not empty.                 
2601      =1  #define SPI0CN0_TXBMT__SET                    0x02 ///< The transmit buffer is empty.                     
2602      =1                                                                                                            
2603      =1  #define SPI0CN0_NSSMD__FMASK                  0x0C ///< Slave Select Mode                                 
2604      =1  #define SPI0CN0_NSSMD__SHIFT                  0x02 ///< Slave Select Mode                                 
2605      =1  #define SPI0CN0_NSSMD__3_WIRE                 0x00 ///< 3-Wire Slave or 3-Wire Master Mode. NSS signal is 
2606      =1                                                     ///< not routed to a port pin.                         
2607      =1  #define SPI0CN0_NSSMD__4_WIRE_SLAVE           0x04 ///< 4-Wire Slave or Multi-Master Mode. NSS is an input
2608      =1                                                     ///< to the device.                                    
2609      =1  #define SPI0CN0_NSSMD__4_WIRE_MASTER_NSS_LOW  0x08 ///< 4-Wire Single-Master Mode. NSS is an output and   
2610      =1                                                     ///< logic low.                                        
2611      =1  #define SPI0CN0_NSSMD__4_WIRE_MASTER_NSS_HIGH 0x0C ///< 4-Wire Single-Master Mode. NSS is an output and   
2612      =1                                                     ///< logic high.                                       
2613      =1                                                                                                            
2614      =1  #define SPI0CN0_RXOVRN__BMASK                 0x10 ///< Receive Overrun Flag                              
2615      =1  #define SPI0CN0_RXOVRN__SHIFT                 0x04 ///< Receive Overrun Flag                              
2616      =1  #define SPI0CN0_RXOVRN__NOT_SET               0x00 ///< A receive overrun did not occur.                  
2617      =1  #define SPI0CN0_RXOVRN__SET                   0x10 ///< A receive overrun occurred.                       
2618      =1                                                                                                            
2619      =1  #define SPI0CN0_MODF__BMASK                   0x20 ///< Mode Fault Flag                                   
2620      =1  #define SPI0CN0_MODF__SHIFT                   0x05 ///< Mode Fault Flag                                   
2621      =1  #define SPI0CN0_MODF__NOT_SET                 0x00 ///< A master collision did not occur.                 
2622      =1  #define SPI0CN0_MODF__SET                     0x20 ///< A master collision occurred.                      
2623      =1                                                                                                            
2624      =1  #define SPI0CN0_WCOL__BMASK                   0x40 ///< Write Collision Flag                              
2625      =1  #define SPI0CN0_WCOL__SHIFT                   0x06 ///< Write Collision Flag                              
2626      =1  #define SPI0CN0_WCOL__NOT_SET                 0x00 ///< A write collision did not occur.                  
2627      =1  #define SPI0CN0_WCOL__SET                     0x40 ///< A write collision occurred.                       
2628      =1                                                                                                            
2629      =1  #define SPI0CN0_SPIF__BMASK                   0x80 ///< SPI0 Interrupt Flag                               
2630      =1  #define SPI0CN0_SPIF__SHIFT                   0x07 ///< SPI0 Interrupt Flag                               
2631      =1  #define SPI0CN0_SPIF__NOT_SET                 0x00 ///< A data transfer has not completed since the last  
2632      =1                                                     ///< time SPIF was cleared.                            
2633      =1  #define SPI0CN0_SPIF__SET                     0x80 ///< A data transfer completed.                        
2634      =1                                                                                                            
2635      =1  //------------------------------------------------------------------------------
2636      =1  // SPI0DAT Enums (SPI0 Data @ 0xA3)
2637      =1  //------------------------------------------------------------------------------
2638      =1  #define SPI0DAT_SPI0DAT__FMASK 0xFF ///< SPI0 Transmit and Receive Data
2639      =1  #define SPI0DAT_SPI0DAT__SHIFT 0x00 ///< SPI0 Transmit and Receive Data
2640      =1                                                                         
2641      =1  //------------------------------------------------------------------------------
2642      =1  // TH0 Enums (Timer 0 High Byte @ 0x8C)
2643      =1  //------------------------------------------------------------------------------
2644      =1  #define TH0_TH0__FMASK 0xFF ///< Timer 0 High Byte
2645      =1  #define TH0_TH0__SHIFT 0x00 ///< Timer 0 High Byte
2646      =1                                                    
2647      =1  //------------------------------------------------------------------------------
2648      =1  // TH1 Enums (Timer 1 High Byte @ 0x8D)
C51 COMPILER V9.56.0.0   SPI_0                                                             10/28/2016 17:37:02 PAGE 70  

2649      =1  //------------------------------------------------------------------------------
2650      =1  #define TH1_TH1__FMASK 0xFF ///< Timer 1 High Byte
2651      =1  #define TH1_TH1__SHIFT 0x00 ///< Timer 1 High Byte
2652      =1                                                    
2653      =1  //------------------------------------------------------------------------------
2654      =1  // TL0 Enums (Timer 0 Low Byte @ 0x8A)
2655      =1  //------------------------------------------------------------------------------
2656      =1  #define TL0_TL0__FMASK 0xFF ///< Timer 0 Low Byte
2657      =1  #define TL0_TL0__SHIFT 0x00 ///< Timer 0 Low Byte
2658      =1                                                   
2659      =1  //------------------------------------------------------------------------------
2660      =1  // TL1 Enums (Timer 1 Low Byte @ 0x8B)
2661      =1  //------------------------------------------------------------------------------
2662      =1  #define TL1_TL1__FMASK 0xFF ///< Timer 1 Low Byte
2663      =1  #define TL1_TL1__SHIFT 0x00 ///< Timer 1 Low Byte
2664      =1                                                   
2665      =1  //------------------------------------------------------------------------------
2666      =1  // TMR2CN0 Enums (Timer 2 Control 0 @ 0xC8)
2667      =1  //------------------------------------------------------------------------------
2668      =1  #define TMR2CN0_T2XCLK__BMASK          0x01 ///< Timer 2 External Clock Select                    
2669      =1  #define TMR2CN0_T2XCLK__SHIFT          0x00 ///< Timer 2 External Clock Select                    
2670      =1  #define TMR2CN0_T2XCLK__SYSCLK_DIV_12  0x00 ///< Timer 2 clock is the system clock divided by 12. 
2671      =1  #define TMR2CN0_T2XCLK__EXTOSC_DIV_8   0x01 ///< Timer 2 clock is the external oscillator divided 
2672      =1                                              ///< by 8 (synchronized with SYSCLK).                 
2673      =1                                                                                                    
2674      =1  #define TMR2CN0_T2CSS__BMASK           0x02 ///< Timer 2 Capture Source Select                    
2675      =1  #define TMR2CN0_T2CSS__SHIFT           0x01 ///< Timer 2 Capture Source Select                    
2676      =1  #define TMR2CN0_T2CSS__USB_SOF_CAPTURE 0x00 ///< Capture source is USB SOF event.                 
2677      =1  #define TMR2CN0_T2CSS__LFOSC_CAPTURE   0x02 ///< Capture source is falling edge of Low-Frequency  
2678      =1                                              ///< Oscillator.                                      
2679      =1                                                                                                    
2680      =1  #define TMR2CN0_TR2__BMASK             0x04 ///< Timer 2 Run Control                              
2681      =1  #define TMR2CN0_TR2__SHIFT             0x02 ///< Timer 2 Run Control                              
2682      =1  #define TMR2CN0_TR2__STOP              0x00 ///< Stop Timer 2.                                    
2683      =1  #define TMR2CN0_TR2__RUN               0x04 ///< Start Timer 2 running.                           
2684      =1                                                                                                    
2685      =1  #define TMR2CN0_T2SPLIT__BMASK         0x08 ///< Timer 2 Split Mode Enable                        
2686      =1  #define TMR2CN0_T2SPLIT__SHIFT         0x03 ///< Timer 2 Split Mode Enable                        
2687      =1  #define TMR2CN0_T2SPLIT__16_BIT_RELOAD 0x00 ///< Timer 2 operates in 16-bit auto-reload mode.     
2688      =1  #define TMR2CN0_T2SPLIT__8_BIT_RELOAD  0x08 ///< Timer 2 operates as two 8-bit auto-reload timers.
2689      =1                                                                                                    
2690      =1  #define TMR2CN0_TF2CEN__BMASK          0x10 ///< Timer 2 Capture Enable                           
2691      =1  #define TMR2CN0_TF2CEN__SHIFT          0x04 ///< Timer 2 Capture Enable                           
2692      =1  #define TMR2CN0_TF2CEN__DISABLED       0x00 ///< Disable capture mode.                            
2693      =1  #define TMR2CN0_TF2CEN__ENABLED        0x10 ///< Enable capture mode.                             
2694      =1                                                                                                    
2695      =1  #define TMR2CN0_TF2LEN__BMASK          0x20 ///< Timer 2 Low Byte Interrupt Enable                
2696      =1  #define TMR2CN0_TF2LEN__SHIFT          0x05 ///< Timer 2 Low Byte Interrupt Enable                
2697      =1  #define TMR2CN0_TF2LEN__DISABLED       0x00 ///< Disable low byte interrupts.                     
2698      =1  #define TMR2CN0_TF2LEN__ENABLED        0x20 ///< Enable low byte interrupts.                      
2699      =1                                                                                                    
2700      =1  #define TMR2CN0_TF2L__BMASK            0x40 ///< Timer 2 Low Byte Overflow Flag                   
2701      =1  #define TMR2CN0_TF2L__SHIFT            0x06 ///< Timer 2 Low Byte Overflow Flag                   
2702      =1  #define TMR2CN0_TF2L__NOT_SET          0x00 ///< Timer 2 low byte did not overflow.               
2703      =1  #define TMR2CN0_TF2L__SET              0x40 ///< Timer 2 low byte overflowed.                     
2704      =1                                                                                                    
2705      =1  #define TMR2CN0_TF2H__BMASK            0x80 ///< Timer 2 High Byte Overflow Flag                  
2706      =1  #define TMR2CN0_TF2H__SHIFT            0x07 ///< Timer 2 High Byte Overflow Flag                  
2707      =1  #define TMR2CN0_TF2H__NOT_SET          0x00 ///< Timer 2 8-bit high byte or 16-bit value did not  
2708      =1                                              ///< overflow.                                        
2709      =1  #define TMR2CN0_TF2H__SET              0x80 ///< Timer 2 8-bit high byte or 16-bit value          
2710      =1                                              ///< overflowed.                                      
C51 COMPILER V9.56.0.0   SPI_0                                                             10/28/2016 17:37:02 PAGE 71  

2711      =1                                                                                                    
2712      =1  //------------------------------------------------------------------------------
2713      =1  // TMR2H Enums (Timer 2 High Byte @ 0xCD)
2714      =1  //------------------------------------------------------------------------------
2715      =1  #define TMR2H_TMR2H__FMASK 0xFF ///< Timer 2 High Byte
2716      =1  #define TMR2H_TMR2H__SHIFT 0x00 ///< Timer 2 High Byte
2717      =1                                                        
2718      =1  //------------------------------------------------------------------------------
2719      =1  // TMR2L Enums (Timer 2 Low Byte @ 0xCC)
2720      =1  //------------------------------------------------------------------------------
2721      =1  #define TMR2L_TMR2L__FMASK 0xFF ///< Timer 2 Low Byte
2722      =1  #define TMR2L_TMR2L__SHIFT 0x00 ///< Timer 2 Low Byte
2723      =1                                                       
2724      =1  //------------------------------------------------------------------------------
2725      =1  // TMR2RLH Enums (Timer 2 Reload High Byte @ 0xCB)
2726      =1  //------------------------------------------------------------------------------
2727      =1  #define TMR2RLH_TMR2RLH__FMASK 0xFF ///< Timer 2 Reload High Byte
2728      =1  #define TMR2RLH_TMR2RLH__SHIFT 0x00 ///< Timer 2 Reload High Byte
2729      =1                                                                   
2730      =1  //------------------------------------------------------------------------------
2731      =1  // TMR2RLL Enums (Timer 2 Reload Low Byte @ 0xCA)
2732      =1  //------------------------------------------------------------------------------
2733      =1  #define TMR2RLL_TMR2RLL__FMASK 0xFF ///< Timer 2 Reload Low Byte
2734      =1  #define TMR2RLL_TMR2RLL__SHIFT 0x00 ///< Timer 2 Reload Low Byte
2735      =1                                                                  
2736      =1  //------------------------------------------------------------------------------
2737      =1  // TMR3CN0 Enums (Timer 3 Control 0 @ 0x91)
2738      =1  //------------------------------------------------------------------------------
2739      =1  #define TMR3CN0_T3XCLK__BMASK          0x01 ///< Timer 3 External Clock Select                    
2740      =1  #define TMR3CN0_T3XCLK__SHIFT          0x00 ///< Timer 3 External Clock Select                    
2741      =1  #define TMR3CN0_T3XCLK__SYSCLK_DIV_12  0x00 ///< Timer 3 clock is the system clock divided by 12. 
2742      =1  #define TMR3CN0_T3XCLK__EXTOSC_DIV_8   0x01 ///< Timer 3 clock is the external oscillator divided 
2743      =1                                              ///< by 8 (synchronized with SYSCLK).                 
2744      =1                                                                                                    
2745      =1  #define TMR3CN0_T3CSS__BMASK           0x02 ///< Timer 3 Capture Source Select                    
2746      =1  #define TMR3CN0_T3CSS__SHIFT           0x01 ///< Timer 3 Capture Source Select                    
2747      =1  #define TMR3CN0_T3CSS__USB_SOF_CAPTURE 0x00 ///< Capture source is USB SOF event.                 
2748      =1  #define TMR3CN0_T3CSS__LFOSC_CAPTURE   0x02 ///< Capture source is falling edge of Low-Frequency  
2749      =1                                              ///< Oscillator.                                      
2750      =1                                                                                                    
2751      =1  #define TMR3CN0_TR3__BMASK             0x04 ///< Timer 3 Run Control                              
2752      =1  #define TMR3CN0_TR3__SHIFT             0x02 ///< Timer 3 Run Control                              
2753      =1  #define TMR3CN0_TR3__STOP              0x00 ///< Stop Timer 3.                                    
2754      =1  #define TMR3CN0_TR3__RUN               0x04 ///< Start Timer 3 running.                           
2755      =1                                                                                                    
2756      =1  #define TMR3CN0_T3SPLIT__BMASK         0x08 ///< Timer 3 Split Mode Enable                        
2757      =1  #define TMR3CN0_T3SPLIT__SHIFT         0x03 ///< Timer 3 Split Mode Enable                        
2758      =1  #define TMR3CN0_T3SPLIT__16_BIT_RELOAD 0x00 ///< Timer 3 operates in 16-bit auto-reload mode.     
2759      =1  #define TMR3CN0_T3SPLIT__8_BIT_RELOAD  0x08 ///< Timer 3 operates as two 8-bit auto-reload timers.
2760      =1                                                                                                    
2761      =1  #define TMR3CN0_TF3CEN__BMASK          0x10 ///< Timer 3 Capture Enable                           
2762      =1  #define TMR3CN0_TF3CEN__SHIFT          0x04 ///< Timer 3 Capture Enable                           
2763      =1  #define TMR3CN0_TF3CEN__DISABLED       0x00 ///< Disable capture mode.                            
2764      =1  #define TMR3CN0_TF3CEN__ENABLED        0x10 ///< Enable capture mode.                             
2765      =1                                                                                                    
2766      =1  #define TMR3CN0_TF3LEN__BMASK          0x20 ///< Timer 3 Low Byte Interrupt Enable                
2767      =1  #define TMR3CN0_TF3LEN__SHIFT          0x05 ///< Timer 3 Low Byte Interrupt Enable                
2768      =1  #define TMR3CN0_TF3LEN__DISABLED       0x00 ///< Disable low byte interrupts.                     
2769      =1  #define TMR3CN0_TF3LEN__ENABLED        0x20 ///< Enable low byte interrupts.                      
2770      =1                                                                                                    
2771      =1  #define TMR3CN0_TF3L__BMASK            0x40 ///< Timer 3 Low Byte Overflow Flag                   
2772      =1  #define TMR3CN0_TF3L__SHIFT            0x06 ///< Timer 3 Low Byte Overflow Flag                   
C51 COMPILER V9.56.0.0   SPI_0                                                             10/28/2016 17:37:02 PAGE 72  

2773      =1  #define TMR3CN0_TF3L__NOT_SET          0x00 ///< Timer 3 low byte did not overflow.               
2774      =1  #define TMR3CN0_TF3L__SET              0x40 ///< Timer 3 low byte overflowed.                     
2775      =1                                                                                                    
2776      =1  #define TMR3CN0_TF3H__BMASK            0x80 ///< Timer 3 High Byte Overflow Flag                  
2777      =1  #define TMR3CN0_TF3H__SHIFT            0x07 ///< Timer 3 High Byte Overflow Flag                  
2778      =1  #define TMR3CN0_TF3H__NOT_SET          0x00 ///< Timer 3 8-bit high byte or 16-bit value did not  
2779      =1                                              ///< overflow.                                        
2780      =1  #define TMR3CN0_TF3H__SET              0x80 ///< Timer 3 8-bit high byte or 16-bit value          
2781      =1                                              ///< overflowed.                                      
2782      =1                                                                                                    
2783      =1  //------------------------------------------------------------------------------
2784      =1  // TMR3H Enums (Timer 3 High Byte @ 0x95)
2785      =1  //------------------------------------------------------------------------------
2786      =1  #define TMR3H_TMR3H__FMASK 0xFF ///< Timer 3 High Byte
2787      =1  #define TMR3H_TMR3H__SHIFT 0x00 ///< Timer 3 High Byte
2788      =1                                                        
2789      =1  //------------------------------------------------------------------------------
2790      =1  // TMR3L Enums (Timer 3 Low Byte @ 0x94)
2791      =1  //------------------------------------------------------------------------------
2792      =1  #define TMR3L_TMR3L__FMASK 0xFF ///< Timer 3 Low Byte
2793      =1  #define TMR3L_TMR3L__SHIFT 0x00 ///< Timer 3 Low Byte
2794      =1                                                       
2795      =1  //------------------------------------------------------------------------------
2796      =1  // TMR3RLH Enums (Timer 3 Reload High Byte @ 0x93)
2797      =1  //------------------------------------------------------------------------------
2798      =1  #define TMR3RLH_TMR3RLH__FMASK 0xFF ///< Timer 3 Reload High Byte
2799      =1  #define TMR3RLH_TMR3RLH__SHIFT 0x00 ///< Timer 3 Reload High Byte
2800      =1                                                                   
2801      =1  //------------------------------------------------------------------------------
2802      =1  // TMR3RLL Enums (Timer 3 Reload Low Byte @ 0x92)
2803      =1  //------------------------------------------------------------------------------
2804      =1  #define TMR3RLL_TMR3RLL__FMASK 0xFF ///< Timer 3 Reload Low Byte
2805      =1  #define TMR3RLL_TMR3RLL__SHIFT 0x00 ///< Timer 3 Reload Low Byte
2806      =1                                                                  
2807      =1  //------------------------------------------------------------------------------
2808      =1  // TMR4CN0 Enums (Timer 4 Control 0 @ 0x91)
2809      =1  //------------------------------------------------------------------------------
2810      =1  #define TMR4CN0_T4XCLK__BMASK          0x01 ///< Timer 4 External Clock Select                    
2811      =1  #define TMR4CN0_T4XCLK__SHIFT          0x00 ///< Timer 4 External Clock Select                    
2812      =1  #define TMR4CN0_T4XCLK__SYSCLK_DIV_12  0x00 ///< Timer 4 clock is the system clock divided by 12. 
2813      =1  #define TMR4CN0_T4XCLK__EXTOSC_DIV_8   0x01 ///< Timer 4 clock is the external oscillator divided 
2814      =1                                              ///< by 8 (synchronized with SYSCLK).                 
2815      =1                                                                                                    
2816      =1  #define TMR4CN0_TR4__BMASK             0x04 ///< Timer 4 Run Control                              
2817      =1  #define TMR4CN0_TR4__SHIFT             0x02 ///< Timer 4 Run Control                              
2818      =1  #define TMR4CN0_TR4__STOP              0x00 ///< Stop Timer 4.                                    
2819      =1  #define TMR4CN0_TR4__RUN               0x04 ///< Start Timer 4 running.                           
2820      =1                                                                                                    
2821      =1  #define TMR4CN0_T4SPLIT__BMASK         0x08 ///< Timer 4 Split Mode Enable                        
2822      =1  #define TMR4CN0_T4SPLIT__SHIFT         0x03 ///< Timer 4 Split Mode Enable                        
2823      =1  #define TMR4CN0_T4SPLIT__16_BIT_RELOAD 0x00 ///< Timer 4 operates in 16-bit auto-reload mode.     
2824      =1  #define TMR4CN0_T4SPLIT__8_BIT_RELOAD  0x08 ///< Timer 4 operates as two 8-bit auto-reload timers.
2825      =1                                                                                                    
2826      =1  #define TMR4CN0_TF4LEN__BMASK          0x20 ///< Timer 4 Low Byte Interrupt Enable                
2827      =1  #define TMR4CN0_TF4LEN__SHIFT          0x05 ///< Timer 4 Low Byte Interrupt Enable                
2828      =1  #define TMR4CN0_TF4LEN__DISABLED       0x00 ///< Disable low byte interrupts.                     
2829      =1  #define TMR4CN0_TF4LEN__ENABLED        0x20 ///< Enable low byte interrupts.                      
2830      =1                                                                                                    
2831      =1  #define TMR4CN0_TF4L__BMASK            0x40 ///< Timer 4 Low Byte Overflow Flag                   
2832      =1  #define TMR4CN0_TF4L__SHIFT            0x06 ///< Timer 4 Low Byte Overflow Flag                   
2833      =1  #define TMR4CN0_TF4L__NOT_SET          0x00 ///< Timer 4 low byte did not overflow.               
2834      =1  #define TMR4CN0_TF4L__SET              0x40 ///< Timer 4 low byte overflowed.                     
C51 COMPILER V9.56.0.0   SPI_0                                                             10/28/2016 17:37:02 PAGE 73  

2835      =1                                                                                                    
2836      =1  #define TMR4CN0_TF4H__BMASK            0x80 ///< Timer 4 High Byte Overflow Flag                  
2837      =1  #define TMR4CN0_TF4H__SHIFT            0x07 ///< Timer 4 High Byte Overflow Flag                  
2838      =1  #define TMR4CN0_TF4H__NOT_SET          0x00 ///< Timer 4 8-bit high byte or 16-bit value did not  
2839      =1                                              ///< overflow.                                        
2840      =1  #define TMR4CN0_TF4H__SET              0x80 ///< Timer 4 8-bit high byte or 16-bit value          
2841      =1                                              ///< overflowed.                                      
2842      =1                                                                                                    
2843      =1  //------------------------------------------------------------------------------
2844      =1  // TMR4H Enums (Timer 4 High Byte @ 0x95)
2845      =1  //------------------------------------------------------------------------------
2846      =1  #define TMR4H_TMR4H__FMASK 0xFF ///< Timer 4 High Byte
2847      =1  #define TMR4H_TMR4H__SHIFT 0x00 ///< Timer 4 High Byte
2848      =1                                                        
2849      =1  //------------------------------------------------------------------------------
2850      =1  // TMR4L Enums (Timer 4 Low Byte @ 0x94)
2851      =1  //------------------------------------------------------------------------------
2852      =1  #define TMR4L_TMR4L__FMASK 0xFF ///< Timer 4 Low Byte
2853      =1  #define TMR4L_TMR4L__SHIFT 0x00 ///< Timer 4 Low Byte
2854      =1                                                       
2855      =1  //------------------------------------------------------------------------------
2856      =1  // TMR4RLH Enums (Timer 4 Reload High Byte @ 0x93)
2857      =1  //------------------------------------------------------------------------------
2858      =1  #define TMR4RLH_TMR4RLH__FMASK 0xFF ///< Timer 4 Reload High Byte
2859      =1  #define TMR4RLH_TMR4RLH__SHIFT 0x00 ///< Timer 4 Reload High Byte
2860      =1                                                                   
2861      =1  //------------------------------------------------------------------------------
2862      =1  // TMR4RLL Enums (Timer 4 Reload Low Byte @ 0x92)
2863      =1  //------------------------------------------------------------------------------
2864      =1  #define TMR4RLL_TMR4RLL__FMASK 0xFF ///< Timer 4 Reload Low Byte
2865      =1  #define TMR4RLL_TMR4RLL__SHIFT 0x00 ///< Timer 4 Reload Low Byte
2866      =1                                                                  
2867      =1  //------------------------------------------------------------------------------
2868      =1  // TMR5CN0 Enums (Timer 5 Control 0 @ 0xC8)
2869      =1  //------------------------------------------------------------------------------
2870      =1  #define TMR5CN0_T5XCLK__BMASK          0x01 ///< Timer 5 External Clock Select                    
2871      =1  #define TMR5CN0_T5XCLK__SHIFT          0x00 ///< Timer 5 External Clock Select                    
2872      =1  #define TMR5CN0_T5XCLK__SYSCLK_DIV_12  0x00 ///< Timer 5 clock is the system clock divided by 12. 
2873      =1  #define TMR5CN0_T5XCLK__EXTOSC_DIV_8   0x01 ///< Timer 5 clock is the external oscillator divided 
2874      =1                                              ///< by 8 (synchronized with SYSCLK).                 
2875      =1                                                                                                    
2876      =1  #define TMR5CN0_TR5__BMASK             0x04 ///< Timer 5 Run Control                              
2877      =1  #define TMR5CN0_TR5__SHIFT             0x02 ///< Timer 5 Run Control                              
2878      =1  #define TMR5CN0_TR5__STOP              0x00 ///< Stop Timer 5.                                    
2879      =1  #define TMR5CN0_TR5__RUN               0x04 ///< Start Timer 5 running.                           
2880      =1                                                                                                    
2881      =1  #define TMR5CN0_T5SPLIT__BMASK         0x08 ///< Timer 5 Split Mode Enable                        
2882      =1  #define TMR5CN0_T5SPLIT__SHIFT         0x03 ///< Timer 5 Split Mode Enable                        
2883      =1  #define TMR5CN0_T5SPLIT__16_BIT_RELOAD 0x00 ///< Timer 5 operates in 16-bit auto-reload mode.     
2884      =1  #define TMR5CN0_T5SPLIT__8_BIT_RELOAD  0x08 ///< Timer 5 operates as two 8-bit auto-reload timers.
2885      =1                                                                                                    
2886      =1  #define TMR5CN0_TF5LEN__BMASK          0x20 ///< Timer 5 Low Byte Interrupt Enable                
2887      =1  #define TMR5CN0_TF5LEN__SHIFT          0x05 ///< Timer 5 Low Byte Interrupt Enable                
2888      =1  #define TMR5CN0_TF5LEN__DISABLED       0x00 ///< Disable low byte interrupts.                     
2889      =1  #define TMR5CN0_TF5LEN__ENABLED        0x20 ///< Enable low byte interrupts.                      
2890      =1                                                                                                    
2891      =1  #define TMR5CN0_TF5L__BMASK            0x40 ///< Timer 5 Low Byte Overflow Flag                   
2892      =1  #define TMR5CN0_TF5L__SHIFT            0x06 ///< Timer 5 Low Byte Overflow Flag                   
2893      =1  #define TMR5CN0_TF5L__NOT_SET          0x00 ///< Timer 5 low byte did not overflow.               
2894      =1  #define TMR5CN0_TF5L__SET              0x40 ///< Timer 5 low byte overflowed.                     
2895      =1                                                                                                    
2896      =1  #define TMR5CN0_TF5H__BMASK            0x80 ///< Timer 5 High Byte Overflow Flag                  
C51 COMPILER V9.56.0.0   SPI_0                                                             10/28/2016 17:37:02 PAGE 74  

2897      =1  #define TMR5CN0_TF5H__SHIFT            0x07 ///< Timer 5 High Byte Overflow Flag                  
2898      =1  #define TMR5CN0_TF5H__NOT_SET          0x00 ///< Timer 5 8-bit high byte or 16-bit value did not  
2899      =1                                              ///< overflow.                                        
2900      =1  #define TMR5CN0_TF5H__SET              0x80 ///< Timer 5 8-bit high byte or 16-bit value          
2901      =1                                              ///< overflowed.                                      
2902      =1                                                                                                    
2903      =1  //------------------------------------------------------------------------------
2904      =1  // TMR5H Enums (Timer 5 High Byte @ 0xCD)
2905      =1  //------------------------------------------------------------------------------
2906      =1  #define TMR5H_TMR5H__FMASK 0xFF ///< Timer 5 High Byte
2907      =1  #define TMR5H_TMR5H__SHIFT 0x00 ///< Timer 5 High Byte
2908      =1                                                        
2909      =1  //------------------------------------------------------------------------------
2910      =1  // TMR5L Enums (Timer 5 Low Byte @ 0xCC)
2911      =1  //------------------------------------------------------------------------------
2912      =1  #define TMR5L_TMR5L__FMASK 0xFF ///< Timer 5 Low Byte
2913      =1  #define TMR5L_TMR5L__SHIFT 0x00 ///< Timer 5 Low Byte
2914      =1                                                       
2915      =1  //------------------------------------------------------------------------------
2916      =1  // TMR5RLH Enums (Timer 5 Reload High Byte @ 0xCB)
2917      =1  //------------------------------------------------------------------------------
2918      =1  #define TMR5RLH_TMR5RLH__FMASK 0xFF ///< Timer 5 Reload High Byte
2919      =1  #define TMR5RLH_TMR5RLH__SHIFT 0x00 ///< Timer 5 Reload High Byte
2920      =1                                                                   
2921      =1  //------------------------------------------------------------------------------
2922      =1  // TMR5RLL Enums (Timer 5 Reload Low Byte @ 0xCA)
2923      =1  //------------------------------------------------------------------------------
2924      =1  #define TMR5RLL_TMR5RLL__FMASK 0xFF ///< Timer 5 Reload Low Byte
2925      =1  #define TMR5RLL_TMR5RLL__SHIFT 0x00 ///< Timer 5 Reload Low Byte
2926      =1                                                                  
2927      =1  //------------------------------------------------------------------------------
2928      =1  // CKCON0 Enums (Clock Control 0 @ 0x8E)
2929      =1  //------------------------------------------------------------------------------
2930      =1  #define CKCON0_SCA__FMASK           0x03 ///< Timer 0/1 Prescale                                
2931      =1  #define CKCON0_SCA__SHIFT           0x00 ///< Timer 0/1 Prescale                                
2932      =1  #define CKCON0_SCA__SYSCLK_DIV_12   0x00 ///< System clock divided by 12.                       
2933      =1  #define CKCON0_SCA__SYSCLK_DIV_4    0x01 ///< System clock divided by 4.                        
2934      =1  #define CKCON0_SCA__SYSCLK_DIV_48   0x02 ///< System clock divided by 48.                       
2935      =1  #define CKCON0_SCA__EXTOSC_DIV_8    0x03 ///< External oscillator divided by 8 (synchronized    
2936      =1                                           ///< with the system clock).                           
2937      =1                                                                                                  
2938      =1  #define CKCON0_T0M__BMASK           0x04 ///< Timer 0 Clock Select                              
2939      =1  #define CKCON0_T0M__SHIFT           0x02 ///< Timer 0 Clock Select                              
2940      =1  #define CKCON0_T0M__PRESCALE        0x00 ///< Counter/Timer 0 uses the clock defined by the     
2941      =1                                           ///< prescale field, SCA.                              
2942      =1  #define CKCON0_T0M__SYSCLK          0x04 ///< Counter/Timer 0 uses the system clock.            
2943      =1                                                                                                  
2944      =1  #define CKCON0_T1M__BMASK           0x08 ///< Timer 1 Clock Select                              
2945      =1  #define CKCON0_T1M__SHIFT           0x03 ///< Timer 1 Clock Select                              
2946      =1  #define CKCON0_T1M__PRESCALE        0x00 ///< Timer 1 uses the clock defined by the prescale    
2947      =1                                           ///< field, SCA.                                       
2948      =1  #define CKCON0_T1M__SYSCLK          0x08 ///< Timer 1 uses the system clock.                    
2949      =1                                                                                                  
2950      =1  #define CKCON0_T2ML__BMASK          0x10 ///< Timer 2 Low Byte Clock Select                     
2951      =1  #define CKCON0_T2ML__SHIFT          0x04 ///< Timer 2 Low Byte Clock Select                     
2952      =1  #define CKCON0_T2ML__EXTERNAL_CLOCK 0x00 ///< Timer 2 low byte uses the clock defined by T2XCLK 
2953      =1                                           ///< in TMR2CN0.                                       
2954      =1  #define CKCON0_T2ML__SYSCLK         0x10 ///< Timer 2 low byte uses the system clock.           
2955      =1                                                                                                  
2956      =1  #define CKCON0_T2MH__BMASK          0x20 ///< Timer 2 High Byte Clock Select                    
2957      =1  #define CKCON0_T2MH__SHIFT          0x05 ///< Timer 2 High Byte Clock Select                    
2958      =1  #define CKCON0_T2MH__EXTERNAL_CLOCK 0x00 ///< Timer 2 high byte uses the clock defined by T2XCLK
C51 COMPILER V9.56.0.0   SPI_0                                                             10/28/2016 17:37:02 PAGE 75  

2959      =1                                           ///< in TMR2CN0.                                       
2960      =1  #define CKCON0_T2MH__SYSCLK         0x20 ///< Timer 2 high byte uses the system clock.          
2961      =1                                                                                                  
2962      =1  #define CKCON0_T3ML__BMASK          0x40 ///< Timer 3 Low Byte Clock Select                     
2963      =1  #define CKCON0_T3ML__SHIFT          0x06 ///< Timer 3 Low Byte Clock Select                     
2964      =1  #define CKCON0_T3ML__EXTERNAL_CLOCK 0x00 ///< Timer 3 low byte uses the clock defined by T3XCLK 
2965      =1                                           ///< in TMR3CN0.                                       
2966      =1  #define CKCON0_T3ML__SYSCLK         0x40 ///< Timer 3 low byte uses the system clock.           
2967      =1                                                                                                  
2968      =1  #define CKCON0_T3MH__BMASK          0x80 ///< Timer 3 High Byte Clock Select                    
2969      =1  #define CKCON0_T3MH__SHIFT          0x07 ///< Timer 3 High Byte Clock Select                    
2970      =1  #define CKCON0_T3MH__EXTERNAL_CLOCK 0x00 ///< Timer 3 high byte uses the clock defined by T3XCLK
2971      =1                                           ///< in TMR3CN0.                                       
2972      =1  #define CKCON0_T3MH__SYSCLK         0x80 ///< Timer 3 high byte uses the system clock.          
2973      =1                                                                                                  
2974      =1  //------------------------------------------------------------------------------
2975      =1  // CKCON1 Enums (Clock Control 1 @ 0xE4)
2976      =1  //------------------------------------------------------------------------------
2977      =1  #define CKCON1_T4ML__BMASK          0x01 ///< Timer 4 Low Byte Clock Select                     
2978      =1  #define CKCON1_T4ML__SHIFT          0x00 ///< Timer 4 Low Byte Clock Select                     
2979      =1  #define CKCON1_T4ML__EXTERNAL_CLOCK 0x00 ///< Timer 4 low byte uses the clock defined by T4XCLK 
2980      =1                                           ///< in TMR4CN0.                                       
2981      =1  #define CKCON1_T4ML__SYSCLK         0x01 ///< Timer 4 low byte uses the system clock.           
2982      =1                                                                                                  
2983      =1  #define CKCON1_T4MH__BMASK          0x02 ///< Timer 4 High Byte Clock Select                    
2984      =1  #define CKCON1_T4MH__SHIFT          0x01 ///< Timer 4 High Byte Clock Select                    
2985      =1  #define CKCON1_T4MH__EXTERNAL_CLOCK 0x00 ///< Timer 4 high byte uses the clock defined by T4XCLK
2986      =1                                           ///< in TMR4CN0.                                       
2987      =1  #define CKCON1_T4MH__SYSCLK         0x02 ///< Timer 4 high byte uses the system clock.          
2988      =1                                                                                                  
2989      =1  #define CKCON1_T5ML__BMASK          0x04 ///< Timer 5 Low Byte Clock Select                     
2990      =1  #define CKCON1_T5ML__SHIFT          0x02 ///< Timer 5 Low Byte Clock Select                     
2991      =1  #define CKCON1_T5ML__EXTERNAL_CLOCK 0x00 ///< Timer 5 low byte uses the clock defined by T5XCLK 
2992      =1                                           ///< in TMR5CN.                                        
2993      =1  #define CKCON1_T5ML__SYSCLK         0x04 ///< Timer 5 low byte uses the system clock.           
2994      =1                                                                                                  
2995      =1  #define CKCON1_T5MH__BMASK          0x08 ///< Timer 5 High Byte Clock Select                    
2996      =1  #define CKCON1_T5MH__SHIFT          0x03 ///< Timer 5 High Byte Clock Select                    
2997      =1  #define CKCON1_T5MH__EXTERNAL_CLOCK 0x00 ///< Timer 5 high byte uses the clock defined by T5XCLK
2998      =1                                           ///< in TMR5CN.                                        
2999      =1  #define CKCON1_T5MH__SYSCLK         0x08 ///< Timer 5 high byte uses the system clock.          
3000      =1                                                                                                  
3001      =1  //------------------------------------------------------------------------------
3002      =1  // TCON Enums (Timer 0/1 Control @ 0x88)
3003      =1  //------------------------------------------------------------------------------
3004      =1  #define TCON_IT0__BMASK   0x01 ///< Interrupt 0 Type Select  
3005      =1  #define TCON_IT0__SHIFT   0x00 ///< Interrupt 0 Type Select  
3006      =1  #define TCON_IT0__LEVEL   0x00 ///< INT0 is level triggered. 
3007      =1  #define TCON_IT0__EDGE    0x01 ///< INT0 is edge triggered.  
3008      =1                                                               
3009      =1  #define TCON_IE0__BMASK   0x02 ///< External Interrupt 0     
3010      =1  #define TCON_IE0__SHIFT   0x01 ///< External Interrupt 0     
3011      =1  #define TCON_IE0__NOT_SET 0x00 ///< Edge/level not detected. 
3012      =1  #define TCON_IE0__SET     0x02 ///< Edge/level detected      
3013      =1                                                               
3014      =1  #define TCON_IT1__BMASK   0x04 ///< Interrupt 1 Type Select  
3015      =1  #define TCON_IT1__SHIFT   0x02 ///< Interrupt 1 Type Select  
3016      =1  #define TCON_IT1__LEVEL   0x00 ///< INT1 is level triggered. 
3017      =1  #define TCON_IT1__EDGE    0x04 ///< INT1 is edge triggered.  
3018      =1                                                               
3019      =1  #define TCON_IE1__BMASK   0x08 ///< External Interrupt 1     
3020      =1  #define TCON_IE1__SHIFT   0x03 ///< External Interrupt 1     
C51 COMPILER V9.56.0.0   SPI_0                                                             10/28/2016 17:37:02 PAGE 76  

3021      =1  #define TCON_IE1__NOT_SET 0x00 ///< Edge/level not detected. 
3022      =1  #define TCON_IE1__SET     0x08 ///< Edge/level detected      
3023      =1                                                               
3024      =1  #define TCON_TR0__BMASK   0x10 ///< Timer 0 Run Control      
3025      =1  #define TCON_TR0__SHIFT   0x04 ///< Timer 0 Run Control      
3026      =1  #define TCON_TR0__STOP    0x00 ///< Stop Timer 0.            
3027      =1  #define TCON_TR0__RUN     0x10 ///< Start Timer 0 running.   
3028      =1                                                               
3029      =1  #define TCON_TF0__BMASK   0x20 ///< Timer 0 Overflow Flag    
3030      =1  #define TCON_TF0__SHIFT   0x05 ///< Timer 0 Overflow Flag    
3031      =1  #define TCON_TF0__NOT_SET 0x00 ///< Timer 0 did not overflow.
3032      =1  #define TCON_TF0__SET     0x20 ///< Timer 0 overflowed.      
3033      =1                                                               
3034      =1  #define TCON_TR1__BMASK   0x40 ///< Timer 1 Run Control      
3035      =1  #define TCON_TR1__SHIFT   0x06 ///< Timer 1 Run Control      
3036      =1  #define TCON_TR1__STOP    0x00 ///< Stop Timer 1.            
3037      =1  #define TCON_TR1__RUN     0x40 ///< Start Timer 1 running.   
3038      =1                                                               
3039      =1  #define TCON_TF1__BMASK   0x80 ///< Timer 1 Overflow Flag    
3040      =1  #define TCON_TF1__SHIFT   0x07 ///< Timer 1 Overflow Flag    
3041      =1  #define TCON_TF1__NOT_SET 0x00 ///< Timer 1 did not overflow.
3042      =1  #define TCON_TF1__SET     0x80 ///< Timer 1 overflowed.      
3043      =1                                                               
3044      =1  //------------------------------------------------------------------------------
3045      =1  // TMOD Enums (Timer 0/1 Mode @ 0x89)
3046      =1  //------------------------------------------------------------------------------
3047      =1  #define TMOD_T0M__FMASK      0x03 ///< Timer 0 Mode Select                               
3048      =1  #define TMOD_T0M__SHIFT      0x00 ///< Timer 0 Mode Select                               
3049      =1  #define TMOD_T0M__MODE0      0x00 ///< Mode 0, 13-bit Counter/Timer                      
3050      =1  #define TMOD_T0M__MODE1      0x01 ///< Mode 1, 16-bit Counter/Timer                      
3051      =1  #define TMOD_T0M__MODE2      0x02 ///< Mode 2, 8-bit Counter/Timer with Auto-Reload      
3052      =1  #define TMOD_T0M__MODE3      0x03 ///< Mode 3, Two 8-bit Counter/Timers                  
3053      =1                                                                                           
3054      =1  #define TMOD_CT0__BMASK      0x04 ///< Counter/Timer 0 Select                            
3055      =1  #define TMOD_CT0__SHIFT      0x02 ///< Counter/Timer 0 Select                            
3056      =1  #define TMOD_CT0__TIMER      0x00 ///< Timer Mode. Timer 0 increments on the clock       
3057      =1                                    ///< defined by T0M in the CKCON0 register.            
3058      =1  #define TMOD_CT0__COUNTER    0x04 ///< Counter Mode. Timer 0 increments on high-to-low   
3059      =1                                    ///< transitions of an external pin (T0).              
3060      =1                                                                                           
3061      =1  #define TMOD_GATE0__BMASK    0x08 ///< Timer 0 Gate Control                              
3062      =1  #define TMOD_GATE0__SHIFT    0x03 ///< Timer 0 Gate Control                              
3063      =1  #define TMOD_GATE0__DISABLED 0x00 ///< Timer 0 enabled when TR0 = 1 irrespective of INT0 
3064      =1                                    ///< logic level.                                      
3065      =1  #define TMOD_GATE0__ENABLED  0x08 ///< Timer 0 enabled only when TR0 = 1 and INT0 is     
3066      =1                                    ///< active as defined by bit IN0PL in register IT01CF.
3067      =1                                                                                           
3068      =1  #define TMOD_T1M__FMASK      0x30 ///< Timer 1 Mode Select                               
3069      =1  #define TMOD_T1M__SHIFT      0x04 ///< Timer 1 Mode Select                               
3070      =1  #define TMOD_T1M__MODE0      0x00 ///< Mode 0, 13-bit Counter/Timer                      
3071      =1  #define TMOD_T1M__MODE1      0x10 ///< Mode 1, 16-bit Counter/Timer                      
3072      =1  #define TMOD_T1M__MODE2      0x20 ///< Mode 2, 8-bit Counter/Timer with Auto-Reload      
3073      =1  #define TMOD_T1M__MODE3      0x30 ///< Mode 3, Timer 1 Inactive                          
3074      =1                                                                                           
3075      =1  #define TMOD_CT1__BMASK      0x40 ///< Counter/Timer 1 Select                            
3076      =1  #define TMOD_CT1__SHIFT      0x06 ///< Counter/Timer 1 Select                            
3077      =1  #define TMOD_CT1__TIMER      0x00 ///< Timer Mode. Timer 1 increments on the clock       
3078      =1                                    ///< defined by T1M in the CKCON0 register.            
3079      =1  #define TMOD_CT1__COUNTER    0x40 ///< Counter Mode. Timer 1 increments on high-to-low   
3080      =1                                    ///< transitions of an external pin (T1).              
3081      =1                                                                                           
3082      =1  #define TMOD_GATE1__BMASK    0x80 ///< Timer 1 Gate Control                              
C51 COMPILER V9.56.0.0   SPI_0                                                             10/28/2016 17:37:02 PAGE 77  

3083      =1  #define TMOD_GATE1__SHIFT    0x07 ///< Timer 1 Gate Control                              
3084      =1  #define TMOD_GATE1__DISABLED 0x00 ///< Timer 1 enabled when TR1 = 1 irrespective of INT1 
3085      =1                                    ///< logic level.                                      
3086      =1  #define TMOD_GATE1__ENABLED  0x80 ///< Timer 1 enabled only when TR1 = 1 and INT1 is     
3087      =1                                    ///< active as defined by bit IN1PL in register IT01CF.
3088      =1                                                                                           
3089      =1  //------------------------------------------------------------------------------
3090      =1  // SBCON1 Enums (UART1 Baud Rate Generator Control @ 0xAC)
3091      =1  //------------------------------------------------------------------------------
3092      =1  #define SBCON1_BPS__FMASK     0x03 ///< Baud Rate Prescaler Select                     
3093      =1  #define SBCON1_BPS__SHIFT     0x00 ///< Baud Rate Prescaler Select                     
3094      =1  #define SBCON1_BPS__DIV_BY_12 0x00 ///< Prescaler = 12.                                
3095      =1  #define SBCON1_BPS__DIV_BY_4  0x01 ///< Prescaler = 4.                                 
3096      =1  #define SBCON1_BPS__DIV_BY_48 0x02 ///< Prescaler = 48.                                
3097      =1  #define SBCON1_BPS__DIV_BY_1  0x03 ///< Prescaler = 1.                                 
3098      =1                                                                                         
3099      =1  #define SBCON1_BREN__BMASK    0x40 ///< Baud Rate Generator Enable                     
3100      =1  #define SBCON1_BREN__SHIFT    0x06 ///< Baud Rate Generator Enable                     
3101      =1  #define SBCON1_BREN__DISABLED 0x00 ///< Disable the baud rate generator. UART1 will not
3102      =1                                     ///< function.                                      
3103      =1  #define SBCON1_BREN__ENABLED  0x40 ///< Enable the baud rate generator.                
3104      =1                                                                                         
3105      =1  //------------------------------------------------------------------------------
3106      =1  // SBRLH1 Enums (UART1 Baud Rate Generator High Byte @ 0xB5)
3107      =1  //------------------------------------------------------------------------------
3108      =1  #define SBRLH1_BRH__FMASK 0xFF ///< UART1 Baud Rate Reload High
3109      =1  #define SBRLH1_BRH__SHIFT 0x00 ///< UART1 Baud Rate Reload High
3110      =1                                                                 
3111      =1  //------------------------------------------------------------------------------
3112      =1  // SBRLL1 Enums (UART1 Baud Rate Generator Low Byte @ 0xB4)
3113      =1  //------------------------------------------------------------------------------
3114      =1  #define SBRLL1_BRL__FMASK 0xFF ///< UART1 Baud Rate Reload Low
3115      =1  #define SBRLL1_BRL__SHIFT 0x00 ///< UART1 Baud Rate Reload Low
3116      =1                                                                
3117      =1  //------------------------------------------------------------------------------
3118      =1  // SBUF1 Enums (UART1 Serial Port Data Buffer @ 0xD3)
3119      =1  //------------------------------------------------------------------------------
3120      =1  #define SBUF1_SBUF1__FMASK 0xFF ///< Serial Port Data Buffer
3121      =1  #define SBUF1_SBUF1__SHIFT 0x00 ///< Serial Port Data Buffer
3122      =1                                                              
3123      =1  //------------------------------------------------------------------------------
3124      =1  // SCON1 Enums (UART1 Serial Port Control @ 0xD2)
3125      =1  //------------------------------------------------------------------------------
3126      =1  #define SCON1_RI__BMASK             0x01 ///< Receive Interrupt Flag                           
3127      =1  #define SCON1_RI__SHIFT             0x00 ///< Receive Interrupt Flag                           
3128      =1  #define SCON1_RI__NOT_SET           0x00 ///< New data has not been received by UART1.         
3129      =1  #define SCON1_RI__SET               0x01 ///< UART1 received one or more data bytes.           
3130      =1                                                                                                 
3131      =1  #define SCON1_TI__BMASK             0x02 ///< Transmit Interrupt Flag                          
3132      =1  #define SCON1_TI__SHIFT             0x01 ///< Transmit Interrupt Flag                          
3133      =1  #define SCON1_TI__NOT_SET           0x00 ///< A byte of data has not been transmitted by UART1.
3134      =1  #define SCON1_TI__SET               0x02 ///< UART1 transmitted a byte of data.                
3135      =1                                                                                                 
3136      =1  #define SCON1_RBX__BMASK            0x04 ///< Extra Receive Bit                                
3137      =1  #define SCON1_RBX__SHIFT            0x02 ///< Extra Receive Bit                                
3138      =1  #define SCON1_RBX__LOW              0x00 ///< The extra bit or the first stop bit is 0.        
3139      =1  #define SCON1_RBX__HIGH             0x04 ///< The extra bit or the first stop bit is 1.        
3140      =1                                                                                                 
3141      =1  #define SCON1_TBX__BMASK            0x08 ///< Extra Transmission Bit                           
3142      =1  #define SCON1_TBX__SHIFT            0x03 ///< Extra Transmission Bit                           
3143      =1  #define SCON1_TBX__LOW              0x00 ///< Set extra bit to 0 (low).                        
3144      =1  #define SCON1_TBX__HIGH             0x08 ///< Set extra bit to 1 (high).                       
C51 COMPILER V9.56.0.0   SPI_0                                                             10/28/2016 17:37:02 PAGE 78  

3145      =1                                                                                                 
3146      =1  #define SCON1_REN__BMASK            0x10 ///< Receive Enable                                   
3147      =1  #define SCON1_REN__SHIFT            0x04 ///< Receive Enable                                   
3148      =1  #define SCON1_REN__RECEIVE_DISABLED 0x00 ///< UART1 reception disabled.                        
3149      =1  #define SCON1_REN__RECEIVE_ENABLED  0x10 ///< UART1 reception enabled.                         
3150      =1                                                                                                 
3151      =1  #define SCON1_PERR__BMASK           0x40 ///< Parity Error Flag                                
3152      =1  #define SCON1_PERR__SHIFT           0x06 ///< Parity Error Flag                                
3153      =1  #define SCON1_PERR__NOT_SET         0x00 ///< Parity error has not occurred.                   
3154      =1  #define SCON1_PERR__SET             0x40 ///< Parity error has occurred.                       
3155      =1                                                                                                 
3156      =1  #define SCON1_OVR__BMASK            0x80 ///< Receive FIFO Overrun Flag                        
3157      =1  #define SCON1_OVR__SHIFT            0x07 ///< Receive FIFO Overrun Flag                        
3158      =1  #define SCON1_OVR__NOT_SET          0x00 ///< Receive FIFO overrun has not occurred.           
3159      =1  #define SCON1_OVR__SET              0x80 ///< Receive FIFO overrun has occurred.               
3160      =1                                                                                                 
3161      =1  //------------------------------------------------------------------------------
3162      =1  // SMOD1 Enums (UART1 Mode @ 0xE5)
3163      =1  //------------------------------------------------------------------------------
3164      =1  #define SMOD1_SBL__BMASK          0x01 ///< Stop Bit Length                                 
3165      =1  #define SMOD1_SBL__SHIFT          0x00 ///< Stop Bit Length                                 
3166      =1  #define SMOD1_SBL__SHORT          0x00 ///< Short: Stop bit is active for one bit time.     
3167      =1  #define SMOD1_SBL__LONG           0x01 ///< Long: Stop bit is active for two bit times (data
3168      =1                                         ///< length = 6, 7, or 8 bits) or 1.5 bit times (data
3169      =1                                         ///< length = 5 bits).                               
3170      =1                                                                                              
3171      =1  #define SMOD1_XBE__BMASK          0x02 ///< Extra Bit Enable                                
3172      =1  #define SMOD1_XBE__SHIFT          0x01 ///< Extra Bit Enable                                
3173      =1  #define SMOD1_XBE__DISABLED       0x00 ///< Disable the extra bit.                          
3174      =1  #define SMOD1_XBE__ENABLED        0x02 ///< Enable the extra bit.                           
3175      =1                                                                                              
3176      =1  #define SMOD1_SDL__FMASK          0x0C ///< Data Length                                     
3177      =1  #define SMOD1_SDL__SHIFT          0x02 ///< Data Length                                     
3178      =1  #define SMOD1_SDL__5_BITS         0x00 ///< 5 bits.                                         
3179      =1  #define SMOD1_SDL__6_BITS         0x04 ///< 6 bits.                                         
3180      =1  #define SMOD1_SDL__7_BITS         0x08 ///< 7 bits.                                         
3181      =1  #define SMOD1_SDL__8_BITS         0x0C ///< 8 bits.                                         
3182      =1                                                                                              
3183      =1  #define SMOD1_PE__BMASK           0x10 ///< Parity Enable                                   
3184      =1  #define SMOD1_PE__SHIFT           0x04 ///< Parity Enable                                   
3185      =1  #define SMOD1_PE__PARITY_DISABLED 0x00 ///< Disable hardware parity.                        
3186      =1  #define SMOD1_PE__PARITY_ENABLED  0x10 ///< Enable hardware parity.                         
3187      =1                                                                                              
3188      =1  #define SMOD1_SPT__FMASK          0x60 ///< Parity Type                                     
3189      =1  #define SMOD1_SPT__SHIFT          0x05 ///< Parity Type                                     
3190      =1  #define SMOD1_SPT__ODD_PARITY     0x00 ///< Odd.                                            
3191      =1  #define SMOD1_SPT__EVEN_PARITY    0x20 ///< Even.                                           
3192      =1  #define SMOD1_SPT__MARK_PARITY    0x40 ///< Mark.                                           
3193      =1  #define SMOD1_SPT__SPACE_PARITY   0x60 ///< Space.                                          
3194      =1                                                                                              
3195      =1  #define SMOD1_MCE__BMASK          0x80 ///< Multiprocessor Communication Enable             
3196      =1  #define SMOD1_MCE__SHIFT          0x07 ///< Multiprocessor Communication Enable             
3197      =1  #define SMOD1_MCE__MULTI_DISABLED 0x00 ///< RI will be activated if the stop bits are 1.    
3198      =1  #define SMOD1_MCE__MULTI_ENABLED  0x80 ///< RI will be activated if the stop bits and extra 
3199      =1                                         ///< bit are 1. The extra bit must be enabled using  
3200      =1                                         ///< XBE.                                            
3201      =1                                                                                              
3202      =1  //------------------------------------------------------------------------------
3203      =1  // SBUF0 Enums (UART0 Serial Port Data Buffer @ 0x99)
3204      =1  //------------------------------------------------------------------------------
3205      =1  #define SBUF0_SBUF0__FMASK 0xFF ///< Serial Data Buffer
3206      =1  #define SBUF0_SBUF0__SHIFT 0x00 ///< Serial Data Buffer
C51 COMPILER V9.56.0.0   SPI_0                                                             10/28/2016 17:37:02 PAGE 79  

3207      =1                                                         
3208      =1  //------------------------------------------------------------------------------
3209      =1  // SCON0 Enums (UART0 Serial Port Control @ 0x98)
3210      =1  //------------------------------------------------------------------------------
3211      =1  #define SCON0_RI__BMASK             0x01 ///< Receive Interrupt Flag                           
3212      =1  #define SCON0_RI__SHIFT             0x00 ///< Receive Interrupt Flag                           
3213      =1  #define SCON0_RI__NOT_SET           0x00 ///< A byte of data has not been received by UART0.   
3214      =1  #define SCON0_RI__SET               0x01 ///< UART0 received a byte of data.                   
3215      =1                                                                                                 
3216      =1  #define SCON0_TI__BMASK             0x02 ///< Transmit Interrupt Flag                          
3217      =1  #define SCON0_TI__SHIFT             0x01 ///< Transmit Interrupt Flag                          
3218      =1  #define SCON0_TI__NOT_SET           0x00 ///< A byte of data has not been transmitted by UART0.
3219      =1  #define SCON0_TI__SET               0x02 ///< UART0 transmitted a byte of data.                
3220      =1                                                                                                 
3221      =1  #define SCON0_RB8__BMASK            0x04 ///< Ninth Receive Bit                                
3222      =1  #define SCON0_RB8__SHIFT            0x02 ///< Ninth Receive Bit                                
3223      =1  #define SCON0_RB8__CLEARED_TO_0     0x00 ///< In Mode 0, the STOP bit was 0. In Mode 1, the 9th
3224      =1                                           ///< bit was 0.                                       
3225      =1  #define SCON0_RB8__SET_TO_1         0x04 ///< In Mode 0, the STOP bit was 1. In Mode 1, the 9th
3226      =1                                           ///< bit was 1.                                       
3227      =1                                                                                                 
3228      =1  #define SCON0_TB8__BMASK            0x08 ///< Ninth Transmission Bit                           
3229      =1  #define SCON0_TB8__SHIFT            0x03 ///< Ninth Transmission Bit                           
3230      =1  #define SCON0_TB8__CLEARED_TO_0     0x00 ///< In Mode 1, set the 9th transmission bit to 0.    
3231      =1  #define SCON0_TB8__SET_TO_1         0x08 ///< In Mode 1, set the 9th transmission bit to 1.    
3232      =1                                                                                                 
3233      =1  #define SCON0_REN__BMASK            0x10 ///< Receive Enable                                   
3234      =1  #define SCON0_REN__SHIFT            0x04 ///< Receive Enable                                   
3235      =1  #define SCON0_REN__RECEIVE_DISABLED 0x00 ///< UART0 reception disabled.                        
3236      =1  #define SCON0_REN__RECEIVE_ENABLED  0x10 ///< UART0 reception enabled.                         
3237      =1                                                                                                 
3238      =1  #define SCON0_MCE__BMASK            0x20 ///< Multiprocessor Communication Enable              
3239      =1  #define SCON0_MCE__SHIFT            0x05 ///< Multiprocessor Communication Enable              
3240      =1  #define SCON0_MCE__MULTI_DISABLED   0x00 ///< Ignore level of 9th bit / Stop bit.              
3241      =1  #define SCON0_MCE__MULTI_ENABLED    0x20 ///< RI is set and an interrupt is generated only when
3242      =1                                           ///< the stop bit is logic 1 (Mode 0) or when the 9th 
3243      =1                                           ///< bit is logic 1 (Mode 1).                         
3244      =1                                                                                                 
3245      =1  #define SCON0_SMODE__BMASK          0x80 ///< Serial Port 0 Operation Mode                     
3246      =1  #define SCON0_SMODE__SHIFT          0x07 ///< Serial Port 0 Operation Mode                     
3247      =1  #define SCON0_SMODE__8_BIT          0x00 ///< 8-bit UART with Variable Baud Rate (Mode 0).     
3248      =1  #define SCON0_SMODE__9_BIT          0x80 ///< 9-bit UART with Variable Baud Rate (Mode 1).     
3249      =1                                                                                                 
3250      =1  //------------------------------------------------------------------------------
3251      =1  // CLKREC Enums (USB0 Clock Recovery Control @ 0x0F)
3252      =1  //------------------------------------------------------------------------------
3253      =1  #define CLKREC_CRLOW__BMASK      0x20 ///< Low Speed Clock Recovery Mode               
3254      =1  #define CLKREC_CRLOW__SHIFT      0x05 ///< Low Speed Clock Recovery Mode               
3255      =1  #define CLKREC_CRLOW__FULL_SPEED 0x00 ///< Full Speed Mode.                            
3256      =1  #define CLKREC_CRLOW__LOW_SPEED  0x20 ///< Low Speed Mode.                             
3257      =1                                                                                         
3258      =1  #define CLKREC_CRSSEN__BMASK     0x40 ///< Clock Recovery Single Step                  
3259      =1  #define CLKREC_CRSSEN__SHIFT     0x06 ///< Clock Recovery Single Step                  
3260      =1  #define CLKREC_CRSSEN__DISABLED  0x00 ///< Disable single-step mode (normal calibration
3261      =1                                        ///< mode).                                      
3262      =1  #define CLKREC_CRSSEN__ENABLED   0x40 ///< Enable single-step mode.                    
3263      =1                                                                                         
3264      =1  #define CLKREC_CRE__BMASK        0x80 ///< Clock Recovery Enable                       
3265      =1  #define CLKREC_CRE__SHIFT        0x07 ///< Clock Recovery Enable                       
3266      =1  #define CLKREC_CRE__DISABLED     0x00 ///< Disable clock recovery.                     
3267      =1  #define CLKREC_CRE__ENABLED      0x80 ///< Enable clock recovery.                      
3268      =1                                                                                         
C51 COMPILER V9.56.0.0   SPI_0                                                             10/28/2016 17:37:02 PAGE 80  

3269      =1  //------------------------------------------------------------------------------
3270      =1  // CMIE Enums (USB0 Common Interrupt Enable @ 0x0B)
3271      =1  //------------------------------------------------------------------------------
3272      =1  #define CMIE_SUSINTE__BMASK    0x01 ///< Suspend Interrupt Enable       
3273      =1  #define CMIE_SUSINTE__SHIFT    0x00 ///< Suspend Interrupt Enable       
3274      =1  #define CMIE_SUSINTE__DISABLED 0x00 ///< Disable suspend interrupts.    
3275      =1  #define CMIE_SUSINTE__ENABLED  0x01 ///< Enable suspend interrupts.     
3276      =1                                                                          
3277      =1  #define CMIE_RSUINTE__BMASK    0x02 ///< Resume Interrupt Enable        
3278      =1  #define CMIE_RSUINTE__SHIFT    0x01 ///< Resume Interrupt Enable        
3279      =1  #define CMIE_RSUINTE__DISABLED 0x00 ///< Disable resume interrupts.     
3280      =1  #define CMIE_RSUINTE__ENABLED  0x02 ///< Enable resume interrupts.      
3281      =1                                                                          
3282      =1  #define CMIE_RSTINTE__BMASK    0x04 ///< Reset Interrupt Enable         
3283      =1  #define CMIE_RSTINTE__SHIFT    0x02 ///< Reset Interrupt Enable         
3284      =1  #define CMIE_RSTINTE__DISABLED 0x00 ///< Disable reset interrupts.      
3285      =1  #define CMIE_RSTINTE__ENABLED  0x04 ///< Enable reset interrupts.       
3286      =1                                                                          
3287      =1  #define CMIE_SOFE__BMASK       0x08 ///< Start of Frame Interrupt Enable
3288      =1  #define CMIE_SOFE__SHIFT       0x03 ///< Start of Frame Interrupt Enable
3289      =1  #define CMIE_SOFE__DISABLED    0x00 ///< Disable SOF interrupts.        
3290      =1  #define CMIE_SOFE__ENABLED     0x08 ///< Enable SOF interrupts.         
3291      =1                                                                          
3292      =1  //------------------------------------------------------------------------------
3293      =1  // CMINT Enums (USB0 Common Interrupt @ 0x06)
3294      =1  //------------------------------------------------------------------------------
3295      =1  #define CMINT_SUSINT__BMASK   0x01 ///< Suspend Interrupt Flag       
3296      =1  #define CMINT_SUSINT__SHIFT   0x00 ///< Suspend Interrupt Flag       
3297      =1  #define CMINT_SUSINT__NOT_SET 0x00 ///< Suspend interrupt inactive.  
3298      =1  #define CMINT_SUSINT__SET     0x01 ///< Suspend interrupt active.    
3299      =1                                                                       
3300      =1  #define CMINT_RSUINT__BMASK   0x02 ///< Resume Interrupt Flag        
3301      =1  #define CMINT_RSUINT__SHIFT   0x01 ///< Resume Interrupt Flag        
3302      =1  #define CMINT_RSUINT__NOT_SET 0x00 ///< Resume interrupt inactive.   
3303      =1  #define CMINT_RSUINT__SET     0x02 ///< Resume interrupt active.     
3304      =1                                                                       
3305      =1  #define CMINT_RSTINT__BMASK   0x04 ///< Reset Interrupt Flag         
3306      =1  #define CMINT_RSTINT__SHIFT   0x02 ///< Reset Interrupt Flag         
3307      =1  #define CMINT_RSTINT__NOT_SET 0x00 ///< Reset interrupt inactive.    
3308      =1  #define CMINT_RSTINT__SET     0x04 ///< Reset interrupt active.      
3309      =1                                                                       
3310      =1  #define CMINT_SOF__BMASK      0x08 ///< Start of Frame Interrupt Flag
3311      =1  #define CMINT_SOF__SHIFT      0x03 ///< Start of Frame Interrupt Flag
3312      =1  #define CMINT_SOF__NOT_SET    0x00 ///< SOF interrupt inactive.      
3313      =1  #define CMINT_SOF__SET        0x08 ///< SOF interrupt active.        
3314      =1                                                                       
3315      =1  //------------------------------------------------------------------------------
3316      =1  // E0CNT Enums (USB0 Endpoint0 Data Count @ 0x16)
3317      =1  //------------------------------------------------------------------------------
3318      =1  #define E0CNT_E0CNT__FMASK 0x7F ///< Endpoint 0 Data Count
3319      =1  #define E0CNT_E0CNT__SHIFT 0x00 ///< Endpoint 0 Data Count
3320      =1                                                            
3321      =1  //------------------------------------------------------------------------------
3322      =1  // E0CSR Enums (USB0 Endpoint0 Control @ 0x11)
3323      =1  //------------------------------------------------------------------------------
3324      =1  #define E0CSR_OPRDY__BMASK     0x01 ///< OUT Packet Ready                                  
3325      =1  #define E0CSR_OPRDY__SHIFT     0x00 ///< OUT Packet Ready                                  
3326      =1  #define E0CSR_OPRDY__NOT_SET   0x00 ///< A data packet has not been received.              
3327      =1  #define E0CSR_OPRDY__SET       0x01 ///< A data packet has been received.                  
3328      =1                                                                                             
3329      =1  #define E0CSR_INPRDY__BMASK    0x02 ///< IN Packet Ready                                   
3330      =1  #define E0CSR_INPRDY__SHIFT    0x01 ///< IN Packet Ready                                   
C51 COMPILER V9.56.0.0   SPI_0                                                             10/28/2016 17:37:02 PAGE 81  

3331      =1  #define E0CSR_INPRDY__NOT_SET  0x00 ///< An IN packet is not ready to transmit.            
3332      =1  #define E0CSR_INPRDY__SET      0x02 ///< An IN packet is ready to transmit.                
3333      =1                                                                                             
3334      =1  #define E0CSR_STSTL__BMASK     0x04 ///< Sent Stall                                        
3335      =1  #define E0CSR_STSTL__SHIFT     0x02 ///< Sent Stall                                        
3336      =1  #define E0CSR_STSTL__NOT_SET   0x00 ///< A STALL handshake signal was not transmitted.     
3337      =1  #define E0CSR_STSTL__SET       0x04 ///< A STALL handshake signal was transmitted.         
3338      =1                                                                                             
3339      =1  #define E0CSR_DATAEND__BMASK   0x08 ///< Data End                                          
3340      =1  #define E0CSR_DATAEND__SHIFT   0x03 ///< Data End                                          
3341      =1  #define E0CSR_DATAEND__NOT_SET 0x00 ///< This is not the last data packet.                 
3342      =1  #define E0CSR_DATAEND__SET     0x08 ///< This is the last data packet.                     
3343      =1                                                                                             
3344      =1  #define E0CSR_SUEND__BMASK     0x10 ///< Setup End                                         
3345      =1  #define E0CSR_SUEND__SHIFT     0x04 ///< Setup End                                         
3346      =1  #define E0CSR_SUEND__NOT_SET   0x00 ///< A control transaction did not end before firmware 
3347      =1                                      ///< wrote a 1 to the DATAEND bit.                     
3348      =1  #define E0CSR_SUEND__SET       0x10 ///< A control transaction ended before firmware wrote 
3349      =1                                      ///< a 1 to the DATAEND bit.                           
3350      =1                                                                                             
3351      =1  #define E0CSR_SDSTL__BMASK     0x20 ///< Send Stall                                        
3352      =1  #define E0CSR_SDSTL__SHIFT     0x05 ///< Send Stall                                        
3353      =1  #define E0CSR_SDSTL__NOT_SET   0x00 ///< Do not send a STALL.                              
3354      =1  #define E0CSR_SDSTL__SET       0x20 ///< Send a STALL.                                     
3355      =1                                                                                             
3356      =1  #define E0CSR_SOPRDY__BMASK    0x40 ///< Serviced OPRDY                                    
3357      =1  #define E0CSR_SOPRDY__SHIFT    0x06 ///< Serviced OPRDY                                    
3358      =1  #define E0CSR_SOPRDY__NOT_SET  0x00 ///< OUT packet has not been serviced.                 
3359      =1  #define E0CSR_SOPRDY__SET      0x40 ///< OUT packet has been serviced.                     
3360      =1                                                                                             
3361      =1  #define E0CSR_SSUEND__BMASK    0x80 ///< Serviced Setup End                                
3362      =1  #define E0CSR_SSUEND__SHIFT    0x07 ///< Serviced Setup End                                
3363      =1  #define E0CSR_SSUEND__NOT_SET  0x00 ///< The setup end (SUEND) event has not been serviced.
3364      =1  #define E0CSR_SSUEND__SET      0x80 ///< The setup end (SUEND) event has been serviced.    
3365      =1                                                                                             
3366      =1  //------------------------------------------------------------------------------
3367      =1  // EENABLE Enums (USB0 Endpoint Enable @ 0x1E)
3368      =1  //------------------------------------------------------------------------------
3369      =1  #define EENABLE_EEN1__BMASK    0x02 ///< Endpoint 1 Enable                                
3370      =1  #define EENABLE_EEN1__SHIFT    0x01 ///< Endpoint 1 Enable                                
3371      =1  #define EENABLE_EEN1__DISABLED 0x00 ///< Disable Endpoint 1 (no NACK, ACK, or STALL on the
3372      =1                                      ///< USB network).                                    
3373      =1  #define EENABLE_EEN1__ENABLED  0x02 ///< Enable Endpoint 1 (normal).                      
3374      =1                                                                                            
3375      =1  #define EENABLE_EEN2__BMASK    0x04 ///< Endpoint 2 Enable                                
3376      =1  #define EENABLE_EEN2__SHIFT    0x02 ///< Endpoint 2 Enable                                
3377      =1  #define EENABLE_EEN2__DISABLED 0x00 ///< Disable Endpoint 2 (no NACK, ACK, or STALL on the
3378      =1                                      ///< USB network).                                    
3379      =1  #define EENABLE_EEN2__ENABLED  0x04 ///< Enable Endpoint 2 (normal).                      
3380      =1                                                                                            
3381      =1  #define EENABLE_EEN3__BMASK    0x08 ///< Endpoint 3 Enable                                
3382      =1  #define EENABLE_EEN3__SHIFT    0x03 ///< Endpoint 3 Enable                                
3383      =1  #define EENABLE_EEN3__DISABLED 0x00 ///< Disable Endpoint 3 (no NACK, ACK, or STALL on the
3384      =1                                      ///< USB network).                                    
3385      =1  #define EENABLE_EEN3__ENABLED  0x08 ///< Enable Endpoint 3 (normal).                      
3386      =1                                                                                            
3387      =1  //------------------------------------------------------------------------------
3388      =1  // EINCSRH Enums (USB0 IN Endpoint Control High @ 0x12)
3389      =1  //------------------------------------------------------------------------------
3390      =1  #define EINCSRH_SPLIT__BMASK        0x04 ///< FIFO Split Enable                                
3391      =1  #define EINCSRH_SPLIT__SHIFT        0x02 ///< FIFO Split Enable                                
3392      =1  #define EINCSRH_SPLIT__DISABLED     0x00 ///< Disable split mode.                              
C51 COMPILER V9.56.0.0   SPI_0                                                             10/28/2016 17:37:02 PAGE 82  

3393      =1  #define EINCSRH_SPLIT__ENABLED      0x04 ///< Enable split mode.                               
3394      =1                                                                                                 
3395      =1  #define EINCSRH_FCDT__BMASK         0x08 ///< Force Data Toggle                                
3396      =1  #define EINCSRH_FCDT__SHIFT         0x03 ///< Force Data Toggle                                
3397      =1  #define EINCSRH_FCDT__ACK_TOGGLE    0x00 ///< Endpoint data toggle switches only when an ACK is
3398      =1                                           ///< received following a data packet transmission.   
3399      =1  #define EINCSRH_FCDT__ALWAYS_TOGGLE 0x08 ///< Endpoint data toggle forced to switch after every
3400      =1                                           ///< data packet is transmitted, regardless of ACK    
3401      =1                                           ///< reception.                                       
3402      =1                                                                                                 
3403      =1  #define EINCSRH_DIRSEL__BMASK       0x20 ///< Endpoint Direction Select                        
3404      =1  #define EINCSRH_DIRSEL__SHIFT       0x05 ///< Endpoint Direction Select                        
3405      =1  #define EINCSRH_DIRSEL__OUT         0x00 ///< Endpoint direction selected as OUT.              
3406      =1  #define EINCSRH_DIRSEL__IN          0x20 ///< Endpoint direction selected as IN.               
3407      =1                                                                                                 
3408      =1  #define EINCSRH_ISO__BMASK          0x40 ///< Isochronous Transfer Enable                      
3409      =1  #define EINCSRH_ISO__SHIFT          0x06 ///< Isochronous Transfer Enable                      
3410      =1  #define EINCSRH_ISO__DISABLED       0x00 ///< Endpoint configured for Bulk/Interrupt transfers.
3411      =1  #define EINCSRH_ISO__ENABLED        0x40 ///< Endpoint configured for Isochronous transfers.   
3412      =1                                                                                                 
3413      =1  #define EINCSRH_DBIEN__BMASK        0x80 ///< IN Endpoint Double-Buffer Enable                 
3414      =1  #define EINCSRH_DBIEN__SHIFT        0x07 ///< IN Endpoint Double-Buffer Enable                 
3415      =1  #define EINCSRH_DBIEN__DISABLED     0x00 ///< Disable double-buffering for the selected IN     
3416      =1                                           ///< endpoint.                                        
3417      =1  #define EINCSRH_DBIEN__ENABLED      0x80 ///< Enable double-buffering for the selected IN      
3418      =1                                           ///< endpoint.                                        
3419      =1                                                                                                 
3420      =1  //------------------------------------------------------------------------------
3421      =1  // EINCSRL Enums (USB0 IN Endpoint Control Low @ 0x11)
3422      =1  //------------------------------------------------------------------------------
3423      =1  #define EINCSRL_INPRDY__BMASK     0x01 ///< In Packet Ready                                   
3424      =1  #define EINCSRL_INPRDY__SHIFT     0x00 ///< In Packet Ready                                   
3425      =1  #define EINCSRL_INPRDY__NOT_SET   0x00 ///< A packet is not available in the Endpoint IN FIFO.
3426      =1  #define EINCSRL_INPRDY__SET       0x01 ///< A packet is available in the Endpoint IN FIFO.    
3427      =1                                                                                                
3428      =1  #define EINCSRL_FIFONE__BMASK     0x02 ///< FIFO Not Empty                                    
3429      =1  #define EINCSRL_FIFONE__SHIFT     0x01 ///< FIFO Not Empty                                    
3430      =1  #define EINCSRL_FIFONE__EMPTY     0x00 ///< The IN Endpoint FIFO is empty.                    
3431      =1  #define EINCSRL_FIFONE__NOT_EMPTY 0x02 ///< The IN Endpoint FIFO contains one or more packets.
3432      =1                                                                                                
3433      =1  #define EINCSRL_UNDRUN__BMASK     0x04 ///< Data Underrun Flag                                
3434      =1  #define EINCSRL_UNDRUN__SHIFT     0x02 ///< Data Underrun Flag                                
3435      =1  #define EINCSRL_UNDRUN__NOT_SET   0x00 ///< A data underrun did not occur.                    
3436      =1  #define EINCSRL_UNDRUN__SET       0x04 ///< A data underrun occurred.                         
3437      =1                                                                                                
3438      =1  #define EINCSRL_FLUSH__BMASK      0x08 ///< FIFO Flush                                        
3439      =1  #define EINCSRL_FLUSH__SHIFT      0x03 ///< FIFO Flush                                        
3440      =1  #define EINCSRL_FLUSH__NOT_SET    0x00 ///< Do not flush the next packet.                     
3441      =1  #define EINCSRL_FLUSH__SET        0x08 ///< Flush the next packet to be transmitted from the  
3442      =1                                         ///< IN Endpoint FIFO.                                 
3443      =1                                                                                                
3444      =1  #define EINCSRL_SDSTL__BMASK      0x10 ///< Send Stall                                        
3445      =1  #define EINCSRL_SDSTL__SHIFT      0x04 ///< Send Stall                                        
3446      =1  #define EINCSRL_SDSTL__NOT_SET    0x00 ///< Terminate the STALL.                              
3447      =1  #define EINCSRL_SDSTL__SET        0x10 ///< Generate a STALL in response to an IN token.      
3448      =1                                                                                                
3449      =1  #define EINCSRL_STSTL__BMASK      0x20 ///< Sent Stall Flag                                   
3450      =1  #define EINCSRL_STSTL__SHIFT      0x05 ///< Sent Stall Flag                                   
3451      =1  #define EINCSRL_STSTL__NOT_SET    0x00 ///< A STALL handshake was not transmitted.            
3452      =1  #define EINCSRL_STSTL__SET        0x20 ///< A STALL handshake was transmitted.                
3453      =1                                                                                                
3454      =1  #define EINCSRL_CLRDT__BMASK      0x40 ///< Clear Data Toggle                                 
C51 COMPILER V9.56.0.0   SPI_0                                                             10/28/2016 17:37:02 PAGE 83  

3455      =1  #define EINCSRL_CLRDT__SHIFT      0x06 ///< Clear Data Toggle                                 
3456      =1  #define EINCSRL_CLRDT__CLEAR      0x00 ///< Clear the IN Endpoint data toggle.                
3457      =1                                                                                                
3458      =1  //------------------------------------------------------------------------------
3459      =1  // EOUTCNTH Enums (USB0 OUT Endpoint Count High @ 0x17)
3460      =1  //------------------------------------------------------------------------------
3461      =1  #define EOUTCNTH_EOCH__FMASK 0x03 ///< OUT Endpoint Count High
3462      =1  #define EOUTCNTH_EOCH__SHIFT 0x00 ///< OUT Endpoint Count High
3463      =1                                                                
3464      =1  //------------------------------------------------------------------------------
3465      =1  // EOUTCNTL Enums (USB0 OUT Endpoint Count Low @ 0x16)
3466      =1  //------------------------------------------------------------------------------
3467      =1  #define EOUTCNTL_EOCL__FMASK 0xFF ///< OUT Endpoint Count Low
3468      =1  #define EOUTCNTL_EOCL__SHIFT 0x00 ///< OUT Endpoint Count Low
3469      =1                                                               
3470      =1  //------------------------------------------------------------------------------
3471      =1  // EOUTCSRH Enums (USB0 OUT Endpoint Control High @ 0x15)
3472      =1  //------------------------------------------------------------------------------
3473      =1  #define EOUTCSRH_ISO__BMASK      0x40 ///< Isochronous Transfer Enable                      
3474      =1  #define EOUTCSRH_ISO__SHIFT      0x06 ///< Isochronous Transfer Enable                      
3475      =1  #define EOUTCSRH_ISO__DISABLED   0x00 ///< Endpoint configured for Bulk/Interrupt transfers.
3476      =1  #define EOUTCSRH_ISO__ENABLED    0x40 ///< Endpoint configured for Isochronous transfers.   
3477      =1                                                                                              
3478      =1  #define EOUTCSRH_DBOEN__BMASK    0x80 ///< Double-Buffer Enable                             
3479      =1  #define EOUTCSRH_DBOEN__SHIFT    0x07 ///< Double-Buffer Enable                             
3480      =1  #define EOUTCSRH_DBOEN__DISABLED 0x00 ///< Disable double-buffering for the selected OUT    
3481      =1                                        ///< endpoint.                                        
3482      =1  #define EOUTCSRH_DBOEN__ENABLED  0x80 ///< Enable double-buffering for the selected OUT     
3483      =1                                        ///< endpoint.                                        
3484      =1                                                                                              
3485      =1  //------------------------------------------------------------------------------
3486      =1  // EOUTCSRL Enums (USB0 OUT Endpoint Control Low @ 0x14)
3487      =1  //------------------------------------------------------------------------------
3488      =1  #define EOUTCSRL_OPRDY__BMASK      0x01 ///< OUT Packet Ready                                  
3489      =1  #define EOUTCSRL_OPRDY__SHIFT      0x00 ///< OUT Packet Ready                                  
3490      =1  #define EOUTCSRL_OPRDY__NOT_SET    0x00 ///< A data packet is not available in the Endpoint OUT
3491      =1                                          ///< FIFO.                                             
3492      =1  #define EOUTCSRL_OPRDY__SET        0x01 ///< A data packet is available in the Endpoint OUT    
3493      =1                                          ///< FIFO.                                             
3494      =1                                                                                                 
3495      =1  #define EOUTCSRL_FIFOFUL__BMASK    0x02 ///< OUT FIFO Full                                     
3496      =1  #define EOUTCSRL_FIFOFUL__SHIFT    0x01 ///< OUT FIFO Full                                     
3497      =1  #define EOUTCSRL_FIFOFUL__NOT_FULL 0x00 ///< OUT endpoint FIFO is not full.                    
3498      =1  #define EOUTCSRL_FIFOFUL__FULL     0x02 ///< OUT endpoint FIFO is full.                        
3499      =1                                                                                                 
3500      =1  #define EOUTCSRL_OVRUN__BMASK      0x04 ///< Data Overrun Flag                                 
3501      =1  #define EOUTCSRL_OVRUN__SHIFT      0x02 ///< Data Overrun Flag                                 
3502      =1  #define EOUTCSRL_OVRUN__NOT_SET    0x00 ///< No data overrun.                                  
3503      =1  #define EOUTCSRL_OVRUN__SET        0x04 ///< A data packet was lost because of a full FIFO     
3504      =1                                          ///< since this flag was last cleared.                 
3505      =1                                                                                                 
3506      =1  #define EOUTCSRL_DATERR__BMASK     0x08 ///< Data Error Flag                                   
3507      =1  #define EOUTCSRL_DATERR__SHIFT     0x03 ///< Data Error Flag                                   
3508      =1  #define EOUTCSRL_DATERR__NOT_SET   0x00 ///< A received packet does not have a CRC or bit-     
3509      =1                                          ///< stuffing error.                                   
3510      =1  #define EOUTCSRL_DATERR__SET       0x08 ///< A received packet has a CRC or bit-stuffing error.
3511      =1                                                                                                 
3512      =1  #define EOUTCSRL_FLUSH__BMASK      0x10 ///< FIFO Flush                                        
3513      =1  #define EOUTCSRL_FLUSH__SHIFT      0x04 ///< FIFO Flush                                        
3514      =1  #define EOUTCSRL_FLUSH__NOT_SET    0x00 ///< Do not flush the next packet.                     
3515      =1  #define EOUTCSRL_FLUSH__SET        0x10 ///< Flush the next packet to be read from the OUT     
3516      =1                                          ///< endpoint FIFO.                                    
C51 COMPILER V9.56.0.0   SPI_0                                                             10/28/2016 17:37:02 PAGE 84  

3517      =1                                                                                                 
3518      =1  #define EOUTCSRL_SDSTL__BMASK      0x20 ///< Send Stall                                        
3519      =1  #define EOUTCSRL_SDSTL__SHIFT      0x05 ///< Send Stall                                        
3520      =1  #define EOUTCSRL_SDSTL__NOT_SET    0x00 ///< Terminate the STALL.                              
3521      =1  #define EOUTCSRL_SDSTL__SET        0x20 ///< Generate a STALL handshake.                       
3522      =1                                                                                                 
3523      =1  #define EOUTCSRL_STSTL__BMASK      0x40 ///< Sent Stall Flag                                   
3524      =1  #define EOUTCSRL_STSTL__SHIFT      0x06 ///< Sent Stall Flag                                   
3525      =1  #define EOUTCSRL_STSTL__NOT_SET    0x00 ///< A STALL handshake was not transmitted.            
3526      =1  #define EOUTCSRL_STSTL__SET        0x40 ///< A STALL handshake was transmitted.                
3527      =1                                                                                                 
3528      =1  #define EOUTCSRL_CLRDT__BMASK      0x80 ///< Clear Data Toggle                                 
3529      =1  #define EOUTCSRL_CLRDT__SHIFT      0x07 ///< Clear Data Toggle                                 
3530      =1  #define EOUTCSRL_CLRDT__CLEAR      0x00 ///< Clear the OUT Endpoint data toggle.               
3531      =1                                                                                                 
3532      =1  //------------------------------------------------------------------------------
3533      =1  // FADDR Enums (USB0 Function Address @ 0x00)
3534      =1  //------------------------------------------------------------------------------
3535      =1  #define FADDR_FADDR__FMASK    0x7F ///< Function Address                               
3536      =1  #define FADDR_FADDR__SHIFT    0x00 ///< Function Address                               
3537      =1                                                                                         
3538      =1  #define FADDR_UPDATE__BMASK   0x80 ///< Function Address Update                        
3539      =1  #define FADDR_UPDATE__SHIFT   0x07 ///< Function Address Update                        
3540      =1  #define FADDR_UPDATE__NOT_SET 0x00 ///< The last address written to FADDR is in effect.
3541      =1  #define FADDR_UPDATE__SET     0x80 ///< The last address written to FADDR is not yet in
3542      =1                                     ///< effect.                                        
3543      =1                                                                                         
3544      =1  //------------------------------------------------------------------------------
3545      =1  // FIFO0 Enums (USB0 Endpoint 0 FIFO Access @ 0x20)
3546      =1  //------------------------------------------------------------------------------
3547      =1  #define FIFO0_FIFODATA__FMASK 0xFF ///< Endpoint 0 FIFO Access
3548      =1  #define FIFO0_FIFODATA__SHIFT 0x00 ///< Endpoint 0 FIFO Access
3549      =1                                                                
3550      =1  //------------------------------------------------------------------------------
3551      =1  // FIFO1 Enums (USB0 Endpoint 1 FIFO Access @ 0x21)
3552      =1  //------------------------------------------------------------------------------
3553      =1  #define FIFO1_FIFODATA__FMASK 0xFF ///< Endpoint 1 FIFO Access
3554      =1  #define FIFO1_FIFODATA__SHIFT 0x00 ///< Endpoint 1 FIFO Access
3555      =1                                                                
3556      =1  //------------------------------------------------------------------------------
3557      =1  // FIFO2 Enums (USB0 Endpoint 2 FIFO Access @ 0x22)
3558      =1  //------------------------------------------------------------------------------
3559      =1  #define FIFO2_FIFODATA__FMASK 0xFF ///< Endpoint 2 FIFO Access
3560      =1  #define FIFO2_FIFODATA__SHIFT 0x00 ///< Endpoint 2 FIFO Access
3561      =1                                                                
3562      =1  //------------------------------------------------------------------------------
3563      =1  // FIFO3 Enums (USB0 Endpoint 3 FIFO Access @ 0x23)
3564      =1  //------------------------------------------------------------------------------
3565      =1  #define FIFO3_FIFODATA__FMASK 0xFF ///< Endpoint 3 FIFO Access
3566      =1  #define FIFO3_FIFODATA__SHIFT 0x00 ///< Endpoint 3 FIFO Access
3567      =1                                                                
3568      =1  //------------------------------------------------------------------------------
3569      =1  // FRAMEH Enums (USB0 Frame Number High @ 0x0D)
3570      =1  //------------------------------------------------------------------------------
3571      =1  #define FRAMEH_FRMEH__FMASK 0x07 ///< Frame Number High
3572      =1  #define FRAMEH_FRMEH__SHIFT 0x00 ///< Frame Number High
3573      =1                                                         
3574      =1  //------------------------------------------------------------------------------
3575      =1  // FRAMEL Enums (USB0 Frame Number Low @ 0x0C)
3576      =1  //------------------------------------------------------------------------------
3577      =1  #define FRAMEL_FRMEL__FMASK 0xFF ///< Frame Number Low
3578      =1  #define FRAMEL_FRMEL__SHIFT 0x00 ///< Frame Number Low
C51 COMPILER V9.56.0.0   SPI_0                                                             10/28/2016 17:37:02 PAGE 85  

3579      =1                                                        
3580      =1  //------------------------------------------------------------------------------
3581      =1  // IN1IE Enums (USB0 IN Endpoint Interrupt Enable @ 0x07)
3582      =1  //------------------------------------------------------------------------------
3583      =1  #define IN1IE_EP0E__BMASK    0x01 ///< Endpoint 0 Interrupt Enable      
3584      =1  #define IN1IE_EP0E__SHIFT    0x00 ///< Endpoint 0 Interrupt Enable      
3585      =1  #define IN1IE_EP0E__DISABLED 0x00 ///< Disable Endpoint 0 interrupts.   
3586      =1  #define IN1IE_EP0E__ENABLED  0x01 ///< Enable Endpoint 0 interrupts.    
3587      =1                                                                          
3588      =1  #define IN1IE_IN1E__BMASK    0x02 ///< IN Endpoint 1 Interrupt Enable   
3589      =1  #define IN1IE_IN1E__SHIFT    0x01 ///< IN Endpoint 1 Interrupt Enable   
3590      =1  #define IN1IE_IN1E__DISABLED 0x00 ///< Disable Endpoint 1 IN interrupts.
3591      =1  #define IN1IE_IN1E__ENABLED  0x02 ///< Enable Endpoint 1 IN interrupts. 
3592      =1                                                                          
3593      =1  #define IN1IE_IN2E__BMASK    0x04 ///< IN Endpoint 2 Interrupt Enable   
3594      =1  #define IN1IE_IN2E__SHIFT    0x02 ///< IN Endpoint 2 Interrupt Enable   
3595      =1  #define IN1IE_IN2E__DISABLED 0x00 ///< Disable Endpoint 2 IN interrupts.
3596      =1  #define IN1IE_IN2E__ENABLED  0x04 ///< Enable Endpoint 2 IN interrupts. 
3597      =1                                                                          
3598      =1  #define IN1IE_IN3E__BMASK    0x08 ///< IN Endpoint 3 Interrupt Enable   
3599      =1  #define IN1IE_IN3E__SHIFT    0x03 ///< IN Endpoint 3 Interrupt Enable   
3600      =1  #define IN1IE_IN3E__DISABLED 0x00 ///< Disable Endpoint 3 IN interrupts.
3601      =1  #define IN1IE_IN3E__ENABLED  0x08 ///< Enable Endpoint 3 IN interrupts. 
3602      =1                                                                          
3603      =1  //------------------------------------------------------------------------------
3604      =1  // IN1INT Enums (USB0 IN Endpoint Interrupt @ 0x02)
3605      =1  //------------------------------------------------------------------------------
3606      =1  #define IN1INT_EP0__BMASK   0x01 ///< Endpoint 0 Interrupt Flag        
3607      =1  #define IN1INT_EP0__SHIFT   0x00 ///< Endpoint 0 Interrupt Flag        
3608      =1  #define IN1INT_EP0__NOT_SET 0x00 ///< Endpoint 0 interrupt inactive.   
3609      =1  #define IN1INT_EP0__SET     0x01 ///< Endpoint 0 interrupt active.     
3610      =1                                                                         
3611      =1  #define IN1INT_IN1__BMASK   0x02 ///< IN Endpoint 1 Interrupt Flag     
3612      =1  #define IN1INT_IN1__SHIFT   0x01 ///< IN Endpoint 1 Interrupt Flag     
3613      =1  #define IN1INT_IN1__NOT_SET 0x00 ///< IN Endpoint 1 interrupt inactive.
3614      =1  #define IN1INT_IN1__SET     0x02 ///< IN Endpoint 1 interrupt active.  
3615      =1                                                                         
3616      =1  #define IN1INT_IN2__BMASK   0x04 ///< IN Endpoint 2 Interrupt Flag     
3617      =1  #define IN1INT_IN2__SHIFT   0x02 ///< IN Endpoint 2 Interrupt Flag     
3618      =1  #define IN1INT_IN2__NOT_SET 0x00 ///< IN Endpoint 2 interrupt inactive.
3619      =1  #define IN1INT_IN2__SET     0x04 ///< IN Endpoint 2 interrupt active.  
3620      =1                                                                         
3621      =1  #define IN1INT_IN3__BMASK   0x08 ///< IN Endpoint 3 Interrupt Flag     
3622      =1  #define IN1INT_IN3__SHIFT   0x03 ///< IN Endpoint 3 Interrupt Flag     
3623      =1  #define IN1INT_IN3__NOT_SET 0x00 ///< IN Endpoint 3 interrupt inactive.
3624      =1  #define IN1INT_IN3__SET     0x08 ///< IN Endpoint 3 interrupt active.  
3625      =1                                                                         
3626      =1  //------------------------------------------------------------------------------
3627      =1  // INDEX Enums (USB0 Endpoint Index @ 0x0E)
3628      =1  //------------------------------------------------------------------------------
3629      =1  #define INDEX_EPSEL__FMASK      0x0F ///< Endpoint Select Bits
3630      =1  #define INDEX_EPSEL__SHIFT      0x00 ///< Endpoint Select Bits
3631      =1  #define INDEX_EPSEL__ENDPOINT_0 0x00 ///< Endpoint 0.         
3632      =1  #define INDEX_EPSEL__ENDPOINT_1 0x01 ///< Endpoint 1.         
3633      =1  #define INDEX_EPSEL__ENDPOINT_2 0x02 ///< Endpoint 2.         
3634      =1  #define INDEX_EPSEL__ENDPOINT_3 0x03 ///< Endpoint 3.         
3635      =1                                                                
3636      =1  //------------------------------------------------------------------------------
3637      =1  // OUT1IE Enums (USB0 OUT Endpoint Interrupt Enable @ 0x09)
3638      =1  //------------------------------------------------------------------------------
3639      =1  #define OUT1IE_OUT1E__BMASK    0x02 ///< OUT Endpoint 1 Interrupt Enable   
3640      =1  #define OUT1IE_OUT1E__SHIFT    0x01 ///< OUT Endpoint 1 Interrupt Enable   
C51 COMPILER V9.56.0.0   SPI_0                                                             10/28/2016 17:37:02 PAGE 86  

3641      =1  #define OUT1IE_OUT1E__DISABLED 0x00 ///< Disable Endpoint 1 OUT interrupts.
3642      =1  #define OUT1IE_OUT1E__ENABLED  0x02 ///< Enable Endpoint 1 OUT interrupts. 
3643      =1                                                                             
3644      =1  #define OUT1IE_OUT2E__BMASK    0x04 ///< OUT Endpoint 2 Interrupt Enable   
3645      =1  #define OUT1IE_OUT2E__SHIFT    0x02 ///< OUT Endpoint 2 Interrupt Enable   
3646      =1  #define OUT1IE_OUT2E__DISABLED 0x00 ///< Disable Endpoint 2 OUT interrupts.
3647      =1  #define OUT1IE_OUT2E__ENABLED  0x04 ///< Enable Endpoint 2 OUT interrupts. 
3648      =1                                                                             
3649      =1  #define OUT1IE_OUT3E__BMASK    0x08 ///< OUT Endpoint 3 Interrupt Enable   
3650      =1  #define OUT1IE_OUT3E__SHIFT    0x03 ///< OUT Endpoint 3 Interrupt Enable   
3651      =1  #define OUT1IE_OUT3E__DISABLED 0x00 ///< Disable Endpoint 3 OUT interrupts.
3652      =1  #define OUT1IE_OUT3E__ENABLED  0x08 ///< Enable Endpoint 3 OUT interrupts. 
3653      =1                                                                             
3654      =1  //------------------------------------------------------------------------------
3655      =1  // OUT1INT Enums (USB0 OUT Endpoint Interrupt @ 0x04)
3656      =1  //------------------------------------------------------------------------------
3657      =1  #define OUT1INT_OUT1__BMASK   0x02 ///< OUT Endpoint 1 Interrupt Flag     
3658      =1  #define OUT1INT_OUT1__SHIFT   0x01 ///< OUT Endpoint 1 Interrupt Flag     
3659      =1  #define OUT1INT_OUT1__NOT_SET 0x00 ///< OUT Endpoint 1 interrupt inactive.
3660      =1  #define OUT1INT_OUT1__SET     0x02 ///< OUT Endpoint 1 interrupt active.  
3661      =1                                                                            
3662      =1  #define OUT1INT_OUT2__BMASK   0x04 ///< OUT Endpoint 2 Interrupt Flag     
3663      =1  #define OUT1INT_OUT2__SHIFT   0x02 ///< OUT Endpoint 2 Interrupt Flag     
3664      =1  #define OUT1INT_OUT2__NOT_SET 0x00 ///< OUT Endpoint 2 interrupt inactive.
3665      =1  #define OUT1INT_OUT2__SET     0x04 ///< OUT Endpoint 2 interrupt active.  
3666      =1                                                                            
3667      =1  #define OUT1INT_OUT3__BMASK   0x08 ///< OUT Endpoint 3 Interrupt Flag     
3668      =1  #define OUT1INT_OUT3__SHIFT   0x03 ///< OUT Endpoint 3 Interrupt Flag     
3669      =1  #define OUT1INT_OUT3__NOT_SET 0x00 ///< OUT Endpoint 3 interrupt inactive.
3670      =1  #define OUT1INT_OUT3__SET     0x08 ///< OUT Endpoint 3 interrupt active.  
3671      =1                                                                            
3672      =1  //------------------------------------------------------------------------------
3673      =1  // POWER Enums (USB0 Power @ 0x01)
3674      =1  //------------------------------------------------------------------------------
3675      =1  #define POWER_SUSEN__BMASK         0x01 ///< Suspend Detection Enable                          
3676      =1  #define POWER_SUSEN__SHIFT         0x00 ///< Suspend Detection Enable                          
3677      =1  #define POWER_SUSEN__DISABLED      0x00 ///< Disable suspend detection. USB0 will ignore       
3678      =1                                          ///< suspend signaling on the bus.                     
3679      =1  #define POWER_SUSEN__ENABLED       0x01 ///< Enable suspend detection. USB0 will enter suspend 
3680      =1                                          ///< mode if it detects suspend signaling on the bus.  
3681      =1                                                                                                 
3682      =1  #define POWER_SUSMD__BMASK         0x02 ///< Suspend Mode                                      
3683      =1  #define POWER_SUSMD__SHIFT         0x01 ///< Suspend Mode                                      
3684      =1  #define POWER_SUSMD__NOT_SUSPENDED 0x00 ///< USB0 not in suspend mode.                         
3685      =1  #define POWER_SUSMD__SUSPENDED     0x02 ///< USB0 in suspend mode.                             
3686      =1                                                                                                 
3687      =1  #define POWER_RESUME__BMASK        0x04 ///< Force Resume                                      
3688      =1  #define POWER_RESUME__SHIFT        0x02 ///< Force Resume                                      
3689      =1  #define POWER_RESUME__START        0x04 ///< Generate resume signalling to create a remote     
3690      =1                                          ///< wakeup event.                                     
3691      =1                                                                                                 
3692      =1  #define POWER_USBRST__BMASK        0x08 ///< Reset Detect                                      
3693      =1  #define POWER_USBRST__SHIFT        0x03 ///< Reset Detect                                      
3694      =1  #define POWER_USBRST__NOT_SET      0x00 ///< USB reset signalling not detected.                
3695      =1  #define POWER_USBRST__SET          0x08 ///< USB reset signalling detected.                    
3696      =1                                                                                                 
3697      =1  #define POWER_USBINH__BMASK        0x10 ///< USB0 Inhibit                                      
3698      =1  #define POWER_USBINH__SHIFT        0x04 ///< USB0 Inhibit                                      
3699      =1  #define POWER_USBINH__ENABLED      0x00 ///< USB0 enabled.                                     
3700      =1  #define POWER_USBINH__DISABLED     0x10 ///< USB0 inhibited. All USB traffic is ignored.       
3701      =1                                                                                                 
3702      =1  #define POWER_ISOUD__BMASK         0x80 ///< Isochronous Update Mode                           
C51 COMPILER V9.56.0.0   SPI_0                                                             10/28/2016 17:37:02 PAGE 87  

3703      =1  #define POWER_ISOUD__SHIFT         0x07 ///< Isochronous Update Mode                           
3704      =1  #define POWER_ISOUD__IN_TOKEN      0x00 ///< When firmware writes INPRDY = 1, USB0 will send   
3705      =1                                          ///< the packet when the next IN token is received.    
3706      =1  #define POWER_ISOUD__SOF_TOKEN     0x80 ///< When firmware writes INPRDY = 1, USB0 will wait   
3707      =1                                          ///< for a SOF token before sending the packet. If an  
3708      =1                                          ///< IN token is received before a SOF token, USB0 will
3709      =1                                          ///< send a zero-length data packet.                   
3710      =1                                                                                                 
3711      =1  //------------------------------------------------------------------------------
3712      =1  // USB0ADR Enums (USB0 Indirect Address @ 0x96)
3713      =1  //------------------------------------------------------------------------------
3714      =1  #define USB0ADR_USB0ADR__FMASK          0x3F ///< USB0 Indirect Register Address                    
3715      =1  #define USB0ADR_USB0ADR__SHIFT          0x00 ///< USB0 Indirect Register Address                    
3716      =1  #define USB0ADR_USB0ADR__FADDR          0x00 ///< Function Address.                                 
3717      =1  #define USB0ADR_USB0ADR__POWER          0x01 ///< Power Management.                                 
3718      =1  #define USB0ADR_USB0ADR__IN1INT         0x02 ///< Endpoint 0 and Endpoints 1-3 IN Interrupt Flags.  
3719      =1  #define USB0ADR_USB0ADR__OUT1INT        0x04 ///< Endpoints 1-3 OUT Interrupt Flags.                
3720      =1  #define USB0ADR_USB0ADR__CMINT          0x06 ///< Common USB Interrupt Flags.                       
3721      =1  #define USB0ADR_USB0ADR__IN1IE          0x07 ///< Endpoint 0 and Endpoints 1-3 IN Interrupt Enables.
3722      =1  #define USB0ADR_USB0ADR__OUT1IE         0x09 ///< Endpoints 1-3 OUT Interrupt Enables.              
3723      =1  #define USB0ADR_USB0ADR__CMIE           0x0B ///< Common USB Interrupt Enables.                     
3724      =1  #define USB0ADR_USB0ADR__FRAMEL         0x0C ///< Frame Number Low Byte.                            
3725      =1  #define USB0ADR_USB0ADR__FRAMEH         0x0D ///< Frame Number High Byte.                           
3726      =1  #define USB0ADR_USB0ADR__INDEX          0x0E ///< Endpoint Index Selection.                         
3727      =1  #define USB0ADR_USB0ADR__CLKREC         0x0F ///< Clock Recovery Control.                           
3728      =1  #define USB0ADR_USB0ADR__E0CSR_EINCSRL  0x11 ///< Endpoint 0 Control / Status, Endpoint IN Control /
3729      =1                                               ///< Status Low Byte.                                  
3730      =1  #define USB0ADR_USB0ADR__EINCSRH        0x12 ///< Endpoint IN Control / Status High Byte.           
3731      =1  #define USB0ADR_USB0ADR__EOUTCSRL       0x14 ///< Endpoint OUT Control / Status Low Byte.           
3732      =1  #define USB0ADR_USB0ADR__EOUTCSRH       0x15 ///< Endpoint OUT Control / Status High Byte.          
3733      =1  #define USB0ADR_USB0ADR__E0CNT_EOUTCNTL 0x16 ///< Number of Received Bytes in Endpoint 0 FIFO,      
3734      =1                                               ///< Endpoint OUT Packet Count Low Byte.               
3735      =1  #define USB0ADR_USB0ADR__EOUTCNTH       0x17 ///< Endpoint OUT Packet Count High Byte.              
3736      =1  #define USB0ADR_USB0ADR__EENABLE        0x1E ///< Endpoint Enable.                                  
3737      =1  #define USB0ADR_USB0ADR__FIFO0          0x20 ///< Endpoint 0 FIFO.                                  
3738      =1  #define USB0ADR_USB0ADR__FIFO1          0x21 ///< Endpoint 1 FIFO.                                  
3739      =1  #define USB0ADR_USB0ADR__FIFO2          0x22 ///< Endpoint 2 FIFO.                                  
3740      =1  #define USB0ADR_USB0ADR__FIFO3          0x23 ///< Endpoint 3 FIFO.                                  
3741      =1                                                                                                      
3742      =1  #define USB0ADR_AUTORD__BMASK           0x40 ///< USB0 Register Auto-Read Flag                      
3743      =1  #define USB0ADR_AUTORD__SHIFT           0x06 ///< USB0 Register Auto-Read Flag                      
3744      =1  #define USB0ADR_AUTORD__DISABLED        0x00 ///< BUSY must be written manually for each USB0       
3745      =1                                               ///< indirect register read.                           
3746      =1  #define USB0ADR_AUTORD__ENABLED         0x40 ///< The next indirect register read will automatically
3747      =1                                               ///< be initiated when firmware reads USB0DAT (USBADDR 
3748      =1                                               ///< bits will not be changed).                        
3749      =1                                                                                                      
3750      =1  #define USB0ADR_BUSY__BMASK             0x80 ///< USB0 Register Read Busy Flag                      
3751      =1  #define USB0ADR_BUSY__SHIFT             0x07 ///< USB0 Register Read Busy Flag                      
3752      =1  #define USB0ADR_BUSY__NOT_SET           0x00 ///< A read is not in progress.                        
3753      =1  #define USB0ADR_BUSY__SET               0x80 ///< Initiate a read or a read is in progress.         
3754      =1                                                                                                      
3755      =1  //------------------------------------------------------------------------------
3756      =1  // USB0DAT Enums (USB0 Data @ 0x97)
3757      =1  //------------------------------------------------------------------------------
3758      =1  #define USB0DAT_USB0DAT__FMASK 0xFF ///< USB0 Data
3759      =1  #define USB0DAT_USB0DAT__SHIFT 0x00 ///< USB0 Data
3760      =1                                                    
3761      =1  //------------------------------------------------------------------------------
3762      =1  // USB0XCN Enums (USB0 Transceiver Control @ 0xD7)
3763      =1  //------------------------------------------------------------------------------
3764      =1  #define USB0XCN_Dn__BMASK                0x01 ///< D- Signal Status                                 
C51 COMPILER V9.56.0.0   SPI_0                                                             10/28/2016 17:37:02 PAGE 88  

3765      =1  #define USB0XCN_Dn__SHIFT                0x00 ///< D- Signal Status                                 
3766      =1  #define USB0XCN_Dn__LOW                  0x00 ///< D- signal currently at logic 0.                  
3767      =1  #define USB0XCN_Dn__HIGH                 0x01 ///< D- signal currently at logic 1.                  
3768      =1                                                                                                      
3769      =1  #define USB0XCN_Dp__BMASK                0x02 ///< D+ Signal Status                                 
3770      =1  #define USB0XCN_Dp__SHIFT                0x01 ///< D+ Signal Status                                 
3771      =1  #define USB0XCN_Dp__LOW                  0x00 ///< D+ signal currently at logic 0.                  
3772      =1  #define USB0XCN_Dp__HIGH                 0x02 ///< D+ signal currently at logic 1.                  
3773      =1                                                                                                      
3774      =1  #define USB0XCN_DFREC__BMASK             0x04 ///< Differential Receiver                            
3775      =1  #define USB0XCN_DFREC__SHIFT             0x02 ///< Differential Receiver                            
3776      =1  #define USB0XCN_DFREC__DIFFERENTIAL_ZERO 0x00 ///< Differential 0 signalling on the bus.            
3777      =1  #define USB0XCN_DFREC__DIFFERENTIAL_ONE  0x04 ///< Differential 1 signalling on the bus.            
3778      =1                                                                                                      
3779      =1  #define USB0XCN_PHYTST__FMASK            0x18 ///< Physical Layer Test                              
3780      =1  #define USB0XCN_PHYTST__SHIFT            0x03 ///< Physical Layer Test                              
3781      =1  #define USB0XCN_PHYTST__MODE0            0x00 ///< Mode 0: Normal (non-test mode) (D+ = X, D- = X). 
3782      =1  #define USB0XCN_PHYTST__MODE1            0x08 ///< Mode 1: Differential 1 forced (D+ = 1, D- = 0).  
3783      =1  #define USB0XCN_PHYTST__MODE2            0x10 ///< Mode 2: Differential 0 forced (D+ = 0, D- = 1).  
3784      =1  #define USB0XCN_PHYTST__MODE3            0x18 ///< Mode 3: Single-Ended 0 forced (D+ = 0, D- = 0).  
3785      =1                                                                                                      
3786      =1  #define USB0XCN_SPEED__BMASK             0x20 ///< USB0 Speed Select                                
3787      =1  #define USB0XCN_SPEED__SHIFT             0x05 ///< USB0 Speed Select                                
3788      =1  #define USB0XCN_SPEED__LOW_SPEED         0x00 ///< USB0 operates as a Low Speed device. If enabled, 
3789      =1                                                ///< the internal pull-up resistor appears on the D-  
3790      =1                                                ///< line.                                            
3791      =1  #define USB0XCN_SPEED__FULL_SPEED        0x20 ///< USB0 operates as a Full Speed device. If enabled,
3792      =1                                                ///< the internal pull-up resistor appears on the D+  
3793      =1                                                ///< line.                                            
3794      =1                                                                                                      
3795      =1  #define USB0XCN_PHYEN__BMASK             0x40 ///< Physical Layer Enable                            
3796      =1  #define USB0XCN_PHYEN__SHIFT             0x06 ///< Physical Layer Enable                            
3797      =1  #define USB0XCN_PHYEN__DISABLED          0x00 ///< Disable the USB0 physical layer transceiver      
3798      =1                                                ///< (suspend).                                       
3799      =1  #define USB0XCN_PHYEN__ENABLED           0x40 ///< Enable the USB0 physical layer transceiver       
3800      =1                                                ///< (normal).                                        
3801      =1                                                                                                      
3802      =1  #define USB0XCN_PREN__BMASK              0x80 ///< Internal Pull-up Resistor Enable                 
3803      =1  #define USB0XCN_PREN__SHIFT              0x07 ///< Internal Pull-up Resistor Enable                 
3804      =1  #define USB0XCN_PREN__PULL_UP_DISABLED   0x00 ///< Internal pull-up resistor disabled (device       
3805      =1                                                ///< effectively detached from USB network).          
3806      =1  #define USB0XCN_PREN__PULL_UP_ENABLED    0x80 ///< Internal pull-up resistor enabled when VBUS is   
3807      =1                                                ///< present (device attached to the USB network).    
3808      =1                                                                                                      
3809      =1  //------------------------------------------------------------------------------
3810      =1  // VDM0CN Enums (Supply Monitor Control @ 0xFF)
3811      =1  //------------------------------------------------------------------------------
3812      =1  #define VDM0CN_VDDSTAT__BMASK  0x40 ///< Supply Status                                   
3813      =1  #define VDM0CN_VDDSTAT__SHIFT  0x06 ///< Supply Status                                   
3814      =1  #define VDM0CN_VDDSTAT__BELOW  0x00 ///< VDD is at or below the supply monitor threshold.
3815      =1  #define VDM0CN_VDDSTAT__ABOVE  0x40 ///< VDD is above the supply monitor threshold.      
3816      =1                                                                                           
3817      =1  #define VDM0CN_VDMEN__BMASK    0x80 ///< Supply Monitor Enable                           
3818      =1  #define VDM0CN_VDMEN__SHIFT    0x07 ///< Supply Monitor Enable                           
3819      =1  #define VDM0CN_VDMEN__DISABLED 0x00 ///< Supply Monitor Disabled.                        
3820      =1  #define VDM0CN_VDMEN__ENABLED  0x80 ///< Supply Monitor Enabled.                         
3821      =1                                                                                           
3822      =1  //------------------------------------------------------------------------------
3823      =1  // REF0CN Enums (Voltage Reference Control @ 0xD1)
3824      =1  //------------------------------------------------------------------------------
3825      =1  #define REF0CN_REFBE__BMASK    0x01 ///< Internal Reference Buffer Enable                  
3826      =1  #define REF0CN_REFBE__SHIFT    0x00 ///< Internal Reference Buffer Enable                  
C51 COMPILER V9.56.0.0   SPI_0                                                             10/28/2016 17:37:02 PAGE 89  

3827      =1  #define REF0CN_REFBE__DISABLED 0x00 ///< Disable the internal reference buffer.            
3828      =1  #define REF0CN_REFBE__ENABLED  0x01 ///< Enable the internal reference buffer. The internal
3829      =1                                      ///< voltage reference is driven on the VREF pin.      
3830      =1                                                                                             
3831      =1  #define REF0CN_TEMPE__BMASK    0x04 ///< Temperature Sensor Enable                         
3832      =1  #define REF0CN_TEMPE__SHIFT    0x02 ///< Temperature Sensor Enable                         
3833      =1  #define REF0CN_TEMPE__DISABLED 0x00 ///< Disable the internal Temperature Sensor.          
3834      =1  #define REF0CN_TEMPE__ENABLED  0x04 ///< Enable the internal Temperature Sensor.           
3835      =1                                                                                             
3836      =1  #define REF0CN_REFSL__BMASK    0x08 ///< Voltage Reference Select                          
3837      =1  #define REF0CN_REFSL__SHIFT    0x03 ///< Voltage Reference Select                          
3838      =1  #define REF0CN_REFSL__VREF     0x00 ///< Use the VREF pin as the voltage reference.        
3839      =1  #define REF0CN_REFSL__VDD      0x08 ///< Use VDD as the voltage reference.                 
3840      =1                                                                                             
3841      =1  #define REF0CN_REGOVR__BMASK   0x10 ///< Regulator Reference Override                      
3842      =1  #define REF0CN_REGOVR__SHIFT   0x04 ///< Regulator Reference Override                      
3843      =1  #define REF0CN_REGOVR__REFSL   0x00 ///< The REFSL bit selects the voltage reference       
3844      =1                                      ///< source.                                           
3845      =1  #define REF0CN_REGOVR__VREG    0x10 ///< Use the output of the internal regulator as the   
3846      =1                                      ///< voltage reference source.                         
3847      =1                                                                                             
3848      =1  #define REF0CN_REFBGS__BMASK   0x80 ///< Reference Buffer Gain Select                      
3849      =1  #define REF0CN_REFBGS__SHIFT   0x07 ///< Reference Buffer Gain Select                      
3850      =1  #define REF0CN_REFBGS__GAIN_2  0x00 ///< The on-chip voltage reference buffer gain is 2.   
3851      =1  #define REF0CN_REFBGS__GAIN_1  0x80 ///< The on-chip voltage reference buffer gain is 1.   
3852      =1                                                                                             
3853      =1  //------------------------------------------------------------------------------
3854      =1  // REG01CN Enums (Voltage Regulator Control @ 0xC9)
3855      =1  //------------------------------------------------------------------------------
3856      =1  #define REG01CN_REG1MD__BMASK     0x02 ///< VREG1 Voltage Regulator Mode                     
3857      =1  #define REG01CN_REG1MD__SHIFT     0x01 ///< VREG1 Voltage Regulator Mode                     
3858      =1  #define REG01CN_REG1MD__NORMAL    0x00 ///< VREG1 Voltage Regulator in normal mode.          
3859      =1  #define REG01CN_REG1MD__LOW_POWER 0x02 ///< VREG1 Voltage Regulator in low power mode.       
3860      =1                                                                                               
3861      =1  #define REG01CN_STOPCF__BMASK     0x08 ///< VREG1 Stop and Shutdown Mode Configuration       
3862      =1  #define REG01CN_STOPCF__SHIFT     0x03 ///< VREG1 Stop and Shutdown Mode Configuration       
3863      =1  #define REG01CN_STOPCF__ACTIVE    0x00 ///< VREG1 Regulator is still active in stop mode. Any
3864      =1                                         ///< enabled reset source will reset the device.      
3865      =1  #define REG01CN_STOPCF__SHUTDOWN  0x08 ///< VREG1 Regulator is shut down in stop mode (device
3866      =1                                         ///< enters Shutdown mode). Only the RSTb pin or power
3867      =1                                         ///< cycle can reset the device.                      
3868      =1                                                                                               
3869      =1  #define REG01CN_REG0MD__BMASK     0x10 ///< VREG0 Voltage Regulator Mode                     
3870      =1  #define REG01CN_REG0MD__SHIFT     0x04 ///< VREG0 Voltage Regulator Mode                     
3871      =1  #define REG01CN_REG0MD__NORMAL    0x00 ///< VREG0 Voltage Regulator in normal mode.          
3872      =1  #define REG01CN_REG0MD__LOW_POWER 0x10 ///< VREG0 Voltage Regulator in low power mode.       
3873      =1                                                                                               
3874      =1  #define REG01CN_VBSTAT__BMASK     0x40 ///< VBUS Signal Status                               
3875      =1  #define REG01CN_VBSTAT__SHIFT     0x06 ///< VBUS Signal Status                               
3876      =1  #define REG01CN_VBSTAT__NOT_SET   0x00 ///< VBUS signal currently absent (device not attached
3877      =1                                         ///< to USB network).                                 
3878      =1  #define REG01CN_VBSTAT__SET       0x40 ///< VBUS signal currently present (device attached to
3879      =1                                         ///< USB network).                                    
3880      =1                                                                                               
3881      =1  #define REG01CN_REG0DIS__BMASK    0x80 ///< Voltage Regulator (REG0) Disable                 
3882      =1  #define REG01CN_REG0DIS__SHIFT    0x07 ///< Voltage Regulator (REG0) Disable                 
3883      =1  #define REG01CN_REG0DIS__ENABLED  0x00 ///< Enable the VREG0 Voltage Regulator.              
3884      =1  #define REG01CN_REG0DIS__DISABLED 0x80 ///< Disable the VREG0 Voltage Regulator.             
3885      =1                                                                                               
3886      =1  //------------------------------------------------------------------------------
3887      =1  // EMI0CF Enums (External Memory Configuration @ 0x85)
3888      =1  //------------------------------------------------------------------------------
C51 COMPILER V9.56.0.0   SPI_0                                                             10/28/2016 17:37:02 PAGE 90  

3889      =1  #define EMI0CF_EALE__FMASK                    0x03 ///< ALE Pulse-Width Select                            
3890      =1  #define EMI0CF_EALE__SHIFT                    0x00 ///< ALE Pulse-Width Select                            
3891      =1  #define EMI0CF_EALE__1_CLOCK                  0x00 ///< ALE high and ALE low pulse width = 1 SYSCLK cycle.
3892      =1  #define EMI0CF_EALE__2_CLOCKS                 0x01 ///< ALE high and ALE low pulse width = 2 SYSCLK       
3893      =1                                                     ///< cycles.                                           
3894      =1  #define EMI0CF_EALE__3_CLOCKS                 0x02 ///< ALE high and ALE low pulse width = 3 SYSCLK       
3895      =1                                                     ///< cycles.                                           
3896      =1  #define EMI0CF_EALE__4_CLOCKS                 0x03 ///< ALE high and ALE low pulse width = 4 SYSCLK       
3897      =1                                                     ///< cycles.                                           
3898      =1                                                                                                            
3899      =1  #define EMI0CF_EMD__FMASK                     0x0C ///< EMIF Operating Mode Select                        
3900      =1  #define EMI0CF_EMD__SHIFT                     0x02 ///< EMIF Operating Mode Select                        
3901      =1  #define EMI0CF_EMD__INTERNAL_ONLY             0x00 ///< Internal Only: MOVX accesses on-chip XRAM only.   
3902      =1                                                     ///< All effective addresses alias to on-chip memory   
3903      =1                                                     ///< space.                                            
3904      =1  #define EMI0CF_EMD__SPLIT_WITHOUT_BANK_SELECT 0x04 ///< Split Mode without Bank Select: Accesses below the
3905      =1                                                     ///< internal XRAM boundary are directed on-chip.      
3906      =1                                                     ///< Accesses above the internal XRAM boundary are     
3907      =1                                                     ///< directed off-chip. 8-bit off-chip MOVX operations 
3908      =1                                                     ///< use the current contents of the Address high port 
3909      =1                                                     ///< latches to resolve the upper address byte. To     
3910      =1                                                     ///< access off chip space, EMI0CN must be set to a    
3911      =1                                                     ///< page that is not contained in the on-chip address 
3912      =1                                                     ///< space.                                            
3913      =1  #define EMI0CF_EMD__SPLIT_WITH_BANK_SELECT    0x08 ///< Split Mode with Bank Select: Accesses below the   
3914      =1                                                     ///< internal XRAM boundary are directed on-chip.      
3915      =1                                                     ///< Accesses above the internal XRAM boundary are     
3916      =1                                                     ///< directed off-chip. 8-bit off-chip MOVX operations 
3917      =1                                                     ///< uses the contents of EMI0CN to determine the high-
3918      =1                                                     ///< byte of the address.                              
3919      =1  #define EMI0CF_EMD__EXTERNAL_ONLY             0x0C ///< External Only: MOVX accesses off-chip XRAM only.  
3920      =1                                                     ///< On-chip XRAM is not visible to the core.          
3921      =1                                                                                                            
3922      =1  #define EMI0CF_MUXMD__BMASK                   0x10 ///< EMIF Multiplex Mode Select                        
3923      =1  #define EMI0CF_MUXMD__SHIFT                   0x04 ///< EMIF Multiplex Mode Select                        
3924      =1  #define EMI0CF_MUXMD__MULTIPLEXED             0x00 ///< EMIF operates in multiplexed address/data mode.   
3925      =1  #define EMI0CF_MUXMD__NON_MULTIPLEXED         0x10 ///< EMIF operates in non-multiplexed mode (separate   
3926      =1                                                     ///< address and data pins).                           
3927      =1                                                                                                            
3928      =1  #define EMI0CF_USBFAE__BMASK                  0x40 ///< USB FIFO Access Enable                            
3929      =1  #define EMI0CF_USBFAE__SHIFT                  0x06 ///< USB FIFO Access Enable                            
3930      =1  #define EMI0CF_USBFAE__FIFO_ACCESS_DISABLED   0x00 ///< USB FIFO RAM not available through MOVX           
3931      =1                                                     ///< instructions.                                     
3932      =1  #define EMI0CF_USBFAE__FIFO_ACCESS_ENABLED    0x40 ///< USB FIFO RAM available using MOVX instructions.   
3933      =1                                                     ///< The 1 KB of USB RAM will be mapped in XRAM space  
3934      =1                                                     ///< at addresses 0x0400 to 0x07FF. The USB clock must 
3935      =1                                                     ///< be active and greater than or equal to twice the  
3936      =1                                                     ///< SYSCLK (USBCLK > 2 x SYSCLK) to access this area  
3937      =1                                                     ///< with MOVX instructions.                           
3938      =1                                                                                                            
3939      =1  //------------------------------------------------------------------------------
3940      =1  // EMI0CN Enums (External Memory Interface Control @ 0xAA)
3941      =1  //------------------------------------------------------------------------------
3942      =1  #define EMI0CN_PGSEL__FMASK 0xFF ///< XRAM Page Select
3943      =1  #define EMI0CN_PGSEL__SHIFT 0x00 ///< XRAM Page Select
3944      =1                                                        
3945      =1  //------------------------------------------------------------------------------
3946      =1  // EMI0TC Enums (External Memory Timing Control @ 0x84)
3947      =1  //------------------------------------------------------------------------------
3948      =1  #define EMI0TC_AHOLD__FMASK      0x03 ///< EMIF Address Hold Time                      
3949      =1  #define EMI0TC_AHOLD__SHIFT      0x00 ///< EMIF Address Hold Time                      
3950      =1  #define EMI0TC_AHOLD__0_CLOCKS   0x00 ///< Address hold time = 0 SYSCLK cycles.        
C51 COMPILER V9.56.0.0   SPI_0                                                             10/28/2016 17:37:02 PAGE 91  

3951      =1  #define EMI0TC_AHOLD__1_CLOCK    0x01 ///< Address hold time = 1 SYSCLK cycle.         
3952      =1  #define EMI0TC_AHOLD__2_CLOCKS   0x02 ///< Address hold time = 2 SYSCLK cycles.        
3953      =1  #define EMI0TC_AHOLD__3_CLOCKS   0x03 ///< Address hold time = 3 SYSCLK cycles.        
3954      =1                                                                                         
3955      =1  #define EMI0TC_PWIDTH__FMASK     0x3C ///< EMIF /WR and /RD Pulse-Width Control        
3956      =1  #define EMI0TC_PWIDTH__SHIFT     0x02 ///< EMIF /WR and /RD Pulse-Width Control        
3957      =1  #define EMI0TC_PWIDTH__1_CLOCK   0x00 ///< /WR and /RD pulse width is 1 SYSCLK cycle.  
3958      =1  #define EMI0TC_PWIDTH__2_CLOCKS  0x04 ///< /WR and /RD pulse width is 2 SYSCLK cycles. 
3959      =1  #define EMI0TC_PWIDTH__3_CLOCKS  0x08 ///< /WR and /RD pulse width is 3 SYSCLK cycles. 
3960      =1  #define EMI0TC_PWIDTH__4_CLOCKS  0x0C ///< /WR and /RD pulse width is 4 SYSCLK cycles. 
3961      =1  #define EMI0TC_PWIDTH__5_CLOCKS  0x10 ///< /WR and /RD pulse width is 5 SYSCLK cycles. 
3962      =1  #define EMI0TC_PWIDTH__6_CLOCKS  0x14 ///< /WR and /RD pulse width is 6 SYSCLK cycles. 
3963      =1  #define EMI0TC_PWIDTH__7_CLOCKS  0x18 ///< /WR and /RD pulse width is 7 SYSCLK cycles. 
3964      =1  #define EMI0TC_PWIDTH__8_CLOCKS  0x1C ///< /WR and /RD pulse width is 8 SYSCLK cycles. 
3965      =1  #define EMI0TC_PWIDTH__9_CLOCKS  0x20 ///< /WR and /RD pulse width is 9 SYSCLK cycles. 
3966      =1  #define EMI0TC_PWIDTH__10_CLOCKS 0x24 ///< /WR and /RD pulse width is 10 SYSCLK cycles.
3967      =1  #define EMI0TC_PWIDTH__11_CLOCKS 0x28 ///< /WR and /RD pulse width is 11 SYSCLK cycles.
3968      =1  #define EMI0TC_PWIDTH__12_CLOCKS 0x2C ///< /WR and /RD pulse width is 12 SYSCLK cycles.
3969      =1  #define EMI0TC_PWIDTH__13_CLOCKS 0x30 ///< /WR and /RD pulse width is 13 SYSCLK cycles.
3970      =1  #define EMI0TC_PWIDTH__14_CLOCKS 0x34 ///< /WR and /RD pulse width is 14 SYSCLK cycles.
3971      =1  #define EMI0TC_PWIDTH__15_CLOCKS 0x38 ///< /WR and /RD pulse width is 15 SYSCLK cycles.
3972      =1  #define EMI0TC_PWIDTH__16_CLOCKS 0x3C ///< /WR and /RD pulse width is 16 SYSCLK cycles.
3973      =1                                                                                         
3974      =1  #define EMI0TC_ASETUP__FMASK     0xC0 ///< EMIF Address Setup Time                     
3975      =1  #define EMI0TC_ASETUP__SHIFT     0x06 ///< EMIF Address Setup Time                     
3976      =1  #define EMI0TC_ASETUP__0_CLOCKS  0x00 ///< Address setup time = 0 SYSCLK cycles.       
3977      =1  #define EMI0TC_ASETUP__1_CLOCK   0x40 ///< Address setup time = 1 SYSCLK cycle.        
3978      =1  #define EMI0TC_ASETUP__2_CLOCKS  0x80 ///< Address setup time = 2 SYSCLK cycles.       
3979      =1  #define EMI0TC_ASETUP__3_CLOCKS  0xC0 ///< Address setup time = 3 SYSCLK cycles.       
3980      =1                                                                                         
3981      =1  #endif // SI_EFM8UB2_REGISTER_ENUMS_H
3982      =1  //-eof--------------------------------------------------------------------------
3983      =1  
   9          #include "spi_0.h"
   1      =1  /******************************************************************************
   2      =1   * Copyright (c) 2015 by Silicon Laboratories Inc. All rights reserved.
   3      =1   *
   4      =1   * http://developer.silabs.com/legal/version/v11/Silicon_Labs_Software_License_Agreement.txt
   5      =1   *****************************************************************************/
   6      =1  
   7      =1  #ifndef __SPI_0_H__
   8      =1  #define __SPI_0_H__
   9      =1  
  10      =1  #include "SI_EFM8UB2_Defs.h"
   1      =2  //------------------------------------------------------------------------------
   2      =2  // Copyright 2014 Silicon Laboratories, Inc.
   3      =2  // All rights reserved. This program and the accompanying materials
   4      =2  // are made available under the terms of the Silicon Laboratories End User
   5      =2  // License Agreement which accompanies this distribution, and is available at
   6      =2  // http://developer.silabs.com/legal/version/v11/Silicon_Labs_Software_License_Agreement.txt
   7      =2  // Original content and implementation provided by Silicon Laboratories.
   8      =2  //------------------------------------------------------------------------------
   9      =2  //Supported Devices:
  10      =2  //  EFM8UB20F32G_QFN32
  11      =2  //  EFM8UB20F32G_QFP32
  12      =2  //  EFM8UB20F32G_QFP48
  13      =2  //  EFM8UB20F64G_QFN32
  14      =2  //  EFM8UB20F64G_QFP32
  15      =2  //  EFM8UB20F64G_QFP48
  16      =2  
  17      =2  #ifndef SI_EFM8UB2_DEFS_H
           =2 #define SI_EFM8UB2_DEFS_H
C51 COMPILER V9.56.0.0   SPI_0                                                             10/28/2016 17:37:02 PAGE 92  

           =2 
           =2 #include <si_toolchain.h>
           =2 
           =2 //-----------------------------------------------------------------------------
           =2 // Register Definitions
           =2 //-----------------------------------------------------------------------------
           =2 SI_SFR (ACC,      0xE0); ///< Accumulator                           
           =2 SI_SFR (ADC0CF,   0xBC); ///< ADC0 Configuration                    
           =2 SI_SFR (ADC0CN0,  0xE8); ///< ADC0 Control                          
           =2 SI_SFR (ADC0GTH,  0xC4); ///< ADC0 Greater-Than High Byte           
           =2 SI_SFR (ADC0GTL,  0xC3); ///< ADC0 Greater-Than Low Byte            
           =2 SI_SFR (ADC0H,    0xBE); ///< ADC0 Data Word High Byte              
           =2 SI_SFR (ADC0L,    0xBD); ///< ADC0 Data Word Low Byte               
           =2 SI_SFR (ADC0LTH,  0xC6); ///< ADC0 Less-Than High Byte              
           =2 SI_SFR (ADC0LTL,  0xC5); ///< ADC0 Less-Than Low Byte               
           =2 SI_SFR (AMX0N,    0xBA); ///< AMUX0 Negative Multiplexer Selection  
           =2 SI_SFR (AMX0P,    0xBB); ///< AMUX0 Positive Multiplexer Selection  
           =2 SI_SFR (B,        0xF0); ///< B Register                            
           =2 SI_SFR (CKCON0,   0x8E); ///< Clock Control 0                       
           =2 SI_SFR (CKCON1,   0xE4); ///< Clock Control 1                       
           =2 SI_SFR (CLKSEL,   0xA9); ///< Clock Select                          
           =2 SI_SFR (CMP0CN0,  0x9B); ///< Comparator 0 Control 0                
           =2 SI_SFR (CMP0MD,   0x9D); ///< Comparator 0 Mode                     
           =2 SI_SFR (CMP0MX,   0x9F); ///< Comparator 0 Multiplexer Selection    
           =2 SI_SFR (CMP1CN0,  0x9A); ///< Comparator 1 Control 0                
           =2 SI_SFR (CMP1MD,   0x9C); ///< Comparator 1 Mode                     
           =2 SI_SFR (CMP1MX,   0x9E); ///< Comparator 1 Multiplexer Selection    
           =2 SI_SFR (DPH,      0x83); ///< Data Pointer High                     
           =2 SI_SFR (DPL,      0x82); ///< Data Pointer Low                      
           =2 SI_SFR (EIE1,     0xE6); ///< Extended Interrupt Enable 1           
           =2 SI_SFR (EIE2,     0xE7); ///< Extended Interrupt Enable 2           
           =2 SI_SFR (EIP1,     0xF6); ///< Extended Interrupt Priority 1         
           =2 SI_SFR (EIP2,     0xF7); ///< Extended Interrupt Priority 2         
           =2 SI_SFR (EMI0CF,   0x85); ///< External Memory Configuration         
           =2 SI_SFR (EMI0CN,   0xAA); ///< External Memory Interface Control     
           =2 SI_SFR (EMI0TC,   0x84); ///< External Memory Timing Control        
           =2 SI_SFR (FLKEY,    0xB7); ///< Flash Lock and Key                    
           =2 SI_SFR (FLSCL,    0xB6); ///< Flash Scale                           
           =2 SI_SFR (HFO0CAL,  0xB3); ///< High Frequency Oscillator Calibration 
           =2 SI_SFR (HFO0CN,   0xB2); ///< High Frequency Oscillator Control     
           =2 SI_SFR (IE,       0xA8); ///< Interrupt Enable                      
           =2 SI_SFR (IP,       0xB8); ///< Interrupt Priority                    
           =2 SI_SFR (IT01CF,   0xE4); ///< INT0/INT1 Configuration               
           =2 SI_SFR (LFO0CN,   0x86); ///< Low Frequency Oscillator Control      
           =2 SI_SFR (P0,       0x80); ///< Port 0 Pin Latch                      
           =2 SI_SFR (P0MDIN,   0xF1); ///< Port 0 Input Mode                     
           =2 SI_SFR (P0MDOUT,  0xA4); ///< Port 0 Output Mode                    
           =2 SI_SFR (P0SKIP,   0xD4); ///< Port 0 Skip                           
           =2 SI_SFR (P1,       0x90); ///< Port 1 Pin Latch                      
           =2 SI_SFR (P1MDIN,   0xF2); ///< Port 1 Input Mode                     
           =2 SI_SFR (P1MDOUT,  0xA5); ///< Port 1 Output Mode                    
           =2 SI_SFR (P1SKIP,   0xD5); ///< Port 1 Skip                           
           =2 SI_SFR (P2,       0xA0); ///< Port 2 Pin Latch                      
           =2 SI_SFR (P2MDIN,   0xF3); ///< Port 2 Input Mode                     
           =2 SI_SFR (P2MDOUT,  0xA6); ///< Port 2 Output Mode                    
           =2 SI_SFR (P2SKIP,   0xD6); ///< Port 2 Skip                           
           =2 SI_SFR (P3,       0xB0); ///< Port 3 Pin Latch                      
           =2 SI_SFR (P3MDIN,   0xF4); ///< Port 3 Input Mode                     
           =2 SI_SFR (P3MDOUT,  0xA7); ///< Port 3 Output Mode                    
           =2 SI_SFR (P3SKIP,   0xDF); ///< Port 3 Skip                           
           =2 SI_SFR (P4,       0xC7); ///< Port 4 Pin Latch                      
           =2 SI_SFR (P4MDIN,   0xF5); ///< Port 4 Input Mode                     
C51 COMPILER V9.56.0.0   SPI_0                                                             10/28/2016 17:37:02 PAGE 93  

           =2 SI_SFR (P4MDOUT,  0xAE); ///< Port 4 Output Mode                    
           =2 SI_SFR (PCA0CN0,  0xD8); ///< PCA Control 0                         
           =2 SI_SFR (PCA0CPH0, 0xFC); ///< PCA Channel 0 Capture Module High Byte
           =2 SI_SFR (PCA0CPH1, 0xEA); ///< PCA Channel 1 Capture Module High Byte
           =2 SI_SFR (PCA0CPH2, 0xEC); ///< PCA Channel 2 Capture Module High Byte
           =2 SI_SFR (PCA0CPH3, 0xEE); ///< PCA Channel 3 Capture Module High Byte
           =2 SI_SFR (PCA0CPH4, 0xFE); ///< PCA Channel 4 Capture Module High Byte
           =2 SI_SFR (PCA0CPL0, 0xFB); ///< PCA Channel 0 Capture Module Low Byte 
           =2 SI_SFR (PCA0CPL1, 0xE9); ///< PCA Channel 1 Capture Module Low Byte 
           =2 SI_SFR (PCA0CPL2, 0xEB); ///< PCA Channel 2 Capture Module Low Byte 
           =2 SI_SFR (PCA0CPL3, 0xED); ///< PCA Channel 3 Capture Module Low Byte 
           =2 SI_SFR (PCA0CPL4, 0xFD); ///< PCA Channel 4 Capture Module Low Byte 
           =2 SI_SFR (PCA0CPM0, 0xDA); ///< PCA Channel 0 Capture/Compare Mode    
           =2 SI_SFR (PCA0CPM1, 0xDB); ///< PCA Channel 1 Capture/Compare Mode    
           =2 SI_SFR (PCA0CPM2, 0xDC); ///< PCA Channel 2 Capture/Compare Mode    
           =2 SI_SFR (PCA0CPM3, 0xDD); ///< PCA Channel 3 Capture/Compare Mode    
           =2 SI_SFR (PCA0CPM4, 0xDE); ///< PCA Channel 4 Capture/Compare Mode    
           =2 SI_SFR (PCA0H,    0xFA); ///< PCA Counter/Timer High Byte           
           =2 SI_SFR (PCA0L,    0xF9); ///< PCA Counter/Timer Low Byte            
           =2 SI_SFR (PCA0MD,   0xD9); ///< PCA Mode                              
           =2 SI_SFR (PCON0,    0x87); ///< Power Control                         
           =2 SI_SFR (PFE0CN,   0xAF); ///< Prefetch Engine Control               
           =2 SI_SFR (PSCTL,    0x8F); ///< Program Store Control                 
           =2 SI_SFR (PSW,      0xD0); ///< Program Status Word                   
           =2 SI_SFR (REF0CN,   0xD1); ///< Voltage Reference Control             
           =2 SI_SFR (REG01CN,  0xC9); ///< Voltage Regulator Control             
           =2 SI_SFR (RSTSRC,   0xEF); ///< Reset Source                          
           =2 SI_SFR (SBCON1,   0xAC); ///< UART1 Baud Rate Generator Control     
           =2 SI_SFR (SBRLH1,   0xB5); ///< UART1 Baud Rate Generator High Byte   
           =2 SI_SFR (SBRLL1,   0xB4); ///< UART1 Baud Rate Generator Low Byte    
           =2 SI_SFR (SBUF0,    0x99); ///< UART0 Serial Port Data Buffer         
           =2 SI_SFR (SBUF1,    0xD3); ///< UART1 Serial Port Data Buffer         
           =2 SI_SFR (SCON0,    0x98); ///< UART0 Serial Port Control             
           =2 SI_SFR (SCON1,    0xD2); ///< UART1 Serial Port Control             
           =2 SI_SFR (SFRPAGE,  0xBF); ///< SFR Page                              
           =2 SI_SFR (SMB0ADM,  0xCE); ///< SMBus 0 Slave Address Mask            
           =2 SI_SFR (SMB0ADR,  0xCF); ///< SMBus 0 Slave Address                 
           =2 SI_SFR (SMB0CF,   0xC1); ///< SMBus 0 Configuration                 
           =2 SI_SFR (SMB0CN0,  0xC0); ///< SMBus 0 Control                       
           =2 SI_SFR (SMB0DAT,  0xC2); ///< SMBus 0 Data                          
           =2 SI_SFR (SMB1ADM,  0xCE); ///< SMBus 1 Slave Address Mask            
           =2 SI_SFR (SMB1ADR,  0xCF); ///< SMBus 1 Slave Address                 
           =2 SI_SFR (SMB1CF,   0xC1); ///< SMBus 1 Configuration                 
           =2 SI_SFR (SMB1CN0,  0xC0); ///< SMBus 1 Control                       
           =2 SI_SFR (SMB1DAT,  0xC2); ///< SMBus 1 Data                          
           =2 SI_SFR (SMBTC,    0xB9); ///< SMBus Timing and Pin Control          
           =2 SI_SFR (SMOD1,    0xE5); ///< UART1 Mode                            
           =2 SI_SFR (SP,       0x81); ///< Stack Pointer                         
           =2 SI_SFR (SPI0CFG,  0xA1); ///< SPI0 Configuration                    
           =2 SI_SFR (SPI0CKR,  0xA2); ///< SPI0 Clock Rate                       
           =2 SI_SFR (SPI0CN0,  0xF8); ///< SPI0 Control                          
           =2 SI_SFR (SPI0DAT,  0xA3); ///< SPI0 Data                             
           =2 SI_SFR (TCON,     0x88); ///< Timer 0/1 Control                     
           =2 SI_SFR (TH0,      0x8C); ///< Timer 0 High Byte                     
           =2 SI_SFR (TH1,      0x8D); ///< Timer 1 High Byte                     
           =2 SI_SFR (TL0,      0x8A); ///< Timer 0 Low Byte                      
           =2 SI_SFR (TL1,      0x8B); ///< Timer 1 Low Byte                      
           =2 SI_SFR (TMOD,     0x89); ///< Timer 0/1 Mode                        
           =2 SI_SFR (TMR2CN0,  0xC8); ///< Timer 2 Control 0                     
           =2 SI_SFR (TMR2H,    0xCD); ///< Timer 2 High Byte                     
           =2 SI_SFR (TMR2L,    0xCC); ///< Timer 2 Low Byte                      
           =2 SI_SFR (TMR2RLH,  0xCB); ///< Timer 2 Reload High Byte              
C51 COMPILER V9.56.0.0   SPI_0                                                             10/28/2016 17:37:02 PAGE 94  

           =2 SI_SFR (TMR2RLL,  0xCA); ///< Timer 2 Reload Low Byte               
           =2 SI_SFR (TMR3CN0,  0x91); ///< Timer 3 Control 0                     
           =2 SI_SFR (TMR3H,    0x95); ///< Timer 3 High Byte                     
           =2 SI_SFR (TMR3L,    0x94); ///< Timer 3 Low Byte                      
           =2 SI_SFR (TMR3RLH,  0x93); ///< Timer 3 Reload High Byte              
           =2 SI_SFR (TMR3RLL,  0x92); ///< Timer 3 Reload Low Byte               
           =2 SI_SFR (TMR4CN0,  0x91); ///< Timer 4 Control 0                     
           =2 SI_SFR (TMR4H,    0x95); ///< Timer 4 High Byte                     
           =2 SI_SFR (TMR4L,    0x94); ///< Timer 4 Low Byte                      
           =2 SI_SFR (TMR4RLH,  0x93); ///< Timer 4 Reload High Byte              
           =2 SI_SFR (TMR4RLL,  0x92); ///< Timer 4 Reload Low Byte               
           =2 SI_SFR (TMR5CN0,  0xC8); ///< Timer 5 Control 0                     
           =2 SI_SFR (TMR5H,    0xCD); ///< Timer 5 High Byte                     
           =2 SI_SFR (TMR5L,    0xCC); ///< Timer 5 Low Byte                      
           =2 SI_SFR (TMR5RLH,  0xCB); ///< Timer 5 Reload High Byte              
           =2 SI_SFR (TMR5RLL,  0xCA); ///< Timer 5 Reload Low Byte               
           =2 SI_SFR (USB0ADR,  0x96); ///< USB0 Indirect Address                 
           =2 SI_SFR (USB0DAT,  0x97); ///< USB0 Data                             
           =2 SI_SFR (USB0XCN,  0xD7); ///< USB0 Transceiver Control              
           =2 SI_SFR (VDM0CN,   0xFF); ///< Supply Monitor Control                
           =2 SI_SFR (XBR0,     0xE1); ///< Port I/O Crossbar 0                   
           =2 SI_SFR (XBR1,     0xE2); ///< Port I/O Crossbar 1                   
           =2 SI_SFR (XBR2,     0xE3); ///< Port I/O Crossbar 2                   
           =2 SI_SFR (XOSC0CN,  0xB1); ///< External Oscillator Control           
           =2 
           =2 //------------------------------------------------------------------------------
           =2 // 16-bit Register Definitions (may not work on all compilers)
           =2 //------------------------------------------------------------------------------
           =2 SI_SFR16 (ADC0GT,  0xC3); ///< ADC0 Greater-Than            
           =2 SI_SFR16 (ADC0,    0xBD); ///< ADC0 Data Word               
           =2 SI_SFR16 (ADC0LT,  0xC5); ///< ADC0 Less-Than               
           =2 SI_SFR16 (DP,      0x82); ///< Data Pointer                 
           =2 SI_SFR16 (PCA0CP0, 0xFB); ///< PCA Channel 0 Capture Module 
           =2 SI_SFR16 (PCA0CP1, 0xE9); ///< PCA Channel 1 Capture Module 
           =2 SI_SFR16 (PCA0CP2, 0xEB); ///< PCA Channel 2 Capture Module 
           =2 SI_SFR16 (PCA0CP3, 0xED); ///< PCA Channel 3 Capture Module 
           =2 SI_SFR16 (PCA0CP4, 0xFD); ///< PCA Channel 4 Capture Module 
           =2 SI_SFR16 (PCA0,    0xF9); ///< PCA Counter/Timer            
           =2 SI_SFR16 (SBRL1,   0xB4); ///< UART1 Baud Rate Generator    
           =2 SI_SFR16 (TMR2,    0xCC); ///< Timer 2                      
           =2 SI_SFR16 (TMR2RL,  0xCA); ///< Timer 2 Reload               
           =2 SI_SFR16 (TMR3,    0x94); ///< Timer 3                      
           =2 SI_SFR16 (TMR3RL,  0x92); ///< Timer 3 Reload               
           =2 SI_SFR16 (TMR4,    0x94); ///< Timer 4                      
           =2 SI_SFR16 (TMR4RL,  0x92); ///< Timer 4 Reload               
           =2 SI_SFR16 (TMR5,    0xCC); ///< Timer 5                      
           =2 SI_SFR16 (TMR5RL,  0xCA); ///< Timer 5 Reload               
           =2 
           =2 //------------------------------------------------------------------------------
           =2 // Indirect Register Definitions
           =2 //------------------------------------------------------------------------------
           =2 #define CLKREC   0x0F ///< USB0 Clock Recovery Control       
           =2 #define CMIE     0x0B ///< USB0 Common Interrupt Enable      
           =2 #define CMINT    0x06 ///< USB0 Common Interrupt             
           =2 #define E0CNT    0x16 ///< USB0 Endpoint0 Data Count         
           =2 #define E0CSR    0x11 ///< USB0 Endpoint0 Control            
           =2 #define EENABLE  0x1E ///< USB0 Endpoint Enable              
           =2 #define EINCSRH  0x12 ///< USB0 IN Endpoint Control High     
           =2 #define EINCSRL  0x11 ///< USB0 IN Endpoint Control          
           =2 #define EOUTCNTH 0x17 ///< USB0 OUT Endpoint Count High      
           =2 #define EOUTCNTL 0x16 ///< USB0 OUT Endpoint Count           
           =2 #define EOUTCSRH 0x15 ///< USB0 OUT Endpoint Control High    
C51 COMPILER V9.56.0.0   SPI_0                                                             10/28/2016 17:37:02 PAGE 95  

           =2 #define EOUTCSRL 0x14 ///< USB0 OUT Endpoint Control         
           =2 #define FADDR    0x00 ///< USB0 Function Address             
           =2 #define FIFO0    0x20 ///< USB0 Endpoint 0 FIFO Access       
           =2 #define FIFO1    0x21 ///< USB0 Endpoint 1 FIFO Access       
           =2 #define FIFO2    0x22 ///< USB0 Endpoint 2 FIFO Access       
           =2 #define FIFO3    0x23 ///< USB0 Endpoint 3 FIFO Access       
           =2 #define FRAMEH   0x0D ///< USB0 Frame Number High            
           =2 #define FRAMEL   0x0C ///< USB0 Frame Number                 
           =2 #define IN1IE    0x07 ///< USB0 IN Endpoint Interrupt Enable 
           =2 #define IN1INT   0x02 ///< USB0 IN Endpoint Interrupt        
           =2 #define INDEX    0x0E ///< USB0 Endpoint Index               
           =2 #define OUT1IE   0x09 ///< USB0 OUT Endpoint Interrupt Enable
           =2 #define OUT1INT  0x04 ///< USB0 OUT Endpoint Interrupt       
           =2 #define POWER    0x01 ///< USB0 Power                        
           =2 
           =2 //------------------------------------------------------------------------------
           =2 // Bit Definitions
           =2 //------------------------------------------------------------------------------
           =2 
           =2 // ACC (Accumulator)
           =2 #define SFR_ACC 0xE0
           =2 SI_SBIT (ACC_ACC0, SFR_ACC, 0); ///< Accumulator Bit 0
           =2 SI_SBIT (ACC_ACC1, SFR_ACC, 1); ///< Accumulator Bit 1
           =2 SI_SBIT (ACC_ACC2, SFR_ACC, 2); ///< Accumulator Bit 2
           =2 SI_SBIT (ACC_ACC3, SFR_ACC, 3); ///< Accumulator Bit 3
           =2 SI_SBIT (ACC_ACC4, SFR_ACC, 4); ///< Accumulator Bit 4
           =2 SI_SBIT (ACC_ACC5, SFR_ACC, 5); ///< Accumulator Bit 5
           =2 SI_SBIT (ACC_ACC6, SFR_ACC, 6); ///< Accumulator Bit 6
           =2 SI_SBIT (ACC_ACC7, SFR_ACC, 7); ///< Accumulator Bit 7
           =2 
           =2 // ADC0CN0 (ADC0 Control)
           =2 #define SFR_ADC0CN0 0xE8
           =2 SI_SBIT (ADC0CN0_ADCM0,  SFR_ADC0CN0, 0); ///< Start of Conversion Mode Select Bit 0
           =2 SI_SBIT (ADC0CN0_ADCM1,  SFR_ADC0CN0, 1); ///< Start of Conversion Mode Select Bit 1
           =2 SI_SBIT (ADC0CN0_ADCM2,  SFR_ADC0CN0, 2); ///< Start of Conversion Mode Select Bit 2
           =2 SI_SBIT (ADC0CN0_ADWINT, SFR_ADC0CN0, 3); ///< Window Compare Interrupt Flag        
           =2 SI_SBIT (ADC0CN0_ADBUSY, SFR_ADC0CN0, 4); ///< ADC Busy                             
           =2 SI_SBIT (ADC0CN0_ADINT,  SFR_ADC0CN0, 5); ///< Conversion Complete Interrupt Flag   
           =2 SI_SBIT (ADC0CN0_ADTM,   SFR_ADC0CN0, 6); ///< Track Mode                           
           =2 SI_SBIT (ADC0CN0_ADEN,   SFR_ADC0CN0, 7); ///< ADC Enable                           
           =2 
           =2 // B (B Register)
           =2 #define SFR_B 0xF0
           =2 SI_SBIT (B_B0, SFR_B, 0); ///< B Register Bit 0
           =2 SI_SBIT (B_B1, SFR_B, 1); ///< B Register Bit 1
           =2 SI_SBIT (B_B2, SFR_B, 2); ///< B Register Bit 2
           =2 SI_SBIT (B_B3, SFR_B, 3); ///< B Register Bit 3
           =2 SI_SBIT (B_B4, SFR_B, 4); ///< B Register Bit 4
           =2 SI_SBIT (B_B5, SFR_B, 5); ///< B Register Bit 5
           =2 SI_SBIT (B_B6, SFR_B, 6); ///< B Register Bit 6
           =2 SI_SBIT (B_B7, SFR_B, 7); ///< B Register Bit 7
           =2 
           =2 // IE (Interrupt Enable)
           =2 #define SFR_IE 0xA8
           =2 SI_SBIT (IE_EX0,   SFR_IE, 0); ///< External Interrupt 0 Enable
           =2 SI_SBIT (IE_ET0,   SFR_IE, 1); ///< Timer 0 Interrupt Enable   
           =2 SI_SBIT (IE_EX1,   SFR_IE, 2); ///< External Interrupt 1 Enable
           =2 SI_SBIT (IE_ET1,   SFR_IE, 3); ///< Timer 1 Interrupt Enable   
           =2 SI_SBIT (IE_ES0,   SFR_IE, 4); ///< UART0 Interrupt Enable     
           =2 SI_SBIT (IE_ET2,   SFR_IE, 5); ///< Timer 2 Interrupt Enable   
           =2 SI_SBIT (IE_ESPI0, SFR_IE, 6); ///< SPI0 Interrupt Enable      
           =2 SI_SBIT (IE_EA,    SFR_IE, 7); ///< All Interrupts Enable      
C51 COMPILER V9.56.0.0   SPI_0                                                             10/28/2016 17:37:02 PAGE 96  

           =2 
           =2 // IP (Interrupt Priority)
           =2 #define SFR_IP 0xB8
           =2 SI_SBIT (IP_PX0,   SFR_IP, 0); ///< External Interrupt 0 Priority Control                        
           =2 SI_SBIT (IP_PT0,   SFR_IP, 1); ///< Timer 0 Interrupt Priority Control                           
           =2 SI_SBIT (IP_PX1,   SFR_IP, 2); ///< External Interrupt 1 Priority Control                        
           =2 SI_SBIT (IP_PT1,   SFR_IP, 3); ///< Timer 1 Interrupt Priority Control                           
           =2 SI_SBIT (IP_PS0,   SFR_IP, 4); ///< UART0 Interrupt Priority Control                             
           =2 SI_SBIT (IP_PT2,   SFR_IP, 5); ///< Timer 2 Interrupt Priority Control                           
           =2 SI_SBIT (IP_PSPI0, SFR_IP, 6); ///< Serial Peripheral Interface (SPI0) Interrupt Priority Control
           =2 
           =2 // P0 (Port 0 Pin Latch)
           =2 #define SFR_P0 0x80
           =2 SI_SBIT (P0_B0, SFR_P0, 0); ///< Port 0 Bit 0 Latch
           =2 SI_SBIT (P0_B1, SFR_P0, 1); ///< Port 0 Bit 1 Latch
           =2 SI_SBIT (P0_B2, SFR_P0, 2); ///< Port 0 Bit 2 Latch
           =2 SI_SBIT (P0_B3, SFR_P0, 3); ///< Port 0 Bit 3 Latch
           =2 SI_SBIT (P0_B4, SFR_P0, 4); ///< Port 0 Bit 4 Latch
           =2 SI_SBIT (P0_B5, SFR_P0, 5); ///< Port 0 Bit 5 Latch
           =2 SI_SBIT (P0_B6, SFR_P0, 6); ///< Port 0 Bit 6 Latch
           =2 SI_SBIT (P0_B7, SFR_P0, 7); ///< Port 0 Bit 7 Latch
           =2 
           =2 // P1 (Port 1 Pin Latch)
           =2 #define SFR_P1 0x90
           =2 SI_SBIT (P1_B0, SFR_P1, 0); ///< Port 1 Bit 0 Latch
           =2 SI_SBIT (P1_B1, SFR_P1, 1); ///< Port 1 Bit 1 Latch
           =2 SI_SBIT (P1_B2, SFR_P1, 2); ///< Port 1 Bit 2 Latch
           =2 SI_SBIT (P1_B3, SFR_P1, 3); ///< Port 1 Bit 3 Latch
           =2 SI_SBIT (P1_B4, SFR_P1, 4); ///< Port 1 Bit 4 Latch
           =2 SI_SBIT (P1_B5, SFR_P1, 5); ///< Port 1 Bit 5 Latch
           =2 SI_SBIT (P1_B6, SFR_P1, 6); ///< Port 1 Bit 6 Latch
           =2 SI_SBIT (P1_B7, SFR_P1, 7); ///< Port 1 Bit 7 Latch
           =2 
           =2 // P2 (Port 2 Pin Latch)
           =2 #define SFR_P2 0xA0
           =2 SI_SBIT (P2_B0, SFR_P2, 0); ///< Port 2 Bit 0 Latch
           =2 SI_SBIT (P2_B1, SFR_P2, 1); ///< Port 2 Bit 1 Latch
           =2 SI_SBIT (P2_B2, SFR_P2, 2); ///< Port 2 Bit 2 Latch
           =2 SI_SBIT (P2_B3, SFR_P2, 3); ///< Port 2 Bit 3 Latch
           =2 SI_SBIT (P2_B4, SFR_P2, 4); ///< Port 2 Bit 4 Latch
           =2 SI_SBIT (P2_B5, SFR_P2, 5); ///< Port 2 Bit 5 Latch
           =2 SI_SBIT (P2_B6, SFR_P2, 6); ///< Port 2 Bit 6 Latch
           =2 SI_SBIT (P2_B7, SFR_P2, 7); ///< Port 2 Bit 7 Latch
           =2 
           =2 // P3 (Port 3 Pin Latch)
           =2 #define SFR_P3 0xB0
           =2 SI_SBIT (P3_B0, SFR_P3, 0); ///< Port 3 Bit 0 Latch
           =2 SI_SBIT (P3_B1, SFR_P3, 1); ///< Port 3 Bit 1 Latch
           =2 SI_SBIT (P3_B2, SFR_P3, 2); ///< Port 3 Bit 2 Latch
           =2 SI_SBIT (P3_B3, SFR_P3, 3); ///< Port 3 Bit 3 Latch
           =2 SI_SBIT (P3_B4, SFR_P3, 4); ///< Port 3 Bit 4 Latch
           =2 SI_SBIT (P3_B5, SFR_P3, 5); ///< Port 3 Bit 5 Latch
           =2 SI_SBIT (P3_B6, SFR_P3, 6); ///< Port 3 Bit 6 Latch
           =2 SI_SBIT (P3_B7, SFR_P3, 7); ///< Port 3 Bit 7 Latch
           =2 
           =2 // PCA0CN0 (PCA Control 0)
           =2 #define SFR_PCA0CN0 0xD8
           =2 SI_SBIT (PCA0CN0_CCF0, SFR_PCA0CN0, 0); ///< PCA Module 0 Capture/Compare Flag
           =2 SI_SBIT (PCA0CN0_CCF1, SFR_PCA0CN0, 1); ///< PCA Module 1 Capture/Compare Flag
           =2 SI_SBIT (PCA0CN0_CCF2, SFR_PCA0CN0, 2); ///< PCA Module 2 Capture/Compare Flag
           =2 SI_SBIT (PCA0CN0_CCF3, SFR_PCA0CN0, 3); ///< PCA Module 3 Capture/Compare Flag
           =2 SI_SBIT (PCA0CN0_CCF4, SFR_PCA0CN0, 4); ///< PCA Module 4 Capture/Compare Flag
C51 COMPILER V9.56.0.0   SPI_0                                                             10/28/2016 17:37:02 PAGE 97  

           =2 SI_SBIT (PCA0CN0_CR,   SFR_PCA0CN0, 6); ///< PCA Counter/Timer Run Control    
           =2 SI_SBIT (PCA0CN0_CF,   SFR_PCA0CN0, 7); ///< PCA Counter/Timer Overflow Flag  
           =2 
           =2 // PSW (Program Status Word)
           =2 #define SFR_PSW 0xD0
           =2 SI_SBIT (PSW_PARITY, SFR_PSW, 0); ///< Parity Flag               
           =2 SI_SBIT (PSW_F1,     SFR_PSW, 1); ///< User Flag 1               
           =2 SI_SBIT (PSW_OV,     SFR_PSW, 2); ///< Overflow Flag             
           =2 SI_SBIT (PSW_RS0,    SFR_PSW, 3); ///< Register Bank Select Bit 0
           =2 SI_SBIT (PSW_RS1,    SFR_PSW, 4); ///< Register Bank Select Bit 1
           =2 SI_SBIT (PSW_F0,     SFR_PSW, 5); ///< User Flag 0               
           =2 SI_SBIT (PSW_AC,     SFR_PSW, 6); ///< Auxiliary Carry Flag      
           =2 SI_SBIT (PSW_CY,     SFR_PSW, 7); ///< Carry Flag                
           =2 
           =2 // SCON0 (UART0 Serial Port Control)
           =2 #define SFR_SCON0 0x98
           =2 SI_SBIT (SCON0_RI,    SFR_SCON0, 0); ///< Receive Interrupt Flag             
           =2 SI_SBIT (SCON0_TI,    SFR_SCON0, 1); ///< Transmit Interrupt Flag            
           =2 SI_SBIT (SCON0_RB8,   SFR_SCON0, 2); ///< Ninth Receive Bit                  
           =2 SI_SBIT (SCON0_TB8,   SFR_SCON0, 3); ///< Ninth Transmission Bit             
           =2 SI_SBIT (SCON0_REN,   SFR_SCON0, 4); ///< Receive Enable                     
           =2 SI_SBIT (SCON0_MCE,   SFR_SCON0, 5); ///< Multiprocessor Communication Enable
           =2 SI_SBIT (SCON0_SMODE, SFR_SCON0, 7); ///< Serial Port 0 Operation Mode       
           =2 
           =2 // SMB0CN0 (SMBus 0 Control)
           =2 #define SFR_SMB0CN0 0xC0
           =2 SI_SBIT (SMB0CN0_SI,      SFR_SMB0CN0, 0); ///< SMBus Interrupt Flag            
           =2 SI_SBIT (SMB0CN0_ACK,     SFR_SMB0CN0, 1); ///< SMBus Acknowledge               
           =2 SI_SBIT (SMB0CN0_ARBLOST, SFR_SMB0CN0, 2); ///< SMBus Arbitration Lost Indicator
           =2 SI_SBIT (SMB0CN0_ACKRQ,   SFR_SMB0CN0, 3); ///< SMBus Acknowledge Request       
           =2 SI_SBIT (SMB0CN0_STO,     SFR_SMB0CN0, 4); ///< SMBus Stop Flag                 
           =2 SI_SBIT (SMB0CN0_STA,     SFR_SMB0CN0, 5); ///< SMBus Start Flag                
           =2 SI_SBIT (SMB0CN0_TXMODE,  SFR_SMB0CN0, 6); ///< SMBus Transmit Mode Indicator   
           =2 SI_SBIT (SMB0CN0_MASTER,  SFR_SMB0CN0, 7); ///< SMBus Master/Slave Indicator    
           =2 
           =2 // SMB1CN0 (SMBus 1 Control)
           =2 #define SFR_SMB1CN0 0xC0
           =2 SI_SBIT (SMB1CN0_SI,      SFR_SMB1CN0, 0); ///< SMBus Interrupt Flag            
           =2 SI_SBIT (SMB1CN0_ACK,     SFR_SMB1CN0, 1); ///< SMBus Acknowledge               
           =2 SI_SBIT (SMB1CN0_ARBLOST, SFR_SMB1CN0, 2); ///< SMBus Arbitration Lost Indicator
           =2 SI_SBIT (SMB1CN0_ACKRQ,   SFR_SMB1CN0, 3); ///< SMBus Acknowledge Request       
           =2 SI_SBIT (SMB1CN0_STO,     SFR_SMB1CN0, 4); ///< SMBus Stop Flag                 
           =2 SI_SBIT (SMB1CN0_STA,     SFR_SMB1CN0, 5); ///< SMBus Start Flag                
           =2 SI_SBIT (SMB1CN0_TXMODE,  SFR_SMB1CN0, 6); ///< SMBus Transmit Mode Indicator   
           =2 SI_SBIT (SMB1CN0_MASTER,  SFR_SMB1CN0, 7); ///< SMBus Master/Slave Indicator    
           =2 
           =2 // SPI0CN0 (SPI0 Control)
           =2 #define SFR_SPI0CN0 0xF8
           =2 SI_SBIT (SPI0CN0_SPIEN,  SFR_SPI0CN0, 0); ///< SPI0 Enable            
           =2 SI_SBIT (SPI0CN0_TXBMT,  SFR_SPI0CN0, 1); ///< Transmit Buffer Empty  
           =2 SI_SBIT (SPI0CN0_NSSMD0, SFR_SPI0CN0, 2); ///< Slave Select Mode Bit 0
           =2 SI_SBIT (SPI0CN0_NSSMD1, SFR_SPI0CN0, 3); ///< Slave Select Mode Bit 1
           =2 SI_SBIT (SPI0CN0_RXOVRN, SFR_SPI0CN0, 4); ///< Receive Overrun Flag   
           =2 SI_SBIT (SPI0CN0_MODF,   SFR_SPI0CN0, 5); ///< Mode Fault Flag        
           =2 SI_SBIT (SPI0CN0_WCOL,   SFR_SPI0CN0, 6); ///< Write Collision Flag   
           =2 SI_SBIT (SPI0CN0_SPIF,   SFR_SPI0CN0, 7); ///< SPI0 Interrupt Flag    
           =2 
           =2 // TCON (Timer 0/1 Control)
           =2 #define SFR_TCON 0x88
           =2 SI_SBIT (TCON_IT0, SFR_TCON, 0); ///< Interrupt 0 Type Select
           =2 SI_SBIT (TCON_IE0, SFR_TCON, 1); ///< External Interrupt 0   
           =2 SI_SBIT (TCON_IT1, SFR_TCON, 2); ///< Interrupt 1 Type Select
C51 COMPILER V9.56.0.0   SPI_0                                                             10/28/2016 17:37:02 PAGE 98  

           =2 SI_SBIT (TCON_IE1, SFR_TCON, 3); ///< External Interrupt 1   
           =2 SI_SBIT (TCON_TR0, SFR_TCON, 4); ///< Timer 0 Run Control    
           =2 SI_SBIT (TCON_TF0, SFR_TCON, 5); ///< Timer 0 Overflow Flag  
           =2 SI_SBIT (TCON_TR1, SFR_TCON, 6); ///< Timer 1 Run Control    
           =2 SI_SBIT (TCON_TF1, SFR_TCON, 7); ///< Timer 1 Overflow Flag  
           =2 
           =2 // TMR2CN0 (Timer 2 Control 0)
           =2 #define SFR_TMR2CN0 0xC8
           =2 SI_SBIT (TMR2CN0_T2XCLK,  SFR_TMR2CN0, 0); ///< Timer 2 External Clock Select    
           =2 SI_SBIT (TMR2CN0_T2CSS,   SFR_TMR2CN0, 1); ///< Timer 2 Capture Source Select    
           =2 SI_SBIT (TMR2CN0_TR2,     SFR_TMR2CN0, 2); ///< Timer 2 Run Control              
           =2 SI_SBIT (TMR2CN0_T2SPLIT, SFR_TMR2CN0, 3); ///< Timer 2 Split Mode Enable        
           =2 SI_SBIT (TMR2CN0_TF2CEN,  SFR_TMR2CN0, 4); ///< Timer 2 Capture Enable           
           =2 SI_SBIT (TMR2CN0_TF2LEN,  SFR_TMR2CN0, 5); ///< Timer 2 Low Byte Interrupt Enable
           =2 SI_SBIT (TMR2CN0_TF2L,    SFR_TMR2CN0, 6); ///< Timer 2 Low Byte Overflow Flag   
           =2 SI_SBIT (TMR2CN0_TF2H,    SFR_TMR2CN0, 7); ///< Timer 2 High Byte Overflow Flag  
           =2 
           =2 // TMR5CN0 (Timer 5 Control 0)
           =2 #define SFR_TMR5CN0 0xC8
           =2 SI_SBIT (TMR5CN0_T5XCLK,  SFR_TMR5CN0, 0); ///< Timer 5 External Clock Select    
           =2 SI_SBIT (TMR5CN0_TR5,     SFR_TMR5CN0, 2); ///< Timer 5 Run Control              
           =2 SI_SBIT (TMR5CN0_T5SPLIT, SFR_TMR5CN0, 3); ///< Timer 5 Split Mode Enable        
           =2 SI_SBIT (TMR5CN0_TF5LEN,  SFR_TMR5CN0, 5); ///< Timer 5 Low Byte Interrupt Enable
           =2 SI_SBIT (TMR5CN0_TF5L,    SFR_TMR5CN0, 6); ///< Timer 5 Low Byte Overflow Flag   
           =2 SI_SBIT (TMR5CN0_TF5H,    SFR_TMR5CN0, 7); ///< Timer 5 High Byte Overflow Flag  
           =2 
           =2 //------------------------------------------------------------------------------
           =2 // Interrupt Definitions
           =2 //------------------------------------------------------------------------------
           =2 #define INT0_IRQn    0  ///< External Interrupt 0  
           =2 #define TIMER0_IRQn  1  ///< Timer 0 Overflow      
           =2 #define INT1_IRQn    2  ///< External Interrupt 1  
           =2 #define TIMER1_IRQn  3  ///< Timer 1 Overflow      
           =2 #define UART0_IRQn   4  ///< UART 0                
           =2 #define TIMER2_IRQn  5  ///< Timer 2 Overflow      
           =2 #define SPI0_IRQn    6  ///< SPI0                  
           =2 #define SMBUS0_IRQn  7  ///< SMBus 0               
           =2 #define USB0_IRQn    8  ///< USB0                  
           =2 #define ADC0WC_IRQn  9  ///< ADC0 Window Compare   
           =2 #define ADC0EOC_IRQn 10 ///< ADC0 End of Conversion
           =2 #define PCA0_IRQn    11 ///< PCA0                  
           =2 #define CMP0_IRQn    12 ///< Comparator 0          
           =2 #define CMP1_IRQn    13 ///< Comparator 1          
           =2 #define TIMER3_IRQn  14 ///< Timer 3 Overflow      
           =2 #define VBUSLVL_IRQn 15 ///< VBUS Level            
           =2 #define UART1_IRQn   16 ///< UART 1                
           =2 #define SMBUS1_IRQn  18 ///< SMBus 1               
           =2 #define TIMER4_IRQn  19 ///< Timer 4 Overflow      
           =2 #define TIMER5_IRQn  20 ///< Timer 5 Overflow      
           =2 
           =2 //------------------------------------------------------------------------------
           =2 // SFR Page Definitions
           =2 //------------------------------------------------------------------------------
           =2 #define LEGACY_PAGE 0x00 ///< Legacy SFR Page                   
           =2 #define CONFIG_PAGE 0x0F ///< System and Port Configuration Page
           =2 #define SMB1_PAGE   0x0F ///< SMBus 1 Page                      
           =2 
           =2 //-----------------------------------------------------------------------------
           =2 // SDCC PDATA External Memory Paging Support
           =2 //-----------------------------------------------------------------------------
           =2 
           =2 #if defined SDCC
C51 COMPILER V9.56.0.0   SPI_0                                                             10/28/2016 17:37:02 PAGE 99  

           =2 
           =2 SI_SFR(_XPAGE, 0xAA); // Point to the EMI0CN register
           =2 
           =2 #endif
           =2 
           =2 #endif // SI_EFM8UB2_DEFS_H
 459      =2  //-eof--------------------------------------------------------------------------
 460      =2  
  11      =1  #include "SI_EFM8UB2_Register_Enums.h"
   1      =2  //------------------------------------------------------------------------------
   2      =2  // Copyright 2014 Silicon Laboratories, Inc.
   3      =2  // All rights reserved. This program and the accompanying materials
   4      =2  // are made available under the terms of the Silicon Laboratories End User
   5      =2  // License Agreement which accompanies this distribution, and is available at
   6      =2  // http://developer.silabs.com/legal/version/v11/Silicon_Labs_Software_License_Agreement.txt
   7      =2  // Original content and implementation provided by Silicon Laboratories.
   8      =2  //------------------------------------------------------------------------------
   9      =2  //Supported Devices:
  10      =2  //  EFM8UB20F32G_QFN32
  11      =2  //  EFM8UB20F32G_QFP32
  12      =2  //  EFM8UB20F32G_QFP48
  13      =2  //  EFM8UB20F64G_QFN32
  14      =2  //  EFM8UB20F64G_QFP32
  15      =2  //  EFM8UB20F64G_QFP48
  16      =2  
  17      =2  #ifndef SI_EFM8UB2_REGISTER_ENUMS_H
           =2 #define SI_EFM8UB2_REGISTER_ENUMS_H
           =2 
           =2 //Standard device includes
           =2 #include "SI_EFM8UB2_Defs.h"
           =2 //------------------------------------------------------------------------------
           =2 // ADC0CF Enums (ADC0 Configuration @ 0xBC)
           =2 //------------------------------------------------------------------------------
           =2 #define ADC0CF_ADLJST__BMASK           0x04 ///< ADC0 Left Justify Select                   
           =2 #define ADC0CF_ADLJST__SHIFT           0x02 ///< ADC0 Left Justify Select                   
           =2 #define ADC0CF_ADLJST__RIGHT_JUSTIFIED 0x00 ///< Data in the ADC0H:ADC0L registers is right-
           =2                                             ///< justified.                                 
           =2 #define ADC0CF_ADLJST__LEFT_JUSTIFIED  0x04 ///< Data in the ADC0H:ADC0L registers is left- 
           =2                                             ///< justified.                                 
           =2                                                                                             
           =2 #define ADC0CF_ADSC__FMASK             0xF8 ///< SAR Clock Divider                          
           =2 #define ADC0CF_ADSC__SHIFT             0x03 ///< SAR Clock Divider                          
           =2                                                                                             
           =2 //------------------------------------------------------------------------------
           =2 // ADC0CN0 Enums (ADC0 Control @ 0xE8)
           =2 //------------------------------------------------------------------------------
           =2 #define ADC0CN0_ADCM__FMASK         0x07 ///< Start of Conversion Mode Select                   
           =2 #define ADC0CN0_ADCM__SHIFT         0x00 ///< Start of Conversion Mode Select                   
           =2 #define ADC0CN0_ADCM__ADBUSY        0x00 ///< ADC0 conversion initiated on write of 1 to ADBUSY.
           =2 #define ADC0CN0_ADCM__TIMER0        0x01 ///< ADC0 conversion initiated on overflow of Timer 0. 
           =2 #define ADC0CN0_ADCM__TIMER2        0x02 ///< ADC0 conversion initiated on overflow of Timer 2. 
           =2 #define ADC0CN0_ADCM__TIMER1        0x03 ///< ADC0 conversion initiated on overflow of Timer 1. 
           =2 #define ADC0CN0_ADCM__CNVSTR        0x04 ///< ADC0 conversion initiated on rising edge of       
           =2                                          ///< CNVSTR.                                           
           =2 #define ADC0CN0_ADCM__TIMER3        0x05 ///< ADC0 conversion initiated on overflow of Timer 3. 
           =2 #define ADC0CN0_ADCM__TIMER4        0x06 ///< ADC0 conversion initiated on overflow of Timer 4. 
           =2 #define ADC0CN0_ADCM__TIMER5        0x07 ///< ADC0 conversion initiated on overflow of Timer 5. 
           =2                                                                                                 
           =2 #define ADC0CN0_ADWINT__BMASK       0x08 ///< Window Compare Interrupt Flag                     
           =2 #define ADC0CN0_ADWINT__SHIFT       0x03 ///< Window Compare Interrupt Flag                     
           =2 #define ADC0CN0_ADWINT__NOT_SET     0x00 ///< An ADC window compare event did not occur.        
           =2 #define ADC0CN0_ADWINT__SET         0x08 ///< An ADC window compare event occurred.             
C51 COMPILER V9.56.0.0   SPI_0                                                             10/28/2016 17:37:02 PAGE 100 

           =2                                                                                                 
           =2 #define ADC0CN0_ADBUSY__BMASK       0x10 ///< ADC Busy                                          
           =2 #define ADC0CN0_ADBUSY__SHIFT       0x04 ///< ADC Busy                                          
           =2 #define ADC0CN0_ADBUSY__NOT_SET     0x00 ///< An ADC0 conversion is not currently in progress.  
           =2 #define ADC0CN0_ADBUSY__SET         0x10 ///< ADC0 conversion is in progress or start an ADC0   
           =2                                          ///< conversion.                                       
           =2                                                                                                 
           =2 #define ADC0CN0_ADINT__BMASK        0x20 ///< Conversion Complete Interrupt Flag                
           =2 #define ADC0CN0_ADINT__SHIFT        0x05 ///< Conversion Complete Interrupt Flag                
           =2 #define ADC0CN0_ADINT__NOT_SET      0x00 ///< ADC0 has not completed a conversion since the last
           =2                                          ///< time ADINT was cleared.                           
           =2 #define ADC0CN0_ADINT__SET          0x20 ///< ADC0 completed a data conversion.                 
           =2                                                                                                 
           =2 #define ADC0CN0_ADTM__BMASK         0x40 ///< Track Mode                                        
           =2 #define ADC0CN0_ADTM__SHIFT         0x06 ///< Track Mode                                        
           =2 #define ADC0CN0_ADTM__TRACK_NORMAL  0x00 ///< Normal Track Mode. When ADC0 is enabled,          
           =2                                          ///< conversion begins immediately following the start-
           =2                                          ///< of-conversion signal.                             
           =2 #define ADC0CN0_ADTM__TRACK_DELAYED 0x40 ///< Delayed Track Mode. When ADC0 is enabled,         
           =2                                          ///< conversion begins 3 SAR clock cycles following the
           =2                                          ///< start-of-conversion signal. The ADC is allowed to 
           =2                                          ///< track during this time. Note that there is not a  
           =2                                          ///< tracking delay when the external conversion start 
           =2                                          ///< (CNVSTR) is used as the start-of-conversion       
           =2                                          ///< source.                                           
           =2                                                                                                 
           =2 #define ADC0CN0_ADEN__BMASK         0x80 ///< ADC Enable                                        
           =2 #define ADC0CN0_ADEN__SHIFT         0x07 ///< ADC Enable                                        
           =2 #define ADC0CN0_ADEN__DISABLED      0x00 ///< ADC0 Disabled (low-power shutdown).               
           =2 #define ADC0CN0_ADEN__ENABLED       0x80 ///< ADC0 Enabled (active and ready for data           
           =2                                          ///< conversions).                                     
           =2                                                                                                 
           =2 //------------------------------------------------------------------------------
           =2 // ADC0GTH Enums (ADC0 Greater-Than High Byte @ 0xC4)
           =2 //------------------------------------------------------------------------------
           =2 #define ADC0GTH_ADC0GTH__FMASK 0xFF ///< Greater-Than High Byte
           =2 #define ADC0GTH_ADC0GTH__SHIFT 0x00 ///< Greater-Than High Byte
           =2                                                                
           =2 //------------------------------------------------------------------------------
           =2 // ADC0GTL Enums (ADC0 Greater-Than Low Byte @ 0xC3)
           =2 //------------------------------------------------------------------------------
           =2 #define ADC0GTL_ADC0GTL__FMASK 0xFF ///< Greater-Than Low Byte
           =2 #define ADC0GTL_ADC0GTL__SHIFT 0x00 ///< Greater-Than Low Byte
           =2                                                               
           =2 //------------------------------------------------------------------------------
           =2 // ADC0H Enums (ADC0 Data Word High Byte @ 0xBE)
           =2 //------------------------------------------------------------------------------
           =2 #define ADC0H_ADC0H__FMASK 0xFF ///< Data Word High Byte
           =2 #define ADC0H_ADC0H__SHIFT 0x00 ///< Data Word High Byte
           =2                                                         
           =2 //------------------------------------------------------------------------------
           =2 // ADC0L Enums (ADC0 Data Word Low Byte @ 0xBD)
           =2 //------------------------------------------------------------------------------
           =2 #define ADC0L_ADC0L__FMASK 0xFF ///< Data Word Low Byte
           =2 #define ADC0L_ADC0L__SHIFT 0x00 ///< Data Word Low Byte
           =2                                                        
           =2 //------------------------------------------------------------------------------
           =2 // ADC0LTH Enums (ADC0 Less-Than High Byte @ 0xC6)
           =2 //------------------------------------------------------------------------------
           =2 #define ADC0LTH_ADC0LTH__FMASK 0xFF ///< Less-Than High Byte
           =2 #define ADC0LTH_ADC0LTH__SHIFT 0x00 ///< Less-Than High Byte
           =2                                                             
C51 COMPILER V9.56.0.0   SPI_0                                                             10/28/2016 17:37:02 PAGE 101 

           =2 //------------------------------------------------------------------------------
           =2 // ADC0LTL Enums (ADC0 Less-Than Low Byte @ 0xC5)
           =2 //------------------------------------------------------------------------------
           =2 #define ADC0LTL_ADC0LTL__FMASK 0xFF ///< Less-Than Low Byte
           =2 #define ADC0LTL_ADC0LTL__SHIFT 0x00 ///< Less-Than Low Byte
           =2                                                            
           =2 //------------------------------------------------------------------------------
           =2 // AMX0N Enums (AMUX0 Negative Multiplexer Selection @ 0xBA)
           =2 //------------------------------------------------------------------------------
           =2 #define AMX0N_AMX0N__FMASK   0x3F ///< AMUX0 Negative Input Selection
           =2 #define AMX0N_AMX0N__SHIFT   0x00 ///< AMUX0 Negative Input Selection
           =2 #define AMX0N_AMX0N__ADC0N0  0x00 ///< Select ADC0N.0.               
           =2 #define AMX0N_AMX0N__ADC0N1  0x01 ///< Select ADC0N.1.               
           =2 #define AMX0N_AMX0N__ADC0N2  0x02 ///< Select ADC0N.2.               
           =2 #define AMX0N_AMX0N__ADC0N3  0x03 ///< Select ADC0N.3.               
           =2 #define AMX0N_AMX0N__ADC0N4  0x04 ///< Select ADC0N.4.               
           =2 #define AMX0N_AMX0N__ADC0N5  0x05 ///< Select ADC0N.5.               
           =2 #define AMX0N_AMX0N__ADC0N6  0x06 ///< Select ADC0N.6.               
           =2 #define AMX0N_AMX0N__ADC0N7  0x07 ///< Select ADC0N.7.               
           =2 #define AMX0N_AMX0N__ADC0N8  0x08 ///< Select ADC0N.8.               
           =2 #define AMX0N_AMX0N__ADC0N9  0x09 ///< Select ADC0N.9.               
           =2 #define AMX0N_AMX0N__ADC0N10 0x0A ///< Select ADC0N.10.              
           =2 #define AMX0N_AMX0N__ADC0N11 0x0B ///< Select ADC0N.11.              
           =2 #define AMX0N_AMX0N__ADC0N12 0x0C ///< Select ADC0N.12.              
           =2 #define AMX0N_AMX0N__ADC0N13 0x0D ///< Select ADC0N.13.              
           =2 #define AMX0N_AMX0N__ADC0N14 0x0E ///< Select ADC0N.14.              
           =2 #define AMX0N_AMX0N__ADC0N15 0x0F ///< Select ADC0N.15.              
           =2 #define AMX0N_AMX0N__ADC0N16 0x10 ///< Select ADC0N.16.              
           =2 #define AMX0N_AMX0N__ADC0N17 0x11 ///< Select ADC0N.17.              
           =2 #define AMX0N_AMX0N__ADC0N18 0x12 ///< Select ADC0N.18.              
           =2 #define AMX0N_AMX0N__ADC0N19 0x13 ///< Select ADC0N.19.              
           =2 #define AMX0N_AMX0N__ADC0N20 0x14 ///< Select ADC0N.20.              
           =2 #define AMX0N_AMX0N__ADC0N21 0x15 ///< Select ADC0N.21.              
           =2 #define AMX0N_AMX0N__ADC0N22 0x16 ///< Select ADC0N.22.              
           =2 #define AMX0N_AMX0N__ADC0N23 0x17 ///< Select ADC0N.23.              
           =2 #define AMX0N_AMX0N__ADC0N24 0x18 ///< Select ADC0N.24.              
           =2 #define AMX0N_AMX0N__ADC0N25 0x19 ///< Select ADC0N.25.              
           =2 #define AMX0N_AMX0N__ADC0N26 0x1A ///< Select ADC0N.26.              
           =2 #define AMX0N_AMX0N__ADC0N27 0x1B ///< Select ADC0N.27.              
           =2 #define AMX0N_AMX0N__ADC0N28 0x1C ///< Select ADC0N.28.              
           =2 #define AMX0N_AMX0N__ADC0N29 0x1D ///< Select ADC0N.29.              
           =2 #define AMX0N_AMX0N__VREF    0x1E ///< Internal Voltage Reference.   
           =2 #define AMX0N_AMX0N__GND     0x1F ///< Ground (single-ended mode).   
           =2 #define AMX0N_AMX0N__ADC0N32 0x20 ///< Select ADC0N.32.              
           =2 #define AMX0N_AMX0N__ADC0N33 0x21 ///< Select ADC0N.33.              
           =2 #define AMX0N_AMX0N__ADC0N34 0x22 ///< Select ADC0N.34.              
           =2                                                                      
           =2 //------------------------------------------------------------------------------
           =2 // AMX0P Enums (AMUX0 Positive Multiplexer Selection @ 0xBB)
           =2 //------------------------------------------------------------------------------
           =2 #define AMX0P_AMX0P__FMASK   0x3F ///< AMUX0 Positive Input Selection
           =2 #define AMX0P_AMX0P__SHIFT   0x00 ///< AMUX0 Positive Input Selection
           =2 #define AMX0P_AMX0P__ADC0P0  0x00 ///< Select ADC0P.0.               
           =2 #define AMX0P_AMX0P__ADC0P1  0x01 ///< Select ADC0P.1.               
           =2 #define AMX0P_AMX0P__ADC0P2  0x02 ///< Select ADC0P.2.               
           =2 #define AMX0P_AMX0P__ADC0P3  0x03 ///< Select ADC0P.3.               
           =2 #define AMX0P_AMX0P__ADC0P4  0x04 ///< Select ADC0P.4.               
           =2 #define AMX0P_AMX0P__ADC0P5  0x05 ///< Select ADC0P.5.               
           =2 #define AMX0P_AMX0P__ADC0P6  0x06 ///< Select ADC0P.6.               
           =2 #define AMX0P_AMX0P__ADC0P7  0x07 ///< Select ADC0P.7.               
           =2 #define AMX0P_AMX0P__ADC0P8  0x08 ///< Select ADC0P.8.               
           =2 #define AMX0P_AMX0P__ADC0P9  0x09 ///< Select ADC0P.9.               
C51 COMPILER V9.56.0.0   SPI_0                                                             10/28/2016 17:37:02 PAGE 102 

           =2 #define AMX0P_AMX0P__ADC0P10 0x0A ///< Select ADC0P.10.              
           =2 #define AMX0P_AMX0P__ADC0P11 0x0B ///< Select ADC0P.11.              
           =2 #define AMX0P_AMX0P__ADC0P12 0x0C ///< Select ADC0P.12.              
           =2 #define AMX0P_AMX0P__ADC0P13 0x0D ///< Select ADC0P.13.              
           =2 #define AMX0P_AMX0P__ADC0P14 0x0E ///< Select ADC0P.14.              
           =2 #define AMX0P_AMX0P__ADC0P15 0x0F ///< Select ADC0P.15.              
           =2 #define AMX0P_AMX0P__ADC0P16 0x10 ///< Select ADC0P.16.              
           =2 #define AMX0P_AMX0P__ADC0P17 0x11 ///< Select ADC0P.17.              
           =2 #define AMX0P_AMX0P__ADC0P18 0x12 ///< Select ADC0P.18.              
           =2 #define AMX0P_AMX0P__ADC0P19 0x13 ///< Select ADC0P.19.              
           =2 #define AMX0P_AMX0P__ADC0P20 0x14 ///< Select ADC0P.20.              
           =2 #define AMX0P_AMX0P__ADC0P21 0x15 ///< Select ADC0P.21.              
           =2 #define AMX0P_AMX0P__ADC0P22 0x16 ///< Select ADC0P.22.              
           =2 #define AMX0P_AMX0P__ADC0P23 0x17 ///< Select ADC0P.23.              
           =2 #define AMX0P_AMX0P__ADC0P24 0x18 ///< Select ADC0P.24.              
           =2 #define AMX0P_AMX0P__ADC0P25 0x19 ///< Select ADC0P.25.              
           =2 #define AMX0P_AMX0P__ADC0P26 0x1A ///< Select ADC0P.26.              
           =2 #define AMX0P_AMX0P__ADC0P27 0x1B ///< Select ADC0P.27.              
           =2 #define AMX0P_AMX0P__ADC0P28 0x1C ///< Select ADC0P.28.              
           =2 #define AMX0P_AMX0P__ADC0P29 0x1D ///< Select ADC0P.29.              
           =2 #define AMX0P_AMX0P__TEMP    0x1E ///< Temperature sensor.           
           =2 #define AMX0P_AMX0P__VDD     0x1F ///< VDD Supply Voltage.           
           =2 #define AMX0P_AMX0P__ADC0P32 0x20 ///< Select ADC0P.32.              
           =2 #define AMX0P_AMX0P__ADC0P33 0x21 ///< Select ADC0P.33.              
           =2 #define AMX0P_AMX0P__ADC0P34 0x22 ///< Select ADC0P.34.              
           =2                                                                      
           =2 //------------------------------------------------------------------------------
           =2 // ACC Enums (Accumulator @ 0xE0)
           =2 //------------------------------------------------------------------------------
           =2 #define ACC_ACC__FMASK 0xFF ///< Accumulator
           =2 #define ACC_ACC__SHIFT 0x00 ///< Accumulator
           =2                                             
           =2 //------------------------------------------------------------------------------
           =2 // B Enums (B Register @ 0xF0)
           =2 //------------------------------------------------------------------------------
           =2 #define B_B__FMASK 0xFF ///< B Register
           =2 #define B_B__SHIFT 0x00 ///< B Register
           =2                                        
           =2 //------------------------------------------------------------------------------
           =2 // DPH Enums (Data Pointer High @ 0x83)
           =2 //------------------------------------------------------------------------------
           =2 #define DPH_DPH__FMASK 0xFF ///< Data Pointer High
           =2 #define DPH_DPH__SHIFT 0x00 ///< Data Pointer High
           =2                                                   
           =2 //------------------------------------------------------------------------------
           =2 // DPL Enums (Data Pointer Low @ 0x82)
           =2 //------------------------------------------------------------------------------
           =2 #define DPL_DPL__FMASK 0xFF ///< Data Pointer Low
           =2 #define DPL_DPL__SHIFT 0x00 ///< Data Pointer Low
           =2                                                  
           =2 //------------------------------------------------------------------------------
           =2 // PFE0CN Enums (Prefetch Engine Control @ 0xAF)
           =2 //------------------------------------------------------------------------------
           =2 #define PFE0CN_FLBWE__BMASK                0x01 ///< Flash Block Write Enable                      
           =2 #define PFE0CN_FLBWE__SHIFT                0x00 ///< Flash Block Write Enable                      
           =2 #define PFE0CN_FLBWE__BLOCK_WRITE_DISABLED 0x00 ///< Each byte of a firmware flash write is written
           =2                                                 ///< individually.                                 
           =2 #define PFE0CN_FLBWE__BLOCK_WRITE_ENABLED  0x01 ///< Flash bytes are written in groups of two.     
           =2                                                                                                    
           =2 #define PFE0CN_PFEN__BMASK                 0x20 ///< Prefetch Enable                               
           =2 #define PFE0CN_PFEN__SHIFT                 0x05 ///< Prefetch Enable                               
           =2 #define PFE0CN_PFEN__DISABLED              0x00 ///< Disable the prefetch engine (SYSCLK < 25 MHz).
C51 COMPILER V9.56.0.0   SPI_0                                                             10/28/2016 17:37:02 PAGE 103 

           =2 #define PFE0CN_PFEN__ENABLED               0x20 ///< Enable the prefetch engine (SYSCLK > 25 MHz). 
           =2                                                                                                    
           =2 //------------------------------------------------------------------------------
           =2 // PSW Enums (Program Status Word @ 0xD0)
           =2 //------------------------------------------------------------------------------
           =2 #define PSW_PARITY__BMASK   0x01 ///< Parity Flag                                       
           =2 #define PSW_PARITY__SHIFT   0x00 ///< Parity Flag                                       
           =2 #define PSW_PARITY__NOT_SET 0x00 ///< The sum of the 8 bits in the accumulator is even. 
           =2 #define PSW_PARITY__SET     0x01 ///< The sum of the 8 bits in the accumulator is odd.  
           =2                                                                                         
           =2 #define PSW_F1__BMASK       0x02 ///< User Flag 1                                       
           =2 #define PSW_F1__SHIFT       0x01 ///< User Flag 1                                       
           =2 #define PSW_F1__NOT_SET     0x00 ///< Flag is not set.                                  
           =2 #define PSW_F1__SET         0x02 ///< Flag is set.                                      
           =2                                                                                         
           =2 #define PSW_OV__BMASK       0x04 ///< Overflow Flag                                     
           =2 #define PSW_OV__SHIFT       0x02 ///< Overflow Flag                                     
           =2 #define PSW_OV__NOT_SET     0x00 ///< An overflow did not occur.                        
           =2 #define PSW_OV__SET         0x04 ///< An overflow occurred.                             
           =2                                                                                         
           =2 #define PSW_RS__FMASK       0x18 ///< Register Bank Select                              
           =2 #define PSW_RS__SHIFT       0x03 ///< Register Bank Select                              
           =2 #define PSW_RS__BANK0       0x00 ///< Bank 0, Addresses 0x00-0x07                       
           =2 #define PSW_RS__BANK1       0x08 ///< Bank 1, Addresses 0x08-0x0F                       
           =2 #define PSW_RS__BANK2       0x10 ///< Bank 2, Addresses 0x10-0x17                       
           =2 #define PSW_RS__BANK3       0x18 ///< Bank 3, Addresses 0x18-0x1F                       
           =2                                                                                         
           =2 #define PSW_F0__BMASK       0x20 ///< User Flag 0                                       
           =2 #define PSW_F0__SHIFT       0x05 ///< User Flag 0                                       
           =2 #define PSW_F0__NOT_SET     0x00 ///< Flag is not set.                                  
           =2 #define PSW_F0__SET         0x20 ///< Flag is set.                                      
           =2                                                                                         
           =2 #define PSW_AC__BMASK       0x40 ///< Auxiliary Carry Flag                              
           =2 #define PSW_AC__SHIFT       0x06 ///< Auxiliary Carry Flag                              
           =2 #define PSW_AC__NOT_SET     0x00 ///< A carry into (addition) or borrow from            
           =2                                  ///< (subtraction) the high order nibble did not occur.
           =2 #define PSW_AC__SET         0x40 ///< A carry into (addition) or borrow from            
           =2                                  ///< (subtraction) the high order nibble occurred.     
           =2                                                                                         
           =2 #define PSW_CY__BMASK       0x80 ///< Carry Flag                                        
           =2 #define PSW_CY__SHIFT       0x07 ///< Carry Flag                                        
           =2 #define PSW_CY__NOT_SET     0x00 ///< A carry (addition) or borrow (subtraction) did not
           =2                                  ///< occur.                                            
           =2 #define PSW_CY__SET         0x80 ///< A carry (addition) or borrow (subtraction)        
           =2                                  ///< occurred.                                         
           =2                                                                                         
           =2 //------------------------------------------------------------------------------
           =2 // SP Enums (Stack Pointer @ 0x81)
           =2 //------------------------------------------------------------------------------
           =2 #define SP_SP__FMASK 0xFF ///< Stack Pointer
           =2 #define SP_SP__SHIFT 0x00 ///< Stack Pointer
           =2                                             
           =2 //------------------------------------------------------------------------------
           =2 // CLKSEL Enums (Clock Select @ 0xA9)
           =2 //------------------------------------------------------------------------------
           =2 #define CLKSEL_CLKSL__FMASK               0x07 ///< System Clock Source Select Bits                   
           =2 #define CLKSEL_CLKSL__SHIFT               0x00 ///< System Clock Source Select Bits                   
           =2 #define CLKSEL_CLKSL__DIVIDED_HFOSC_DIV_4 0x00 ///< Clock (SYSCLK) derived from the Internal High-    
           =2                                                ///< Frequency Oscillator / 4 and scaled per the IFCN  
           =2                                                ///< bits in register OSCICN.                          
           =2 #define CLKSEL_CLKSL__EXTOSC              0x01 ///< Clock (SYSCLK) derived from the External          
           =2                                                ///< Oscillator circuit.                               
C51 COMPILER V9.56.0.0   SPI_0                                                             10/28/2016 17:37:02 PAGE 104 

           =2 #define CLKSEL_CLKSL__HFOSC_DIV_2         0x02 ///< Clock (SYSCLK) derived from the Internal High-    
           =2                                                ///< Frequency Oscillator / 2.                         
           =2 #define CLKSEL_CLKSL__HFOSC               0x03 ///< Clock (SYSCLK) derived from the Internal High-    
           =2                                                ///< Frequency Oscillator.                             
           =2 #define CLKSEL_CLKSL__LFOSC               0x04 ///< Clock (SYSCLK) derived from the Internal Low-     
           =2                                                ///< Frequency Oscillator and scaled per the OSCLD bits
           =2                                                ///< in register OSCLCN.                               
           =2                                                                                                       
           =2 #define CLKSEL_OUTCLK__BMASK              0x08 ///< Crossbar Clock Out Select                         
           =2 #define CLKSEL_OUTCLK__SHIFT              0x03 ///< Crossbar Clock Out Select                         
           =2 #define CLKSEL_OUTCLK__SYSCLK             0x00 ///< Enabling the Crossbar SYSCLK signal outputs       
           =2                                                ///< SYSCLK.                                           
           =2 #define CLKSEL_OUTCLK__SYSCLK_SYNC_IO     0x08 ///< Enabling the Crossbar SYSCLK signal outputs SYSCLK
           =2                                                ///< synchronized with the Port I/O.                   
           =2                                                                                                       
           =2 #define CLKSEL_USBCLK__FMASK              0x70 ///< USB Clock Source Select Bits                      
           =2 #define CLKSEL_USBCLK__SHIFT              0x04 ///< USB Clock Source Select Bits                      
           =2 #define CLKSEL_USBCLK__HFOSC              0x00 ///< USB clock (USBCLK) derived from the Internal High-
           =2                                                ///< Frequency Oscillator.                             
           =2 #define CLKSEL_USBCLK__HFOSC_DIV_8        0x10 ///< USB clock (USBCLK) derived from the Internal High-
           =2                                                ///< Frequency Oscillator / 8.                         
           =2 #define CLKSEL_USBCLK__EXTOSC             0x20 ///< USB clock (USBCLK) derived from the External      
           =2                                                ///< Oscillator.                                       
           =2 #define CLKSEL_USBCLK__EXTOSC_DIV_2       0x30 ///< USB clock (USBCLK) derived from the External      
           =2                                                ///< Oscillator / 2.                                   
           =2 #define CLKSEL_USBCLK__EXTOSC_DIV_3       0x40 ///< USB clock (USBCLK) derived from the External      
           =2                                                ///< Oscillator / 3.                                   
           =2 #define CLKSEL_USBCLK__EXTOSC_DIV_4       0x50 ///< USB clock (USBCLK) derived from the External      
           =2                                                ///< Oscillator / 4.                                   
           =2 #define CLKSEL_USBCLK__LFOSC              0x60 ///< USB clock (USBCLK) derived from the Internal Low- 
           =2                                                ///< Frequency Oscillator.                             
           =2                                                                                                       
           =2 //------------------------------------------------------------------------------
           =2 // CMP0CN0 Enums (Comparator 0 Control 0 @ 0x9B)
           =2 //------------------------------------------------------------------------------
           =2 #define CMP0CN0_CPHYN__FMASK                0x03 ///< Comparator Negative Hysteresis Control            
           =2 #define CMP0CN0_CPHYN__SHIFT                0x00 ///< Comparator Negative Hysteresis Control            
           =2 #define CMP0CN0_CPHYN__DISABLED             0x00 ///< Negative Hysteresis disabled.                     
           =2 #define CMP0CN0_CPHYN__ENABLED_MODE1        0x01 ///< Negative Hysteresis = Hysteresis 1.               
           =2 #define CMP0CN0_CPHYN__ENABLED_MODE2        0x02 ///< Negative Hysteresis = Hysteresis 2.               
           =2 #define CMP0CN0_CPHYN__ENABLED_MODE3        0x03 ///< Negative Hysteresis = Hysteresis 3 (Maximum).     
           =2                                                                                                         
           =2 #define CMP0CN0_CPHYP__FMASK                0x0C ///< Comparator Positive Hysteresis Control            
           =2 #define CMP0CN0_CPHYP__SHIFT                0x02 ///< Comparator Positive Hysteresis Control            
           =2 #define CMP0CN0_CPHYP__DISABLED             0x00 ///< Positive Hysteresis disabled.                     
           =2 #define CMP0CN0_CPHYP__ENABLED_MODE1        0x04 ///< Positive Hysteresis = Hysteresis 1.               
           =2 #define CMP0CN0_CPHYP__ENABLED_MODE2        0x08 ///< Positive Hysteresis = Hysteresis 2.               
           =2 #define CMP0CN0_CPHYP__ENABLED_MODE3        0x0C ///< Positive Hysteresis = Hysteresis 3 (Maximum).     
           =2                                                                                                         
           =2 #define CMP0CN0_CPFIF__BMASK                0x10 ///< Comparator Falling-Edge Flag                      
           =2 #define CMP0CN0_CPFIF__SHIFT                0x04 ///< Comparator Falling-Edge Flag                      
           =2 #define CMP0CN0_CPFIF__NOT_SET              0x00 ///< No comparator falling edge has occurred since this
           =2                                                  ///< flag was last cleared.                            
           =2 #define CMP0CN0_CPFIF__FALLING_EDGE         0x10 ///< Comparator falling edge has occurred.             
           =2                                                                                                         
           =2 #define CMP0CN0_CPRIF__BMASK                0x20 ///< Comparator Rising-Edge Flag                       
           =2 #define CMP0CN0_CPRIF__SHIFT                0x05 ///< Comparator Rising-Edge Flag                       
           =2 #define CMP0CN0_CPRIF__NOT_SET              0x00 ///< No comparator rising edge has occurred since this 
           =2                                                  ///< flag was last cleared.                            
           =2 #define CMP0CN0_CPRIF__RISING_EDGE          0x20 ///< Comparator rising edge has occurred.              
           =2                                                                                                         
           =2 #define CMP0CN0_CPOUT__BMASK                0x40 ///< Comparator Output State Flag                      
C51 COMPILER V9.56.0.0   SPI_0                                                             10/28/2016 17:37:02 PAGE 105 

           =2 #define CMP0CN0_CPOUT__SHIFT                0x06 ///< Comparator Output State Flag                      
           =2 #define CMP0CN0_CPOUT__POS_LESS_THAN_NEG    0x00 ///< Voltage on CP0P < CP0N.                           
           =2 #define CMP0CN0_CPOUT__POS_GREATER_THAN_NEG 0x40 ///< Voltage on CP0P > CP0N.                           
           =2                                                                                                         
           =2 #define CMP0CN0_CPEN__BMASK                 0x80 ///< Comparator Enable                                 
           =2 #define CMP0CN0_CPEN__SHIFT                 0x07 ///< Comparator Enable                                 
           =2 #define CMP0CN0_CPEN__DISABLED              0x00 ///< Comparator disabled.                              
           =2 #define CMP0CN0_CPEN__ENABLED               0x80 ///< Comparator enabled.                               
           =2                                                                                                         
           =2 //------------------------------------------------------------------------------
           =2 // CMP0MD Enums (Comparator 0 Mode @ 0x9D)
           =2 //------------------------------------------------------------------------------
           =2 #define CMP0MD_CPMD__FMASK              0x03 ///< Comparator Mode Select                      
           =2 #define CMP0MD_CPMD__SHIFT              0x00 ///< Comparator Mode Select                      
           =2 #define CMP0MD_CPMD__MODE0              0x00 ///< Mode 0 (Fastest Response Time, Highest Power
           =2                                              ///< Consumption)                                
           =2 #define CMP0MD_CPMD__MODE1              0x01 ///< Mode 1                                      
           =2 #define CMP0MD_CPMD__MODE2              0x02 ///< Mode 2                                      
           =2 #define CMP0MD_CPMD__MODE3              0x03 ///< Mode 3 (Slowest Response Time, Lowest Power 
           =2                                              ///< Consumption)                                
           =2                                                                                               
           =2 #define CMP0MD_CPFIE__BMASK             0x10 ///< Comparator Falling-Edge Interrupt Enable    
           =2 #define CMP0MD_CPFIE__SHIFT             0x04 ///< Comparator Falling-Edge Interrupt Enable    
           =2 #define CMP0MD_CPFIE__FALL_INT_DISABLED 0x00 ///< Comparator falling-edge interrupt disabled. 
           =2 #define CMP0MD_CPFIE__FALL_INT_ENABLED  0x10 ///< Comparator falling-edge interrupt enabled.  
           =2                                                                                               
           =2 #define CMP0MD_CPRIE__BMASK             0x20 ///< Comparator Rising-Edge Interrupt Enable     
           =2 #define CMP0MD_CPRIE__SHIFT             0x05 ///< Comparator Rising-Edge Interrupt Enable     
           =2 #define CMP0MD_CPRIE__RISE_INT_DISABLED 0x00 ///< Comparator rising-edge interrupt disabled.  
           =2 #define CMP0MD_CPRIE__RISE_INT_ENABLED  0x20 ///< Comparator rising-edge interrupt enabled.   
           =2                                                                                               
           =2 //------------------------------------------------------------------------------
           =2 // CMP0MX Enums (Comparator 0 Multiplexer Selection @ 0x9F)
           =2 //------------------------------------------------------------------------------
           =2 #define CMP0MX_CMXP__FMASK  0x07 ///< Comparator Positive Input MUX Selection
           =2 #define CMP0MX_CMXP__SHIFT  0x00 ///< Comparator Positive Input MUX Selection
           =2 #define CMP0MX_CMXP__CMP0P0 0x00 ///< External pin CMP0P.0.                  
           =2 #define CMP0MX_CMXP__CMP0P1 0x01 ///< External pin CMP0P.1.                  
           =2 #define CMP0MX_CMXP__CMP0P2 0x02 ///< External pin CMP0P.2.                  
           =2 #define CMP0MX_CMXP__CMP0P3 0x03 ///< External pin CMP0P.3.                  
           =2 #define CMP0MX_CMXP__CMP0P4 0x04 ///< External pin CMP0P.4.                  
           =2                                                                              
           =2 #define CMP0MX_CMXN__FMASK  0x70 ///< Comparator Negative Input MUX Selection
           =2 #define CMP0MX_CMXN__SHIFT  0x04 ///< Comparator Negative Input MUX Selection
           =2 #define CMP0MX_CMXN__CMP0N0 0x00 ///< External pin CMP0N.0.                  
           =2 #define CMP0MX_CMXN__CMP0N1 0x10 ///< External pin CMP0N.1.                  
           =2 #define CMP0MX_CMXN__CMP0N2 0x20 ///< External pin CMP0N.2.                  
           =2 #define CMP0MX_CMXN__CMP0N3 0x30 ///< External pin CMP0N.3.                  
           =2 #define CMP0MX_CMXN__CMP0N4 0x40 ///< External pin CMP0N.4.                  
           =2                                                                              
           =2 //------------------------------------------------------------------------------
           =2 // CMP1CN0 Enums (Comparator 1 Control 0 @ 0x9A)
           =2 //------------------------------------------------------------------------------
           =2 #define CMP1CN0_CPHYN__FMASK                0x03 ///< Comparator Negative Hysteresis Control            
           =2 #define CMP1CN0_CPHYN__SHIFT                0x00 ///< Comparator Negative Hysteresis Control            
           =2 #define CMP1CN0_CPHYN__DISABLED             0x00 ///< Negative Hysteresis disabled.                     
           =2 #define CMP1CN0_CPHYN__ENABLED_MODE1        0x01 ///< Negative Hysteresis = Hysteresis 1.               
           =2 #define CMP1CN0_CPHYN__ENABLED_MODE2        0x02 ///< Negative Hysteresis = Hysteresis 2.               
           =2 #define CMP1CN0_CPHYN__ENABLED_MODE3        0x03 ///< Negative Hysteresis = Hysteresis 3 (Maximum).     
           =2                                                                                                         
           =2 #define CMP1CN0_CPHYP__FMASK                0x0C ///< Comparator Positive Hysteresis Control            
           =2 #define CMP1CN0_CPHYP__SHIFT                0x02 ///< Comparator Positive Hysteresis Control            
C51 COMPILER V9.56.0.0   SPI_0                                                             10/28/2016 17:37:02 PAGE 106 

           =2 #define CMP1CN0_CPHYP__DISABLED             0x00 ///< Positive Hysteresis disabled.                     
           =2 #define CMP1CN0_CPHYP__ENABLED_MODE1        0x04 ///< Positive Hysteresis = Hysteresis 1.               
           =2 #define CMP1CN0_CPHYP__ENABLED_MODE2        0x08 ///< Positive Hysteresis = Hysteresis 2.               
           =2 #define CMP1CN0_CPHYP__ENABLED_MODE3        0x0C ///< Positive Hysteresis = Hysteresis 3 (Maximum).     
           =2                                                                                                         
           =2 #define CMP1CN0_CPFIF__BMASK                0x10 ///< Comparator Falling-Edge Flag                      
           =2 #define CMP1CN0_CPFIF__SHIFT                0x04 ///< Comparator Falling-Edge Flag                      
           =2 #define CMP1CN0_CPFIF__NOT_SET              0x00 ///< No comparator falling edge has occurred since this
           =2                                                  ///< flag was last cleared.                            
           =2 #define CMP1CN0_CPFIF__FALLING_EDGE         0x10 ///< Comparator falling edge has occurred.             
           =2                                                                                                         
           =2 #define CMP1CN0_CPRIF__BMASK                0x20 ///< Comparator Rising-Edge Flag                       
           =2 #define CMP1CN0_CPRIF__SHIFT                0x05 ///< Comparator Rising-Edge Flag                       
           =2 #define CMP1CN0_CPRIF__NOT_SET              0x00 ///< No comparator rising edge has occurred since this 
           =2                                                  ///< flag was last cleared.                            
           =2 #define CMP1CN0_CPRIF__RISING_EDGE          0x20 ///< Comparator rising edge has occurred.              
           =2                                                                                                         
           =2 #define CMP1CN0_CPOUT__BMASK                0x40 ///< Comparator Output State Flag                      
           =2 #define CMP1CN0_CPOUT__SHIFT                0x06 ///< Comparator Output State Flag                      
           =2 #define CMP1CN0_CPOUT__POS_LESS_THAN_NEG    0x00 ///< Voltage on CP1P < CP1N.                           
           =2 #define CMP1CN0_CPOUT__POS_GREATER_THAN_NEG 0x40 ///< Voltage on CP1P > CP1N.                           
           =2                                                                                                         
           =2 #define CMP1CN0_CPEN__BMASK                 0x80 ///< Comparator Enable                                 
           =2 #define CMP1CN0_CPEN__SHIFT                 0x07 ///< Comparator Enable                                 
           =2 #define CMP1CN0_CPEN__DISABLED              0x00 ///< Comparator disabled.                              
           =2 #define CMP1CN0_CPEN__ENABLED               0x80 ///< Comparator enabled.                               
           =2                                                                                                         
           =2 //------------------------------------------------------------------------------
           =2 // CMP1MD Enums (Comparator 1 Mode @ 0x9C)
           =2 //------------------------------------------------------------------------------
           =2 #define CMP1MD_CPMD__FMASK              0x03 ///< Comparator Mode Select                      
           =2 #define CMP1MD_CPMD__SHIFT              0x00 ///< Comparator Mode Select                      
           =2 #define CMP1MD_CPMD__MODE0              0x00 ///< Mode 0 (Fastest Response Time, Highest Power
           =2                                              ///< Consumption)                                
           =2 #define CMP1MD_CPMD__MODE1              0x01 ///< Mode 1                                      
           =2 #define CMP1MD_CPMD__MODE2              0x02 ///< Mode 2                                      
           =2 #define CMP1MD_CPMD__MODE3              0x03 ///< Mode 3 (Slowest Response Time, Lowest Power 
           =2                                              ///< Consumption)                                
           =2                                                                                               
           =2 #define CMP1MD_CPFIE__BMASK             0x10 ///< Comparator Falling-Edge Interrupt Enable    
           =2 #define CMP1MD_CPFIE__SHIFT             0x04 ///< Comparator Falling-Edge Interrupt Enable    
           =2 #define CMP1MD_CPFIE__FALL_INT_DISABLED 0x00 ///< Comparator falling-edge interrupt disabled. 
           =2 #define CMP1MD_CPFIE__FALL_INT_ENABLED  0x10 ///< Comparator falling-edge interrupt enabled.  
           =2                                                                                               
           =2 #define CMP1MD_CPRIE__BMASK             0x20 ///< Comparator Rising-Edge Interrupt Enable     
           =2 #define CMP1MD_CPRIE__SHIFT             0x05 ///< Comparator Rising-Edge Interrupt Enable     
           =2 #define CMP1MD_CPRIE__RISE_INT_DISABLED 0x00 ///< Comparator rising-edge interrupt disabled.  
           =2 #define CMP1MD_CPRIE__RISE_INT_ENABLED  0x20 ///< Comparator rising-edge interrupt enabled.   
           =2                                                                                               
           =2 //------------------------------------------------------------------------------
           =2 // CMP1MX Enums (Comparator 1 Multiplexer Selection @ 0x9E)
           =2 //------------------------------------------------------------------------------
           =2 #define CMP1MX_CMXP__FMASK  0x07 ///< Comparator Positive Input MUX Selection
           =2 #define CMP1MX_CMXP__SHIFT  0x00 ///< Comparator Positive Input MUX Selection
           =2 #define CMP1MX_CMXP__CMP1P0 0x00 ///< External pin CMP1P.0.                  
           =2 #define CMP1MX_CMXP__CMP1P1 0x01 ///< External pin CMP1P.1.                  
           =2 #define CMP1MX_CMXP__CMP1P2 0x02 ///< External pin CMP1P.2.                  
           =2 #define CMP1MX_CMXP__CMP1P3 0x03 ///< External pin CMP1P.3.                  
           =2 #define CMP1MX_CMXP__CMP1P4 0x04 ///< External pin CMP1P.4.                  
           =2                                                                              
           =2 #define CMP1MX_CMXN__FMASK  0x70 ///< Comparator Negative Input MUX Selection
           =2 #define CMP1MX_CMXN__SHIFT  0x04 ///< Comparator Negative Input MUX Selection
C51 COMPILER V9.56.0.0   SPI_0                                                             10/28/2016 17:37:02 PAGE 107 

           =2 #define CMP1MX_CMXN__CMP1N0 0x00 ///< External pin CMP1N.0.                  
           =2 #define CMP1MX_CMXN__CMP1N1 0x10 ///< External pin CMP1N.1.                  
           =2 #define CMP1MX_CMXN__CMP1N2 0x20 ///< External pin CMP1N.2.                  
           =2 #define CMP1MX_CMXN__CMP1N3 0x30 ///< External pin CMP1N.3.                  
           =2 #define CMP1MX_CMXN__CMP1N4 0x40 ///< External pin CMP1N.4.                  
           =2                                                                              
           =2 //------------------------------------------------------------------------------
           =2 // IT01CF Enums (INT0/INT1 Configuration @ 0xE4)
           =2 //------------------------------------------------------------------------------
           =2 #define IT01CF_IN0SL__FMASK       0x07 ///< INT0 Port Pin Selection   
           =2 #define IT01CF_IN0SL__SHIFT       0x00 ///< INT0 Port Pin Selection   
           =2 #define IT01CF_IN0SL__P0_0        0x00 ///< Select P0.0.              
           =2 #define IT01CF_IN0SL__P0_1        0x01 ///< Select P0.1.              
           =2 #define IT01CF_IN0SL__P0_2        0x02 ///< Select P0.2.              
           =2 #define IT01CF_IN0SL__P0_3        0x03 ///< Select P0.3.              
           =2 #define IT01CF_IN0SL__P0_4        0x04 ///< Select P0.4.              
           =2 #define IT01CF_IN0SL__P0_5        0x05 ///< Select P0.5.              
           =2 #define IT01CF_IN0SL__P0_6        0x06 ///< Select P0.6.              
           =2 #define IT01CF_IN0SL__P0_7        0x07 ///< Select P0.7.              
           =2                                                                       
           =2 #define IT01CF_IN0PL__BMASK       0x08 ///< INT0 Polarity             
           =2 #define IT01CF_IN0PL__SHIFT       0x03 ///< INT0 Polarity             
           =2 #define IT01CF_IN0PL__ACTIVE_LOW  0x00 ///< INT0 input is active low. 
           =2 #define IT01CF_IN0PL__ACTIVE_HIGH 0x08 ///< INT0 input is active high.
           =2                                                                       
           =2 #define IT01CF_IN1SL__FMASK       0x70 ///< INT1 Port Pin Selection   
           =2 #define IT01CF_IN1SL__SHIFT       0x04 ///< INT1 Port Pin Selection   
           =2 #define IT01CF_IN1SL__P0_0        0x00 ///< Select P0.0.              
           =2 #define IT01CF_IN1SL__P0_1        0x10 ///< Select P0.1.              
           =2 #define IT01CF_IN1SL__P0_2        0x20 ///< Select P0.2.              
           =2 #define IT01CF_IN1SL__P0_3        0x30 ///< Select P0.3.              
           =2 #define IT01CF_IN1SL__P0_4        0x40 ///< Select P0.4.              
           =2 #define IT01CF_IN1SL__P0_5        0x50 ///< Select P0.5.              
           =2 #define IT01CF_IN1SL__P0_6        0x60 ///< Select P0.6.              
           =2 #define IT01CF_IN1SL__P0_7        0x70 ///< Select P0.7.              
           =2                                                                       
           =2 #define IT01CF_IN1PL__BMASK       0x80 ///< INT1 Polarity             
           =2 #define IT01CF_IN1PL__SHIFT       0x07 ///< INT1 Polarity             
           =2 #define IT01CF_IN1PL__ACTIVE_LOW  0x00 ///< INT1 input is active low. 
           =2 #define IT01CF_IN1PL__ACTIVE_HIGH 0x80 ///< INT1 input is active high.
           =2                                                                       
           =2 //------------------------------------------------------------------------------
           =2 // XOSC0CN Enums (External Oscillator Control @ 0xB1)
           =2 //------------------------------------------------------------------------------
           =2 #define XOSC0CN_XFCN__FMASK           0x07 ///< External Oscillator Frequency Control            
           =2 #define XOSC0CN_XFCN__SHIFT           0x00 ///< External Oscillator Frequency Control            
           =2 #define XOSC0CN_XFCN__MODE0           0x00 ///< Select external oscillator mode 0: Crystal       
           =2                                            ///< frequency <= 20 kHz, RC/C frequency <= 25 kHz, C 
           =2                                            ///< mode K factor = 0.87.                            
           =2 #define XOSC0CN_XFCN__MODE1           0x01 ///< Select external oscillator mode 1: 20 kHz <      
           =2                                            ///< Crystal frequency <= 58 kHz, 25 kHz < RC/C       
           =2                                            ///< frequency <= 50 kHz, C mode K factor = 2.6.      
           =2 #define XOSC0CN_XFCN__MODE2           0x02 ///< Select external oscillator mode 2: 58 kHz <      
           =2                                            ///< Crystal frequency <= 155 kHz, 50 kHz < RC/C      
           =2                                            ///< frequency <= 100 kHz, C mode K factor = 7.7.     
           =2 #define XOSC0CN_XFCN__MODE3           0x03 ///< Select external oscillator mode 3: 155 kHz <     
           =2                                            ///< Crystal frequency <= 415 kHz, 100 kHz < RC/C     
           =2                                            ///< frequency <= 200 kHz, C mode K factor = 22.      
           =2 #define XOSC0CN_XFCN__MODE4           0x04 ///< Select external oscillator mode 4: 415 kHz <     
           =2                                            ///< Crystal frequency <= 1.1 MHz, 200 kHz < RC/C     
           =2                                            ///< frequency <= 400 kHz, C mode K factor = 65.      
           =2 #define XOSC0CN_XFCN__MODE5           0x05 ///< Select external oscillator mode 5: 1.1 MHz <     
C51 COMPILER V9.56.0.0   SPI_0                                                             10/28/2016 17:37:02 PAGE 108 

           =2                                            ///< Crystal frequency <= 3.1 MHz, 400 kHz < RC/C     
           =2                                            ///< frequency <= 800 kHz, C mode K factor = 180.     
           =2 #define XOSC0CN_XFCN__MODE6           0x06 ///< Select external oscillator mode 6: 3.1 MHz <     
           =2                                            ///< Crystal frequency <= 8.2 kHz, 800 kHz < RC/C     
           =2                                            ///< frequency <= 1.6 MHz, C mode K factor = 664.     
           =2 #define XOSC0CN_XFCN__MODE7           0x07 ///< Select external oscillator mode 7: 8.2 MHz <     
           =2                                            ///< Crystal frequency <= 25 MHz, 1.6 MHz < RC/C      
           =2                                            ///< frequency <= 3.2 MHz, C mode K factor = 1590.    
           =2                                                                                                  
           =2 #define XOSC0CN_XOSCMD__FMASK         0x70 ///< External Oscillator Mode                         
           =2 #define XOSC0CN_XOSCMD__SHIFT         0x04 ///< External Oscillator Mode                         
           =2 #define XOSC0CN_XOSCMD__DISABLED      0x00 ///< External Oscillator circuit disabled.            
           =2 #define XOSC0CN_XOSCMD__CMOS          0x20 ///< External CMOS Clock Mode.                        
           =2 #define XOSC0CN_XOSCMD__CMOS_DIV_2    0x30 ///< External CMOS Clock Mode with divide by 2 stage. 
           =2 #define XOSC0CN_XOSCMD__RC_DIV_2      0x40 ///< RC Oscillator Mode with divide by 2 stage.       
           =2 #define XOSC0CN_XOSCMD__C_DIV_2       0x50 ///< Capacitor Oscillator Mode with divide by 2 stage.
           =2 #define XOSC0CN_XOSCMD__CRYSTAL       0x60 ///< Crystal Oscillator Mode.                         
           =2 #define XOSC0CN_XOSCMD__CRYSTAL_DIV_2 0x70 ///< Crystal Oscillator Mode with divide by 2 stage.  
           =2                                                                                                  
           =2 #define XOSC0CN_XCLKVLD__BMASK        0x80 ///< External Oscillator Valid Flag                   
           =2 #define XOSC0CN_XCLKVLD__SHIFT        0x07 ///< External Oscillator Valid Flag                   
           =2 #define XOSC0CN_XCLKVLD__NOT_SET      0x00 ///< External Oscillator is unused or not yet stable. 
           =2 #define XOSC0CN_XCLKVLD__SET          0x80 ///< External Oscillator is running and stable.       
           =2                                                                                                  
           =2 //------------------------------------------------------------------------------
           =2 // FLKEY Enums (Flash Lock and Key @ 0xB7)
           =2 //------------------------------------------------------------------------------
           =2 #define FLKEY_FLKEY__FMASK    0xFF ///< Flash Lock and Key                             
           =2 #define FLKEY_FLKEY__SHIFT    0x00 ///< Flash Lock and Key                             
           =2 #define FLKEY_FLKEY__LOCKED   0x00 ///< Flash is write/erase locked.                   
           =2 #define FLKEY_FLKEY__FIRST    0x01 ///< The first key code has been written (0xA5).    
           =2 #define FLKEY_FLKEY__UNLOCKED 0x02 ///< Flash is unlocked (writes/erases allowed).     
           =2 #define FLKEY_FLKEY__DISABLED 0x03 ///< Flash writes/erases are disabled until the next
           =2                                    ///< reset.                                         
           =2 #define FLKEY_FLKEY__KEY1     0xA5 ///< Flash writes and erases are enabled by writing 
           =2                                    ///< 0xA5 followed by 0xF1 to the FLKEY register.   
           =2 #define FLKEY_FLKEY__KEY2     0xF1 ///< Flash writes and erases are enabled by writing 
           =2                                    ///< 0xA5 followed by 0xF1 to the FLKEY register.   
           =2                                                                                        
           =2 //------------------------------------------------------------------------------
           =2 // FLSCL Enums (Flash Scale @ 0xB6)
           =2 //------------------------------------------------------------------------------
           =2 #define FLSCL_FLRT__BMASK               0x10 ///< Flash Read Timing                       
           =2 #define FLSCL_FLRT__SHIFT               0x04 ///< Flash Read Timing                       
           =2 #define FLSCL_FLRT__SYSCLK_BELOW_25_MHZ 0x00 ///< SYSCLK <= 25 MHz.                       
           =2 #define FLSCL_FLRT__SYSCLK_BELOW_48_MHZ 0x10 ///< SYSCLK <= 48 MHz.                       
           =2                                                                                           
           =2 #define FLSCL_FOSE__BMASK               0x80 ///< Flash One-Shot Enable                   
           =2 #define FLSCL_FOSE__SHIFT               0x07 ///< Flash One-Shot Enable                   
           =2 #define FLSCL_FOSE__DISABLED            0x00 ///< Disable the flash one-shot.             
           =2 #define FLSCL_FOSE__ENABLED             0x80 ///< Enable the flash one-shot (recommended).
           =2                                                                                           
           =2 //------------------------------------------------------------------------------
           =2 // PSCTL Enums (Program Store Control @ 0x8F)
           =2 //------------------------------------------------------------------------------
           =2 #define PSCTL_PSWE__BMASK          0x01 ///< Program Store Write Enable                      
           =2 #define PSCTL_PSWE__SHIFT          0x00 ///< Program Store Write Enable                      
           =2 #define PSCTL_PSWE__WRITE_DISABLED 0x00 ///< Writes to flash program memory disabled.        
           =2 #define PSCTL_PSWE__WRITE_ENABLED  0x01 ///< Writes to flash program memory enabled; the MOVX
           =2                                         ///< write instruction targets flash memory.         
           =2                                                                                              
           =2 #define PSCTL_PSEE__BMASK          0x02 ///< Program Store Erase Enable                      
C51 COMPILER V9.56.0.0   SPI_0                                                             10/28/2016 17:37:02 PAGE 109 

           =2 #define PSCTL_PSEE__SHIFT          0x01 ///< Program Store Erase Enable                      
           =2 #define PSCTL_PSEE__ERASE_DISABLED 0x00 ///< Flash program memory erasure disabled.          
           =2 #define PSCTL_PSEE__ERASE_ENABLED  0x02 ///< Flash program memory erasure enabled.           
           =2                                                                                              
           =2 //------------------------------------------------------------------------------
           =2 // HFO0CAL Enums (High Frequency Oscillator Calibration @ 0xB3)
           =2 //------------------------------------------------------------------------------
           =2 #define HFO0CAL_OSCICL__FMASK 0x7F ///< Internal Oscillator Calibration
           =2 #define HFO0CAL_OSCICL__SHIFT 0x00 ///< Internal Oscillator Calibration
           =2                                                                        
           =2 //------------------------------------------------------------------------------
           =2 // HFO0CN Enums (High Frequency Oscillator Control @ 0xB2)
           =2 //------------------------------------------------------------------------------
           =2 #define HFO0CN_IFCN__FMASK        0x03 ///< Oscillator Frequency Divider Control              
           =2 #define HFO0CN_IFCN__SHIFT        0x00 ///< Oscillator Frequency Divider Control              
           =2 #define HFO0CN_IFCN__SYSCLK_DIV_8 0x00 ///< SYSCLK can be derived from Internal H-F Oscillator
           =2                                        ///< divided by 8 (1.5 MHz).                           
           =2 #define HFO0CN_IFCN__SYSCLK_DIV_4 0x01 ///< SYSCLK can be derived from Internal H-F Oscillator
           =2                                        ///< divided by 4 (3 MHz).                             
           =2 #define HFO0CN_IFCN__SYSCLK_DIV_2 0x02 ///< SYSCLK can be derived from Internal H-F Oscillator
           =2                                        ///< divided by 2 (6 MHz).                             
           =2 #define HFO0CN_IFCN__SYSCLK_DIV_1 0x03 ///< SYSCLK can be derived from Internal H-F Oscillator
           =2                                        ///< divided by 1 (12 MHz).                            
           =2                                                                                               
           =2 #define HFO0CN_SUSPEND__BMASK     0x20 ///< Oscillator Suspend Enable                         
           =2 #define HFO0CN_SUSPEND__SHIFT     0x05 ///< Oscillator Suspend Enable                         
           =2 #define HFO0CN_SUSPEND__DISABLED  0x00 ///< The internal oscillator is not in suspend mode.   
           =2 #define HFO0CN_SUSPEND__ENABLED   0x20 ///< Place the internal oscillator in suspend mode.    
           =2                                                                                               
           =2 #define HFO0CN_IFRDY__BMASK       0x40 ///< Oscillator Frequency Ready Flag                   
           =2 #define HFO0CN_IFRDY__SHIFT       0x06 ///< Oscillator Frequency Ready Flag                   
           =2 #define HFO0CN_IFRDY__NOT_SET     0x00 ///< The Internal High Frequency Oscillator is not     
           =2                                        ///< running at the programmed frequency.              
           =2 #define HFO0CN_IFRDY__SET         0x40 ///< The Internal High Frequency Oscillator is running 
           =2                                        ///< at the programmed frequency.                      
           =2                                                                                               
           =2 #define HFO0CN_IOSCEN__BMASK      0x80 ///< Oscillator Enable                                 
           =2 #define HFO0CN_IOSCEN__SHIFT      0x07 ///< Oscillator Enable                                 
           =2 #define HFO0CN_IOSCEN__DISABLED   0x00 ///< Disable the High Frequency Oscillator.            
           =2 #define HFO0CN_IOSCEN__ENABLED    0x80 ///< Enable the High Frequency Oscillator.             
           =2                                                                                               
           =2 //------------------------------------------------------------------------------
           =2 // EIE1 Enums (Extended Interrupt Enable 1 @ 0xE6)
           =2 //------------------------------------------------------------------------------
           =2 #define EIE1_ESMB0__BMASK     0x01 ///< SMBus (SMB0) Interrupt Enable                     
           =2 #define EIE1_ESMB0__SHIFT     0x00 ///< SMBus (SMB0) Interrupt Enable                     
           =2 #define EIE1_ESMB0__DISABLED  0x00 ///< Disable all SMB0 interrupts.                      
           =2 #define EIE1_ESMB0__ENABLED   0x01 ///< Enable interrupt requests generated by SMB0.      
           =2                                                                                           
           =2 #define EIE1_EUSB0__BMASK     0x02 ///< USB (USB0) Interrupt Enable                       
           =2 #define EIE1_EUSB0__SHIFT     0x01 ///< USB (USB0) Interrupt Enable                       
           =2 #define EIE1_EUSB0__DISABLED  0x00 ///< Disable all USB0 interrupts.                      
           =2 #define EIE1_EUSB0__ENABLED   0x02 ///< Enable interrupt requests generated by USB0.      
           =2                                                                                           
           =2 #define EIE1_EWADC0__BMASK    0x04 ///< ADC0 Window Comparison Interrupt Enable           
           =2 #define EIE1_EWADC0__SHIFT    0x02 ///< ADC0 Window Comparison Interrupt Enable           
           =2 #define EIE1_EWADC0__DISABLED 0x00 ///< Disable ADC0 Window Comparison interrupt.         
           =2 #define EIE1_EWADC0__ENABLED  0x04 ///< Enable interrupt requests generated by ADC0 Window
           =2                                    ///< Compare flag (ADWINT).                            
           =2                                                                                           
           =2 #define EIE1_EADC0__BMASK     0x08 ///< ADC0 Conversion Complete Interrupt Enable         
           =2 #define EIE1_EADC0__SHIFT     0x03 ///< ADC0 Conversion Complete Interrupt Enable         
C51 COMPILER V9.56.0.0   SPI_0                                                             10/28/2016 17:37:02 PAGE 110 

           =2 #define EIE1_EADC0__DISABLED  0x00 ///< Disable ADC0 Conversion Complete interrupt.       
           =2 #define EIE1_EADC0__ENABLED   0x08 ///< Enable interrupt requests generated by the ADINT  
           =2                                    ///< flag.                                             
           =2                                                                                           
           =2 #define EIE1_EPCA0__BMASK     0x10 ///< Programmable Counter Array (PCA0) Interrupt Enable
           =2 #define EIE1_EPCA0__SHIFT     0x04 ///< Programmable Counter Array (PCA0) Interrupt Enable
           =2 #define EIE1_EPCA0__DISABLED  0x00 ///< Disable all PCA0 interrupts.                      
           =2 #define EIE1_EPCA0__ENABLED   0x10 ///< Enable interrupt requests generated by PCA0.      
           =2                                                                                           
           =2 #define EIE1_ECP0__BMASK      0x20 ///< Comparator0 (CP0) Interrupt Enable                
           =2 #define EIE1_ECP0__SHIFT      0x05 ///< Comparator0 (CP0) Interrupt Enable                
           =2 #define EIE1_ECP0__DISABLED   0x00 ///< Disable CP0 interrupts.                           
           =2 #define EIE1_ECP0__ENABLED    0x20 ///< Enable interrupt requests generated by the        
           =2                                    ///< comparator 0 CPRIF or CPFIF flags.                
           =2                                                                                           
           =2 #define EIE1_ECP1__BMASK      0x40 ///< Comparator1 (CP1) Interrupt Enable                
           =2 #define EIE1_ECP1__SHIFT      0x06 ///< Comparator1 (CP1) Interrupt Enable                
           =2 #define EIE1_ECP1__DISABLED   0x00 ///< Disable CP1 interrupts.                           
           =2 #define EIE1_ECP1__ENABLED    0x40 ///< Enable interrupt requests generated by the        
           =2                                    ///< comparator 1 CPRIF or CPFIF flags.                
           =2                                                                                           
           =2 #define EIE1_ET3__BMASK       0x80 ///< Timer 3 Interrupt Enable                          
           =2 #define EIE1_ET3__SHIFT       0x07 ///< Timer 3 Interrupt Enable                          
           =2 #define EIE1_ET3__DISABLED    0x00 ///< Disable Timer 3 interrupts.                       
           =2 #define EIE1_ET3__ENABLED     0x80 ///< Enable interrupt requests generated by the TF3L or
           =2                                    ///< TF3H flags.                                       
           =2                                                                                           
           =2 //------------------------------------------------------------------------------
           =2 // EIE2 Enums (Extended Interrupt Enable 2 @ 0xE7)
           =2 //------------------------------------------------------------------------------
           =2 #define EIE2_EVBUS__BMASK    0x01 ///< VBUS Level Interrupt Enable                       
           =2 #define EIE2_EVBUS__SHIFT    0x00 ///< VBUS Level Interrupt Enable                       
           =2 #define EIE2_EVBUS__DISABLED 0x00 ///< Disable all VBUS interrupts.                      
           =2 #define EIE2_EVBUS__ENABLED  0x01 ///< Enable interrupt requests generated by VBUS level 
           =2                                   ///< sense.                                            
           =2                                                                                          
           =2 #define EIE2_ES1__BMASK      0x02 ///< UART1 Interrupt Enable                            
           =2 #define EIE2_ES1__SHIFT      0x01 ///< UART1 Interrupt Enable                            
           =2 #define EIE2_ES1__DISABLED   0x00 ///< Disable UART1 interrupt.                          
           =2 #define EIE2_ES1__ENABLED    0x02 ///< Enable UART1 interrupt.                           
           =2                                                                                          
           =2 #define EIE2_ESMB1__BMASK    0x08 ///< SMBus1 Interrupt Enable                           
           =2 #define EIE2_ESMB1__SHIFT    0x03 ///< SMBus1 Interrupt Enable                           
           =2 #define EIE2_ESMB1__DISABLED 0x00 ///< Disable all SMB1 interrupts.                      
           =2 #define EIE2_ESMB1__ENABLED  0x08 ///< Enable interrupt requests generated by SMB1.      
           =2                                                                                          
           =2 #define EIE2_ET4__BMASK      0x10 ///< Timer 4 Interrupt Enable                          
           =2 #define EIE2_ET4__SHIFT      0x04 ///< Timer 4 Interrupt Enable                          
           =2 #define EIE2_ET4__DISABLED   0x00 ///< Disable Timer 4interrupts.                        
           =2 #define EIE2_ET4__ENABLED    0x10 ///< Enable interrupt requests generated by the TF4L or
           =2                                   ///< TF4H flags.                                       
           =2                                                                                          
           =2 #define EIE2_ET5__BMASK      0x20 ///< Timer 5 Interrupt Enable                          
           =2 #define EIE2_ET5__SHIFT      0x05 ///< Timer 5 Interrupt Enable                          
           =2 #define EIE2_ET5__DISABLED   0x00 ///< Disable Timer 5 interrupts.                       
           =2 #define EIE2_ET5__ENABLED    0x20 ///< Enable interrupt requests generated by the TF5L or
           =2                                   ///< TF5H flags.                                       
           =2                                                                                          
           =2 //------------------------------------------------------------------------------
           =2 // EIP1 Enums (Extended Interrupt Priority 1 @ 0xF6)
           =2 //------------------------------------------------------------------------------
           =2 #define EIP1_PSMB0__BMASK  0x01 ///< SMBus (SMB0) Interrupt Priority Control                     
C51 COMPILER V9.56.0.0   SPI_0                                                             10/28/2016 17:37:02 PAGE 111 

           =2 #define EIP1_PSMB0__SHIFT  0x00 ///< SMBus (SMB0) Interrupt Priority Control                     
           =2 #define EIP1_PSMB0__LOW    0x00 ///< SMB0 interrupt set to low priority level.                   
           =2 #define EIP1_PSMB0__HIGH   0x01 ///< SMB0 interrupt set to high priority level.                  
           =2                                                                                                  
           =2 #define EIP1_PUSB0__BMASK  0x02 ///< USB (USB0) Interrupt Priority Control                       
           =2 #define EIP1_PUSB0__SHIFT  0x01 ///< USB (USB0) Interrupt Priority Control                       
           =2 #define EIP1_PUSB0__LOW    0x00 ///< USB0 interrupt set to low priority level.                   
           =2 #define EIP1_PUSB0__HIGH   0x02 ///< USB0 interrupt set to high priority level.                  
           =2                                                                                                  
           =2 #define EIP1_PWADC0__BMASK 0x04 ///< ADC0 Window Comparator Interrupt Priority Control           
           =2 #define EIP1_PWADC0__SHIFT 0x02 ///< ADC0 Window Comparator Interrupt Priority Control           
           =2 #define EIP1_PWADC0__LOW   0x00 ///< ADC0 Window interrupt set to low priority level.            
           =2 #define EIP1_PWADC0__HIGH  0x04 ///< ADC0 Window interrupt set to high priority level.           
           =2                                                                                                  
           =2 #define EIP1_PADC0__BMASK  0x08 ///< ADC0 Conversion Complete Interrupt Priority Control         
           =2 #define EIP1_PADC0__SHIFT  0x03 ///< ADC0 Conversion Complete Interrupt Priority Control         
           =2 #define EIP1_PADC0__LOW    0x00 ///< ADC0 Conversion Complete interrupt set to low               
           =2                                 ///< priority level.                                             
           =2 #define EIP1_PADC0__HIGH   0x08 ///< ADC0 Conversion Complete interrupt set to high              
           =2                                 ///< priority level.                                             
           =2                                                                                                  
           =2 #define EIP1_PPCA0__BMASK  0x10 ///< Programmable Counter Array (PCA0) Interrupt Priority Control
           =2 #define EIP1_PPCA0__SHIFT  0x04 ///< Programmable Counter Array (PCA0) Interrupt Priority Control
           =2 #define EIP1_PPCA0__LOW    0x00 ///< PCA0 interrupt set to low priority level.                   
           =2 #define EIP1_PPCA0__HIGH   0x10 ///< PCA0 interrupt set to high priority level.                  
           =2                                                                                                  
           =2 #define EIP1_PCP0__BMASK   0x20 ///< Comparator0 (CP0) Interrupt Priority Control                
           =2 #define EIP1_PCP0__SHIFT   0x05 ///< Comparator0 (CP0) Interrupt Priority Control                
           =2 #define EIP1_PCP0__LOW     0x00 ///< CP0 interrupt set to low priority level.                    
           =2 #define EIP1_PCP0__HIGH    0x20 ///< CP0 interrupt set to high priority level.                   
           =2                                                                                                  
           =2 #define EIP1_PCP1__BMASK   0x40 ///< Comparator1 (CP1) Interrupt Priority Control                
           =2 #define EIP1_PCP1__SHIFT   0x06 ///< Comparator1 (CP1) Interrupt Priority Control                
           =2 #define EIP1_PCP1__LOW     0x00 ///< CP1 interrupt set to low priority level.                    
           =2 #define EIP1_PCP1__HIGH    0x40 ///< CP1 interrupt set to high priority level.                   
           =2                                                                                                  
           =2 #define EIP1_PT3__BMASK    0x80 ///< Timer 3 Interrupt Priority Control                          
           =2 #define EIP1_PT3__SHIFT    0x07 ///< Timer 3 Interrupt Priority Control                          
           =2 #define EIP1_PT3__LOW      0x00 ///< Timer 3 interrupts set to low priority level.               
           =2 #define EIP1_PT3__HIGH     0x80 ///< Timer 3 interrupts set to high priority level.              
           =2                                                                                                  
           =2 //------------------------------------------------------------------------------
           =2 // EIP2 Enums (Extended Interrupt Priority 2 @ 0xF7)
           =2 //------------------------------------------------------------------------------
           =2 #define EIP2_PVBUS__BMASK 0x01 ///< VBUS Level Interrupt Priority Control        
           =2 #define EIP2_PVBUS__SHIFT 0x00 ///< VBUS Level Interrupt Priority Control        
           =2 #define EIP2_PVBUS__LOW   0x00 ///< VBUS interrupt set to low priority level.    
           =2 #define EIP2_PVBUS__HIGH  0x01 ///< VBUS interrupt set to high priority level.   
           =2                                                                                  
           =2 #define EIP2_PS1__BMASK   0x02 ///< UART1 Interrupt Priority Control             
           =2 #define EIP2_PS1__SHIFT   0x01 ///< UART1 Interrupt Priority Control             
           =2 #define EIP2_PS1__LOW     0x00 ///< UART1 interrupt set to low priority level.   
           =2 #define EIP2_PS1__HIGH    0x02 ///< UART1 interrupt set to high priority level.  
           =2                                                                                  
           =2 #define EIP2_PSMB1__BMASK 0x08 ///< SMBus1 Interrupt Priority Control            
           =2 #define EIP2_PSMB1__SHIFT 0x03 ///< SMBus1 Interrupt Priority Control            
           =2 #define EIP2_PSMB1__LOW   0x00 ///< SMB1 interrupt set to low priority level.    
           =2 #define EIP2_PSMB1__HIGH  0x08 ///< SMB1 interrupt set to high priority level.   
           =2                                                                                  
           =2 #define EIP2_PT4__BMASK   0x10 ///< Timer 4 Interrupt Priority Control           
           =2 #define EIP2_PT4__SHIFT   0x04 ///< Timer 4 Interrupt Priority Control           
           =2 #define EIP2_PT4__LOW     0x00 ///< Timer 4 interrupt set to low priority level. 
C51 COMPILER V9.56.0.0   SPI_0                                                             10/28/2016 17:37:02 PAGE 112 

           =2 #define EIP2_PT4__HIGH    0x10 ///< Timer 4 interrupt set to high priority level.
           =2                                                                                  
           =2 #define EIP2_PT5__BMASK   0x20 ///< Timer 5 Interrupt Priority Control           
           =2 #define EIP2_PT5__SHIFT   0x05 ///< Timer 5 Interrupt Priority Control           
           =2 #define EIP2_PT5__LOW     0x00 ///< Timer 5 interrupt set to low priority level. 
           =2 #define EIP2_PT5__HIGH    0x20 ///< Timer 5 interrupt set to high priority level.
           =2                                                                                  
           =2 //------------------------------------------------------------------------------
           =2 // IE Enums (Interrupt Enable @ 0xA8)
           =2 //------------------------------------------------------------------------------
           =2 #define IE_EX0__BMASK      0x01 ///< External Interrupt 0 Enable                       
           =2 #define IE_EX0__SHIFT      0x00 ///< External Interrupt 0 Enable                       
           =2 #define IE_EX0__DISABLED   0x00 ///< Disable external interrupt 0.                     
           =2 #define IE_EX0__ENABLED    0x01 ///< Enable interrupt requests generated by the INT0   
           =2                                 ///< input.                                            
           =2                                                                                        
           =2 #define IE_ET0__BMASK      0x02 ///< Timer 0 Interrupt Enable                          
           =2 #define IE_ET0__SHIFT      0x01 ///< Timer 0 Interrupt Enable                          
           =2 #define IE_ET0__DISABLED   0x00 ///< Disable all Timer 0 interrupt.                    
           =2 #define IE_ET0__ENABLED    0x02 ///< Enable interrupt requests generated by the TF0    
           =2                                 ///< flag.                                             
           =2                                                                                        
           =2 #define IE_EX1__BMASK      0x04 ///< External Interrupt 1 Enable                       
           =2 #define IE_EX1__SHIFT      0x02 ///< External Interrupt 1 Enable                       
           =2 #define IE_EX1__DISABLED   0x00 ///< Disable external interrupt 1.                     
           =2 #define IE_EX1__ENABLED    0x04 ///< Enable interrupt requests generated by the INT1   
           =2                                 ///< input.                                            
           =2                                                                                        
           =2 #define IE_ET1__BMASK      0x08 ///< Timer 1 Interrupt Enable                          
           =2 #define IE_ET1__SHIFT      0x03 ///< Timer 1 Interrupt Enable                          
           =2 #define IE_ET1__DISABLED   0x00 ///< Disable all Timer 1 interrupt.                    
           =2 #define IE_ET1__ENABLED    0x08 ///< Enable interrupt requests generated by the TF1    
           =2                                 ///< flag.                                             
           =2                                                                                        
           =2 #define IE_ES0__BMASK      0x10 ///< UART0 Interrupt Enable                            
           =2 #define IE_ES0__SHIFT      0x04 ///< UART0 Interrupt Enable                            
           =2 #define IE_ES0__DISABLED   0x00 ///< Disable UART0 interrupt.                          
           =2 #define IE_ES0__ENABLED    0x10 ///< Enable UART0 interrupt.                           
           =2                                                                                        
           =2 #define IE_ET2__BMASK      0x20 ///< Timer 2 Interrupt Enable                          
           =2 #define IE_ET2__SHIFT      0x05 ///< Timer 2 Interrupt Enable                          
           =2 #define IE_ET2__DISABLED   0x00 ///< Disable Timer 2 interrupt.                        
           =2 #define IE_ET2__ENABLED    0x20 ///< Enable interrupt requests generated by the TF2L or
           =2                                 ///< TF2H flags.                                       
           =2                                                                                        
           =2 #define IE_ESPI0__BMASK    0x40 ///< SPI0 Interrupt Enable                             
           =2 #define IE_ESPI0__SHIFT    0x06 ///< SPI0 Interrupt Enable                             
           =2 #define IE_ESPI0__DISABLED 0x00 ///< Disable all SPI0 interrupts.                      
           =2 #define IE_ESPI0__ENABLED  0x40 ///< Enable interrupt requests generated by SPI0.      
           =2                                                                                        
           =2 #define IE_EA__BMASK       0x80 ///< All Interrupts Enable                             
           =2 #define IE_EA__SHIFT       0x07 ///< All Interrupts Enable                             
           =2 #define IE_EA__DISABLED    0x00 ///< Disable all interrupt sources.                    
           =2 #define IE_EA__ENABLED     0x80 ///< Enable each interrupt according to its individual 
           =2                                 ///< mask setting.                                     
           =2                                                                                        
           =2 //------------------------------------------------------------------------------
           =2 // IP Enums (Interrupt Priority @ 0xB8)
           =2 //------------------------------------------------------------------------------
           =2 #define IP_PX0__BMASK   0x01 ///< External Interrupt 0 Priority Control                        
           =2 #define IP_PX0__SHIFT   0x00 ///< External Interrupt 0 Priority Control                        
           =2 #define IP_PX0__LOW     0x00 ///< External Interrupt 0 set to low priority level.              
C51 COMPILER V9.56.0.0   SPI_0                                                             10/28/2016 17:37:02 PAGE 113 

           =2 #define IP_PX0__HIGH    0x01 ///< External Interrupt 0 set to high priority level.             
           =2                                                                                                
           =2 #define IP_PT0__BMASK   0x02 ///< Timer 0 Interrupt Priority Control                           
           =2 #define IP_PT0__SHIFT   0x01 ///< Timer 0 Interrupt Priority Control                           
           =2 #define IP_PT0__LOW     0x00 ///< Timer 0 interrupt set to low priority level.                 
           =2 #define IP_PT0__HIGH    0x02 ///< Timer 0 interrupt set to high priority level.                
           =2                                                                                                
           =2 #define IP_PX1__BMASK   0x04 ///< External Interrupt 1 Priority Control                        
           =2 #define IP_PX1__SHIFT   0x02 ///< External Interrupt 1 Priority Control                        
           =2 #define IP_PX1__LOW     0x00 ///< External Interrupt 1 set to low priority level.              
           =2 #define IP_PX1__HIGH    0x04 ///< External Interrupt 1 set to high priority level.             
           =2                                                                                                
           =2 #define IP_PT1__BMASK   0x08 ///< Timer 1 Interrupt Priority Control                           
           =2 #define IP_PT1__SHIFT   0x03 ///< Timer 1 Interrupt Priority Control                           
           =2 #define IP_PT1__LOW     0x00 ///< Timer 1 interrupt set to low priority level.                 
           =2 #define IP_PT1__HIGH    0x08 ///< Timer 1 interrupt set to high priority level.                
           =2                                                                                                
           =2 #define IP_PS0__BMASK   0x10 ///< UART0 Interrupt Priority Control                             
           =2 #define IP_PS0__SHIFT   0x04 ///< UART0 Interrupt Priority Control                             
           =2 #define IP_PS0__LOW     0x00 ///< UART0 interrupt set to low priority level.                   
           =2 #define IP_PS0__HIGH    0x10 ///< UART0 interrupt set to high priority level.                  
           =2                                                                                                
           =2 #define IP_PT2__BMASK   0x20 ///< Timer 2 Interrupt Priority Control                           
           =2 #define IP_PT2__SHIFT   0x05 ///< Timer 2 Interrupt Priority Control                           
           =2 #define IP_PT2__LOW     0x00 ///< Timer 2 interrupt set to low priority level.                 
           =2 #define IP_PT2__HIGH    0x20 ///< Timer 2 interrupt set to high priority level.                
           =2                                                                                                
           =2 #define IP_PSPI0__BMASK 0x40 ///< Serial Peripheral Interface (SPI0) Interrupt Priority Control
           =2 #define IP_PSPI0__SHIFT 0x06 ///< Serial Peripheral Interface (SPI0) Interrupt Priority Control
           =2 #define IP_PSPI0__LOW   0x00 ///< SPI0 interrupt set to low priority level.                    
           =2 #define IP_PSPI0__HIGH  0x40 ///< SPI0 interrupt set to high priority level.                   
           =2                                                                                                
           =2 //------------------------------------------------------------------------------
           =2 // LFO0CN Enums (Low Frequency Oscillator Control @ 0x86)
           =2 //------------------------------------------------------------------------------
           =2 #define LFO0CN_OSCLD__FMASK       0x03 ///< Internal L-F Oscillator Divider Select           
           =2 #define LFO0CN_OSCLD__SHIFT       0x00 ///< Internal L-F Oscillator Divider Select           
           =2 #define LFO0CN_OSCLD__DIVIDE_BY_8 0x00 ///< Divide by 8 selected.                            
           =2 #define LFO0CN_OSCLD__DIVIDE_BY_4 0x01 ///< Divide by 4 selected.                            
           =2 #define LFO0CN_OSCLD__DIVIDE_BY_2 0x02 ///< Divide by 2 selected.                            
           =2 #define LFO0CN_OSCLD__DIVIDE_BY_1 0x03 ///< Divide by 1 selected.                            
           =2                                                                                              
           =2 #define LFO0CN_OSCLF__FMASK       0x3C ///< Internal L-F Oscillator Frequency Control        
           =2 #define LFO0CN_OSCLF__SHIFT       0x02 ///< Internal L-F Oscillator Frequency Control        
           =2                                                                                              
           =2 #define LFO0CN_OSCLRDY__BMASK     0x40 ///< Internal L-F Oscillator Ready                    
           =2 #define LFO0CN_OSCLRDY__SHIFT     0x06 ///< Internal L-F Oscillator Ready                    
           =2 #define LFO0CN_OSCLRDY__NOT_SET   0x00 ///< Internal L-F Oscillator frequency not stabilized.
           =2 #define LFO0CN_OSCLRDY__SET       0x40 ///< Internal L-F Oscillator frequency stabilized.    
           =2                                                                                              
           =2 #define LFO0CN_OSCLEN__BMASK      0x80 ///< Internal L-F Oscillator Enable                   
           =2 #define LFO0CN_OSCLEN__SHIFT      0x07 ///< Internal L-F Oscillator Enable                   
           =2 #define LFO0CN_OSCLEN__DISABLED   0x00 ///< Internal L-F Oscillator Disabled.                
           =2 #define LFO0CN_OSCLEN__ENABLED    0x80 ///< Internal L-F Oscillator Enabled.                 
           =2                                                                                              
           =2 //------------------------------------------------------------------------------
           =2 // XBR0 Enums (Port I/O Crossbar 0 @ 0xE1)
           =2 //------------------------------------------------------------------------------
           =2 #define XBR0_URT0E__BMASK     0x01 ///< UART0 I/O Output Enable                        
           =2 #define XBR0_URT0E__SHIFT     0x00 ///< UART0 I/O Output Enable                        
           =2 #define XBR0_URT0E__DISABLED  0x00 ///< UART0 I/O unavailable at Port pin.             
           =2 #define XBR0_URT0E__ENABLED   0x01 ///< UART0 TX, RX routed to Port pins P0.4 and P0.5.
C51 COMPILER V9.56.0.0   SPI_0                                                             10/28/2016 17:37:02 PAGE 114 

           =2                                                                                        
           =2 #define XBR0_SPI0E__BMASK     0x02 ///< SPI I/O Enable                                 
           =2 #define XBR0_SPI0E__SHIFT     0x01 ///< SPI I/O Enable                                 
           =2 #define XBR0_SPI0E__DISABLED  0x00 ///< SPI I/O unavailable at Port pins.              
           =2 #define XBR0_SPI0E__ENABLED   0x02 ///< SPI I/O routed to Port pins. The SPI can be    
           =2                                    ///< assigned either 3 or 4 GPIO pins.              
           =2                                                                                        
           =2 #define XBR0_SMB0E__BMASK     0x04 ///< SMB0 I/O Enable                                
           =2 #define XBR0_SMB0E__SHIFT     0x02 ///< SMB0 I/O Enable                                
           =2 #define XBR0_SMB0E__DISABLED  0x00 ///< SMBus 0 I/O unavailable at Port pins.          
           =2 #define XBR0_SMB0E__ENABLED   0x04 ///< SMBus 0 I/O routed to Port pins.               
           =2                                                                                        
           =2 #define XBR0_SYSCKE__BMASK    0x08 ///< SYSCLK Output Enable                           
           =2 #define XBR0_SYSCKE__SHIFT    0x03 ///< SYSCLK Output Enable                           
           =2 #define XBR0_SYSCKE__DISABLED 0x00 ///< SYSCLK unavailable at Port pin.                
           =2 #define XBR0_SYSCKE__ENABLED  0x08 ///< SYSCLK output routed to Port pin.              
           =2                                                                                        
           =2 #define XBR0_CP0E__BMASK      0x10 ///< Comparator0 Output Enable                      
           =2 #define XBR0_CP0E__SHIFT      0x04 ///< Comparator0 Output Enable                      
           =2 #define XBR0_CP0E__DISABLED   0x00 ///< CP0 unavailable at Port pin.                   
           =2 #define XBR0_CP0E__ENABLED    0x10 ///< CP0 routed to Port pin.                        
           =2                                                                                        
           =2 #define XBR0_CP0AE__BMASK     0x20 ///< Comparator0 Asynchronous Output Enable         
           =2 #define XBR0_CP0AE__SHIFT     0x05 ///< Comparator0 Asynchronous Output Enable         
           =2 #define XBR0_CP0AE__DISABLED  0x00 ///< Asynchronous CP0 unavailable at Port pin.      
           =2 #define XBR0_CP0AE__ENABLED   0x20 ///< Asynchronous CP0 routed to Port pin.           
           =2                                                                                        
           =2 #define XBR0_CP1E__BMASK      0x40 ///< Comparator1 Output Enable                      
           =2 #define XBR0_CP1E__SHIFT      0x06 ///< Comparator1 Output Enable                      
           =2 #define XBR0_CP1E__DISABLED   0x00 ///< CP1 unavailable at Port pin.                   
           =2 #define XBR0_CP1E__ENABLED    0x40 ///< CP1 routed to Port pin.                        
           =2                                                                                        
           =2 #define XBR0_CP1AE__BMASK     0x80 ///< Comparator1 Asynchronous Output Enable         
           =2 #define XBR0_CP1AE__SHIFT     0x07 ///< Comparator1 Asynchronous Output Enable         
           =2 #define XBR0_CP1AE__DISABLED  0x00 ///< Asynchronous CP1 unavailable at Port pin.      
           =2 #define XBR0_CP1AE__ENABLED   0x80 ///< Asynchronous CP1 routed to Port pin.           
           =2                                                                                        
           =2 //------------------------------------------------------------------------------
           =2 // XBR1 Enums (Port I/O Crossbar 1 @ 0xE2)
           =2 //------------------------------------------------------------------------------
           =2 #define XBR1_PCA0ME__FMASK                    0x07 ///< PCA Module I/O Enable                            
           =2 #define XBR1_PCA0ME__SHIFT                    0x00 ///< PCA Module I/O Enable                            
           =2 #define XBR1_PCA0ME__DISABLED                 0x00 ///< All PCA I/O unavailable at Port pins.            
           =2 #define XBR1_PCA0ME__CEX0                     0x01 ///< CEX0 routed to Port pin.                         
           =2 #define XBR1_PCA0ME__CEX0_CEX1                0x02 ///< CEX0, CEX1 routed to Port pins.                  
           =2 #define XBR1_PCA0ME__CEX0_CEX1_CEX2           0x03 ///< CEX0, CEX1, CEX2 routed to Port pins.            
           =2 #define XBR1_PCA0ME__CEX0_CEX1_CEX2_CEX3      0x04 ///< CEX0, CEX1, CEX2, CEX3 routed to Port pins.      
           =2 #define XBR1_PCA0ME__CEX0_CEX1_CEX2_CEX3_CEX4 0x05 ///< CEX0, CEX1, CEX2, CEX3, CEX4 routed to Port pins.
           =2                                                                                                          
           =2 #define XBR1_ECIE__BMASK                      0x08 ///< PCA0 External Counter Input Enable               
           =2 #define XBR1_ECIE__SHIFT                      0x03 ///< PCA0 External Counter Input Enable               
           =2 #define XBR1_ECIE__DISABLED                   0x00 ///< ECI unavailable at Port pin.                     
           =2 #define XBR1_ECIE__ENABLED                    0x08 ///< ECI routed to Port pin.                          
           =2                                                                                                          
           =2 #define XBR1_T0E__BMASK                       0x10 ///< T0 Enable                                        
           =2 #define XBR1_T0E__SHIFT                       0x04 ///< T0 Enable                                        
           =2 #define XBR1_T0E__DISABLED                    0x00 ///< T0 unavailable at Port pin.                      
           =2 #define XBR1_T0E__ENABLED                     0x10 ///< T0 routed to Port pin.                           
           =2                                                                                                          
           =2 #define XBR1_T1E__BMASK                       0x20 ///< T1 Enable                                        
           =2 #define XBR1_T1E__SHIFT                       0x05 ///< T1 Enable                                        
           =2 #define XBR1_T1E__DISABLED                    0x00 ///< T1 unavailable at Port pin.                      
C51 COMPILER V9.56.0.0   SPI_0                                                             10/28/2016 17:37:02 PAGE 115 

           =2 #define XBR1_T1E__ENABLED                     0x20 ///< T1 routed to Port pin.                           
           =2                                                                                                          
           =2 #define XBR1_XBARE__BMASK                     0x40 ///< Crossbar Enable                                  
           =2 #define XBR1_XBARE__SHIFT                     0x06 ///< Crossbar Enable                                  
           =2 #define XBR1_XBARE__DISABLED                  0x00 ///< Crossbar disabled.                               
           =2 #define XBR1_XBARE__ENABLED                   0x40 ///< Crossbar enabled.                                
           =2                                                                                                          
           =2 #define XBR1_WEAKPUD__BMASK                   0x80 ///< Port I/O Weak Pullup Disable                     
           =2 #define XBR1_WEAKPUD__SHIFT                   0x07 ///< Port I/O Weak Pullup Disable                     
           =2 #define XBR1_WEAKPUD__PULL_UPS_ENABLED        0x00 ///< Weak Pullups enabled (except for Ports whose I/O 
           =2                                                    ///< are configured for analog mode).                 
           =2 #define XBR1_WEAKPUD__PULL_UPS_DISABLED       0x80 ///< Weak Pullups disabled.                           
           =2                                                                                                          
           =2 //------------------------------------------------------------------------------
           =2 // XBR2 Enums (Port I/O Crossbar 2 @ 0xE3)
           =2 //------------------------------------------------------------------------------
           =2 #define XBR2_URT1E__BMASK    0x01 ///< UART1 I/O Output Enable             
           =2 #define XBR2_URT1E__SHIFT    0x00 ///< UART1 I/O Output Enable             
           =2 #define XBR2_URT1E__DISABLED 0x00 ///< UART1 I/O unavailable at Port pin.  
           =2 #define XBR2_URT1E__ENABLED  0x01 ///< UART1 TX, RX routed to Port pins.   
           =2                                                                            
           =2 #define XBR2_SMB1E__BMASK    0x02 ///< SMBus1 I/O Enable                   
           =2 #define XBR2_SMB1E__SHIFT    0x01 ///< SMBus1 I/O Enable                   
           =2 #define XBR2_SMB1E__DISABLED 0x00 ///< SMBus1 I/O unavailable at Port pins.
           =2 #define XBR2_SMB1E__ENABLED  0x02 ///< SMBus1 I/O routed to Port pins.     
           =2                                                                            
           =2 //------------------------------------------------------------------------------
           =2 // PCA0CPH0 Enums (PCA Channel 0 Capture Module High Byte @ 0xFC)
           =2 //------------------------------------------------------------------------------
           =2 #define PCA0CPH0_PCA0CPH0__FMASK 0xFF ///< PCA Channel 0 Capture Module High Byte
           =2 #define PCA0CPH0_PCA0CPH0__SHIFT 0x00 ///< PCA Channel 0 Capture Module High Byte
           =2                                                                                  
           =2 //------------------------------------------------------------------------------
           =2 // PCA0CPL0 Enums (PCA Channel 0 Capture Module Low Byte @ 0xFB)
           =2 //------------------------------------------------------------------------------
           =2 #define PCA0CPL0_PCA0CPL0__FMASK 0xFF ///< PCA Channel 0 Capture Module Low Byte
           =2 #define PCA0CPL0_PCA0CPL0__SHIFT 0x00 ///< PCA Channel 0 Capture Module Low Byte
           =2                                                                                 
           =2 //------------------------------------------------------------------------------
           =2 // PCA0CPM0 Enums (PCA Channel 0 Capture/Compare Mode @ 0xDA)
           =2 //------------------------------------------------------------------------------
           =2 #define PCA0CPM0_ECCF__BMASK    0x01 ///< Channel 0 Capture/Compare Flag Interrupt Enable
           =2 #define PCA0CPM0_ECCF__SHIFT    0x00 ///< Channel 0 Capture/Compare Flag Interrupt Enable
           =2 #define PCA0CPM0_ECCF__DISABLED 0x00 ///< Disable CCF0 interrupts.                       
           =2 #define PCA0CPM0_ECCF__ENABLED  0x01 ///< Enable a Capture/Compare Flag interrupt request
           =2                                      ///< when CCF0 is set.                              
           =2                                                                                          
           =2 #define PCA0CPM0_PWM__BMASK     0x02 ///< Channel 0 Pulse Width Modulation Mode Enable   
           =2 #define PCA0CPM0_PWM__SHIFT     0x01 ///< Channel 0 Pulse Width Modulation Mode Enable   
           =2 #define PCA0CPM0_PWM__DISABLED  0x00 ///< Disable PWM function.                          
           =2 #define PCA0CPM0_PWM__ENABLED   0x02 ///< Enable PWM function.                           
           =2                                                                                          
           =2 #define PCA0CPM0_TOG__BMASK     0x04 ///< Channel 0 Toggle Function Enable               
           =2 #define PCA0CPM0_TOG__SHIFT     0x02 ///< Channel 0 Toggle Function Enable               
           =2 #define PCA0CPM0_TOG__DISABLED  0x00 ///< Disable toggle function.                       
           =2 #define PCA0CPM0_TOG__ENABLED   0x04 ///< Enable toggle function.                        
           =2                                                                                          
           =2 #define PCA0CPM0_MAT__BMASK     0x08 ///< Channel 0 Match Function Enable                
           =2 #define PCA0CPM0_MAT__SHIFT     0x03 ///< Channel 0 Match Function Enable                
           =2 #define PCA0CPM0_MAT__DISABLED  0x00 ///< Disable match function.                        
           =2 #define PCA0CPM0_MAT__ENABLED   0x08 ///< Enable match function.                         
           =2                                                                                          
C51 COMPILER V9.56.0.0   SPI_0                                                             10/28/2016 17:37:02 PAGE 116 

           =2 #define PCA0CPM0_CAPN__BMASK    0x10 ///< Channel 0 Capture Negative Function Enable     
           =2 #define PCA0CPM0_CAPN__SHIFT    0x04 ///< Channel 0 Capture Negative Function Enable     
           =2 #define PCA0CPM0_CAPN__DISABLED 0x00 ///< Disable negative edge capture.                 
           =2 #define PCA0CPM0_CAPN__ENABLED  0x10 ///< Enable negative edge capture.                  
           =2                                                                                          
           =2 #define PCA0CPM0_CAPP__BMASK    0x20 ///< Channel 0 Capture Positive Function Enable     
           =2 #define PCA0CPM0_CAPP__SHIFT    0x05 ///< Channel 0 Capture Positive Function Enable     
           =2 #define PCA0CPM0_CAPP__DISABLED 0x00 ///< Disable positive edge capture.                 
           =2 #define PCA0CPM0_CAPP__ENABLED  0x20 ///< Enable positive edge capture.                  
           =2                                                                                          
           =2 #define PCA0CPM0_ECOM__BMASK    0x40 ///< Channel 0 Comparator Function Enable           
           =2 #define PCA0CPM0_ECOM__SHIFT    0x06 ///< Channel 0 Comparator Function Enable           
           =2 #define PCA0CPM0_ECOM__DISABLED 0x00 ///< Disable comparator function.                   
           =2 #define PCA0CPM0_ECOM__ENABLED  0x40 ///< Enable comparator function.                    
           =2                                                                                          
           =2 #define PCA0CPM0_PWM16__BMASK   0x80 ///< Channel 0 16-bit Pulse Width Modulation Enable 
           =2 #define PCA0CPM0_PWM16__SHIFT   0x07 ///< Channel 0 16-bit Pulse Width Modulation Enable 
           =2 #define PCA0CPM0_PWM16__8_BIT   0x00 ///< 8-bit PWM selected.                            
           =2 #define PCA0CPM0_PWM16__16_BIT  0x80 ///< 16-bit PWM selected.                           
           =2                                                                                          
           =2 //------------------------------------------------------------------------------
           =2 // PCA0CPH1 Enums (PCA Channel 1 Capture Module High Byte @ 0xEA)
           =2 //------------------------------------------------------------------------------
           =2 #define PCA0CPH1_PCA0CPH1__FMASK 0xFF ///< PCA Channel 1 Capture Module High Byte
           =2 #define PCA0CPH1_PCA0CPH1__SHIFT 0x00 ///< PCA Channel 1 Capture Module High Byte
           =2                                                                                  
           =2 //------------------------------------------------------------------------------
           =2 // PCA0CPL1 Enums (PCA Channel 1 Capture Module Low Byte @ 0xE9)
           =2 //------------------------------------------------------------------------------
           =2 #define PCA0CPL1_PCA0CPL1__FMASK 0xFF ///< PCA Channel 1 Capture Module Low Byte
           =2 #define PCA0CPL1_PCA0CPL1__SHIFT 0x00 ///< PCA Channel 1 Capture Module Low Byte
           =2                                                                                 
           =2 //------------------------------------------------------------------------------
           =2 // PCA0CPM1 Enums (PCA Channel 1 Capture/Compare Mode @ 0xDB)
           =2 //------------------------------------------------------------------------------
           =2 #define PCA0CPM1_ECCF__BMASK    0x01 ///< Channel 1 Capture/Compare Flag Interrupt Enable
           =2 #define PCA0CPM1_ECCF__SHIFT    0x00 ///< Channel 1 Capture/Compare Flag Interrupt Enable
           =2 #define PCA0CPM1_ECCF__DISABLED 0x00 ///< Disable CCF1 interrupts.                       
           =2 #define PCA0CPM1_ECCF__ENABLED  0x01 ///< Enable a Capture/Compare Flag interrupt request
           =2                                      ///< when CCF1 is set.                              
           =2                                                                                          
           =2 #define PCA0CPM1_PWM__BMASK     0x02 ///< Channel 1 Pulse Width Modulation Mode Enable   
           =2 #define PCA0CPM1_PWM__SHIFT     0x01 ///< Channel 1 Pulse Width Modulation Mode Enable   
           =2 #define PCA0CPM1_PWM__DISABLED  0x00 ///< Disable PWM function.                          
           =2 #define PCA0CPM1_PWM__ENABLED   0x02 ///< Enable PWM function.                           
           =2                                                                                          
           =2 #define PCA0CPM1_TOG__BMASK     0x04 ///< Channel 1 Toggle Function Enable               
           =2 #define PCA0CPM1_TOG__SHIFT     0x02 ///< Channel 1 Toggle Function Enable               
           =2 #define PCA0CPM1_TOG__DISABLED  0x00 ///< Disable toggle function.                       
           =2 #define PCA0CPM1_TOG__ENABLED   0x04 ///< Enable toggle function.                        
           =2                                                                                          
           =2 #define PCA0CPM1_MAT__BMASK     0x08 ///< Channel 1 Match Function Enable                
           =2 #define PCA0CPM1_MAT__SHIFT     0x03 ///< Channel 1 Match Function Enable                
           =2 #define PCA0CPM1_MAT__DISABLED  0x00 ///< Disable match function.                        
           =2 #define PCA0CPM1_MAT__ENABLED   0x08 ///< Enable match function.                         
           =2                                                                                          
           =2 #define PCA0CPM1_CAPN__BMASK    0x10 ///< Channel 1 Capture Negative Function Enable     
           =2 #define PCA0CPM1_CAPN__SHIFT    0x04 ///< Channel 1 Capture Negative Function Enable     
           =2 #define PCA0CPM1_CAPN__DISABLED 0x00 ///< Disable negative edge capture.                 
           =2 #define PCA0CPM1_CAPN__ENABLED  0x10 ///< Enable negative edge capture.                  
           =2                                                                                          
           =2 #define PCA0CPM1_CAPP__BMASK    0x20 ///< Channel 1 Capture Positive Function Enable     
C51 COMPILER V9.56.0.0   SPI_0                                                             10/28/2016 17:37:02 PAGE 117 

           =2 #define PCA0CPM1_CAPP__SHIFT    0x05 ///< Channel 1 Capture Positive Function Enable     
           =2 #define PCA0CPM1_CAPP__DISABLED 0x00 ///< Disable positive edge capture.                 
           =2 #define PCA0CPM1_CAPP__ENABLED  0x20 ///< Enable positive edge capture.                  
           =2                                                                                          
           =2 #define PCA0CPM1_ECOM__BMASK    0x40 ///< Channel 1 Comparator Function Enable           
           =2 #define PCA0CPM1_ECOM__SHIFT    0x06 ///< Channel 1 Comparator Function Enable           
           =2 #define PCA0CPM1_ECOM__DISABLED 0x00 ///< Disable comparator function.                   
           =2 #define PCA0CPM1_ECOM__ENABLED  0x40 ///< Enable comparator function.                    
           =2                                                                                          
           =2 #define PCA0CPM1_PWM16__BMASK   0x80 ///< Channel 1 16-bit Pulse Width Modulation Enable 
           =2 #define PCA0CPM1_PWM16__SHIFT   0x07 ///< Channel 1 16-bit Pulse Width Modulation Enable 
           =2 #define PCA0CPM1_PWM16__8_BIT   0x00 ///< 8-bit PWM selected.                            
           =2 #define PCA0CPM1_PWM16__16_BIT  0x80 ///< 16-bit PWM selected.                           
           =2                                                                                          
           =2 //------------------------------------------------------------------------------
           =2 // PCA0CPH2 Enums (PCA Channel 2 Capture Module High Byte @ 0xEC)
           =2 //------------------------------------------------------------------------------
           =2 #define PCA0CPH2_PCA0CPH2__FMASK 0xFF ///< PCA Channel 2 Capture Module High Byte
           =2 #define PCA0CPH2_PCA0CPH2__SHIFT 0x00 ///< PCA Channel 2 Capture Module High Byte
           =2                                                                                  
           =2 //------------------------------------------------------------------------------
           =2 // PCA0CPL2 Enums (PCA Channel 2 Capture Module Low Byte @ 0xEB)
           =2 //------------------------------------------------------------------------------
           =2 #define PCA0CPL2_PCA0CPL2__FMASK 0xFF ///< PCA Channel 2 Capture Module Low Byte
           =2 #define PCA0CPL2_PCA0CPL2__SHIFT 0x00 ///< PCA Channel 2 Capture Module Low Byte
           =2                                                                                 
           =2 //------------------------------------------------------------------------------
           =2 // PCA0CPM2 Enums (PCA Channel 2 Capture/Compare Mode @ 0xDC)
           =2 //------------------------------------------------------------------------------
           =2 #define PCA0CPM2_ECCF__BMASK    0x01 ///< Channel 2 Capture/Compare Flag Interrupt Enable
           =2 #define PCA0CPM2_ECCF__SHIFT    0x00 ///< Channel 2 Capture/Compare Flag Interrupt Enable
           =2 #define PCA0CPM2_ECCF__DISABLED 0x00 ///< Disable CCF2 interrupts.                       
           =2 #define PCA0CPM2_ECCF__ENABLED  0x01 ///< Enable a Capture/Compare Flag interrupt request
           =2                                      ///< when CCF2 is set.                              
           =2                                                                                          
           =2 #define PCA0CPM2_PWM__BMASK     0x02 ///< Channel 2 Pulse Width Modulation Mode Enable   
           =2 #define PCA0CPM2_PWM__SHIFT     0x01 ///< Channel 2 Pulse Width Modulation Mode Enable   
           =2 #define PCA0CPM2_PWM__DISABLED  0x00 ///< Disable PWM function.                          
           =2 #define PCA0CPM2_PWM__ENABLED   0x02 ///< Enable PWM function.                           
           =2                                                                                          
           =2 #define PCA0CPM2_TOG__BMASK     0x04 ///< Channel 2 Toggle Function Enable               
           =2 #define PCA0CPM2_TOG__SHIFT     0x02 ///< Channel 2 Toggle Function Enable               
           =2 #define PCA0CPM2_TOG__DISABLED  0x00 ///< Disable toggle function.                       
           =2 #define PCA0CPM2_TOG__ENABLED   0x04 ///< Enable toggle function.                        
           =2                                                                                          
           =2 #define PCA0CPM2_MAT__BMASK     0x08 ///< Channel 2 Match Function Enable                
           =2 #define PCA0CPM2_MAT__SHIFT     0x03 ///< Channel 2 Match Function Enable                
           =2 #define PCA0CPM2_MAT__DISABLED  0x00 ///< Disable match function.                        
           =2 #define PCA0CPM2_MAT__ENABLED   0x08 ///< Enable match function.                         
           =2                                                                                          
           =2 #define PCA0CPM2_CAPN__BMASK    0x10 ///< Channel 2 Capture Negative Function Enable     
           =2 #define PCA0CPM2_CAPN__SHIFT    0x04 ///< Channel 2 Capture Negative Function Enable     
           =2 #define PCA0CPM2_CAPN__DISABLED 0x00 ///< Disable negative edge capture.                 
           =2 #define PCA0CPM2_CAPN__ENABLED  0x10 ///< Enable negative edge capture.                  
           =2                                                                                          
           =2 #define PCA0CPM2_CAPP__BMASK    0x20 ///< Channel 2 Capture Positive Function Enable     
           =2 #define PCA0CPM2_CAPP__SHIFT    0x05 ///< Channel 2 Capture Positive Function Enable     
           =2 #define PCA0CPM2_CAPP__DISABLED 0x00 ///< Disable positive edge capture.                 
           =2 #define PCA0CPM2_CAPP__ENABLED  0x20 ///< Enable positive edge capture.                  
           =2                                                                                          
           =2 #define PCA0CPM2_ECOM__BMASK    0x40 ///< Channel 2 Comparator Function Enable           
           =2 #define PCA0CPM2_ECOM__SHIFT    0x06 ///< Channel 2 Comparator Function Enable           
C51 COMPILER V9.56.0.0   SPI_0                                                             10/28/2016 17:37:02 PAGE 118 

           =2 #define PCA0CPM2_ECOM__DISABLED 0x00 ///< Disable comparator function.                   
           =2 #define PCA0CPM2_ECOM__ENABLED  0x40 ///< Enable comparator function.                    
           =2                                                                                          
           =2 #define PCA0CPM2_PWM16__BMASK   0x80 ///< Channel 2 16-bit Pulse Width Modulation Enable 
           =2 #define PCA0CPM2_PWM16__SHIFT   0x07 ///< Channel 2 16-bit Pulse Width Modulation Enable 
           =2 #define PCA0CPM2_PWM16__8_BIT   0x00 ///< 8-bit PWM selected.                            
           =2 #define PCA0CPM2_PWM16__16_BIT  0x80 ///< 16-bit PWM selected.                           
           =2                                                                                          
           =2 //------------------------------------------------------------------------------
           =2 // PCA0CPH3 Enums (PCA Channel 3 Capture Module High Byte @ 0xEE)
           =2 //------------------------------------------------------------------------------
           =2 #define PCA0CPH3_PCA0CPH3__FMASK 0xFF ///< PCA Channel 3 Capture Module High Byte
           =2 #define PCA0CPH3_PCA0CPH3__SHIFT 0x00 ///< PCA Channel 3 Capture Module High Byte
           =2                                                                                  
           =2 //------------------------------------------------------------------------------
           =2 // PCA0CPL3 Enums (PCA Channel 3 Capture Module Low Byte @ 0xED)
           =2 //------------------------------------------------------------------------------
           =2 #define PCA0CPL3_PCA0CPL3__FMASK 0xFF ///< PCA Channel 3 Capture Module Low Byte
           =2 #define PCA0CPL3_PCA0CPL3__SHIFT 0x00 ///< PCA Channel 3 Capture Module Low Byte
           =2                                                                                 
           =2 //------------------------------------------------------------------------------
           =2 // PCA0CPM3 Enums (PCA Channel 3 Capture/Compare Mode @ 0xDD)
           =2 //------------------------------------------------------------------------------
           =2 #define PCA0CPM3_ECCF__BMASK    0x01 ///< Channel 3 Capture/Compare Flag Interrupt Enable
           =2 #define PCA0CPM3_ECCF__SHIFT    0x00 ///< Channel 3 Capture/Compare Flag Interrupt Enable
           =2 #define PCA0CPM3_ECCF__DISABLED 0x00 ///< Disable CCF3 interrupts.                       
           =2 #define PCA0CPM3_ECCF__ENABLED  0x01 ///< Enable a Capture/Compare Flag interrupt request
           =2                                      ///< when CCF3 is set.                              
           =2                                                                                          
           =2 #define PCA0CPM3_PWM__BMASK     0x02 ///< Channel 3 Pulse Width Modulation Mode Enable   
           =2 #define PCA0CPM3_PWM__SHIFT     0x01 ///< Channel 3 Pulse Width Modulation Mode Enable   
           =2 #define PCA0CPM3_PWM__DISABLED  0x00 ///< Disable PWM function.                          
           =2 #define PCA0CPM3_PWM__ENABLED   0x02 ///< Enable PWM function.                           
           =2                                                                                          
           =2 #define PCA0CPM3_TOG__BMASK     0x04 ///< Channel 3 Toggle Function Enable               
           =2 #define PCA0CPM3_TOG__SHIFT     0x02 ///< Channel 3 Toggle Function Enable               
           =2 #define PCA0CPM3_TOG__DISABLED  0x00 ///< Disable toggle function.                       
           =2 #define PCA0CPM3_TOG__ENABLED   0x04 ///< Enable toggle function.                        
           =2                                                                                          
           =2 #define PCA0CPM3_MAT__BMASK     0x08 ///< Channel 3 Match Function Enable                
           =2 #define PCA0CPM3_MAT__SHIFT     0x03 ///< Channel 3 Match Function Enable                
           =2 #define PCA0CPM3_MAT__DISABLED  0x00 ///< Disable match function.                        
           =2 #define PCA0CPM3_MAT__ENABLED   0x08 ///< Enable match function.                         
           =2                                                                                          
           =2 #define PCA0CPM3_CAPN__BMASK    0x10 ///< Channel 3 Capture Negative Function Enable     
           =2 #define PCA0CPM3_CAPN__SHIFT    0x04 ///< Channel 3 Capture Negative Function Enable     
           =2 #define PCA0CPM3_CAPN__DISABLED 0x00 ///< Disable negative edge capture.                 
           =2 #define PCA0CPM3_CAPN__ENABLED  0x10 ///< Enable negative edge capture.                  
           =2                                                                                          
           =2 #define PCA0CPM3_CAPP__BMASK    0x20 ///< Channel 3 Capture Positive Function Enable     
           =2 #define PCA0CPM3_CAPP__SHIFT    0x05 ///< Channel 3 Capture Positive Function Enable     
           =2 #define PCA0CPM3_CAPP__DISABLED 0x00 ///< Disable positive edge capture.                 
           =2 #define PCA0CPM3_CAPP__ENABLED  0x20 ///< Enable positive edge capture.                  
           =2                                                                                          
           =2 #define PCA0CPM3_ECOM__BMASK    0x40 ///< Channel 3 Comparator Function Enable           
           =2 #define PCA0CPM3_ECOM__SHIFT    0x06 ///< Channel 3 Comparator Function Enable           
           =2 #define PCA0CPM3_ECOM__DISABLED 0x00 ///< Disable comparator function.                   
           =2 #define PCA0CPM3_ECOM__ENABLED  0x40 ///< Enable comparator function.                    
           =2                                                                                          
           =2 #define PCA0CPM3_PWM16__BMASK   0x80 ///< Channel 3 16-bit Pulse Width Modulation Enable 
           =2 #define PCA0CPM3_PWM16__SHIFT   0x07 ///< Channel 3 16-bit Pulse Width Modulation Enable 
           =2 #define PCA0CPM3_PWM16__8_BIT   0x00 ///< 8-bit PWM selected.                            
C51 COMPILER V9.56.0.0   SPI_0                                                             10/28/2016 17:37:02 PAGE 119 

           =2 #define PCA0CPM3_PWM16__16_BIT  0x80 ///< 16-bit PWM selected.                           
           =2                                                                                          
           =2 //------------------------------------------------------------------------------
           =2 // PCA0CPH4 Enums (PCA Channel 4 Capture Module High Byte @ 0xFE)
           =2 //------------------------------------------------------------------------------
           =2 #define PCA0CPH4_PCA0CPH4__FMASK 0xFF ///< PCA Channel 4 Capture Module High Byte
           =2 #define PCA0CPH4_PCA0CPH4__SHIFT 0x00 ///< PCA Channel 4 Capture Module High Byte
           =2                                                                                  
           =2 //------------------------------------------------------------------------------
           =2 // PCA0CPL4 Enums (PCA Channel 4 Capture Module Low Byte @ 0xFD)
           =2 //------------------------------------------------------------------------------
           =2 #define PCA0CPL4_PCA0CPL4__FMASK 0xFF ///< PCA Channel 4 Capture Module Low Byte
           =2 #define PCA0CPL4_PCA0CPL4__SHIFT 0x00 ///< PCA Channel 4 Capture Module Low Byte
           =2                                                                                 
           =2 //------------------------------------------------------------------------------
           =2 // PCA0CPM4 Enums (PCA Channel 4 Capture/Compare Mode @ 0xDE)
           =2 //------------------------------------------------------------------------------
           =2 #define PCA0CPM4_ECCF__BMASK    0x01 ///< Channel 4 Capture/Compare Flag Interrupt Enable
           =2 #define PCA0CPM4_ECCF__SHIFT    0x00 ///< Channel 4 Capture/Compare Flag Interrupt Enable
           =2 #define PCA0CPM4_ECCF__DISABLED 0x00 ///< Disable CCF4 interrupts.                       
           =2 #define PCA0CPM4_ECCF__ENABLED  0x01 ///< Enable a Capture/Compare Flag interrupt request
           =2                                      ///< when CCF4 is set.                              
           =2                                                                                          
           =2 #define PCA0CPM4_PWM__BMASK     0x02 ///< Channel 4 Pulse Width Modulation Mode Enable   
           =2 #define PCA0CPM4_PWM__SHIFT     0x01 ///< Channel 4 Pulse Width Modulation Mode Enable   
           =2 #define PCA0CPM4_PWM__DISABLED  0x00 ///< Disable PWM function.                          
           =2 #define PCA0CPM4_PWM__ENABLED   0x02 ///< Enable PWM function.                           
           =2                                                                                          
           =2 #define PCA0CPM4_TOG__BMASK     0x04 ///< Channel 4 Toggle Function Enable               
           =2 #define PCA0CPM4_TOG__SHIFT     0x02 ///< Channel 4 Toggle Function Enable               
           =2 #define PCA0CPM4_TOG__DISABLED  0x00 ///< Disable toggle function.                       
           =2 #define PCA0CPM4_TOG__ENABLED   0x04 ///< Enable toggle function.                        
           =2                                                                                          
           =2 #define PCA0CPM4_MAT__BMASK     0x08 ///< Channel 4 Match Function Enable                
           =2 #define PCA0CPM4_MAT__SHIFT     0x03 ///< Channel 4 Match Function Enable                
           =2 #define PCA0CPM4_MAT__DISABLED  0x00 ///< Disable match function.                        
           =2 #define PCA0CPM4_MAT__ENABLED   0x08 ///< Enable match function.                         
           =2                                                                                          
           =2 #define PCA0CPM4_CAPN__BMASK    0x10 ///< Channel 4 Capture Negative Function Enable     
           =2 #define PCA0CPM4_CAPN__SHIFT    0x04 ///< Channel 4 Capture Negative Function Enable     
           =2 #define PCA0CPM4_CAPN__DISABLED 0x00 ///< Disable negative edge capture.                 
           =2 #define PCA0CPM4_CAPN__ENABLED  0x10 ///< Enable negative edge capture.                  
           =2                                                                                          
           =2 #define PCA0CPM4_CAPP__BMASK    0x20 ///< Channel 4 Capture Positive Function Enable     
           =2 #define PCA0CPM4_CAPP__SHIFT    0x05 ///< Channel 4 Capture Positive Function Enable     
           =2 #define PCA0CPM4_CAPP__DISABLED 0x00 ///< Disable positive edge capture.                 
           =2 #define PCA0CPM4_CAPP__ENABLED  0x20 ///< Enable positive edge capture.                  
           =2                                                                                          
           =2 #define PCA0CPM4_ECOM__BMASK    0x40 ///< Channel 4 Comparator Function Enable           
           =2 #define PCA0CPM4_ECOM__SHIFT    0x06 ///< Channel 4 Comparator Function Enable           
           =2 #define PCA0CPM4_ECOM__DISABLED 0x00 ///< Disable comparator function.                   
           =2 #define PCA0CPM4_ECOM__ENABLED  0x40 ///< Enable comparator function.                    
           =2                                                                                          
           =2 #define PCA0CPM4_PWM16__BMASK   0x80 ///< Channel 4 16-bit Pulse Width Modulation Enable 
           =2 #define PCA0CPM4_PWM16__SHIFT   0x07 ///< Channel 4 16-bit Pulse Width Modulation Enable 
           =2 #define PCA0CPM4_PWM16__8_BIT   0x00 ///< 8-bit PWM selected.                            
           =2 #define PCA0CPM4_PWM16__16_BIT  0x80 ///< 16-bit PWM selected.                           
           =2                                                                                          
           =2 //------------------------------------------------------------------------------
           =2 // PCA0CN0 Enums (PCA Control 0 @ 0xD8)
           =2 //------------------------------------------------------------------------------
           =2 #define PCA0CN0_CCF0__BMASK   0x01 ///< PCA Module 0 Capture/Compare Flag             
C51 COMPILER V9.56.0.0   SPI_0                                                             10/28/2016 17:37:02 PAGE 120 

           =2 #define PCA0CN0_CCF0__SHIFT   0x00 ///< PCA Module 0 Capture/Compare Flag             
           =2 #define PCA0CN0_CCF0__NOT_SET 0x00 ///< A match or capture did not occur on channel 0.
           =2 #define PCA0CN0_CCF0__SET     0x01 ///< A match or capture occurred on channel 0.     
           =2                                                                                       
           =2 #define PCA0CN0_CCF1__BMASK   0x02 ///< PCA Module 1 Capture/Compare Flag             
           =2 #define PCA0CN0_CCF1__SHIFT   0x01 ///< PCA Module 1 Capture/Compare Flag             
           =2 #define PCA0CN0_CCF1__NOT_SET 0x00 ///< A match or capture did not occur on channel 1.
           =2 #define PCA0CN0_CCF1__SET     0x02 ///< A match or capture occurred on channel 1.     
           =2                                                                                       
           =2 #define PCA0CN0_CCF2__BMASK   0x04 ///< PCA Module 2 Capture/Compare Flag             
           =2 #define PCA0CN0_CCF2__SHIFT   0x02 ///< PCA Module 2 Capture/Compare Flag             
           =2 #define PCA0CN0_CCF2__NOT_SET 0x00 ///< A match or capture did not occur on channel 2.
           =2 #define PCA0CN0_CCF2__SET     0x04 ///< A match or capture occurred on channel 2.     
           =2                                                                                       
           =2 #define PCA0CN0_CCF3__BMASK   0x08 ///< PCA Module 3 Capture/Compare Flag             
           =2 #define PCA0CN0_CCF3__SHIFT   0x03 ///< PCA Module 3 Capture/Compare Flag             
           =2 #define PCA0CN0_CCF3__NOT_SET 0x00 ///< A match or capture did not occur on channel 3.
           =2 #define PCA0CN0_CCF3__SET     0x08 ///< A match or capture occurred on channel 3.     
           =2                                                                                       
           =2 #define PCA0CN0_CCF4__BMASK   0x10 ///< PCA Module 4 Capture/Compare Flag             
           =2 #define PCA0CN0_CCF4__SHIFT   0x04 ///< PCA Module 4 Capture/Compare Flag             
           =2 #define PCA0CN0_CCF4__NOT_SET 0x00 ///< A match or capture did not occur on channel 4.
           =2 #define PCA0CN0_CCF4__SET     0x10 ///< A match or capture occurred on channel 4.     
           =2                                                                                       
           =2 #define PCA0CN0_CR__BMASK     0x40 ///< PCA Counter/Timer Run Control                 
           =2 #define PCA0CN0_CR__SHIFT     0x06 ///< PCA Counter/Timer Run Control                 
           =2 #define PCA0CN0_CR__STOP      0x00 ///< Stop the PCA Counter/Timer.                   
           =2 #define PCA0CN0_CR__RUN       0x40 ///< Start the PCA Counter/Timer running.          
           =2                                                                                       
           =2 #define PCA0CN0_CF__BMASK     0x80 ///< PCA Counter/Timer Overflow Flag               
           =2 #define PCA0CN0_CF__SHIFT     0x07 ///< PCA Counter/Timer Overflow Flag               
           =2 #define PCA0CN0_CF__NOT_SET   0x00 ///< The PCA counter/timer did not overflow.       
           =2 #define PCA0CN0_CF__SET       0x80 ///< The PCA counter/timer overflowed.             
           =2                                                                                       
           =2 //------------------------------------------------------------------------------
           =2 // PCA0H Enums (PCA Counter/Timer High Byte @ 0xFA)
           =2 //------------------------------------------------------------------------------
           =2 #define PCA0H_PCA0H__FMASK 0xFF ///< PCA Counter/Timer High Byte
           =2 #define PCA0H_PCA0H__SHIFT 0x00 ///< PCA Counter/Timer High Byte
           =2                                                                 
           =2 //------------------------------------------------------------------------------
           =2 // PCA0L Enums (PCA Counter/Timer Low Byte @ 0xF9)
           =2 //------------------------------------------------------------------------------
           =2 #define PCA0L_PCA0L__FMASK 0xFF ///< PCA Counter/Timer Low Byte
           =2 #define PCA0L_PCA0L__SHIFT 0x00 ///< PCA Counter/Timer Low Byte
           =2                                                                
           =2 //------------------------------------------------------------------------------
           =2 // PCA0MD Enums (PCA Mode @ 0xD9)
           =2 //------------------------------------------------------------------------------
           =2 #define PCA0MD_ECF__BMASK            0x01 ///< PCA Counter/Timer Overflow Interrupt Enable       
           =2 #define PCA0MD_ECF__SHIFT            0x00 ///< PCA Counter/Timer Overflow Interrupt Enable       
           =2 #define PCA0MD_ECF__OVF_INT_DISABLED 0x00 ///< Disable the CF interrupt.                         
           =2 #define PCA0MD_ECF__OVF_INT_ENABLED  0x01 ///< Enable a PCA Counter/Timer Overflow interrupt     
           =2                                           ///< request when CF is set.                           
           =2                                                                                                  
           =2 #define PCA0MD_CPS__FMASK            0x0E ///< PCA Counter/Timer Pulse Select                    
           =2 #define PCA0MD_CPS__SHIFT            0x01 ///< PCA Counter/Timer Pulse Select                    
           =2 #define PCA0MD_CPS__SYSCLK_DIV_12    0x00 ///< System clock divided by 12.                       
           =2 #define PCA0MD_CPS__SYSCLK_DIV_4     0x02 ///< System clock divided by 4.                        
           =2 #define PCA0MD_CPS__T0_OVERFLOW      0x04 ///< Timer 0 overflow.                                 
           =2 #define PCA0MD_CPS__ECI              0x06 ///< High-to-low transitions on ECI (max rate = system 
           =2                                           ///< clock divided by 4).                              
C51 COMPILER V9.56.0.0   SPI_0                                                             10/28/2016 17:37:02 PAGE 121 

           =2 #define PCA0MD_CPS__SYSCLK           0x08 ///< System clock.                                     
           =2 #define PCA0MD_CPS__EXTOSC_DIV_8     0x0A ///< External clock divided by 8 (synchronized with the
           =2                                           ///< system clock).                                    
           =2                                                                                                  
           =2 #define PCA0MD_WDLCK__BMASK          0x20 ///< Watchdog Timer Lock                               
           =2 #define PCA0MD_WDLCK__SHIFT          0x05 ///< Watchdog Timer Lock                               
           =2 #define PCA0MD_WDLCK__UNLOCKED       0x00 ///< Watchdog Timer Enable unlocked.                   
           =2 #define PCA0MD_WDLCK__LOCKED         0x20 ///< Watchdog Timer Enable locked.                     
           =2                                                                                                  
           =2 #define PCA0MD_WDTE__BMASK           0x40 ///< Watchdog Timer Enable                             
           =2 #define PCA0MD_WDTE__SHIFT           0x06 ///< Watchdog Timer Enable                             
           =2 #define PCA0MD_WDTE__DISABLED        0x00 ///< Disable Watchdog Timer.                           
           =2 #define PCA0MD_WDTE__ENABLED         0x40 ///< Enable PCA Module 4 as the Watchdog Timer.        
           =2                                                                                                  
           =2 #define PCA0MD_CIDL__BMASK           0x80 ///< PCA Counter/Timer Idle Control                    
           =2 #define PCA0MD_CIDL__SHIFT           0x07 ///< PCA Counter/Timer Idle Control                    
           =2 #define PCA0MD_CIDL__NORMAL          0x00 ///< PCA continues to function normally while the      
           =2                                           ///< system controller is in Idle Mode.                
           =2 #define PCA0MD_CIDL__SUSPEND         0x80 ///< PCA operation is suspended while the system       
           =2                                           ///< controller is in Idle Mode.                       
           =2                                                                                                  
           =2 //------------------------------------------------------------------------------
           =2 // PCON0 Enums (Power Control @ 0x87)
           =2 //------------------------------------------------------------------------------
           =2 #define PCON0_IDLE__BMASK  0x01 ///< Idle Mode Select                                
           =2 #define PCON0_IDLE__SHIFT  0x00 ///< Idle Mode Select                                
           =2 #define PCON0_IDLE__NORMAL 0x00 ///< Idle mode not activated.                        
           =2 #define PCON0_IDLE__IDLE   0x01 ///< CPU goes into Idle mode (shuts off clock to CPU,
           =2                                 ///< but clocks to enabled peripherals are still     
           =2                                 ///< active).                                        
           =2                                                                                      
           =2 #define PCON0_STOP__BMASK  0x02 ///< Stop Mode Select                                
           =2 #define PCON0_STOP__SHIFT  0x01 ///< Stop Mode Select                                
           =2 #define PCON0_STOP__NORMAL 0x00 ///< Stop mode not activated.                        
           =2 #define PCON0_STOP__STOP   0x02 ///< CPU goes into Stop mode (internal oscillator    
           =2                                 ///< stopped).                                       
           =2                                                                                      
           =2 #define PCON0_GF0__BMASK   0x04 ///< General Purpose Flag 0                          
           =2 #define PCON0_GF0__SHIFT   0x02 ///< General Purpose Flag 0                          
           =2 #define PCON0_GF0__NOT_SET 0x00 ///< The GF0 flag is not set. Clear the GF0 flag.    
           =2 #define PCON0_GF0__SET     0x04 ///< The GF0 flag is set. Set the GF0 flag.          
           =2                                                                                      
           =2 #define PCON0_GF1__BMASK   0x08 ///< General Purpose Flag 1                          
           =2 #define PCON0_GF1__SHIFT   0x03 ///< General Purpose Flag 1                          
           =2 #define PCON0_GF1__NOT_SET 0x00 ///< The GF1 flag is not set. Clear the GF1 flag.    
           =2 #define PCON0_GF1__SET     0x08 ///< The GF1 flag is set. Set the GF1 flag.          
           =2                                                                                      
           =2 #define PCON0_GF2__BMASK   0x10 ///< General Purpose Flag 2                          
           =2 #define PCON0_GF2__SHIFT   0x04 ///< General Purpose Flag 2                          
           =2 #define PCON0_GF2__NOT_SET 0x00 ///< The GF2 flag is not set. Clear the GF2 flag.    
           =2 #define PCON0_GF2__SET     0x10 ///< The GF2 flag is set. Set the GF2 flag.          
           =2                                                                                      
           =2 #define PCON0_GF3__BMASK   0x20 ///< General Purpose Flag 3                          
           =2 #define PCON0_GF3__SHIFT   0x05 ///< General Purpose Flag 3                          
           =2 #define PCON0_GF3__NOT_SET 0x00 ///< The GF3 flag is not set. Clear the GF3 flag.    
           =2 #define PCON0_GF3__SET     0x20 ///< The GF3 flag is set. Set the GF3 flag.          
           =2                                                                                      
           =2 #define PCON0_GF4__BMASK   0x40 ///< General Purpose Flag 4                          
           =2 #define PCON0_GF4__SHIFT   0x06 ///< General Purpose Flag 4                          
           =2 #define PCON0_GF4__NOT_SET 0x00 ///< The GF4 flag is not set. Clear the GF4 flag.    
           =2 #define PCON0_GF4__SET     0x40 ///< The GF4 flag is set. Set the GF4 flag.          
           =2                                                                                      
C51 COMPILER V9.56.0.0   SPI_0                                                             10/28/2016 17:37:02 PAGE 122 

           =2 #define PCON0_GF5__BMASK   0x80 ///< General Purpose Flag 5                          
           =2 #define PCON0_GF5__SHIFT   0x07 ///< General Purpose Flag 5                          
           =2 #define PCON0_GF5__NOT_SET 0x00 ///< The GF5 flag is not set. Clear the GF5 flag.    
           =2 #define PCON0_GF5__SET     0x80 ///< The GF5 flag is set. Set the GF5 flag.          
           =2                                                                                      
           =2 //------------------------------------------------------------------------------
           =2 // P0 Enums (Port 0 Pin Latch @ 0x80)
           =2 //------------------------------------------------------------------------------
           =2 #define P0_B0__BMASK 0x01 ///< Port 0 Bit 0 Latch                            
           =2 #define P0_B0__SHIFT 0x00 ///< Port 0 Bit 0 Latch                            
           =2 #define P0_B0__LOW   0x00 ///< P0.0 is low. Set P0.0 to drive low.           
           =2 #define P0_B0__HIGH  0x01 ///< P0.0 is high. Set P0.0 to drive or float high.
           =2                                                                              
           =2 #define P0_B1__BMASK 0x02 ///< Port 0 Bit 1 Latch                            
           =2 #define P0_B1__SHIFT 0x01 ///< Port 0 Bit 1 Latch                            
           =2 #define P0_B1__LOW   0x00 ///< P0.1 is low. Set P0.1 to drive low.           
           =2 #define P0_B1__HIGH  0x02 ///< P0.1 is high. Set P0.1 to drive or float high.
           =2                                                                              
           =2 #define P0_B2__BMASK 0x04 ///< Port 0 Bit 2 Latch                            
           =2 #define P0_B2__SHIFT 0x02 ///< Port 0 Bit 2 Latch                            
           =2 #define P0_B2__LOW   0x00 ///< P0.2 is low. Set P0.2 to drive low.           
           =2 #define P0_B2__HIGH  0x04 ///< P0.2 is high. Set P0.2 to drive or float high.
           =2                                                                              
           =2 #define P0_B3__BMASK 0x08 ///< Port 0 Bit 3 Latch                            
           =2 #define P0_B3__SHIFT 0x03 ///< Port 0 Bit 3 Latch                            
           =2 #define P0_B3__LOW   0x00 ///< P0.3 is low. Set P0.3 to drive low.           
           =2 #define P0_B3__HIGH  0x08 ///< P0.3 is high. Set P0.3 to drive or float high.
           =2                                                                              
           =2 #define P0_B4__BMASK 0x10 ///< Port 0 Bit 4 Latch                            
           =2 #define P0_B4__SHIFT 0x04 ///< Port 0 Bit 4 Latch                            
           =2 #define P0_B4__LOW   0x00 ///< P0.4 is low. Set P0.4 to drive low.           
           =2 #define P0_B4__HIGH  0x10 ///< P0.4 is high. Set P0.4 to drive or float high.
           =2                                                                              
           =2 #define P0_B5__BMASK 0x20 ///< Port 0 Bit 5 Latch                            
           =2 #define P0_B5__SHIFT 0x05 ///< Port 0 Bit 5 Latch                            
           =2 #define P0_B5__LOW   0x00 ///< P0.5 is low. Set P0.5 to drive low.           
           =2 #define P0_B5__HIGH  0x20 ///< P0.5 is high. Set P0.5 to drive or float high.
           =2                                                                              
           =2 #define P0_B6__BMASK 0x40 ///< Port 0 Bit 6 Latch                            
           =2 #define P0_B6__SHIFT 0x06 ///< Port 0 Bit 6 Latch                            
           =2 #define P0_B6__LOW   0x00 ///< P0.6 is low. Set P0.6 to drive low.           
           =2 #define P0_B6__HIGH  0x40 ///< P0.6 is high. Set P0.6 to drive or float high.
           =2                                                                              
           =2 #define P0_B7__BMASK 0x80 ///< Port 0 Bit 7 Latch                            
           =2 #define P0_B7__SHIFT 0x07 ///< Port 0 Bit 7 Latch                            
           =2 #define P0_B7__LOW   0x00 ///< P0.7 is low. Set P0.7 to drive low.           
           =2 #define P0_B7__HIGH  0x80 ///< P0.7 is high. Set P0.7 to drive or float high.
           =2                                                                              
           =2 //------------------------------------------------------------------------------
           =2 // P0MDIN Enums (Port 0 Input Mode @ 0xF1)
           =2 //------------------------------------------------------------------------------
           =2 #define P0MDIN_B0__BMASK   0x01 ///< Port 0 Bit 0 Input Mode                 
           =2 #define P0MDIN_B0__SHIFT   0x00 ///< Port 0 Bit 0 Input Mode                 
           =2 #define P0MDIN_B0__ANALOG  0x00 ///< P0.0 pin is configured for analog mode. 
           =2 #define P0MDIN_B0__DIGITAL 0x01 ///< P0.0 pin is configured for digital mode.
           =2                                                                              
           =2 #define P0MDIN_B1__BMASK   0x02 ///< Port 0 Bit 1 Input Mode                 
           =2 #define P0MDIN_B1__SHIFT   0x01 ///< Port 0 Bit 1 Input Mode                 
           =2 #define P0MDIN_B1__ANALOG  0x00 ///< P0.1 pin is configured for analog mode. 
           =2 #define P0MDIN_B1__DIGITAL 0x02 ///< P0.1 pin is configured for digital mode.
           =2                                                                              
           =2 #define P0MDIN_B2__BMASK   0x04 ///< Port 0 Bit 2 Input Mode                 
C51 COMPILER V9.56.0.0   SPI_0                                                             10/28/2016 17:37:02 PAGE 123 

           =2 #define P0MDIN_B2__SHIFT   0x02 ///< Port 0 Bit 2 Input Mode                 
           =2 #define P0MDIN_B2__ANALOG  0x00 ///< P0.2 pin is configured for analog mode. 
           =2 #define P0MDIN_B2__DIGITAL 0x04 ///< P0.2 pin is configured for digital mode.
           =2                                                                              
           =2 #define P0MDIN_B3__BMASK   0x08 ///< Port 0 Bit 3 Input Mode                 
           =2 #define P0MDIN_B3__SHIFT   0x03 ///< Port 0 Bit 3 Input Mode                 
           =2 #define P0MDIN_B3__ANALOG  0x00 ///< P0.3 pin is configured for analog mode. 
           =2 #define P0MDIN_B3__DIGITAL 0x08 ///< P0.3 pin is configured for digital mode.
           =2                                                                              
           =2 #define P0MDIN_B4__BMASK   0x10 ///< Port 0 Bit 4 Input Mode                 
           =2 #define P0MDIN_B4__SHIFT   0x04 ///< Port 0 Bit 4 Input Mode                 
           =2 #define P0MDIN_B4__ANALOG  0x00 ///< P0.4 pin is configured for analog mode. 
           =2 #define P0MDIN_B4__DIGITAL 0x10 ///< P0.4 pin is configured for digital mode.
           =2                                                                              
           =2 #define P0MDIN_B5__BMASK   0x20 ///< Port 0 Bit 5 Input Mode                 
           =2 #define P0MDIN_B5__SHIFT   0x05 ///< Port 0 Bit 5 Input Mode                 
           =2 #define P0MDIN_B5__ANALOG  0x00 ///< P0.5 pin is configured for analog mode. 
           =2 #define P0MDIN_B5__DIGITAL 0x20 ///< P0.5 pin is configured for digital mode.
           =2                                                                              
           =2 #define P0MDIN_B6__BMASK   0x40 ///< Port 0 Bit 6 Input Mode                 
           =2 #define P0MDIN_B6__SHIFT   0x06 ///< Port 0 Bit 6 Input Mode                 
           =2 #define P0MDIN_B6__ANALOG  0x00 ///< P0.6 pin is configured for analog mode. 
           =2 #define P0MDIN_B6__DIGITAL 0x40 ///< P0.6 pin is configured for digital mode.
           =2                                                                              
           =2 #define P0MDIN_B7__BMASK   0x80 ///< Port 0 Bit 7 Input Mode                 
           =2 #define P0MDIN_B7__SHIFT   0x07 ///< Port 0 Bit 7 Input Mode                 
           =2 #define P0MDIN_B7__ANALOG  0x00 ///< P0.7 pin is configured for analog mode. 
           =2 #define P0MDIN_B7__DIGITAL 0x80 ///< P0.7 pin is configured for digital mode.
           =2                                                                              
           =2 //------------------------------------------------------------------------------
           =2 // P0MDOUT Enums (Port 0 Output Mode @ 0xA4)
           =2 //------------------------------------------------------------------------------
           =2 #define P0MDOUT_B0__BMASK      0x01 ///< Port 0 Bit 0 Output Mode  
           =2 #define P0MDOUT_B0__SHIFT      0x00 ///< Port 0 Bit 0 Output Mode  
           =2 #define P0MDOUT_B0__OPEN_DRAIN 0x00 ///< P0.0 output is open-drain.
           =2 #define P0MDOUT_B0__PUSH_PULL  0x01 ///< P0.0 output is push-pull. 
           =2                                                                    
           =2 #define P0MDOUT_B1__BMASK      0x02 ///< Port 0 Bit 1 Output Mode  
           =2 #define P0MDOUT_B1__SHIFT      0x01 ///< Port 0 Bit 1 Output Mode  
           =2 #define P0MDOUT_B1__OPEN_DRAIN 0x00 ///< P0.1 output is open-drain.
           =2 #define P0MDOUT_B1__PUSH_PULL  0x02 ///< P0.1 output is push-pull. 
           =2                                                                    
           =2 #define P0MDOUT_B2__BMASK      0x04 ///< Port 0 Bit 2 Output Mode  
           =2 #define P0MDOUT_B2__SHIFT      0x02 ///< Port 0 Bit 2 Output Mode  
           =2 #define P0MDOUT_B2__OPEN_DRAIN 0x00 ///< P0.2 output is open-drain.
           =2 #define P0MDOUT_B2__PUSH_PULL  0x04 ///< P0.2 output is push-pull. 
           =2                                                                    
           =2 #define P0MDOUT_B3__BMASK      0x08 ///< Port 0 Bit 3 Output Mode  
           =2 #define P0MDOUT_B3__SHIFT      0x03 ///< Port 0 Bit 3 Output Mode  
           =2 #define P0MDOUT_B3__OPEN_DRAIN 0x00 ///< P0.3 output is open-drain.
           =2 #define P0MDOUT_B3__PUSH_PULL  0x08 ///< P0.3 output is push-pull. 
           =2                                                                    
           =2 #define P0MDOUT_B4__BMASK      0x10 ///< Port 0 Bit 4 Output Mode  
           =2 #define P0MDOUT_B4__SHIFT      0x04 ///< Port 0 Bit 4 Output Mode  
           =2 #define P0MDOUT_B4__OPEN_DRAIN 0x00 ///< P0.4 output is open-drain.
           =2 #define P0MDOUT_B4__PUSH_PULL  0x10 ///< P0.4 output is push-pull. 
           =2                                                                    
           =2 #define P0MDOUT_B5__BMASK      0x20 ///< Port 0 Bit 5 Output Mode  
           =2 #define P0MDOUT_B5__SHIFT      0x05 ///< Port 0 Bit 5 Output Mode  
           =2 #define P0MDOUT_B5__OPEN_DRAIN 0x00 ///< P0.5 output is open-drain.
           =2 #define P0MDOUT_B5__PUSH_PULL  0x20 ///< P0.5 output is push-pull. 
           =2                                                                    
C51 COMPILER V9.56.0.0   SPI_0                                                             10/28/2016 17:37:02 PAGE 124 

           =2 #define P0MDOUT_B6__BMASK      0x40 ///< Port 0 Bit 6 Output Mode  
           =2 #define P0MDOUT_B6__SHIFT      0x06 ///< Port 0 Bit 6 Output Mode  
           =2 #define P0MDOUT_B6__OPEN_DRAIN 0x00 ///< P0.6 output is open-drain.
           =2 #define P0MDOUT_B6__PUSH_PULL  0x40 ///< P0.6 output is push-pull. 
           =2                                                                    
           =2 #define P0MDOUT_B7__BMASK      0x80 ///< Port 0 Bit 7 Output Mode  
           =2 #define P0MDOUT_B7__SHIFT      0x07 ///< Port 0 Bit 7 Output Mode  
           =2 #define P0MDOUT_B7__OPEN_DRAIN 0x00 ///< P0.7 output is open-drain.
           =2 #define P0MDOUT_B7__PUSH_PULL  0x80 ///< P0.7 output is push-pull. 
           =2                                                                    
           =2 //------------------------------------------------------------------------------
           =2 // P0SKIP Enums (Port 0 Skip @ 0xD4)
           =2 //------------------------------------------------------------------------------
           =2 #define P0SKIP_B0__BMASK       0x01 ///< Port 0 Bit 0 Skip                       
           =2 #define P0SKIP_B0__SHIFT       0x00 ///< Port 0 Bit 0 Skip                       
           =2 #define P0SKIP_B0__NOT_SKIPPED 0x00 ///< P0.0 pin is not skipped by the crossbar.
           =2 #define P0SKIP_B0__SKIPPED     0x01 ///< P0.0 pin is skipped by the crossbar.    
           =2                                                                                  
           =2 #define P0SKIP_B1__BMASK       0x02 ///< Port 0 Bit 1 Skip                       
           =2 #define P0SKIP_B1__SHIFT       0x01 ///< Port 0 Bit 1 Skip                       
           =2 #define P0SKIP_B1__NOT_SKIPPED 0x00 ///< P0.1 pin is not skipped by the crossbar.
           =2 #define P0SKIP_B1__SKIPPED     0x02 ///< P0.1 pin is skipped by the crossbar.    
           =2                                                                                  
           =2 #define P0SKIP_B2__BMASK       0x04 ///< Port 0 Bit 2 Skip                       
           =2 #define P0SKIP_B2__SHIFT       0x02 ///< Port 0 Bit 2 Skip                       
           =2 #define P0SKIP_B2__NOT_SKIPPED 0x00 ///< P0.2 pin is not skipped by the crossbar.
           =2 #define P0SKIP_B2__SKIPPED     0x04 ///< P0.2 pin is skipped by the crossbar.    
           =2                                                                                  
           =2 #define P0SKIP_B3__BMASK       0x08 ///< Port 0 Bit 3 Skip                       
           =2 #define P0SKIP_B3__SHIFT       0x03 ///< Port 0 Bit 3 Skip                       
           =2 #define P0SKIP_B3__NOT_SKIPPED 0x00 ///< P0.3 pin is not skipped by the crossbar.
           =2 #define P0SKIP_B3__SKIPPED     0x08 ///< P0.3 pin is skipped by the crossbar.    
           =2                                                                                  
           =2 #define P0SKIP_B4__BMASK       0x10 ///< Port 0 Bit 4 Skip                       
           =2 #define P0SKIP_B4__SHIFT       0x04 ///< Port 0 Bit 4 Skip                       
           =2 #define P0SKIP_B4__NOT_SKIPPED 0x00 ///< P0.4 pin is not skipped by the crossbar.
           =2 #define P0SKIP_B4__SKIPPED     0x10 ///< P0.4 pin is skipped by the crossbar.    
           =2                                                                                  
           =2 #define P0SKIP_B5__BMASK       0x20 ///< Port 0 Bit 5 Skip                       
           =2 #define P0SKIP_B5__SHIFT       0x05 ///< Port 0 Bit 5 Skip                       
           =2 #define P0SKIP_B5__NOT_SKIPPED 0x00 ///< P0.5 pin is not skipped by the crossbar.
           =2 #define P0SKIP_B5__SKIPPED     0x20 ///< P0.5 pin is skipped by the crossbar.    
           =2                                                                                  
           =2 #define P0SKIP_B6__BMASK       0x40 ///< Port 0 Bit 6 Skip                       
           =2 #define P0SKIP_B6__SHIFT       0x06 ///< Port 0 Bit 6 Skip                       
           =2 #define P0SKIP_B6__NOT_SKIPPED 0x00 ///< P0.6 pin is not skipped by the crossbar.
           =2 #define P0SKIP_B6__SKIPPED     0x40 ///< P0.6 pin is skipped by the crossbar.    
           =2                                                                                  
           =2 #define P0SKIP_B7__BMASK       0x80 ///< Port 0 Bit 7 Skip                       
           =2 #define P0SKIP_B7__SHIFT       0x07 ///< Port 0 Bit 7 Skip                       
           =2 #define P0SKIP_B7__NOT_SKIPPED 0x00 ///< P0.7 pin is not skipped by the crossbar.
           =2 #define P0SKIP_B7__SKIPPED     0x80 ///< P0.7 pin is skipped by the crossbar.    
           =2                                                                                  
           =2 //------------------------------------------------------------------------------
           =2 // P1 Enums (Port 1 Pin Latch @ 0x90)
           =2 //------------------------------------------------------------------------------
           =2 #define P1_B0__BMASK 0x01 ///< Port 1 Bit 0 Latch                            
           =2 #define P1_B0__SHIFT 0x00 ///< Port 1 Bit 0 Latch                            
           =2 #define P1_B0__LOW   0x00 ///< P1.0 is low. Set P1.0 to drive low.           
           =2 #define P1_B0__HIGH  0x01 ///< P1.0 is high. Set P1.0 to drive or float high.
           =2                                                                              
           =2 #define P1_B1__BMASK 0x02 ///< Port 1 Bit 1 Latch                            
C51 COMPILER V9.56.0.0   SPI_0                                                             10/28/2016 17:37:02 PAGE 125 

           =2 #define P1_B1__SHIFT 0x01 ///< Port 1 Bit 1 Latch                            
           =2 #define P1_B1__LOW   0x00 ///< P1.1 is low. Set P1.1 to drive low.           
           =2 #define P1_B1__HIGH  0x02 ///< P1.1 is high. Set P1.1 to drive or float high.
           =2                                                                              
           =2 #define P1_B2__BMASK 0x04 ///< Port 1 Bit 2 Latch                            
           =2 #define P1_B2__SHIFT 0x02 ///< Port 1 Bit 2 Latch                            
           =2 #define P1_B2__LOW   0x00 ///< P1.2 is low. Set P1.2 to drive low.           
           =2 #define P1_B2__HIGH  0x04 ///< P1.2 is high. Set P1.2 to drive or float high.
           =2                                                                              
           =2 #define P1_B3__BMASK 0x08 ///< Port 1 Bit 3 Latch                            
           =2 #define P1_B3__SHIFT 0x03 ///< Port 1 Bit 3 Latch                            
           =2 #define P1_B3__LOW   0x00 ///< P1.3 is low. Set P1.3 to drive low.           
           =2 #define P1_B3__HIGH  0x08 ///< P1.3 is high. Set P1.3 to drive or float high.
           =2                                                                              
           =2 #define P1_B4__BMASK 0x10 ///< Port 1 Bit 4 Latch                            
           =2 #define P1_B4__SHIFT 0x04 ///< Port 1 Bit 4 Latch                            
           =2 #define P1_B4__LOW   0x00 ///< P1.4 is low. Set P1.4 to drive low.           
           =2 #define P1_B4__HIGH  0x10 ///< P1.4 is high. Set P1.4 to drive or float high.
           =2                                                                              
           =2 #define P1_B5__BMASK 0x20 ///< Port 1 Bit 5 Latch                            
           =2 #define P1_B5__SHIFT 0x05 ///< Port 1 Bit 5 Latch                            
           =2 #define P1_B5__LOW   0x00 ///< P1.5 is low. Set P1.5 to drive low.           
           =2 #define P1_B5__HIGH  0x20 ///< P1.5 is high. Set P1.5 to drive or float high.
           =2                                                                              
           =2 #define P1_B6__BMASK 0x40 ///< Port 1 Bit 6 Latch                            
           =2 #define P1_B6__SHIFT 0x06 ///< Port 1 Bit 6 Latch                            
           =2 #define P1_B6__LOW   0x00 ///< P1.6 is low. Set P1.6 to drive low.           
           =2 #define P1_B6__HIGH  0x40 ///< P1.6 is high. Set P1.6 to drive or float high.
           =2                                                                              
           =2 #define P1_B7__BMASK 0x80 ///< Port 1 Bit 7 Latch                            
           =2 #define P1_B7__SHIFT 0x07 ///< Port 1 Bit 7 Latch                            
           =2 #define P1_B7__LOW   0x00 ///< P1.7 is low. Set P1.7 to drive low.           
           =2 #define P1_B7__HIGH  0x80 ///< P1.7 is high. Set P1.7 to drive or float high.
           =2                                                                              
           =2 //------------------------------------------------------------------------------
           =2 // P1MDIN Enums (Port 1 Input Mode @ 0xF2)
           =2 //------------------------------------------------------------------------------
           =2 #define P1MDIN_B0__BMASK   0x01 ///< Port 1 Bit 0 Input Mode                 
           =2 #define P1MDIN_B0__SHIFT   0x00 ///< Port 1 Bit 0 Input Mode                 
           =2 #define P1MDIN_B0__ANALOG  0x00 ///< P1.0 pin is configured for analog mode. 
           =2 #define P1MDIN_B0__DIGITAL 0x01 ///< P1.0 pin is configured for digital mode.
           =2                                                                              
           =2 #define P1MDIN_B1__BMASK   0x02 ///< Port 1 Bit 1 Input Mode                 
           =2 #define P1MDIN_B1__SHIFT   0x01 ///< Port 1 Bit 1 Input Mode                 
           =2 #define P1MDIN_B1__ANALOG  0x00 ///< P1.1 pin is configured for analog mode. 
           =2 #define P1MDIN_B1__DIGITAL 0x02 ///< P1.1 pin is configured for digital mode.
           =2                                                                              
           =2 #define P1MDIN_B2__BMASK   0x04 ///< Port 1 Bit 2 Input Mode                 
           =2 #define P1MDIN_B2__SHIFT   0x02 ///< Port 1 Bit 2 Input Mode                 
           =2 #define P1MDIN_B2__ANALOG  0x00 ///< P1.2 pin is configured for analog mode. 
           =2 #define P1MDIN_B2__DIGITAL 0x04 ///< P1.2 pin is configured for digital mode.
           =2                                                                              
           =2 #define P1MDIN_B3__BMASK   0x08 ///< Port 1 Bit 3 Input Mode                 
           =2 #define P1MDIN_B3__SHIFT   0x03 ///< Port 1 Bit 3 Input Mode                 
           =2 #define P1MDIN_B3__ANALOG  0x00 ///< P1.3 pin is configured for analog mode. 
           =2 #define P1MDIN_B3__DIGITAL 0x08 ///< P1.3 pin is configured for digital mode.
           =2                                                                              
           =2 #define P1MDIN_B4__BMASK   0x10 ///< Port 1 Bit 4 Input Mode                 
           =2 #define P1MDIN_B4__SHIFT   0x04 ///< Port 1 Bit 4 Input Mode                 
           =2 #define P1MDIN_B4__ANALOG  0x00 ///< P1.4 pin is configured for analog mode. 
           =2 #define P1MDIN_B4__DIGITAL 0x10 ///< P1.4 pin is configured for digital mode.
           =2                                                                              
C51 COMPILER V9.56.0.0   SPI_0                                                             10/28/2016 17:37:02 PAGE 126 

           =2 #define P1MDIN_B5__BMASK   0x20 ///< Port 1 Bit 5 Input Mode                 
           =2 #define P1MDIN_B5__SHIFT   0x05 ///< Port 1 Bit 5 Input Mode                 
           =2 #define P1MDIN_B5__ANALOG  0x00 ///< P1.5 pin is configured for analog mode. 
           =2 #define P1MDIN_B5__DIGITAL 0x20 ///< P1.5 pin is configured for digital mode.
           =2                                                                              
           =2 #define P1MDIN_B6__BMASK   0x40 ///< Port 1 Bit 6 Input Mode                 
           =2 #define P1MDIN_B6__SHIFT   0x06 ///< Port 1 Bit 6 Input Mode                 
           =2 #define P1MDIN_B6__ANALOG  0x00 ///< P1.6 pin is configured for analog mode. 
           =2 #define P1MDIN_B6__DIGITAL 0x40 ///< P1.6 pin is configured for digital mode.
           =2                                                                              
           =2 #define P1MDIN_B7__BMASK   0x80 ///< Port 1 Bit 7 Input Mode                 
           =2 #define P1MDIN_B7__SHIFT   0x07 ///< Port 1 Bit 7 Input Mode                 
           =2 #define P1MDIN_B7__ANALOG  0x00 ///< P1.7 pin is configured for analog mode. 
           =2 #define P1MDIN_B7__DIGITAL 0x80 ///< P1.7 pin is configured for digital mode.
           =2                                                                              
           =2 //------------------------------------------------------------------------------
           =2 // P1MDOUT Enums (Port 1 Output Mode @ 0xA5)
           =2 //------------------------------------------------------------------------------
           =2 #define P1MDOUT_B0__BMASK      0x01 ///< Port 1 Bit 0 Output Mode  
           =2 #define P1MDOUT_B0__SHIFT      0x00 ///< Port 1 Bit 0 Output Mode  
           =2 #define P1MDOUT_B0__OPEN_DRAIN 0x00 ///< P1.0 output is open-drain.
           =2 #define P1MDOUT_B0__PUSH_PULL  0x01 ///< P1.0 output is push-pull. 
           =2                                                                    
           =2 #define P1MDOUT_B1__BMASK      0x02 ///< Port 1 Bit 1 Output Mode  
           =2 #define P1MDOUT_B1__SHIFT      0x01 ///< Port 1 Bit 1 Output Mode  
           =2 #define P1MDOUT_B1__OPEN_DRAIN 0x00 ///< P1.1 output is open-drain.
           =2 #define P1MDOUT_B1__PUSH_PULL  0x02 ///< P1.1 output is push-pull. 
           =2                                                                    
           =2 #define P1MDOUT_B2__BMASK      0x04 ///< Port 1 Bit 2 Output Mode  
           =2 #define P1MDOUT_B2__SHIFT      0x02 ///< Port 1 Bit 2 Output Mode  
           =2 #define P1MDOUT_B2__OPEN_DRAIN 0x00 ///< P1.2 output is open-drain.
           =2 #define P1MDOUT_B2__PUSH_PULL  0x04 ///< P1.2 output is push-pull. 
           =2                                                                    
           =2 #define P1MDOUT_B3__BMASK      0x08 ///< Port 1 Bit 3 Output Mode  
           =2 #define P1MDOUT_B3__SHIFT      0x03 ///< Port 1 Bit 3 Output Mode  
           =2 #define P1MDOUT_B3__OPEN_DRAIN 0x00 ///< P1.3 output is open-drain.
           =2 #define P1MDOUT_B3__PUSH_PULL  0x08 ///< P1.3 output is push-pull. 
           =2                                                                    
           =2 #define P1MDOUT_B4__BMASK      0x10 ///< Port 1 Bit 4 Output Mode  
           =2 #define P1MDOUT_B4__SHIFT      0x04 ///< Port 1 Bit 4 Output Mode  
           =2 #define P1MDOUT_B4__OPEN_DRAIN 0x00 ///< P1.4 output is open-drain.
           =2 #define P1MDOUT_B4__PUSH_PULL  0x10 ///< P1.4 output is push-pull. 
           =2                                                                    
           =2 #define P1MDOUT_B5__BMASK      0x20 ///< Port 1 Bit 5 Output Mode  
           =2 #define P1MDOUT_B5__SHIFT      0x05 ///< Port 1 Bit 5 Output Mode  
           =2 #define P1MDOUT_B5__OPEN_DRAIN 0x00 ///< P1.5 output is open-drain.
           =2 #define P1MDOUT_B5__PUSH_PULL  0x20 ///< P1.5 output is push-pull. 
           =2                                                                    
           =2 #define P1MDOUT_B6__BMASK      0x40 ///< Port 1 Bit 6 Output Mode  
           =2 #define P1MDOUT_B6__SHIFT      0x06 ///< Port 1 Bit 6 Output Mode  
           =2 #define P1MDOUT_B6__OPEN_DRAIN 0x00 ///< P1.6 output is open-drain.
           =2 #define P1MDOUT_B6__PUSH_PULL  0x40 ///< P1.6 output is push-pull. 
           =2                                                                    
           =2 #define P1MDOUT_B7__BMASK      0x80 ///< Port 1 Bit 7 Output Mode  
           =2 #define P1MDOUT_B7__SHIFT      0x07 ///< Port 1 Bit 7 Output Mode  
           =2 #define P1MDOUT_B7__OPEN_DRAIN 0x00 ///< P1.7 output is open-drain.
           =2 #define P1MDOUT_B7__PUSH_PULL  0x80 ///< P1.7 output is push-pull. 
           =2                                                                    
           =2 //------------------------------------------------------------------------------
           =2 // P1SKIP Enums (Port 1 Skip @ 0xD5)
           =2 //------------------------------------------------------------------------------
           =2 #define P1SKIP_B0__BMASK       0x01 ///< Port 1 Bit 0 Skip                       
C51 COMPILER V9.56.0.0   SPI_0                                                             10/28/2016 17:37:02 PAGE 127 

           =2 #define P1SKIP_B0__SHIFT       0x00 ///< Port 1 Bit 0 Skip                       
           =2 #define P1SKIP_B0__NOT_SKIPPED 0x00 ///< P1.0 pin is not skipped by the crossbar.
           =2 #define P1SKIP_B0__SKIPPED     0x01 ///< P1.0 pin is skipped by the crossbar.    
           =2                                                                                  
           =2 #define P1SKIP_B1__BMASK       0x02 ///< Port 1 Bit 1 Skip                       
           =2 #define P1SKIP_B1__SHIFT       0x01 ///< Port 1 Bit 1 Skip                       
           =2 #define P1SKIP_B1__NOT_SKIPPED 0x00 ///< P1.1 pin is not skipped by the crossbar.
           =2 #define P1SKIP_B1__SKIPPED     0x02 ///< P1.1 pin is skipped by the crossbar.    
           =2                                                                                  
           =2 #define P1SKIP_B2__BMASK       0x04 ///< Port 1 Bit 2 Skip                       
           =2 #define P1SKIP_B2__SHIFT       0x02 ///< Port 1 Bit 2 Skip                       
           =2 #define P1SKIP_B2__NOT_SKIPPED 0x00 ///< P1.2 pin is not skipped by the crossbar.
           =2 #define P1SKIP_B2__SKIPPED     0x04 ///< P1.2 pin is skipped by the crossbar.    
           =2                                                                                  
           =2 #define P1SKIP_B3__BMASK       0x08 ///< Port 1 Bit 3 Skip                       
           =2 #define P1SKIP_B3__SHIFT       0x03 ///< Port 1 Bit 3 Skip                       
           =2 #define P1SKIP_B3__NOT_SKIPPED 0x00 ///< P1.3 pin is not skipped by the crossbar.
           =2 #define P1SKIP_B3__SKIPPED     0x08 ///< P1.3 pin is skipped by the crossbar.    
           =2                                                                                  
           =2 #define P1SKIP_B4__BMASK       0x10 ///< Port 1 Bit 4 Skip                       
           =2 #define P1SKIP_B4__SHIFT       0x04 ///< Port 1 Bit 4 Skip                       
           =2 #define P1SKIP_B4__NOT_SKIPPED 0x00 ///< P1.4 pin is not skipped by the crossbar.
           =2 #define P1SKIP_B4__SKIPPED     0x10 ///< P1.4 pin is skipped by the crossbar.    
           =2                                                                                  
           =2 #define P1SKIP_B5__BMASK       0x20 ///< Port 1 Bit 5 Skip                       
           =2 #define P1SKIP_B5__SHIFT       0x05 ///< Port 1 Bit 5 Skip                       
           =2 #define P1SKIP_B5__NOT_SKIPPED 0x00 ///< P1.5 pin is not skipped by the crossbar.
           =2 #define P1SKIP_B5__SKIPPED     0x20 ///< P1.5 pin is skipped by the crossbar.    
           =2                                                                                  
           =2 #define P1SKIP_B6__BMASK       0x40 ///< Port 1 Bit 6 Skip                       
           =2 #define P1SKIP_B6__SHIFT       0x06 ///< Port 1 Bit 6 Skip                       
           =2 #define P1SKIP_B6__NOT_SKIPPED 0x00 ///< P1.6 pin is not skipped by the crossbar.
           =2 #define P1SKIP_B6__SKIPPED     0x40 ///< P1.6 pin is skipped by the crossbar.    
           =2                                                                                  
           =2 #define P1SKIP_B7__BMASK       0x80 ///< Port 1 Bit 7 Skip                       
           =2 #define P1SKIP_B7__SHIFT       0x07 ///< Port 1 Bit 7 Skip                       
           =2 #define P1SKIP_B7__NOT_SKIPPED 0x00 ///< P1.7 pin is not skipped by the crossbar.
           =2 #define P1SKIP_B7__SKIPPED     0x80 ///< P1.7 pin is skipped by the crossbar.    
           =2                                                                                  
           =2 //------------------------------------------------------------------------------
           =2 // P2 Enums (Port 2 Pin Latch @ 0xA0)
           =2 //------------------------------------------------------------------------------
           =2 #define P2_B0__BMASK 0x01 ///< Port 2 Bit 0 Latch                            
           =2 #define P2_B0__SHIFT 0x00 ///< Port 2 Bit 0 Latch                            
           =2 #define P2_B0__LOW   0x00 ///< P2.0 is low. Set P2.0 to drive low.           
           =2 #define P2_B0__HIGH  0x01 ///< P2.0 is high. Set P2.0 to drive or float high.
           =2                                                                              
           =2 #define P2_B1__BMASK 0x02 ///< Port 2 Bit 1 Latch                            
           =2 #define P2_B1__SHIFT 0x01 ///< Port 2 Bit 1 Latch                            
           =2 #define P2_B1__LOW   0x00 ///< P2.1 is low. Set P2.1 to drive low.           
           =2 #define P2_B1__HIGH  0x02 ///< P2.1 is high. Set P2.1 to drive or float high.
           =2                                                                              
           =2 #define P2_B2__BMASK 0x04 ///< Port 2 Bit 2 Latch                            
           =2 #define P2_B2__SHIFT 0x02 ///< Port 2 Bit 2 Latch                            
           =2 #define P2_B2__LOW   0x00 ///< P2.2 is low. Set P2.2 to drive low.           
           =2 #define P2_B2__HIGH  0x04 ///< P2.2 is high. Set P2.2 to drive or float high.
           =2                                                                              
           =2 #define P2_B3__BMASK 0x08 ///< Port 2 Bit 3 Latch                            
           =2 #define P2_B3__SHIFT 0x03 ///< Port 2 Bit 3 Latch                            
           =2 #define P2_B3__LOW   0x00 ///< P2.3 is low. Set P2.3 to drive low.           
           =2 #define P2_B3__HIGH  0x08 ///< P2.3 is high. Set P2.3 to drive or float high.
           =2                                                                              
C51 COMPILER V9.56.0.0   SPI_0                                                             10/28/2016 17:37:02 PAGE 128 

           =2 #define P2_B4__BMASK 0x10 ///< Port 2 Bit 4 Latch                            
           =2 #define P2_B4__SHIFT 0x04 ///< Port 2 Bit 4 Latch                            
           =2 #define P2_B4__LOW   0x00 ///< P2.4 is low. Set P2.4 to drive low.           
           =2 #define P2_B4__HIGH  0x10 ///< P2.4 is high. Set P2.4 to drive or float high.
           =2                                                                              
           =2 #define P2_B5__BMASK 0x20 ///< Port 2 Bit 5 Latch                            
           =2 #define P2_B5__SHIFT 0x05 ///< Port 2 Bit 5 Latch                            
           =2 #define P2_B5__LOW   0x00 ///< P2.5 is low. Set P2.5 to drive low.           
           =2 #define P2_B5__HIGH  0x20 ///< P2.5 is high. Set P2.5 to drive or float high.
           =2                                                                              
           =2 #define P2_B6__BMASK 0x40 ///< Port 2 Bit 6 Latch                            
           =2 #define P2_B6__SHIFT 0x06 ///< Port 2 Bit 6 Latch                            
           =2 #define P2_B6__LOW   0x00 ///< P2.6 is low. Set P2.6 to drive low.           
           =2 #define P2_B6__HIGH  0x40 ///< P2.6 is high. Set P2.6 to drive or float high.
           =2                                                                              
           =2 #define P2_B7__BMASK 0x80 ///< Port 2 Bit 7 Latch                            
           =2 #define P2_B7__SHIFT 0x07 ///< Port 2 Bit 7 Latch                            
           =2 #define P2_B7__LOW   0x00 ///< P2.7 is low. Set P2.7 to drive low.           
           =2 #define P2_B7__HIGH  0x80 ///< P2.7 is high. Set P2.7 to drive or float high.
           =2                                                                              
           =2 //------------------------------------------------------------------------------
           =2 // P2MDIN Enums (Port 2 Input Mode @ 0xF3)
           =2 //------------------------------------------------------------------------------
           =2 #define P2MDIN_B0__BMASK   0x01 ///< Port 2 Bit 0 Input Mode                 
           =2 #define P2MDIN_B0__SHIFT   0x00 ///< Port 2 Bit 0 Input Mode                 
           =2 #define P2MDIN_B0__ANALOG  0x00 ///< P2.0 pin is configured for analog mode. 
           =2 #define P2MDIN_B0__DIGITAL 0x01 ///< P2.0 pin is configured for digital mode.
           =2                                                                              
           =2 #define P2MDIN_B1__BMASK   0x02 ///< Port 2 Bit 1 Input Mode                 
           =2 #define P2MDIN_B1__SHIFT   0x01 ///< Port 2 Bit 1 Input Mode                 
           =2 #define P2MDIN_B1__ANALOG  0x00 ///< P2.1 pin is configured for analog mode. 
           =2 #define P2MDIN_B1__DIGITAL 0x02 ///< P2.1 pin is configured for digital mode.
           =2                                                                              
           =2 #define P2MDIN_B2__BMASK   0x04 ///< Port 2 Bit 2 Input Mode                 
           =2 #define P2MDIN_B2__SHIFT   0x02 ///< Port 2 Bit 2 Input Mode                 
           =2 #define P2MDIN_B2__ANALOG  0x00 ///< P2.2 pin is configured for analog mode. 
           =2 #define P2MDIN_B2__DIGITAL 0x04 ///< P2.2 pin is configured for digital mode.
           =2                                                                              
           =2 #define P2MDIN_B3__BMASK   0x08 ///< Port 2 Bit 3 Input Mode                 
           =2 #define P2MDIN_B3__SHIFT   0x03 ///< Port 2 Bit 3 Input Mode                 
           =2 #define P2MDIN_B3__ANALOG  0x00 ///< P2.3 pin is configured for analog mode. 
           =2 #define P2MDIN_B3__DIGITAL 0x08 ///< P2.3 pin is configured for digital mode.
           =2                                                                              
           =2 #define P2MDIN_B4__BMASK   0x10 ///< Port 2 Bit 4 Input Mode                 
           =2 #define P2MDIN_B4__SHIFT   0x04 ///< Port 2 Bit 4 Input Mode                 
           =2 #define P2MDIN_B4__ANALOG  0x00 ///< P2.4 pin is configured for analog mode. 
           =2 #define P2MDIN_B4__DIGITAL 0x10 ///< P2.4 pin is configured for digital mode.
           =2                                                                              
           =2 #define P2MDIN_B5__BMASK   0x20 ///< Port 2 Bit 5 Input Mode                 
           =2 #define P2MDIN_B5__SHIFT   0x05 ///< Port 2 Bit 5 Input Mode                 
           =2 #define P2MDIN_B5__ANALOG  0x00 ///< P2.5 pin is configured for analog mode. 
           =2 #define P2MDIN_B5__DIGITAL 0x20 ///< P2.5 pin is configured for digital mode.
           =2                                                                              
           =2 #define P2MDIN_B6__BMASK   0x40 ///< Port 2 Bit 6 Input Mode                 
           =2 #define P2MDIN_B6__SHIFT   0x06 ///< Port 2 Bit 6 Input Mode                 
           =2 #define P2MDIN_B6__ANALOG  0x00 ///< P2.6 pin is configured for analog mode. 
           =2 #define P2MDIN_B6__DIGITAL 0x40 ///< P2.6 pin is configured for digital mode.
           =2                                                                              
           =2 #define P2MDIN_B7__BMASK   0x80 ///< Port 2 Bit 7 Input Mode                 
           =2 #define P2MDIN_B7__SHIFT   0x07 ///< Port 2 Bit 7 Input Mode                 
           =2 #define P2MDIN_B7__ANALOG  0x00 ///< P2.7 pin is configured for analog mode. 
           =2 #define P2MDIN_B7__DIGITAL 0x80 ///< P2.7 pin is configured for digital mode.
C51 COMPILER V9.56.0.0   SPI_0                                                             10/28/2016 17:37:02 PAGE 129 

           =2                                                                              
           =2 //------------------------------------------------------------------------------
           =2 // P2MDOUT Enums (Port 2 Output Mode @ 0xA6)
           =2 //------------------------------------------------------------------------------
           =2 #define P2MDOUT_B0__BMASK      0x01 ///< Port 2 Bit 0 Output Mode  
           =2 #define P2MDOUT_B0__SHIFT      0x00 ///< Port 2 Bit 0 Output Mode  
           =2 #define P2MDOUT_B0__OPEN_DRAIN 0x00 ///< P2.0 output is open-drain.
           =2 #define P2MDOUT_B0__PUSH_PULL  0x01 ///< P2.0 output is push-pull. 
           =2                                                                    
           =2 #define P2MDOUT_B1__BMASK      0x02 ///< Port 2 Bit 1 Output Mode  
           =2 #define P2MDOUT_B1__SHIFT      0x01 ///< Port 2 Bit 1 Output Mode  
           =2 #define P2MDOUT_B1__OPEN_DRAIN 0x00 ///< P2.1 output is open-drain.
           =2 #define P2MDOUT_B1__PUSH_PULL  0x02 ///< P2.1 output is push-pull. 
           =2                                                                    
           =2 #define P2MDOUT_B2__BMASK      0x04 ///< Port 2 Bit 2 Output Mode  
           =2 #define P2MDOUT_B2__SHIFT      0x02 ///< Port 2 Bit 2 Output Mode  
           =2 #define P2MDOUT_B2__OPEN_DRAIN 0x00 ///< P2.2 output is open-drain.
           =2 #define P2MDOUT_B2__PUSH_PULL  0x04 ///< P2.2 output is push-pull. 
           =2                                                                    
           =2 #define P2MDOUT_B3__BMASK      0x08 ///< Port 2 Bit 3 Output Mode  
           =2 #define P2MDOUT_B3__SHIFT      0x03 ///< Port 2 Bit 3 Output Mode  
           =2 #define P2MDOUT_B3__OPEN_DRAIN 0x00 ///< P2.3 output is open-drain.
           =2 #define P2MDOUT_B3__PUSH_PULL  0x08 ///< P2.3 output is push-pull. 
           =2                                                                    
           =2 #define P2MDOUT_B4__BMASK      0x10 ///< Port 2 Bit 4 Output Mode  
           =2 #define P2MDOUT_B4__SHIFT      0x04 ///< Port 2 Bit 4 Output Mode  
           =2 #define P2MDOUT_B4__OPEN_DRAIN 0x00 ///< P2.4 output is open-drain.
           =2 #define P2MDOUT_B4__PUSH_PULL  0x10 ///< P2.4 output is push-pull. 
           =2                                                                    
           =2 #define P2MDOUT_B5__BMASK      0x20 ///< Port 2 Bit 5 Output Mode  
           =2 #define P2MDOUT_B5__SHIFT      0x05 ///< Port 2 Bit 5 Output Mode  
           =2 #define P2MDOUT_B5__OPEN_DRAIN 0x00 ///< P2.5 output is open-drain.
           =2 #define P2MDOUT_B5__PUSH_PULL  0x20 ///< P2.5 output is push-pull. 
           =2                                                                    
           =2 #define P2MDOUT_B6__BMASK      0x40 ///< Port 2 Bit 6 Output Mode  
           =2 #define P2MDOUT_B6__SHIFT      0x06 ///< Port 2 Bit 6 Output Mode  
           =2 #define P2MDOUT_B6__OPEN_DRAIN 0x00 ///< P2.6 output is open-drain.
           =2 #define P2MDOUT_B6__PUSH_PULL  0x40 ///< P2.6 output is push-pull. 
           =2                                                                    
           =2 #define P2MDOUT_B7__BMASK      0x80 ///< Port 2 Bit 7 Output Mode  
           =2 #define P2MDOUT_B7__SHIFT      0x07 ///< Port 2 Bit 7 Output Mode  
           =2 #define P2MDOUT_B7__OPEN_DRAIN 0x00 ///< P2.7 output is open-drain.
           =2 #define P2MDOUT_B7__PUSH_PULL  0x80 ///< P2.7 output is push-pull. 
           =2                                                                    
           =2 //------------------------------------------------------------------------------
           =2 // P2SKIP Enums (Port 2 Skip @ 0xD6)
           =2 //------------------------------------------------------------------------------
           =2 #define P2SKIP_B0__BMASK       0x01 ///< Port 2 Bit 0 Skip                       
           =2 #define P2SKIP_B0__SHIFT       0x00 ///< Port 2 Bit 0 Skip                       
           =2 #define P2SKIP_B0__NOT_SKIPPED 0x00 ///< P2.0 pin is not skipped by the crossbar.
           =2 #define P2SKIP_B0__SKIPPED     0x01 ///< P2.0 pin is skipped by the crossbar.    
           =2                                                                                  
           =2 #define P2SKIP_B1__BMASK       0x02 ///< Port 2 Bit 1 Skip                       
           =2 #define P2SKIP_B1__SHIFT       0x01 ///< Port 2 Bit 1 Skip                       
           =2 #define P2SKIP_B1__NOT_SKIPPED 0x00 ///< P2.1 pin is not skipped by the crossbar.
           =2 #define P2SKIP_B1__SKIPPED     0x02 ///< P2.1 pin is skipped by the crossbar.    
           =2                                                                                  
           =2 #define P2SKIP_B2__BMASK       0x04 ///< Port 2 Bit 2 Skip                       
           =2 #define P2SKIP_B2__SHIFT       0x02 ///< Port 2 Bit 2 Skip                       
           =2 #define P2SKIP_B2__NOT_SKIPPED 0x00 ///< P2.2 pin is not skipped by the crossbar.
           =2 #define P2SKIP_B2__SKIPPED     0x04 ///< P2.2 pin is skipped by the crossbar.    
           =2                                                                                  
C51 COMPILER V9.56.0.0   SPI_0                                                             10/28/2016 17:37:02 PAGE 130 

           =2 #define P2SKIP_B3__BMASK       0x08 ///< Port 2 Bit 3 Skip                       
           =2 #define P2SKIP_B3__SHIFT       0x03 ///< Port 2 Bit 3 Skip                       
           =2 #define P2SKIP_B3__NOT_SKIPPED 0x00 ///< P2.3 pin is not skipped by the crossbar.
           =2 #define P2SKIP_B3__SKIPPED     0x08 ///< P2.3 pin is skipped by the crossbar.    
           =2                                                                                  
           =2 #define P2SKIP_B4__BMASK       0x10 ///< Port 2 Bit 4 Skip                       
           =2 #define P2SKIP_B4__SHIFT       0x04 ///< Port 2 Bit 4 Skip                       
           =2 #define P2SKIP_B4__NOT_SKIPPED 0x00 ///< P2.4 pin is not skipped by the crossbar.
           =2 #define P2SKIP_B4__SKIPPED     0x10 ///< P2.4 pin is skipped by the crossbar.    
           =2                                                                                  
           =2 #define P2SKIP_B5__BMASK       0x20 ///< Port 2 Bit 5 Skip                       
           =2 #define P2SKIP_B5__SHIFT       0x05 ///< Port 2 Bit 5 Skip                       
           =2 #define P2SKIP_B5__NOT_SKIPPED 0x00 ///< P2.5 pin is not skipped by the crossbar.
           =2 #define P2SKIP_B5__SKIPPED     0x20 ///< P2.5 pin is skipped by the crossbar.    
           =2                                                                                  
           =2 #define P2SKIP_B6__BMASK       0x40 ///< Port 2 Bit 6 Skip                       
           =2 #define P2SKIP_B6__SHIFT       0x06 ///< Port 2 Bit 6 Skip                       
           =2 #define P2SKIP_B6__NOT_SKIPPED 0x00 ///< P2.6 pin is not skipped by the crossbar.
           =2 #define P2SKIP_B6__SKIPPED     0x40 ///< P2.6 pin is skipped by the crossbar.    
           =2                                                                                  
           =2 #define P2SKIP_B7__BMASK       0x80 ///< Port 2 Bit 7 Skip                       
           =2 #define P2SKIP_B7__SHIFT       0x07 ///< Port 2 Bit 7 Skip                       
           =2 #define P2SKIP_B7__NOT_SKIPPED 0x00 ///< P2.7 pin is not skipped by the crossbar.
           =2 #define P2SKIP_B7__SKIPPED     0x80 ///< P2.7 pin is skipped by the crossbar.    
           =2                                                                                  
           =2 //------------------------------------------------------------------------------
           =2 // P3 Enums (Port 3 Pin Latch @ 0xB0)
           =2 //------------------------------------------------------------------------------
           =2 #define P3_B0__BMASK 0x01 ///< Port 3 Bit 0 Latch                            
           =2 #define P3_B0__SHIFT 0x00 ///< Port 3 Bit 0 Latch                            
           =2 #define P3_B0__LOW   0x00 ///< P3.0 is low. Set P3.0 to drive low.           
           =2 #define P3_B0__HIGH  0x01 ///< P3.0 is high. Set P3.0 to drive or float high.
           =2                                                                              
           =2 #define P3_B1__BMASK 0x02 ///< Port 3 Bit 1 Latch                            
           =2 #define P3_B1__SHIFT 0x01 ///< Port 3 Bit 1 Latch                            
           =2 #define P3_B1__LOW   0x00 ///< P3.1 is low. Set P3.1 to drive low.           
           =2 #define P3_B1__HIGH  0x02 ///< P3.1 is high. Set P3.1 to drive or float high.
           =2                                                                              
           =2 #define P3_B2__BMASK 0x04 ///< Port 3 Bit 2 Latch                            
           =2 #define P3_B2__SHIFT 0x02 ///< Port 3 Bit 2 Latch                            
           =2 #define P3_B2__LOW   0x00 ///< P3.2 is low. Set P3.2 to drive low.           
           =2 #define P3_B2__HIGH  0x04 ///< P3.2 is high. Set P3.2 to drive or float high.
           =2                                                                              
           =2 #define P3_B3__BMASK 0x08 ///< Port 3 Bit 3 Latch                            
           =2 #define P3_B3__SHIFT 0x03 ///< Port 3 Bit 3 Latch                            
           =2 #define P3_B3__LOW   0x00 ///< P3.3 is low. Set P3.3 to drive low.           
           =2 #define P3_B3__HIGH  0x08 ///< P3.3 is high. Set P3.3 to drive or float high.
           =2                                                                              
           =2 #define P3_B4__BMASK 0x10 ///< Port 3 Bit 4 Latch                            
           =2 #define P3_B4__SHIFT 0x04 ///< Port 3 Bit 4 Latch                            
           =2 #define P3_B4__LOW   0x00 ///< P3.4 is low. Set P3.4 to drive low.           
           =2 #define P3_B4__HIGH  0x10 ///< P3.4 is high. Set P3.4 to drive or float high.
           =2                                                                              
           =2 #define P3_B5__BMASK 0x20 ///< Port 3 Bit 5 Latch                            
           =2 #define P3_B5__SHIFT 0x05 ///< Port 3 Bit 5 Latch                            
           =2 #define P3_B5__LOW   0x00 ///< P3.5 is low. Set P3.5 to drive low.           
           =2 #define P3_B5__HIGH  0x20 ///< P3.5 is high. Set P3.5 to drive or float high.
           =2                                                                              
           =2 #define P3_B6__BMASK 0x40 ///< Port 3 Bit 6 Latch                            
           =2 #define P3_B6__SHIFT 0x06 ///< Port 3 Bit 6 Latch                            
           =2 #define P3_B6__LOW   0x00 ///< P3.6 is low. Set P3.6 to drive low.           
           =2 #define P3_B6__HIGH  0x40 ///< P3.6 is high. Set P3.6 to drive or float high.
C51 COMPILER V9.56.0.0   SPI_0                                                             10/28/2016 17:37:02 PAGE 131 

           =2                                                                              
           =2 #define P3_B7__BMASK 0x80 ///< Port 3 Bit 7 Latch                            
           =2 #define P3_B7__SHIFT 0x07 ///< Port 3 Bit 7 Latch                            
           =2 #define P3_B7__LOW   0x00 ///< P3.7 is low. Set P3.7 to drive low.           
           =2 #define P3_B7__HIGH  0x80 ///< P3.7 is high. Set P3.7 to drive or float high.
           =2                                                                              
           =2 //------------------------------------------------------------------------------
           =2 // P3MDIN Enums (Port 3 Input Mode @ 0xF4)
           =2 //------------------------------------------------------------------------------
           =2 #define P3MDIN_B0__BMASK   0x01 ///< Port 3 Bit 0 Input Mode                 
           =2 #define P3MDIN_B0__SHIFT   0x00 ///< Port 3 Bit 0 Input Mode                 
           =2 #define P3MDIN_B0__ANALOG  0x00 ///< P3.0 pin is configured for analog mode. 
           =2 #define P3MDIN_B0__DIGITAL 0x01 ///< P3.0 pin is configured for digital mode.
           =2                                                                              
           =2 #define P3MDIN_B1__BMASK   0x02 ///< Port 3 Bit 1 Input Mode                 
           =2 #define P3MDIN_B1__SHIFT   0x01 ///< Port 3 Bit 1 Input Mode                 
           =2 #define P3MDIN_B1__ANALOG  0x00 ///< P3.1 pin is configured for analog mode. 
           =2 #define P3MDIN_B1__DIGITAL 0x02 ///< P3.1 pin is configured for digital mode.
           =2                                                                              
           =2 #define P3MDIN_B2__BMASK   0x04 ///< Port 3 Bit 2 Input Mode                 
           =2 #define P3MDIN_B2__SHIFT   0x02 ///< Port 3 Bit 2 Input Mode                 
           =2 #define P3MDIN_B2__ANALOG  0x00 ///< P3.2 pin is configured for analog mode. 
           =2 #define P3MDIN_B2__DIGITAL 0x04 ///< P3.2 pin is configured for digital mode.
           =2                                                                              
           =2 #define P3MDIN_B3__BMASK   0x08 ///< Port 3 Bit 3 Input Mode                 
           =2 #define P3MDIN_B3__SHIFT   0x03 ///< Port 3 Bit 3 Input Mode                 
           =2 #define P3MDIN_B3__ANALOG  0x00 ///< P3.3 pin is configured for analog mode. 
           =2 #define P3MDIN_B3__DIGITAL 0x08 ///< P3.3 pin is configured for digital mode.
           =2                                                                              
           =2 #define P3MDIN_B4__BMASK   0x10 ///< Port 3 Bit 4 Input Mode                 
           =2 #define P3MDIN_B4__SHIFT   0x04 ///< Port 3 Bit 4 Input Mode                 
           =2 #define P3MDIN_B4__ANALOG  0x00 ///< P3.4 pin is configured for analog mode. 
           =2 #define P3MDIN_B4__DIGITAL 0x10 ///< P3.4 pin is configured for digital mode.
           =2                                                                              
           =2 #define P3MDIN_B5__BMASK   0x20 ///< Port 3 Bit 5 Input Mode                 
           =2 #define P3MDIN_B5__SHIFT   0x05 ///< Port 3 Bit 5 Input Mode                 
           =2 #define P3MDIN_B5__ANALOG  0x00 ///< P3.5 pin is configured for analog mode. 
           =2 #define P3MDIN_B5__DIGITAL 0x20 ///< P3.5 pin is configured for digital mode.
           =2                                                                              
           =2 #define P3MDIN_B6__BMASK   0x40 ///< Port 3 Bit 6 Input Mode                 
           =2 #define P3MDIN_B6__SHIFT   0x06 ///< Port 3 Bit 6 Input Mode                 
           =2 #define P3MDIN_B6__ANALOG  0x00 ///< P3.6 pin is configured for analog mode. 
           =2 #define P3MDIN_B6__DIGITAL 0x40 ///< P3.6 pin is configured for digital mode.
           =2                                                                              
           =2 #define P3MDIN_B7__BMASK   0x80 ///< Port 3 Bit 7 Input Mode                 
           =2 #define P3MDIN_B7__SHIFT   0x07 ///< Port 3 Bit 7 Input Mode                 
           =2 #define P3MDIN_B7__ANALOG  0x00 ///< P3.7 pin is configured for analog mode. 
           =2 #define P3MDIN_B7__DIGITAL 0x80 ///< P3.7 pin is configured for digital mode.
           =2                                                                              
           =2 //------------------------------------------------------------------------------
           =2 // P3MDOUT Enums (Port 3 Output Mode @ 0xA7)
           =2 //------------------------------------------------------------------------------
           =2 #define P3MDOUT_B0__BMASK      0x01 ///< Port 3 Bit 0 Output Mode  
           =2 #define P3MDOUT_B0__SHIFT      0x00 ///< Port 3 Bit 0 Output Mode  
           =2 #define P3MDOUT_B0__OPEN_DRAIN 0x00 ///< P3.0 output is open-drain.
           =2 #define P3MDOUT_B0__PUSH_PULL  0x01 ///< P3.0 output is push-pull. 
           =2                                                                    
           =2 #define P3MDOUT_B1__BMASK      0x02 ///< Port 3 Bit 1 Output Mode  
           =2 #define P3MDOUT_B1__SHIFT      0x01 ///< Port 3 Bit 1 Output Mode  
           =2 #define P3MDOUT_B1__OPEN_DRAIN 0x00 ///< P3.1 output is open-drain.
           =2 #define P3MDOUT_B1__PUSH_PULL  0x02 ///< P3.1 output is push-pull. 
           =2                                                                    
C51 COMPILER V9.56.0.0   SPI_0                                                             10/28/2016 17:37:02 PAGE 132 

           =2 #define P3MDOUT_B2__BMASK      0x04 ///< Port 3 Bit 2 Output Mode  
           =2 #define P3MDOUT_B2__SHIFT      0x02 ///< Port 3 Bit 2 Output Mode  
           =2 #define P3MDOUT_B2__OPEN_DRAIN 0x00 ///< P3.2 output is open-drain.
           =2 #define P3MDOUT_B2__PUSH_PULL  0x04 ///< P3.2 output is push-pull. 
           =2                                                                    
           =2 #define P3MDOUT_B3__BMASK      0x08 ///< Port 3 Bit 3 Output Mode  
           =2 #define P3MDOUT_B3__SHIFT      0x03 ///< Port 3 Bit 3 Output Mode  
           =2 #define P3MDOUT_B3__OPEN_DRAIN 0x00 ///< P3.3 output is open-drain.
           =2 #define P3MDOUT_B3__PUSH_PULL  0x08 ///< P3.3 output is push-pull. 
           =2                                                                    
           =2 #define P3MDOUT_B4__BMASK      0x10 ///< Port 3 Bit 4 Output Mode  
           =2 #define P3MDOUT_B4__SHIFT      0x04 ///< Port 3 Bit 4 Output Mode  
           =2 #define P3MDOUT_B4__OPEN_DRAIN 0x00 ///< P3.4 output is open-drain.
           =2 #define P3MDOUT_B4__PUSH_PULL  0x10 ///< P3.4 output is push-pull. 
           =2                                                                    
           =2 #define P3MDOUT_B5__BMASK      0x20 ///< Port 3 Bit 5 Output Mode  
           =2 #define P3MDOUT_B5__SHIFT      0x05 ///< Port 3 Bit 5 Output Mode  
           =2 #define P3MDOUT_B5__OPEN_DRAIN 0x00 ///< P3.5 output is open-drain.
           =2 #define P3MDOUT_B5__PUSH_PULL  0x20 ///< P3.5 output is push-pull. 
           =2                                                                    
           =2 #define P3MDOUT_B6__BMASK      0x40 ///< Port 3 Bit 6 Output Mode  
           =2 #define P3MDOUT_B6__SHIFT      0x06 ///< Port 3 Bit 6 Output Mode  
           =2 #define P3MDOUT_B6__OPEN_DRAIN 0x00 ///< P3.6 output is open-drain.
           =2 #define P3MDOUT_B6__PUSH_PULL  0x40 ///< P3.6 output is push-pull. 
           =2                                                                    
           =2 #define P3MDOUT_B7__BMASK      0x80 ///< Port 3 Bit 7 Output Mode  
           =2 #define P3MDOUT_B7__SHIFT      0x07 ///< Port 3 Bit 7 Output Mode  
           =2 #define P3MDOUT_B7__OPEN_DRAIN 0x00 ///< P3.7 output is open-drain.
           =2 #define P3MDOUT_B7__PUSH_PULL  0x80 ///< P3.7 output is push-pull. 
           =2                                                                    
           =2 //------------------------------------------------------------------------------
           =2 // P3SKIP Enums (Port 3 Skip @ 0xDF)
           =2 //------------------------------------------------------------------------------
           =2 #define P3SKIP_B0__BMASK       0x01 ///< Port 3 Bit 0 Skip                       
           =2 #define P3SKIP_B0__SHIFT       0x00 ///< Port 3 Bit 0 Skip                       
           =2 #define P3SKIP_B0__NOT_SKIPPED 0x00 ///< P3.0 pin is not skipped by the crossbar.
           =2 #define P3SKIP_B0__SKIPPED     0x01 ///< P3.0 pin is skipped by the crossbar.    
           =2                                                                                  
           =2 #define P3SKIP_B1__BMASK       0x02 ///< Port 3 Bit 1 Skip                       
           =2 #define P3SKIP_B1__SHIFT       0x01 ///< Port 3 Bit 1 Skip                       
           =2 #define P3SKIP_B1__NOT_SKIPPED 0x00 ///< P3.1 pin is not skipped by the crossbar.
           =2 #define P3SKIP_B1__SKIPPED     0x02 ///< P3.1 pin is skipped by the crossbar.    
           =2                                                                                  
           =2 #define P3SKIP_B2__BMASK       0x04 ///< Port 3 Bit 2 Skip                       
           =2 #define P3SKIP_B2__SHIFT       0x02 ///< Port 3 Bit 2 Skip                       
           =2 #define P3SKIP_B2__NOT_SKIPPED 0x00 ///< P3.2 pin is not skipped by the crossbar.
           =2 #define P3SKIP_B2__SKIPPED     0x04 ///< P3.2 pin is skipped by the crossbar.    
           =2                                                                                  
           =2 #define P3SKIP_B3__BMASK       0x08 ///< Port 3 Bit 3 Skip                       
           =2 #define P3SKIP_B3__SHIFT       0x03 ///< Port 3 Bit 3 Skip                       
           =2 #define P3SKIP_B3__NOT_SKIPPED 0x00 ///< P3.3 pin is not skipped by the crossbar.
           =2 #define P3SKIP_B3__SKIPPED     0x08 ///< P3.3 pin is skipped by the crossbar.    
           =2                                                                                  
           =2 #define P3SKIP_B4__BMASK       0x10 ///< Port 3 Bit 4 Skip                       
           =2 #define P3SKIP_B4__SHIFT       0x04 ///< Port 3 Bit 4 Skip                       
           =2 #define P3SKIP_B4__NOT_SKIPPED 0x00 ///< P3.4 pin is not skipped by the crossbar.
           =2 #define P3SKIP_B4__SKIPPED     0x10 ///< P3.4 pin is skipped by the crossbar.    
           =2                                                                                  
           =2 #define P3SKIP_B5__BMASK       0x20 ///< Port 3 Bit 5 Skip                       
           =2 #define P3SKIP_B5__SHIFT       0x05 ///< Port 3 Bit 5 Skip                       
           =2 #define P3SKIP_B5__NOT_SKIPPED 0x00 ///< P3.5 pin is not skipped by the crossbar.
           =2 #define P3SKIP_B5__SKIPPED     0x20 ///< P3.5 pin is skipped by the crossbar.    
C51 COMPILER V9.56.0.0   SPI_0                                                             10/28/2016 17:37:02 PAGE 133 

           =2                                                                                  
           =2 #define P3SKIP_B6__BMASK       0x40 ///< Port 3 Bit 6 Skip                       
           =2 #define P3SKIP_B6__SHIFT       0x06 ///< Port 3 Bit 6 Skip                       
           =2 #define P3SKIP_B6__NOT_SKIPPED 0x00 ///< P3.6 pin is not skipped by the crossbar.
           =2 #define P3SKIP_B6__SKIPPED     0x40 ///< P3.6 pin is skipped by the crossbar.    
           =2                                                                                  
           =2 #define P3SKIP_B7__BMASK       0x80 ///< Port 3 Bit 7 Skip                       
           =2 #define P3SKIP_B7__SHIFT       0x07 ///< Port 3 Bit 7 Skip                       
           =2 #define P3SKIP_B7__NOT_SKIPPED 0x00 ///< P3.7 pin is not skipped by the crossbar.
           =2 #define P3SKIP_B7__SKIPPED     0x80 ///< P3.7 pin is skipped by the crossbar.    
           =2                                                                                  
           =2 //------------------------------------------------------------------------------
           =2 // P4 Enums (Port 4 Pin Latch @ 0xC7)
           =2 //------------------------------------------------------------------------------
           =2 #define P4_B0__BMASK 0x01 ///< Port 4 Bit 0 Latch                            
           =2 #define P4_B0__SHIFT 0x00 ///< Port 4 Bit 0 Latch                            
           =2 #define P4_B0__LOW   0x00 ///< P4.0 is low. Set P4.0 to drive low.           
           =2 #define P4_B0__HIGH  0x01 ///< P4.0 is high. Set P4.0 to drive or float high.
           =2                                                                              
           =2 #define P4_B1__BMASK 0x02 ///< Port 4 Bit 1 Latch                            
           =2 #define P4_B1__SHIFT 0x01 ///< Port 4 Bit 1 Latch                            
           =2 #define P4_B1__LOW   0x00 ///< P4.1 is low. Set P4.1 to drive low.           
           =2 #define P4_B1__HIGH  0x02 ///< P4.1 is high. Set P4.1 to drive or float high.
           =2                                                                              
           =2 #define P4_B2__BMASK 0x04 ///< Port 4 Bit 2 Latch                            
           =2 #define P4_B2__SHIFT 0x02 ///< Port 4 Bit 2 Latch                            
           =2 #define P4_B2__LOW   0x00 ///< P4.2 is low. Set P4.2 to drive low.           
           =2 #define P4_B2__HIGH  0x04 ///< P4.2 is high. Set P4.2 to drive or float high.
           =2                                                                              
           =2 #define P4_B3__BMASK 0x08 ///< Port 4 Bit 3 Latch                            
           =2 #define P4_B3__SHIFT 0x03 ///< Port 4 Bit 3 Latch                            
           =2 #define P4_B3__LOW   0x00 ///< P4.3 is low. Set P4.3 to drive low.           
           =2 #define P4_B3__HIGH  0x08 ///< P4.3 is high. Set P4.3 to drive or float high.
           =2                                                                              
           =2 #define P4_B4__BMASK 0x10 ///< Port 4 Bit 4 Latch                            
           =2 #define P4_B4__SHIFT 0x04 ///< Port 4 Bit 4 Latch                            
           =2 #define P4_B4__LOW   0x00 ///< P4.4 is low. Set P4.4 to drive low.           
           =2 #define P4_B4__HIGH  0x10 ///< P4.4 is high. Set P4.4 to drive or float high.
           =2                                                                              
           =2 #define P4_B5__BMASK 0x20 ///< Port 4 Bit 5 Latch                            
           =2 #define P4_B5__SHIFT 0x05 ///< Port 4 Bit 5 Latch                            
           =2 #define P4_B5__LOW   0x00 ///< P4.5 is low. Set P4.5 to drive low.           
           =2 #define P4_B5__HIGH  0x20 ///< P4.5 is high. Set P4.5 to drive or float high.
           =2                                                                              
           =2 #define P4_B6__BMASK 0x40 ///< Port 4 Bit 6 Latch                            
           =2 #define P4_B6__SHIFT 0x06 ///< Port 4 Bit 6 Latch                            
           =2 #define P4_B6__LOW   0x00 ///< P4.6 is low. Set P4.6 to drive low.           
           =2 #define P4_B6__HIGH  0x40 ///< P4.6 is high. Set P4.6 to drive or float high.
           =2                                                                              
           =2 #define P4_B7__BMASK 0x80 ///< Port 4 Bit 7 Latch                            
           =2 #define P4_B7__SHIFT 0x07 ///< Port 4 Bit 7 Latch                            
           =2 #define P4_B7__LOW   0x00 ///< P4.7 is low. Set P4.7 to drive low.           
           =2 #define P4_B7__HIGH  0x80 ///< P4.7 is high. Set P4.7 to drive or float high.
           =2                                                                              
           =2 //------------------------------------------------------------------------------
           =2 // P4MDIN Enums (Port 4 Input Mode @ 0xF5)
           =2 //------------------------------------------------------------------------------
           =2 #define P4MDIN_B0__BMASK   0x01 ///< Port 4 Bit 0 Input Mode                 
           =2 #define P4MDIN_B0__SHIFT   0x00 ///< Port 4 Bit 0 Input Mode                 
           =2 #define P4MDIN_B0__ANALOG  0x00 ///< P4.0 pin is configured for analog mode. 
           =2 #define P4MDIN_B0__DIGITAL 0x01 ///< P4.0 pin is configured for digital mode.
           =2                                                                              
C51 COMPILER V9.56.0.0   SPI_0                                                             10/28/2016 17:37:02 PAGE 134 

           =2 #define P4MDIN_B1__BMASK   0x02 ///< Port 4 Bit 1 Input Mode                 
           =2 #define P4MDIN_B1__SHIFT   0x01 ///< Port 4 Bit 1 Input Mode                 
           =2 #define P4MDIN_B1__ANALOG  0x00 ///< P4.1 pin is configured for analog mode. 
           =2 #define P4MDIN_B1__DIGITAL 0x02 ///< P4.1 pin is configured for digital mode.
           =2                                                                              
           =2 #define P4MDIN_B2__BMASK   0x04 ///< Port 4 Bit 2 Input Mode                 
           =2 #define P4MDIN_B2__SHIFT   0x02 ///< Port 4 Bit 2 Input Mode                 
           =2 #define P4MDIN_B2__ANALOG  0x00 ///< P4.2 pin is configured for analog mode. 
           =2 #define P4MDIN_B2__DIGITAL 0x04 ///< P4.2 pin is configured for digital mode.
           =2                                                                              
           =2 #define P4MDIN_B3__BMASK   0x08 ///< Port 4 Bit 3 Input Mode                 
           =2 #define P4MDIN_B3__SHIFT   0x03 ///< Port 4 Bit 3 Input Mode                 
           =2 #define P4MDIN_B3__ANALOG  0x00 ///< P4.3 pin is configured for analog mode. 
           =2 #define P4MDIN_B3__DIGITAL 0x08 ///< P4.3 pin is configured for digital mode.
           =2                                                                              
           =2 #define P4MDIN_B4__BMASK   0x10 ///< Port 4 Bit 4 Input Mode                 
           =2 #define P4MDIN_B4__SHIFT   0x04 ///< Port 4 Bit 4 Input Mode                 
           =2 #define P4MDIN_B4__ANALOG  0x00 ///< P4.4 pin is configured for analog mode. 
           =2 #define P4MDIN_B4__DIGITAL 0x10 ///< P4.4 pin is configured for digital mode.
           =2                                                                              
           =2 #define P4MDIN_B5__BMASK   0x20 ///< Port 4 Bit 5 Input Mode                 
           =2 #define P4MDIN_B5__SHIFT   0x05 ///< Port 4 Bit 5 Input Mode                 
           =2 #define P4MDIN_B5__ANALOG  0x00 ///< P4.5 pin is configured for analog mode. 
           =2 #define P4MDIN_B5__DIGITAL 0x20 ///< P4.5 pin is configured for digital mode.
           =2                                                                              
           =2 #define P4MDIN_B6__BMASK   0x40 ///< Port 4 Bit 6 Input Mode                 
           =2 #define P4MDIN_B6__SHIFT   0x06 ///< Port 4 Bit 6 Input Mode                 
           =2 #define P4MDIN_B6__ANALOG  0x00 ///< P4.6 pin is configured for analog mode. 
           =2 #define P4MDIN_B6__DIGITAL 0x40 ///< P4.6 pin is configured for digital mode.
           =2                                                                              
           =2 #define P4MDIN_B7__BMASK   0x80 ///< Port 4 Bit 7 Input Mode                 
           =2 #define P4MDIN_B7__SHIFT   0x07 ///< Port 4 Bit 7 Input Mode                 
           =2 #define P4MDIN_B7__ANALOG  0x00 ///< P4.7 pin is configured for analog mode. 
           =2 #define P4MDIN_B7__DIGITAL 0x80 ///< P4.7 pin is configured for digital mode.
           =2                                                                              
           =2 //------------------------------------------------------------------------------
           =2 // P4MDOUT Enums (Port 4 Output Mode @ 0xAE)
           =2 //------------------------------------------------------------------------------
           =2 #define P4MDOUT_B0__BMASK      0x01 ///< Port 4 Bit 0 Output Mode  
           =2 #define P4MDOUT_B0__SHIFT      0x00 ///< Port 4 Bit 0 Output Mode  
           =2 #define P4MDOUT_B0__OPEN_DRAIN 0x00 ///< P4.0 output is open-drain.
           =2 #define P4MDOUT_B0__PUSH_PULL  0x01 ///< P4.0 output is push-pull. 
           =2                                                                    
           =2 #define P4MDOUT_B1__BMASK      0x02 ///< Port 4 Bit 1 Output Mode  
           =2 #define P4MDOUT_B1__SHIFT      0x01 ///< Port 4 Bit 1 Output Mode  
           =2 #define P4MDOUT_B1__OPEN_DRAIN 0x00 ///< P4.1 output is open-drain.
           =2 #define P4MDOUT_B1__PUSH_PULL  0x02 ///< P4.1 output is push-pull. 
           =2                                                                    
           =2 #define P4MDOUT_B2__BMASK      0x04 ///< Port 4 Bit 2 Output Mode  
           =2 #define P4MDOUT_B2__SHIFT      0x02 ///< Port 4 Bit 2 Output Mode  
           =2 #define P4MDOUT_B2__OPEN_DRAIN 0x00 ///< P4.2 output is open-drain.
           =2 #define P4MDOUT_B2__PUSH_PULL  0x04 ///< P4.2 output is push-pull. 
           =2                                                                    
           =2 #define P4MDOUT_B3__BMASK      0x08 ///< Port 4 Bit 3 Output Mode  
           =2 #define P4MDOUT_B3__SHIFT      0x03 ///< Port 4 Bit 3 Output Mode  
           =2 #define P4MDOUT_B3__OPEN_DRAIN 0x00 ///< P4.3 output is open-drain.
           =2 #define P4MDOUT_B3__PUSH_PULL  0x08 ///< P4.3 output is push-pull. 
           =2                                                                    
           =2 #define P4MDOUT_B4__BMASK      0x10 ///< Port 4 Bit 4 Output Mode  
           =2 #define P4MDOUT_B4__SHIFT      0x04 ///< Port 4 Bit 4 Output Mode  
           =2 #define P4MDOUT_B4__OPEN_DRAIN 0x00 ///< P4.4 output is open-drain.
           =2 #define P4MDOUT_B4__PUSH_PULL  0x10 ///< P4.4 output is push-pull. 
C51 COMPILER V9.56.0.0   SPI_0                                                             10/28/2016 17:37:02 PAGE 135 

           =2                                                                    
           =2 #define P4MDOUT_B5__BMASK      0x20 ///< Port 4 Bit 5 Output Mode  
           =2 #define P4MDOUT_B5__SHIFT      0x05 ///< Port 4 Bit 5 Output Mode  
           =2 #define P4MDOUT_B5__OPEN_DRAIN 0x00 ///< P4.5 output is open-drain.
           =2 #define P4MDOUT_B5__PUSH_PULL  0x20 ///< P4.5 output is push-pull. 
           =2                                                                    
           =2 #define P4MDOUT_B6__BMASK      0x40 ///< Port 4 Bit 6 Output Mode  
           =2 #define P4MDOUT_B6__SHIFT      0x06 ///< Port 4 Bit 6 Output Mode  
           =2 #define P4MDOUT_B6__OPEN_DRAIN 0x00 ///< P4.6 output is open-drain.
           =2 #define P4MDOUT_B6__PUSH_PULL  0x40 ///< P4.6 output is push-pull. 
           =2                                                                    
           =2 #define P4MDOUT_B7__BMASK      0x80 ///< Port 4 Bit 7 Output Mode  
           =2 #define P4MDOUT_B7__SHIFT      0x07 ///< Port 4 Bit 7 Output Mode  
           =2 #define P4MDOUT_B7__OPEN_DRAIN 0x00 ///< P4.7 output is open-drain.
           =2 #define P4MDOUT_B7__PUSH_PULL  0x80 ///< P4.7 output is push-pull. 
           =2                                                                    
           =2 //------------------------------------------------------------------------------
           =2 // RSTSRC Enums (Reset Source @ 0xEF)
           =2 //------------------------------------------------------------------------------
           =2 #define RSTSRC_PINRSF__BMASK   0x01 ///< HW Pin Reset Flag                                                
             -    
           =2 #define RSTSRC_PINRSF__SHIFT   0x00 ///< HW Pin Reset Flag                                                
             -    
           =2 #define RSTSRC_PINRSF__NOT_SET 0x00 ///< The RSTb pin did not cause the last reset.                       
             -    
           =2 #define RSTSRC_PINRSF__SET     0x01 ///< The RSTb pin caused the last reset.                              
             -    
           =2                                                                                                           
             -    
           =2 #define RSTSRC_PORSF__BMASK    0x02 ///< Power-On / Supply Monitor Reset Flag, and Supply Monitor Reset En
             -able
           =2 #define RSTSRC_PORSF__SHIFT    0x01 ///< Power-On / Supply Monitor Reset Flag, and Supply Monitor Reset En
             -able
           =2 #define RSTSRC_PORSF__NOT_SET  0x00 ///< A power-on or supply monitor reset did not occur.                
             -    
           =2 #define RSTSRC_PORSF__SET      0x02 ///< A power-on or supply monitor reset occurred.                     
             -    
           =2                                                                                                           
             -    
           =2 #define RSTSRC_MCDRSF__BMASK   0x04 ///< Missing Clock Detector Enable and Flag                           
             -    
           =2 #define RSTSRC_MCDRSF__SHIFT   0x02 ///< Missing Clock Detector Enable and Flag                           
             -    
           =2 #define RSTSRC_MCDRSF__NOT_SET 0x00 ///< A missing clock detector reset did not occur.                    
             -    
           =2 #define RSTSRC_MCDRSF__SET     0x04 ///< A missing clock detector reset occurred.                         
             -    
           =2                                                                                                           
             -    
           =2 #define RSTSRC_WDTRSF__BMASK   0x08 ///< Watchdog Timer Reset Flag                                        
             -    
           =2 #define RSTSRC_WDTRSF__SHIFT   0x03 ///< Watchdog Timer Reset Flag                                        
             -    
           =2 #define RSTSRC_WDTRSF__NOT_SET 0x00 ///< A watchdog timer overflow reset did not occur.                   
             -    
           =2 #define RSTSRC_WDTRSF__SET     0x08 ///< A watchdog timer overflow reset occurred.                        
             -    
           =2                                                                                                           
             -    
           =2 #define RSTSRC_SWRSF__BMASK    0x10 ///< Software Reset Force and Flag                                    
             -    
           =2 #define RSTSRC_SWRSF__SHIFT    0x04 ///< Software Reset Force and Flag                                    
C51 COMPILER V9.56.0.0   SPI_0                                                             10/28/2016 17:37:02 PAGE 136 

             -    
           =2 #define RSTSRC_SWRSF__NOT_SET  0x00 ///< A software reset did not occur.                                  
             -    
           =2 #define RSTSRC_SWRSF__SET      0x10 ///< A software reset occurred.                                       
             -    
           =2                                                                                                           
             -    
           =2 #define RSTSRC_C0RSEF__BMASK   0x20 ///< Comparator0 Reset Enable and Flag                                
             -    
           =2 #define RSTSRC_C0RSEF__SHIFT   0x05 ///< Comparator0 Reset Enable and Flag                                
             -    
           =2 #define RSTSRC_C0RSEF__NOT_SET 0x00 ///< A Comparator 0 reset did not occur.                              
             -    
           =2 #define RSTSRC_C0RSEF__SET     0x20 ///< A Comparator 0 reset occurred.                                   
             -    
           =2                                                                                                           
             -    
           =2 #define RSTSRC_FERROR__BMASK   0x40 ///< Flash Error Reset Flag                                           
             -    
           =2 #define RSTSRC_FERROR__SHIFT   0x06 ///< Flash Error Reset Flag                                           
             -    
           =2 #define RSTSRC_FERROR__NOT_SET 0x00 ///< A flash error reset did not occur.                               
             -    
           =2 #define RSTSRC_FERROR__SET     0x40 ///< A flash error reset occurred.                                    
             -    
           =2                                                                                                           
             -    
           =2 #define RSTSRC_USBRSF__BMASK   0x80 ///< USB Reset Enable and Flag                                        
             -    
           =2 #define RSTSRC_USBRSF__SHIFT   0x07 ///< USB Reset Enable and Flag                                        
             -    
           =2 #define RSTSRC_USBRSF__NOT_SET 0x00 ///< A USB0 reset did not occur.                                      
             -    
           =2 #define RSTSRC_USBRSF__SET     0x80 ///< A USB0 reset occurred.                                           
             -    
           =2                                                                                                           
             -    
           =2 //------------------------------------------------------------------------------
           =2 // SFRPAGE Enums (SFR Page @ 0xBF)
           =2 //------------------------------------------------------------------------------
           =2 #define SFRPAGE_SFRPAGE__FMASK 0xFF ///< SFR Page
           =2 #define SFRPAGE_SFRPAGE__SHIFT 0x00 ///< SFR Page
           =2                                                  
           =2 //------------------------------------------------------------------------------
           =2 // SMB0ADM Enums (SMBus 0 Slave Address Mask @ 0xCE)
           =2 //------------------------------------------------------------------------------
           =2 #define SMB0ADM_EHACK__BMASK             0x01 ///< Hardware Acknowledge Enable                     
           =2 #define SMB0ADM_EHACK__SHIFT             0x00 ///< Hardware Acknowledge Enable                     
           =2 #define SMB0ADM_EHACK__ADR_ACK_MANUAL    0x00 ///< Firmware must manually acknowledge all incoming 
           =2                                               ///< address and data bytes.                         
           =2 #define SMB0ADM_EHACK__ADR_ACK_AUTOMATIC 0x01 ///< Automatic slave address recognition and hardware
           =2                                               ///< acknowledge is enabled.                         
           =2                                                                                                    
           =2 #define SMB0ADM_SLVM__FMASK              0xFE ///< SMBus Slave Address Mask                        
           =2 #define SMB0ADM_SLVM__SHIFT              0x01 ///< SMBus Slave Address Mask                        
           =2                                                                                                    
           =2 //------------------------------------------------------------------------------
           =2 // SMB0ADR Enums (SMBus 0 Slave Address @ 0xCF)
           =2 //------------------------------------------------------------------------------
           =2 #define SMB0ADR_GC__BMASK      0x01 ///< General Call Address Enable        
           =2 #define SMB0ADR_GC__SHIFT      0x00 ///< General Call Address Enable        
           =2 #define SMB0ADR_GC__IGNORED    0x00 ///< General Call Address is ignored.   
C51 COMPILER V9.56.0.0   SPI_0                                                             10/28/2016 17:37:02 PAGE 137 

           =2 #define SMB0ADR_GC__RECOGNIZED 0x01 ///< General Call Address is recognized.
           =2                                                                             
           =2 #define SMB0ADR_SLV__FMASK     0xFE ///< SMBus Hardware Slave Address       
           =2 #define SMB0ADR_SLV__SHIFT     0x01 ///< SMBus Hardware Slave Address       
           =2                                                                             
           =2 //------------------------------------------------------------------------------
           =2 // SMB0CF Enums (SMBus 0 Configuration @ 0xC1)
           =2 //------------------------------------------------------------------------------
           =2 #define SMB0CF_SMBCS__FMASK             0x03 ///< SMBus Clock Source Selection                     
           =2 #define SMB0CF_SMBCS__SHIFT             0x00 ///< SMBus Clock Source Selection                     
           =2 #define SMB0CF_SMBCS__TIMER0            0x00 ///< Timer 0 Overflow.                                
           =2 #define SMB0CF_SMBCS__TIMER1            0x01 ///< Timer 1 Overflow.                                
           =2 #define SMB0CF_SMBCS__TIMER2_HIGH       0x02 ///< Timer 2 High Byte Overflow.                      
           =2 #define SMB0CF_SMBCS__TIMER2_LOW        0x03 ///< Timer 2 Low Byte Overflow.                       
           =2                                                                                                    
           =2 #define SMB0CF_SMBFTE__BMASK            0x04 ///< SMBus Free Timeout Detection Enable              
           =2 #define SMB0CF_SMBFTE__SHIFT            0x02 ///< SMBus Free Timeout Detection Enable              
           =2 #define SMB0CF_SMBFTE__FREE_TO_DISABLED 0x00 ///< Disable bus free timeouts.                       
           =2 #define SMB0CF_SMBFTE__FREE_TO_ENABLED  0x04 ///< Enable bus free timeouts. The bus the bus will be
           =2                                              ///< considered free if SCL and SDA remain high for   
           =2                                              ///< more than 10 SMBus clock source periods.         
           =2                                                                                                    
           =2 #define SMB0CF_SMBTOE__BMASK            0x08 ///< SMBus SCL Timeout Detection Enable               
           =2 #define SMB0CF_SMBTOE__SHIFT            0x03 ///< SMBus SCL Timeout Detection Enable               
           =2 #define SMB0CF_SMBTOE__SCL_TO_DISABLED  0x00 ///< Disable SCL low timeouts.                        
           =2 #define SMB0CF_SMBTOE__SCL_TO_ENABLED   0x08 ///< Enable SCL low timeouts.                         
           =2                                                                                                    
           =2 #define SMB0CF_EXTHOLD__BMASK           0x10 ///< SMBus Setup and Hold Time Extension Enable       
           =2 #define SMB0CF_EXTHOLD__SHIFT           0x04 ///< SMBus Setup and Hold Time Extension Enable       
           =2 #define SMB0CF_EXTHOLD__DISABLED        0x00 ///< Disable SDA extended setup and hold times.       
           =2 #define SMB0CF_EXTHOLD__ENABLED         0x10 ///< Enable SDA extended setup and hold times.        
           =2                                                                                                    
           =2 #define SMB0CF_BUSY__BMASK              0x20 ///< SMBus Busy Indicator                             
           =2 #define SMB0CF_BUSY__SHIFT              0x05 ///< SMBus Busy Indicator                             
           =2 #define SMB0CF_BUSY__NOT_SET            0x00 ///< The bus is not busy.                             
           =2 #define SMB0CF_BUSY__SET                0x20 ///< The bus is busy and a transfer is currently in   
           =2                                              ///< progress.                                        
           =2                                                                                                    
           =2 #define SMB0CF_INH__BMASK               0x40 ///< SMBus Slave Inhibit                              
           =2 #define SMB0CF_INH__SHIFT               0x06 ///< SMBus Slave Inhibit                              
           =2 #define SMB0CF_INH__SLAVE_ENABLED       0x00 ///< Slave states are enabled.                        
           =2 #define SMB0CF_INH__SLAVE_DISABLED      0x40 ///< Slave states are inhibited.                      
           =2                                                                                                    
           =2 #define SMB0CF_ENSMB__BMASK             0x80 ///< SMBus Enable                                     
           =2 #define SMB0CF_ENSMB__SHIFT             0x07 ///< SMBus Enable                                     
           =2 #define SMB0CF_ENSMB__DISABLED          0x00 ///< Disable the SMBus module.                        
           =2 #define SMB0CF_ENSMB__ENABLED           0x80 ///< Enable the SMBus module.                         
           =2                                                                                                    
           =2 //------------------------------------------------------------------------------
           =2 // SMB0CN0 Enums (SMBus 0 Control @ 0xC0)
           =2 //------------------------------------------------------------------------------
           =2 #define SMB0CN0_SI__BMASK           0x01 ///< SMBus Interrupt Flag                           
           =2 #define SMB0CN0_SI__SHIFT           0x00 ///< SMBus Interrupt Flag                           
           =2 #define SMB0CN0_SI__NOT_SET         0x00 ///<                                                
           =2 #define SMB0CN0_SI__SET             0x01 ///<                                                
           =2                                                                                              
           =2 #define SMB0CN0_ACK__BMASK          0x02 ///< SMBus Acknowledge                              
           =2 #define SMB0CN0_ACK__SHIFT          0x01 ///< SMBus Acknowledge                              
           =2 #define SMB0CN0_ACK__NOT_SET        0x00 ///< Generate a NACK, or the response was a NACK.   
           =2 #define SMB0CN0_ACK__SET            0x02 ///< Generate an ACK, or the response was an ACK.   
           =2                                                                                              
           =2 #define SMB0CN0_ARBLOST__BMASK      0x04 ///< SMBus Arbitration Lost Indicator               
C51 COMPILER V9.56.0.0   SPI_0                                                             10/28/2016 17:37:02 PAGE 138 

           =2 #define SMB0CN0_ARBLOST__SHIFT      0x02 ///< SMBus Arbitration Lost Indicator               
           =2 #define SMB0CN0_ARBLOST__NOT_SET    0x00 ///< No arbitration error.                          
           =2 #define SMB0CN0_ARBLOST__ERROR      0x04 ///< Arbitration error occurred.                    
           =2                                                                                              
           =2 #define SMB0CN0_ACKRQ__BMASK        0x08 ///< SMBus Acknowledge Request                      
           =2 #define SMB0CN0_ACKRQ__SHIFT        0x03 ///< SMBus Acknowledge Request                      
           =2 #define SMB0CN0_ACKRQ__NOT_SET      0x00 ///< No ACK requested.                              
           =2 #define SMB0CN0_ACKRQ__REQUESTED    0x08 ///< ACK requested.                                 
           =2                                                                                              
           =2 #define SMB0CN0_STO__BMASK          0x10 ///< SMBus Stop Flag                                
           =2 #define SMB0CN0_STO__SHIFT          0x04 ///< SMBus Stop Flag                                
           =2 #define SMB0CN0_STO__NOT_SET        0x00 ///< A STOP is not pending.                         
           =2 #define SMB0CN0_STO__SET            0x10 ///< Generate a STOP or a STOP is currently pending.
           =2                                                                                              
           =2 #define SMB0CN0_STA__BMASK          0x20 ///< SMBus Start Flag                               
           =2 #define SMB0CN0_STA__SHIFT          0x05 ///< SMBus Start Flag                               
           =2 #define SMB0CN0_STA__NOT_SET        0x00 ///< A START was not detected.                      
           =2 #define SMB0CN0_STA__SET            0x20 ///< Generate a START, repeated START, or a START is
           =2                                          ///< currently pending.                             
           =2                                                                                              
           =2 #define SMB0CN0_TXMODE__BMASK       0x40 ///< SMBus Transmit Mode Indicator                  
           =2 #define SMB0CN0_TXMODE__SHIFT       0x06 ///< SMBus Transmit Mode Indicator                  
           =2 #define SMB0CN0_TXMODE__RECEIVER    0x00 ///< SMBus in Receiver Mode.                        
           =2 #define SMB0CN0_TXMODE__TRANSMITTER 0x40 ///< SMBus in Transmitter Mode.                     
           =2                                                                                              
           =2 #define SMB0CN0_MASTER__BMASK       0x80 ///< SMBus Master/Slave Indicator                   
           =2 #define SMB0CN0_MASTER__SHIFT       0x07 ///< SMBus Master/Slave Indicator                   
           =2 #define SMB0CN0_MASTER__SLAVE       0x00 ///< SMBus operating in slave mode.                 
           =2 #define SMB0CN0_MASTER__MASTER      0x80 ///< SMBus operating in master mode.                
           =2                                                                                              
           =2 //------------------------------------------------------------------------------
           =2 // SMB0DAT Enums (SMBus 0 Data @ 0xC2)
           =2 //------------------------------------------------------------------------------
           =2 #define SMB0DAT_SMB0DAT__FMASK 0xFF ///< SMBus 0 Data
           =2 #define SMB0DAT_SMB0DAT__SHIFT 0x00 ///< SMBus 0 Data
           =2                                                      
           =2 //------------------------------------------------------------------------------
           =2 // SMB1ADM Enums (SMBus 1 Slave Address Mask @ 0xCE)
           =2 //------------------------------------------------------------------------------
           =2 #define SMB1ADM_EHACK__BMASK             0x01 ///< Hardware Acknowledge Enable                     
           =2 #define SMB1ADM_EHACK__SHIFT             0x00 ///< Hardware Acknowledge Enable                     
           =2 #define SMB1ADM_EHACK__ADR_ACK_MANUAL    0x00 ///< Firmware must manually acknowledge all incoming 
           =2                                               ///< address and data bytes.                         
           =2 #define SMB1ADM_EHACK__ADR_ACK_AUTOMATIC 0x01 ///< Automatic slave address recognition and hardware
           =2                                               ///< acknowledge is enabled.                         
           =2                                                                                                    
           =2 #define SMB1ADM_SLVM__FMASK              0xFE ///< SMBus Slave Address Mask                        
           =2 #define SMB1ADM_SLVM__SHIFT              0x01 ///< SMBus Slave Address Mask                        
           =2                                                                                                    
           =2 //------------------------------------------------------------------------------
           =2 // SMB1ADR Enums (SMBus 1 Slave Address @ 0xCF)
           =2 //------------------------------------------------------------------------------
           =2 #define SMB1ADR_GC__BMASK      0x01 ///< General Call Address Enable        
           =2 #define SMB1ADR_GC__SHIFT      0x00 ///< General Call Address Enable        
           =2 #define SMB1ADR_GC__IGNORED    0x00 ///< General Call Address is ignored.   
           =2 #define SMB1ADR_GC__RECOGNIZED 0x01 ///< General Call Address is recognized.
           =2                                                                             
           =2 #define SMB1ADR_SLV__FMASK     0xFE ///< SMBus Hardware Slave Address       
           =2 #define SMB1ADR_SLV__SHIFT     0x01 ///< SMBus Hardware Slave Address       
           =2                                                                             
           =2 //------------------------------------------------------------------------------
           =2 // SMB1CF Enums (SMBus 1 Configuration @ 0xC1)
C51 COMPILER V9.56.0.0   SPI_0                                                             10/28/2016 17:37:02 PAGE 139 

           =2 //------------------------------------------------------------------------------
           =2 #define SMB1CF_SMBCS__FMASK             0x03 ///< SMBus Clock Source Selection                     
           =2 #define SMB1CF_SMBCS__SHIFT             0x00 ///< SMBus Clock Source Selection                     
           =2 #define SMB1CF_SMBCS__TIMER0            0x00 ///< Timer 0 Overflow.                                
           =2 #define SMB1CF_SMBCS__TIMER5            0x01 ///< Timer 5 Overflow.                                
           =2 #define SMB1CF_SMBCS__TIMER2_HIGH       0x02 ///< Timer 2 High Byte Overflow.                      
           =2 #define SMB1CF_SMBCS__TIMER2_LOW        0x03 ///< Timer 2 Low Byte Overflow.                       
           =2                                                                                                    
           =2 #define SMB1CF_SMBFTE__BMASK            0x04 ///< SMBus Free Timeout Detection Enable              
           =2 #define SMB1CF_SMBFTE__SHIFT            0x02 ///< SMBus Free Timeout Detection Enable              
           =2 #define SMB1CF_SMBFTE__FREE_TO_DISABLED 0x00 ///< Disable bus free timeouts.                       
           =2 #define SMB1CF_SMBFTE__FREE_TO_ENABLED  0x04 ///< Enable bus free timeouts. The bus the bus will be
           =2                                              ///< considered free if SCL and SDA remain high for   
           =2                                              ///< more than 10 SMBus clock source periods.         
           =2                                                                                                    
           =2 #define SMB1CF_SMBTOE__BMASK            0x08 ///< SMBus SCL Timeout Detection Enable               
           =2 #define SMB1CF_SMBTOE__SHIFT            0x03 ///< SMBus SCL Timeout Detection Enable               
           =2 #define SMB1CF_SMBTOE__SCL_TO_DISABLED  0x00 ///< Disable SCL low timeouts.                        
           =2 #define SMB1CF_SMBTOE__SCL_TO_ENABLED   0x08 ///< Enable SCL low timeouts.                         
           =2                                                                                                    
           =2 #define SMB1CF_EXTHOLD__BMASK           0x10 ///< SMBus Setup and Hold Time Extension Enable       
           =2 #define SMB1CF_EXTHOLD__SHIFT           0x04 ///< SMBus Setup and Hold Time Extension Enable       
           =2 #define SMB1CF_EXTHOLD__DISABLED        0x00 ///< Disable SDA extended setup and hold times.       
           =2 #define SMB1CF_EXTHOLD__ENABLED         0x10 ///< Enable SDA extended setup and hold times.        
           =2                                                                                                    
           =2 #define SMB1CF_BUSY__BMASK              0x20 ///< SMBus Busy Indicator                             
           =2 #define SMB1CF_BUSY__SHIFT              0x05 ///< SMBus Busy Indicator                             
           =2 #define SMB1CF_BUSY__NOT_SET            0x00 ///< The bus is not busy.                             
           =2 #define SMB1CF_BUSY__SET                0x20 ///< The bus is busy and a transfer is currently in   
           =2                                              ///< progress.                                        
           =2                                                                                                    
           =2 #define SMB1CF_INH__BMASK               0x40 ///< SMBus Slave Inhibit                              
           =2 #define SMB1CF_INH__SHIFT               0x06 ///< SMBus Slave Inhibit                              
           =2 #define SMB1CF_INH__SLAVE_ENABLED       0x00 ///< Slave states are enabled.                        
           =2 #define SMB1CF_INH__SLAVE_DISABLED      0x40 ///< Slave states are inhibited.                      
           =2                                                                                                    
           =2 #define SMB1CF_ENSMB__BMASK             0x80 ///< SMBus Enable                                     
           =2 #define SMB1CF_ENSMB__SHIFT             0x07 ///< SMBus Enable                                     
           =2 #define SMB1CF_ENSMB__DISABLED          0x00 ///< Disable the SMBus module.                        
           =2 #define SMB1CF_ENSMB__ENABLED           0x80 ///< Enable the SMBus module.                         
           =2                                                                                                    
           =2 //------------------------------------------------------------------------------
           =2 // SMB1CN0 Enums (SMBus 1 Control @ 0xC0)
           =2 //------------------------------------------------------------------------------
           =2 #define SMB1CN0_SI__BMASK           0x01 ///< SMBus Interrupt Flag                           
           =2 #define SMB1CN0_SI__SHIFT           0x00 ///< SMBus Interrupt Flag                           
           =2 #define SMB1CN0_SI__NOT_SET         0x00 ///<                                                
           =2 #define SMB1CN0_SI__SET             0x01 ///<                                                
           =2                                                                                              
           =2 #define SMB1CN0_ACK__BMASK          0x02 ///< SMBus Acknowledge                              
           =2 #define SMB1CN0_ACK__SHIFT          0x01 ///< SMBus Acknowledge                              
           =2 #define SMB1CN0_ACK__NOT_SET        0x00 ///< Generate a NACK, or the response was a NACK.   
           =2 #define SMB1CN0_ACK__SET            0x02 ///< Generate an ACK, or the response was an ACK.   
           =2                                                                                              
           =2 #define SMB1CN0_ARBLOST__BMASK      0x04 ///< SMBus Arbitration Lost Indicator               
           =2 #define SMB1CN0_ARBLOST__SHIFT      0x02 ///< SMBus Arbitration Lost Indicator               
           =2 #define SMB1CN0_ARBLOST__NOT_SET    0x00 ///< No arbitration error.                          
           =2 #define SMB1CN0_ARBLOST__ERROR      0x04 ///< Arbitration error occurred.                    
           =2                                                                                              
           =2 #define SMB1CN0_ACKRQ__BMASK        0x08 ///< SMBus Acknowledge Request                      
           =2 #define SMB1CN0_ACKRQ__SHIFT        0x03 ///< SMBus Acknowledge Request                      
           =2 #define SMB1CN0_ACKRQ__NOT_SET      0x00 ///< No ACK requested.                              
C51 COMPILER V9.56.0.0   SPI_0                                                             10/28/2016 17:37:02 PAGE 140 

           =2 #define SMB1CN0_ACKRQ__REQUESTED    0x08 ///< ACK requested.                                 
           =2                                                                                              
           =2 #define SMB1CN0_STO__BMASK          0x10 ///< SMBus Stop Flag                                
           =2 #define SMB1CN0_STO__SHIFT          0x04 ///< SMBus Stop Flag                                
           =2 #define SMB1CN0_STO__NOT_SET        0x00 ///< A STOP is not pending.                         
           =2 #define SMB1CN0_STO__SET            0x10 ///< Generate a STOP or a STOP is currently pending.
           =2                                                                                              
           =2 #define SMB1CN0_STA__BMASK          0x20 ///< SMBus Start Flag                               
           =2 #define SMB1CN0_STA__SHIFT          0x05 ///< SMBus Start Flag                               
           =2 #define SMB1CN0_STA__NOT_SET        0x00 ///< A START was not detected.                      
           =2 #define SMB1CN0_STA__SET            0x20 ///< Generate a START, repeated START, or a START is
           =2                                          ///< currently pending.                             
           =2                                                                                              
           =2 #define SMB1CN0_TXMODE__BMASK       0x40 ///< SMBus Transmit Mode Indicator                  
           =2 #define SMB1CN0_TXMODE__SHIFT       0x06 ///< SMBus Transmit Mode Indicator                  
           =2 #define SMB1CN0_TXMODE__RECEIVER    0x00 ///< SMBus in Receiver Mode.                        
           =2 #define SMB1CN0_TXMODE__TRANSMITTER 0x40 ///< SMBus in Transmitter Mode.                     
           =2                                                                                              
           =2 #define SMB1CN0_MASTER__BMASK       0x80 ///< SMBus Master/Slave Indicator                   
           =2 #define SMB1CN0_MASTER__SHIFT       0x07 ///< SMBus Master/Slave Indicator                   
           =2 #define SMB1CN0_MASTER__SLAVE       0x00 ///< SMBus operating in slave mode.                 
           =2 #define SMB1CN0_MASTER__MASTER      0x80 ///< SMBus operating in master mode.                
           =2                                                                                              
           =2 //------------------------------------------------------------------------------
           =2 // SMB1DAT Enums (SMBus 1 Data @ 0xC2)
           =2 //------------------------------------------------------------------------------
           =2 #define SMB1DAT_SMB1DAT__FMASK 0xFF ///< SMBus 1 Data
           =2 #define SMB1DAT_SMB1DAT__SHIFT 0x00 ///< SMBus 1 Data
           =2                                                      
           =2 //------------------------------------------------------------------------------
           =2 // SMBTC Enums (SMBus Timing and Pin Control @ 0xB9)
           =2 //------------------------------------------------------------------------------
           =2 #define SMBTC_SMB0SDD__FMASK         0x03 ///< SMBus 0 Start Detection Window                   
           =2 #define SMBTC_SMB0SDD__SHIFT         0x00 ///< SMBus 0 Start Detection Window                   
           =2 #define SMBTC_SMB0SDD__NONE          0x00 ///< No additional hold time window (0-1 SYSCLK).     
           =2 #define SMBTC_SMB0SDD__ADD_2_SYSCLKS 0x01 ///< Increase hold time window to 2-3 SYSCLKs.        
           =2 #define SMBTC_SMB0SDD__ADD_4_SYSCLKS 0x02 ///< Increase hold time window to 4-5 SYSCLKs.        
           =2 #define SMBTC_SMB0SDD__ADD_8_SYSCLKS 0x03 ///< Increase hold time window to 8-9 SYSCLKs.        
           =2                                                                                                 
           =2 #define SMBTC_SMB1SDD__FMASK         0x0C ///< SMBus 1 Start Detection Window                   
           =2 #define SMBTC_SMB1SDD__SHIFT         0x02 ///< SMBus 1 Start Detection Window                   
           =2 #define SMBTC_SMB1SDD__NONE          0x00 ///< No additional hold time requirement (0-1 SYSCLK).
           =2 #define SMBTC_SMB1SDD__ADD_2_SYSCLKS 0x04 ///< Increase hold time window to 2-3 SYSCLKs.        
           =2 #define SMBTC_SMB1SDD__ADD_4_SYSCLKS 0x08 ///< Increase hold time window to 4-5 SYSCLKs.        
           =2 #define SMBTC_SMB1SDD__ADD_8_SYSCLKS 0x0C ///< Increase hold time window to 8-9 SYSCLKs.        
           =2                                                                                                 
           =2 //------------------------------------------------------------------------------
           =2 // SPI0CFG Enums (SPI0 Configuration @ 0xA1)
           =2 //------------------------------------------------------------------------------
           =2 #define SPI0CFG_RXBMT__BMASK                0x01 ///< Receive Buffer Empty                              
           =2 #define SPI0CFG_RXBMT__SHIFT                0x00 ///< Receive Buffer Empty                              
           =2 #define SPI0CFG_RXBMT__NOT_SET              0x00 ///< New data is available in the receive buffer (Slave
           =2                                                  ///< mode).                                            
           =2 #define SPI0CFG_RXBMT__SET                  0x01 ///< No new data in the receive buffer (Slave mode).   
           =2                                                                                                         
           =2 #define SPI0CFG_SRMT__BMASK                 0x02 ///< Shift Register Empty                              
           =2 #define SPI0CFG_SRMT__SHIFT                 0x01 ///< Shift Register Empty                              
           =2 #define SPI0CFG_SRMT__NOT_SET               0x00 ///< The shift register is not empty.                  
           =2 #define SPI0CFG_SRMT__SET                   0x02 ///< The shift register is empty.                      
           =2                                                                                                         
           =2 #define SPI0CFG_NSSIN__BMASK                0x04 ///< NSS Instantaneous Pin Input                       
           =2 #define SPI0CFG_NSSIN__SHIFT                0x02 ///< NSS Instantaneous Pin Input                       
C51 COMPILER V9.56.0.0   SPI_0                                                             10/28/2016 17:37:02 PAGE 141 

           =2 #define SPI0CFG_NSSIN__LOW                  0x00 ///< The NSS pin is low.                               
           =2 #define SPI0CFG_NSSIN__HIGH                 0x04 ///< The NSS pin is high.                              
           =2                                                                                                         
           =2 #define SPI0CFG_SLVSEL__BMASK               0x08 ///< Slave Selected Flag                               
           =2 #define SPI0CFG_SLVSEL__SHIFT               0x03 ///< Slave Selected Flag                               
           =2 #define SPI0CFG_SLVSEL__NOT_SELECTED        0x00 ///< The Slave is not selected (NSS is high).          
           =2 #define SPI0CFG_SLVSEL__SELECTED            0x08 ///< The Slave is selected (NSS is low).               
           =2                                                                                                         
           =2 #define SPI0CFG_CKPOL__BMASK                0x10 ///< SPI0 Clock Polarity                               
           =2 #define SPI0CFG_CKPOL__SHIFT                0x04 ///< SPI0 Clock Polarity                               
           =2 #define SPI0CFG_CKPOL__IDLE_LOW             0x00 ///< SCK line low in idle state.                       
           =2 #define SPI0CFG_CKPOL__IDLE_HIGH            0x10 ///< SCK line high in idle state.                      
           =2                                                                                                         
           =2 #define SPI0CFG_CKPHA__BMASK                0x20 ///< SPI0 Clock Phase                                  
           =2 #define SPI0CFG_CKPHA__SHIFT                0x05 ///< SPI0 Clock Phase                                  
           =2 #define SPI0CFG_CKPHA__DATA_CENTERED_FIRST  0x00 ///< Data centered on first edge of SCK period.        
           =2 #define SPI0CFG_CKPHA__DATA_CENTERED_SECOND 0x20 ///< Data centered on second edge of SCK period.       
           =2                                                                                                         
           =2 #define SPI0CFG_MSTEN__BMASK                0x40 ///< Master Mode Enable                                
           =2 #define SPI0CFG_MSTEN__SHIFT                0x06 ///< Master Mode Enable                                
           =2 #define SPI0CFG_MSTEN__MASTER_DISABLED      0x00 ///< Disable master mode. Operate in slave mode.       
           =2 #define SPI0CFG_MSTEN__MASTER_ENABLED       0x40 ///< Enable master mode. Operate as a master.          
           =2                                                                                                         
           =2 #define SPI0CFG_SPIBSY__BMASK               0x80 ///< SPI Busy                                          
           =2 #define SPI0CFG_SPIBSY__SHIFT               0x07 ///< SPI Busy                                          
           =2 #define SPI0CFG_SPIBSY__NOT_SET             0x00 ///< A SPI transfer is not in progress.                
           =2 #define SPI0CFG_SPIBSY__SET                 0x80 ///< A SPI transfer is in progress.                    
           =2                                                                                                         
           =2 //------------------------------------------------------------------------------
           =2 // SPI0CKR Enums (SPI0 Clock Rate @ 0xA2)
           =2 //------------------------------------------------------------------------------
           =2 #define SPI0CKR_SPI0CKR__FMASK 0xFF ///< SPI0 Clock Rate
           =2 #define SPI0CKR_SPI0CKR__SHIFT 0x00 ///< SPI0 Clock Rate
           =2                                                         
           =2 //------------------------------------------------------------------------------
           =2 // SPI0CN0 Enums (SPI0 Control @ 0xF8)
           =2 //------------------------------------------------------------------------------
           =2 #define SPI0CN0_SPIEN__BMASK                  0x01 ///< SPI0 Enable                                       
           =2 #define SPI0CN0_SPIEN__SHIFT                  0x00 ///< SPI0 Enable                                       
           =2 #define SPI0CN0_SPIEN__DISABLED               0x00 ///< Disable the SPI module.                           
           =2 #define SPI0CN0_SPIEN__ENABLED                0x01 ///< Enable the SPI module.                            
           =2                                                                                                           
           =2 #define SPI0CN0_TXBMT__BMASK                  0x02 ///< Transmit Buffer Empty                             
           =2 #define SPI0CN0_TXBMT__SHIFT                  0x01 ///< Transmit Buffer Empty                             
           =2 #define SPI0CN0_TXBMT__NOT_SET                0x00 ///< The transmit buffer is not empty.                 
           =2 #define SPI0CN0_TXBMT__SET                    0x02 ///< The transmit buffer is empty.                     
           =2                                                                                                           
           =2 #define SPI0CN0_NSSMD__FMASK                  0x0C ///< Slave Select Mode                                 
           =2 #define SPI0CN0_NSSMD__SHIFT                  0x02 ///< Slave Select Mode                                 
           =2 #define SPI0CN0_NSSMD__3_WIRE                 0x00 ///< 3-Wire Slave or 3-Wire Master Mode. NSS signal is 
           =2                                                    ///< not routed to a port pin.                         
           =2 #define SPI0CN0_NSSMD__4_WIRE_SLAVE           0x04 ///< 4-Wire Slave or Multi-Master Mode. NSS is an input
           =2                                                    ///< to the device.                                    
           =2 #define SPI0CN0_NSSMD__4_WIRE_MASTER_NSS_LOW  0x08 ///< 4-Wire Single-Master Mode. NSS is an output and   
           =2                                                    ///< logic low.                                        
           =2 #define SPI0CN0_NSSMD__4_WIRE_MASTER_NSS_HIGH 0x0C ///< 4-Wire Single-Master Mode. NSS is an output and   
           =2                                                    ///< logic high.                                       
           =2                                                                                                           
           =2 #define SPI0CN0_RXOVRN__BMASK                 0x10 ///< Receive Overrun Flag                              
           =2 #define SPI0CN0_RXOVRN__SHIFT                 0x04 ///< Receive Overrun Flag                              
           =2 #define SPI0CN0_RXOVRN__NOT_SET               0x00 ///< A receive overrun did not occur.                  
           =2 #define SPI0CN0_RXOVRN__SET                   0x10 ///< A receive overrun occurred.                       
C51 COMPILER V9.56.0.0   SPI_0                                                             10/28/2016 17:37:02 PAGE 142 

           =2                                                                                                           
           =2 #define SPI0CN0_MODF__BMASK                   0x20 ///< Mode Fault Flag                                   
           =2 #define SPI0CN0_MODF__SHIFT                   0x05 ///< Mode Fault Flag                                   
           =2 #define SPI0CN0_MODF__NOT_SET                 0x00 ///< A master collision did not occur.                 
           =2 #define SPI0CN0_MODF__SET                     0x20 ///< A master collision occurred.                      
           =2                                                                                                           
           =2 #define SPI0CN0_WCOL__BMASK                   0x40 ///< Write Collision Flag                              
           =2 #define SPI0CN0_WCOL__SHIFT                   0x06 ///< Write Collision Flag                              
           =2 #define SPI0CN0_WCOL__NOT_SET                 0x00 ///< A write collision did not occur.                  
           =2 #define SPI0CN0_WCOL__SET                     0x40 ///< A write collision occurred.                       
           =2                                                                                                           
           =2 #define SPI0CN0_SPIF__BMASK                   0x80 ///< SPI0 Interrupt Flag                               
           =2 #define SPI0CN0_SPIF__SHIFT                   0x07 ///< SPI0 Interrupt Flag                               
           =2 #define SPI0CN0_SPIF__NOT_SET                 0x00 ///< A data transfer has not completed since the last  
           =2                                                    ///< time SPIF was cleared.                            
           =2 #define SPI0CN0_SPIF__SET                     0x80 ///< A data transfer completed.                        
           =2                                                                                                           
           =2 //------------------------------------------------------------------------------
           =2 // SPI0DAT Enums (SPI0 Data @ 0xA3)
           =2 //------------------------------------------------------------------------------
           =2 #define SPI0DAT_SPI0DAT__FMASK 0xFF ///< SPI0 Transmit and Receive Data
           =2 #define SPI0DAT_SPI0DAT__SHIFT 0x00 ///< SPI0 Transmit and Receive Data
           =2                                                                        
           =2 //------------------------------------------------------------------------------
           =2 // TH0 Enums (Timer 0 High Byte @ 0x8C)
           =2 //------------------------------------------------------------------------------
           =2 #define TH0_TH0__FMASK 0xFF ///< Timer 0 High Byte
           =2 #define TH0_TH0__SHIFT 0x00 ///< Timer 0 High Byte
           =2                                                   
           =2 //------------------------------------------------------------------------------
           =2 // TH1 Enums (Timer 1 High Byte @ 0x8D)
           =2 //------------------------------------------------------------------------------
           =2 #define TH1_TH1__FMASK 0xFF ///< Timer 1 High Byte
           =2 #define TH1_TH1__SHIFT 0x00 ///< Timer 1 High Byte
           =2                                                   
           =2 //------------------------------------------------------------------------------
           =2 // TL0 Enums (Timer 0 Low Byte @ 0x8A)
           =2 //------------------------------------------------------------------------------
           =2 #define TL0_TL0__FMASK 0xFF ///< Timer 0 Low Byte
           =2 #define TL0_TL0__SHIFT 0x00 ///< Timer 0 Low Byte
           =2                                                  
           =2 //------------------------------------------------------------------------------
           =2 // TL1 Enums (Timer 1 Low Byte @ 0x8B)
           =2 //------------------------------------------------------------------------------
           =2 #define TL1_TL1__FMASK 0xFF ///< Timer 1 Low Byte
           =2 #define TL1_TL1__SHIFT 0x00 ///< Timer 1 Low Byte
           =2                                                  
           =2 //------------------------------------------------------------------------------
           =2 // TMR2CN0 Enums (Timer 2 Control 0 @ 0xC8)
           =2 //------------------------------------------------------------------------------
           =2 #define TMR2CN0_T2XCLK__BMASK          0x01 ///< Timer 2 External Clock Select                    
           =2 #define TMR2CN0_T2XCLK__SHIFT          0x00 ///< Timer 2 External Clock Select                    
           =2 #define TMR2CN0_T2XCLK__SYSCLK_DIV_12  0x00 ///< Timer 2 clock is the system clock divided by 12. 
           =2 #define TMR2CN0_T2XCLK__EXTOSC_DIV_8   0x01 ///< Timer 2 clock is the external oscillator divided 
           =2                                             ///< by 8 (synchronized with SYSCLK).                 
           =2                                                                                                   
           =2 #define TMR2CN0_T2CSS__BMASK           0x02 ///< Timer 2 Capture Source Select                    
           =2 #define TMR2CN0_T2CSS__SHIFT           0x01 ///< Timer 2 Capture Source Select                    
           =2 #define TMR2CN0_T2CSS__USB_SOF_CAPTURE 0x00 ///< Capture source is USB SOF event.                 
           =2 #define TMR2CN0_T2CSS__LFOSC_CAPTURE   0x02 ///< Capture source is falling edge of Low-Frequency  
           =2                                             ///< Oscillator.                                      
           =2                                                                                                   
C51 COMPILER V9.56.0.0   SPI_0                                                             10/28/2016 17:37:02 PAGE 143 

           =2 #define TMR2CN0_TR2__BMASK             0x04 ///< Timer 2 Run Control                              
           =2 #define TMR2CN0_TR2__SHIFT             0x02 ///< Timer 2 Run Control                              
           =2 #define TMR2CN0_TR2__STOP              0x00 ///< Stop Timer 2.                                    
           =2 #define TMR2CN0_TR2__RUN               0x04 ///< Start Timer 2 running.                           
           =2                                                                                                   
           =2 #define TMR2CN0_T2SPLIT__BMASK         0x08 ///< Timer 2 Split Mode Enable                        
           =2 #define TMR2CN0_T2SPLIT__SHIFT         0x03 ///< Timer 2 Split Mode Enable                        
           =2 #define TMR2CN0_T2SPLIT__16_BIT_RELOAD 0x00 ///< Timer 2 operates in 16-bit auto-reload mode.     
           =2 #define TMR2CN0_T2SPLIT__8_BIT_RELOAD  0x08 ///< Timer 2 operates as two 8-bit auto-reload timers.
           =2                                                                                                   
           =2 #define TMR2CN0_TF2CEN__BMASK          0x10 ///< Timer 2 Capture Enable                           
           =2 #define TMR2CN0_TF2CEN__SHIFT          0x04 ///< Timer 2 Capture Enable                           
           =2 #define TMR2CN0_TF2CEN__DISABLED       0x00 ///< Disable capture mode.                            
           =2 #define TMR2CN0_TF2CEN__ENABLED        0x10 ///< Enable capture mode.                             
           =2                                                                                                   
           =2 #define TMR2CN0_TF2LEN__BMASK          0x20 ///< Timer 2 Low Byte Interrupt Enable                
           =2 #define TMR2CN0_TF2LEN__SHIFT          0x05 ///< Timer 2 Low Byte Interrupt Enable                
           =2 #define TMR2CN0_TF2LEN__DISABLED       0x00 ///< Disable low byte interrupts.                     
           =2 #define TMR2CN0_TF2LEN__ENABLED        0x20 ///< Enable low byte interrupts.                      
           =2                                                                                                   
           =2 #define TMR2CN0_TF2L__BMASK            0x40 ///< Timer 2 Low Byte Overflow Flag                   
           =2 #define TMR2CN0_TF2L__SHIFT            0x06 ///< Timer 2 Low Byte Overflow Flag                   
           =2 #define TMR2CN0_TF2L__NOT_SET          0x00 ///< Timer 2 low byte did not overflow.               
           =2 #define TMR2CN0_TF2L__SET              0x40 ///< Timer 2 low byte overflowed.                     
           =2                                                                                                   
           =2 #define TMR2CN0_TF2H__BMASK            0x80 ///< Timer 2 High Byte Overflow Flag                  
           =2 #define TMR2CN0_TF2H__SHIFT            0x07 ///< Timer 2 High Byte Overflow Flag                  
           =2 #define TMR2CN0_TF2H__NOT_SET          0x00 ///< Timer 2 8-bit high byte or 16-bit value did not  
           =2                                             ///< overflow.                                        
           =2 #define TMR2CN0_TF2H__SET              0x80 ///< Timer 2 8-bit high byte or 16-bit value          
           =2                                             ///< overflowed.                                      
           =2                                                                                                   
           =2 //------------------------------------------------------------------------------
           =2 // TMR2H Enums (Timer 2 High Byte @ 0xCD)
           =2 //------------------------------------------------------------------------------
           =2 #define TMR2H_TMR2H__FMASK 0xFF ///< Timer 2 High Byte
           =2 #define TMR2H_TMR2H__SHIFT 0x00 ///< Timer 2 High Byte
           =2                                                       
           =2 //------------------------------------------------------------------------------
           =2 // TMR2L Enums (Timer 2 Low Byte @ 0xCC)
           =2 //------------------------------------------------------------------------------
           =2 #define TMR2L_TMR2L__FMASK 0xFF ///< Timer 2 Low Byte
           =2 #define TMR2L_TMR2L__SHIFT 0x00 ///< Timer 2 Low Byte
           =2                                                      
           =2 //------------------------------------------------------------------------------
           =2 // TMR2RLH Enums (Timer 2 Reload High Byte @ 0xCB)
           =2 //------------------------------------------------------------------------------
           =2 #define TMR2RLH_TMR2RLH__FMASK 0xFF ///< Timer 2 Reload High Byte
           =2 #define TMR2RLH_TMR2RLH__SHIFT 0x00 ///< Timer 2 Reload High Byte
           =2                                                                  
           =2 //------------------------------------------------------------------------------
           =2 // TMR2RLL Enums (Timer 2 Reload Low Byte @ 0xCA)
           =2 //------------------------------------------------------------------------------
           =2 #define TMR2RLL_TMR2RLL__FMASK 0xFF ///< Timer 2 Reload Low Byte
           =2 #define TMR2RLL_TMR2RLL__SHIFT 0x00 ///< Timer 2 Reload Low Byte
           =2                                                                 
           =2 //------------------------------------------------------------------------------
           =2 // TMR3CN0 Enums (Timer 3 Control 0 @ 0x91)
           =2 //------------------------------------------------------------------------------
           =2 #define TMR3CN0_T3XCLK__BMASK          0x01 ///< Timer 3 External Clock Select                    
           =2 #define TMR3CN0_T3XCLK__SHIFT          0x00 ///< Timer 3 External Clock Select                    
           =2 #define TMR3CN0_T3XCLK__SYSCLK_DIV_12  0x00 ///< Timer 3 clock is the system clock divided by 12. 
C51 COMPILER V9.56.0.0   SPI_0                                                             10/28/2016 17:37:02 PAGE 144 

           =2 #define TMR3CN0_T3XCLK__EXTOSC_DIV_8   0x01 ///< Timer 3 clock is the external oscillator divided 
           =2                                             ///< by 8 (synchronized with SYSCLK).                 
           =2                                                                                                   
           =2 #define TMR3CN0_T3CSS__BMASK           0x02 ///< Timer 3 Capture Source Select                    
           =2 #define TMR3CN0_T3CSS__SHIFT           0x01 ///< Timer 3 Capture Source Select                    
           =2 #define TMR3CN0_T3CSS__USB_SOF_CAPTURE 0x00 ///< Capture source is USB SOF event.                 
           =2 #define TMR3CN0_T3CSS__LFOSC_CAPTURE   0x02 ///< Capture source is falling edge of Low-Frequency  
           =2                                             ///< Oscillator.                                      
           =2                                                                                                   
           =2 #define TMR3CN0_TR3__BMASK             0x04 ///< Timer 3 Run Control                              
           =2 #define TMR3CN0_TR3__SHIFT             0x02 ///< Timer 3 Run Control                              
           =2 #define TMR3CN0_TR3__STOP              0x00 ///< Stop Timer 3.                                    
           =2 #define TMR3CN0_TR3__RUN               0x04 ///< Start Timer 3 running.                           
           =2                                                                                                   
           =2 #define TMR3CN0_T3SPLIT__BMASK         0x08 ///< Timer 3 Split Mode Enable                        
           =2 #define TMR3CN0_T3SPLIT__SHIFT         0x03 ///< Timer 3 Split Mode Enable                        
           =2 #define TMR3CN0_T3SPLIT__16_BIT_RELOAD 0x00 ///< Timer 3 operates in 16-bit auto-reload mode.     
           =2 #define TMR3CN0_T3SPLIT__8_BIT_RELOAD  0x08 ///< Timer 3 operates as two 8-bit auto-reload timers.
           =2                                                                                                   
           =2 #define TMR3CN0_TF3CEN__BMASK          0x10 ///< Timer 3 Capture Enable                           
           =2 #define TMR3CN0_TF3CEN__SHIFT          0x04 ///< Timer 3 Capture Enable                           
           =2 #define TMR3CN0_TF3CEN__DISABLED       0x00 ///< Disable capture mode.                            
           =2 #define TMR3CN0_TF3CEN__ENABLED        0x10 ///< Enable capture mode.                             
           =2                                                                                                   
           =2 #define TMR3CN0_TF3LEN__BMASK          0x20 ///< Timer 3 Low Byte Interrupt Enable                
           =2 #define TMR3CN0_TF3LEN__SHIFT          0x05 ///< Timer 3 Low Byte Interrupt Enable                
           =2 #define TMR3CN0_TF3LEN__DISABLED       0x00 ///< Disable low byte interrupts.                     
           =2 #define TMR3CN0_TF3LEN__ENABLED        0x20 ///< Enable low byte interrupts.                      
           =2                                                                                                   
           =2 #define TMR3CN0_TF3L__BMASK            0x40 ///< Timer 3 Low Byte Overflow Flag                   
           =2 #define TMR3CN0_TF3L__SHIFT            0x06 ///< Timer 3 Low Byte Overflow Flag                   
           =2 #define TMR3CN0_TF3L__NOT_SET          0x00 ///< Timer 3 low byte did not overflow.               
           =2 #define TMR3CN0_TF3L__SET              0x40 ///< Timer 3 low byte overflowed.                     
           =2                                                                                                   
           =2 #define TMR3CN0_TF3H__BMASK            0x80 ///< Timer 3 High Byte Overflow Flag                  
           =2 #define TMR3CN0_TF3H__SHIFT            0x07 ///< Timer 3 High Byte Overflow Flag                  
           =2 #define TMR3CN0_TF3H__NOT_SET          0x00 ///< Timer 3 8-bit high byte or 16-bit value did not  
           =2                                             ///< overflow.                                        
           =2 #define TMR3CN0_TF3H__SET              0x80 ///< Timer 3 8-bit high byte or 16-bit value          
           =2                                             ///< overflowed.                                      
           =2                                                                                                   
           =2 //------------------------------------------------------------------------------
           =2 // TMR3H Enums (Timer 3 High Byte @ 0x95)
           =2 //------------------------------------------------------------------------------
           =2 #define TMR3H_TMR3H__FMASK 0xFF ///< Timer 3 High Byte
           =2 #define TMR3H_TMR3H__SHIFT 0x00 ///< Timer 3 High Byte
           =2                                                       
           =2 //------------------------------------------------------------------------------
           =2 // TMR3L Enums (Timer 3 Low Byte @ 0x94)
           =2 //------------------------------------------------------------------------------
           =2 #define TMR3L_TMR3L__FMASK 0xFF ///< Timer 3 Low Byte
           =2 #define TMR3L_TMR3L__SHIFT 0x00 ///< Timer 3 Low Byte
           =2                                                      
           =2 //------------------------------------------------------------------------------
           =2 // TMR3RLH Enums (Timer 3 Reload High Byte @ 0x93)
           =2 //------------------------------------------------------------------------------
           =2 #define TMR3RLH_TMR3RLH__FMASK 0xFF ///< Timer 3 Reload High Byte
           =2 #define TMR3RLH_TMR3RLH__SHIFT 0x00 ///< Timer 3 Reload High Byte
           =2                                                                  
           =2 //------------------------------------------------------------------------------
           =2 // TMR3RLL Enums (Timer 3 Reload Low Byte @ 0x92)
           =2 //------------------------------------------------------------------------------
C51 COMPILER V9.56.0.0   SPI_0                                                             10/28/2016 17:37:02 PAGE 145 

           =2 #define TMR3RLL_TMR3RLL__FMASK 0xFF ///< Timer 3 Reload Low Byte
           =2 #define TMR3RLL_TMR3RLL__SHIFT 0x00 ///< Timer 3 Reload Low Byte
           =2                                                                 
           =2 //------------------------------------------------------------------------------
           =2 // TMR4CN0 Enums (Timer 4 Control 0 @ 0x91)
           =2 //------------------------------------------------------------------------------
           =2 #define TMR4CN0_T4XCLK__BMASK          0x01 ///< Timer 4 External Clock Select                    
           =2 #define TMR4CN0_T4XCLK__SHIFT          0x00 ///< Timer 4 External Clock Select                    
           =2 #define TMR4CN0_T4XCLK__SYSCLK_DIV_12  0x00 ///< Timer 4 clock is the system clock divided by 12. 
           =2 #define TMR4CN0_T4XCLK__EXTOSC_DIV_8   0x01 ///< Timer 4 clock is the external oscillator divided 
           =2                                             ///< by 8 (synchronized with SYSCLK).                 
           =2                                                                                                   
           =2 #define TMR4CN0_TR4__BMASK             0x04 ///< Timer 4 Run Control                              
           =2 #define TMR4CN0_TR4__SHIFT             0x02 ///< Timer 4 Run Control                              
           =2 #define TMR4CN0_TR4__STOP              0x00 ///< Stop Timer 4.                                    
           =2 #define TMR4CN0_TR4__RUN               0x04 ///< Start Timer 4 running.                           
           =2                                                                                                   
           =2 #define TMR4CN0_T4SPLIT__BMASK         0x08 ///< Timer 4 Split Mode Enable                        
           =2 #define TMR4CN0_T4SPLIT__SHIFT         0x03 ///< Timer 4 Split Mode Enable                        
           =2 #define TMR4CN0_T4SPLIT__16_BIT_RELOAD 0x00 ///< Timer 4 operates in 16-bit auto-reload mode.     
           =2 #define TMR4CN0_T4SPLIT__8_BIT_RELOAD  0x08 ///< Timer 4 operates as two 8-bit auto-reload timers.
           =2                                                                                                   
           =2 #define TMR4CN0_TF4LEN__BMASK          0x20 ///< Timer 4 Low Byte Interrupt Enable                
           =2 #define TMR4CN0_TF4LEN__SHIFT          0x05 ///< Timer 4 Low Byte Interrupt Enable                
           =2 #define TMR4CN0_TF4LEN__DISABLED       0x00 ///< Disable low byte interrupts.                     
           =2 #define TMR4CN0_TF4LEN__ENABLED        0x20 ///< Enable low byte interrupts.                      
           =2                                                                                                   
           =2 #define TMR4CN0_TF4L__BMASK            0x40 ///< Timer 4 Low Byte Overflow Flag                   
           =2 #define TMR4CN0_TF4L__SHIFT            0x06 ///< Timer 4 Low Byte Overflow Flag                   
           =2 #define TMR4CN0_TF4L__NOT_SET          0x00 ///< Timer 4 low byte did not overflow.               
           =2 #define TMR4CN0_TF4L__SET              0x40 ///< Timer 4 low byte overflowed.                     
           =2                                                                                                   
           =2 #define TMR4CN0_TF4H__BMASK            0x80 ///< Timer 4 High Byte Overflow Flag                  
           =2 #define TMR4CN0_TF4H__SHIFT            0x07 ///< Timer 4 High Byte Overflow Flag                  
           =2 #define TMR4CN0_TF4H__NOT_SET          0x00 ///< Timer 4 8-bit high byte or 16-bit value did not  
           =2                                             ///< overflow.                                        
           =2 #define TMR4CN0_TF4H__SET              0x80 ///< Timer 4 8-bit high byte or 16-bit value          
           =2                                             ///< overflowed.                                      
           =2                                                                                                   
           =2 //------------------------------------------------------------------------------
           =2 // TMR4H Enums (Timer 4 High Byte @ 0x95)
           =2 //------------------------------------------------------------------------------
           =2 #define TMR4H_TMR4H__FMASK 0xFF ///< Timer 4 High Byte
           =2 #define TMR4H_TMR4H__SHIFT 0x00 ///< Timer 4 High Byte
           =2                                                       
           =2 //------------------------------------------------------------------------------
           =2 // TMR4L Enums (Timer 4 Low Byte @ 0x94)
           =2 //------------------------------------------------------------------------------
           =2 #define TMR4L_TMR4L__FMASK 0xFF ///< Timer 4 Low Byte
           =2 #define TMR4L_TMR4L__SHIFT 0x00 ///< Timer 4 Low Byte
           =2                                                      
           =2 //------------------------------------------------------------------------------
           =2 // TMR4RLH Enums (Timer 4 Reload High Byte @ 0x93)
           =2 //------------------------------------------------------------------------------
           =2 #define TMR4RLH_TMR4RLH__FMASK 0xFF ///< Timer 4 Reload High Byte
           =2 #define TMR4RLH_TMR4RLH__SHIFT 0x00 ///< Timer 4 Reload High Byte
           =2                                                                  
           =2 //------------------------------------------------------------------------------
           =2 // TMR4RLL Enums (Timer 4 Reload Low Byte @ 0x92)
           =2 //------------------------------------------------------------------------------
           =2 #define TMR4RLL_TMR4RLL__FMASK 0xFF ///< Timer 4 Reload Low Byte
           =2 #define TMR4RLL_TMR4RLL__SHIFT 0x00 ///< Timer 4 Reload Low Byte
C51 COMPILER V9.56.0.0   SPI_0                                                             10/28/2016 17:37:02 PAGE 146 

           =2                                                                 
           =2 //------------------------------------------------------------------------------
           =2 // TMR5CN0 Enums (Timer 5 Control 0 @ 0xC8)
           =2 //------------------------------------------------------------------------------
           =2 #define TMR5CN0_T5XCLK__BMASK          0x01 ///< Timer 5 External Clock Select                    
           =2 #define TMR5CN0_T5XCLK__SHIFT          0x00 ///< Timer 5 External Clock Select                    
           =2 #define TMR5CN0_T5XCLK__SYSCLK_DIV_12  0x00 ///< Timer 5 clock is the system clock divided by 12. 
           =2 #define TMR5CN0_T5XCLK__EXTOSC_DIV_8   0x01 ///< Timer 5 clock is the external oscillator divided 
           =2                                             ///< by 8 (synchronized with SYSCLK).                 
           =2                                                                                                   
           =2 #define TMR5CN0_TR5__BMASK             0x04 ///< Timer 5 Run Control                              
           =2 #define TMR5CN0_TR5__SHIFT             0x02 ///< Timer 5 Run Control                              
           =2 #define TMR5CN0_TR5__STOP              0x00 ///< Stop Timer 5.                                    
           =2 #define TMR5CN0_TR5__RUN               0x04 ///< Start Timer 5 running.                           
           =2                                                                                                   
           =2 #define TMR5CN0_T5SPLIT__BMASK         0x08 ///< Timer 5 Split Mode Enable                        
           =2 #define TMR5CN0_T5SPLIT__SHIFT         0x03 ///< Timer 5 Split Mode Enable                        
           =2 #define TMR5CN0_T5SPLIT__16_BIT_RELOAD 0x00 ///< Timer 5 operates in 16-bit auto-reload mode.     
           =2 #define TMR5CN0_T5SPLIT__8_BIT_RELOAD  0x08 ///< Timer 5 operates as two 8-bit auto-reload timers.
           =2                                                                                                   
           =2 #define TMR5CN0_TF5LEN__BMASK          0x20 ///< Timer 5 Low Byte Interrupt Enable                
           =2 #define TMR5CN0_TF5LEN__SHIFT          0x05 ///< Timer 5 Low Byte Interrupt Enable                
           =2 #define TMR5CN0_TF5LEN__DISABLED       0x00 ///< Disable low byte interrupts.                     
           =2 #define TMR5CN0_TF5LEN__ENABLED        0x20 ///< Enable low byte interrupts.                      
           =2                                                                                                   
           =2 #define TMR5CN0_TF5L__BMASK            0x40 ///< Timer 5 Low Byte Overflow Flag                   
           =2 #define TMR5CN0_TF5L__SHIFT            0x06 ///< Timer 5 Low Byte Overflow Flag                   
           =2 #define TMR5CN0_TF5L__NOT_SET          0x00 ///< Timer 5 low byte did not overflow.               
           =2 #define TMR5CN0_TF5L__SET              0x40 ///< Timer 5 low byte overflowed.                     
           =2                                                                                                   
           =2 #define TMR5CN0_TF5H__BMASK            0x80 ///< Timer 5 High Byte Overflow Flag                  
           =2 #define TMR5CN0_TF5H__SHIFT            0x07 ///< Timer 5 High Byte Overflow Flag                  
           =2 #define TMR5CN0_TF5H__NOT_SET          0x00 ///< Timer 5 8-bit high byte or 16-bit value did not  
           =2                                             ///< overflow.                                        
           =2 #define TMR5CN0_TF5H__SET              0x80 ///< Timer 5 8-bit high byte or 16-bit value          
           =2                                             ///< overflowed.                                      
           =2                                                                                                   
           =2 //------------------------------------------------------------------------------
           =2 // TMR5H Enums (Timer 5 High Byte @ 0xCD)
           =2 //------------------------------------------------------------------------------
           =2 #define TMR5H_TMR5H__FMASK 0xFF ///< Timer 5 High Byte
           =2 #define TMR5H_TMR5H__SHIFT 0x00 ///< Timer 5 High Byte
           =2                                                       
           =2 //------------------------------------------------------------------------------
           =2 // TMR5L Enums (Timer 5 Low Byte @ 0xCC)
           =2 //------------------------------------------------------------------------------
           =2 #define TMR5L_TMR5L__FMASK 0xFF ///< Timer 5 Low Byte
           =2 #define TMR5L_TMR5L__SHIFT 0x00 ///< Timer 5 Low Byte
           =2                                                      
           =2 //------------------------------------------------------------------------------
           =2 // TMR5RLH Enums (Timer 5 Reload High Byte @ 0xCB)
           =2 //------------------------------------------------------------------------------
           =2 #define TMR5RLH_TMR5RLH__FMASK 0xFF ///< Timer 5 Reload High Byte
           =2 #define TMR5RLH_TMR5RLH__SHIFT 0x00 ///< Timer 5 Reload High Byte
           =2                                                                  
           =2 //------------------------------------------------------------------------------
           =2 // TMR5RLL Enums (Timer 5 Reload Low Byte @ 0xCA)
           =2 //------------------------------------------------------------------------------
           =2 #define TMR5RLL_TMR5RLL__FMASK 0xFF ///< Timer 5 Reload Low Byte
           =2 #define TMR5RLL_TMR5RLL__SHIFT 0x00 ///< Timer 5 Reload Low Byte
           =2                                                                 
           =2 //------------------------------------------------------------------------------
C51 COMPILER V9.56.0.0   SPI_0                                                             10/28/2016 17:37:02 PAGE 147 

           =2 // CKCON0 Enums (Clock Control 0 @ 0x8E)
           =2 //------------------------------------------------------------------------------
           =2 #define CKCON0_SCA__FMASK           0x03 ///< Timer 0/1 Prescale                                
           =2 #define CKCON0_SCA__SHIFT           0x00 ///< Timer 0/1 Prescale                                
           =2 #define CKCON0_SCA__SYSCLK_DIV_12   0x00 ///< System clock divided by 12.                       
           =2 #define CKCON0_SCA__SYSCLK_DIV_4    0x01 ///< System clock divided by 4.                        
           =2 #define CKCON0_SCA__SYSCLK_DIV_48   0x02 ///< System clock divided by 48.                       
           =2 #define CKCON0_SCA__EXTOSC_DIV_8    0x03 ///< External oscillator divided by 8 (synchronized    
           =2                                          ///< with the system clock).                           
           =2                                                                                                 
           =2 #define CKCON0_T0M__BMASK           0x04 ///< Timer 0 Clock Select                              
           =2 #define CKCON0_T0M__SHIFT           0x02 ///< Timer 0 Clock Select                              
           =2 #define CKCON0_T0M__PRESCALE        0x00 ///< Counter/Timer 0 uses the clock defined by the     
           =2                                          ///< prescale field, SCA.                              
           =2 #define CKCON0_T0M__SYSCLK          0x04 ///< Counter/Timer 0 uses the system clock.            
           =2                                                                                                 
           =2 #define CKCON0_T1M__BMASK           0x08 ///< Timer 1 Clock Select                              
           =2 #define CKCON0_T1M__SHIFT           0x03 ///< Timer 1 Clock Select                              
           =2 #define CKCON0_T1M__PRESCALE        0x00 ///< Timer 1 uses the clock defined by the prescale    
           =2                                          ///< field, SCA.                                       
           =2 #define CKCON0_T1M__SYSCLK          0x08 ///< Timer 1 uses the system clock.                    
           =2                                                                                                 
           =2 #define CKCON0_T2ML__BMASK          0x10 ///< Timer 2 Low Byte Clock Select                     
           =2 #define CKCON0_T2ML__SHIFT          0x04 ///< Timer 2 Low Byte Clock Select                     
           =2 #define CKCON0_T2ML__EXTERNAL_CLOCK 0x00 ///< Timer 2 low byte uses the clock defined by T2XCLK 
           =2                                          ///< in TMR2CN0.                                       
           =2 #define CKCON0_T2ML__SYSCLK         0x10 ///< Timer 2 low byte uses the system clock.           
           =2                                                                                                 
           =2 #define CKCON0_T2MH__BMASK          0x20 ///< Timer 2 High Byte Clock Select                    
           =2 #define CKCON0_T2MH__SHIFT          0x05 ///< Timer 2 High Byte Clock Select                    
           =2 #define CKCON0_T2MH__EXTERNAL_CLOCK 0x00 ///< Timer 2 high byte uses the clock defined by T2XCLK
           =2                                          ///< in TMR2CN0.                                       
           =2 #define CKCON0_T2MH__SYSCLK         0x20 ///< Timer 2 high byte uses the system clock.          
           =2                                                                                                 
           =2 #define CKCON0_T3ML__BMASK          0x40 ///< Timer 3 Low Byte Clock Select                     
           =2 #define CKCON0_T3ML__SHIFT          0x06 ///< Timer 3 Low Byte Clock Select                     
           =2 #define CKCON0_T3ML__EXTERNAL_CLOCK 0x00 ///< Timer 3 low byte uses the clock defined by T3XCLK 
           =2                                          ///< in TMR3CN0.                                       
           =2 #define CKCON0_T3ML__SYSCLK         0x40 ///< Timer 3 low byte uses the system clock.           
           =2                                                                                                 
           =2 #define CKCON0_T3MH__BMASK          0x80 ///< Timer 3 High Byte Clock Select                    
           =2 #define CKCON0_T3MH__SHIFT          0x07 ///< Timer 3 High Byte Clock Select                    
           =2 #define CKCON0_T3MH__EXTERNAL_CLOCK 0x00 ///< Timer 3 high byte uses the clock defined by T3XCLK
           =2                                          ///< in TMR3CN0.                                       
           =2 #define CKCON0_T3MH__SYSCLK         0x80 ///< Timer 3 high byte uses the system clock.          
           =2                                                                                                 
           =2 //------------------------------------------------------------------------------
           =2 // CKCON1 Enums (Clock Control 1 @ 0xE4)
           =2 //------------------------------------------------------------------------------
           =2 #define CKCON1_T4ML__BMASK          0x01 ///< Timer 4 Low Byte Clock Select                     
           =2 #define CKCON1_T4ML__SHIFT          0x00 ///< Timer 4 Low Byte Clock Select                     
           =2 #define CKCON1_T4ML__EXTERNAL_CLOCK 0x00 ///< Timer 4 low byte uses the clock defined by T4XCLK 
           =2                                          ///< in TMR4CN0.                                       
           =2 #define CKCON1_T4ML__SYSCLK         0x01 ///< Timer 4 low byte uses the system clock.           
           =2                                                                                                 
           =2 #define CKCON1_T4MH__BMASK          0x02 ///< Timer 4 High Byte Clock Select                    
           =2 #define CKCON1_T4MH__SHIFT          0x01 ///< Timer 4 High Byte Clock Select                    
           =2 #define CKCON1_T4MH__EXTERNAL_CLOCK 0x00 ///< Timer 4 high byte uses the clock defined by T4XCLK
           =2                                          ///< in TMR4CN0.                                       
           =2 #define CKCON1_T4MH__SYSCLK         0x02 ///< Timer 4 high byte uses the system clock.          
           =2                                                                                                 
           =2 #define CKCON1_T5ML__BMASK          0x04 ///< Timer 5 Low Byte Clock Select                     
C51 COMPILER V9.56.0.0   SPI_0                                                             10/28/2016 17:37:02 PAGE 148 

           =2 #define CKCON1_T5ML__SHIFT          0x02 ///< Timer 5 Low Byte Clock Select                     
           =2 #define CKCON1_T5ML__EXTERNAL_CLOCK 0x00 ///< Timer 5 low byte uses the clock defined by T5XCLK 
           =2                                          ///< in TMR5CN.                                        
           =2 #define CKCON1_T5ML__SYSCLK         0x04 ///< Timer 5 low byte uses the system clock.           
           =2                                                                                                 
           =2 #define CKCON1_T5MH__BMASK          0x08 ///< Timer 5 High Byte Clock Select                    
           =2 #define CKCON1_T5MH__SHIFT          0x03 ///< Timer 5 High Byte Clock Select                    
           =2 #define CKCON1_T5MH__EXTERNAL_CLOCK 0x00 ///< Timer 5 high byte uses the clock defined by T5XCLK
           =2                                          ///< in TMR5CN.                                        
           =2 #define CKCON1_T5MH__SYSCLK         0x08 ///< Timer 5 high byte uses the system clock.          
           =2                                                                                                 
           =2 //------------------------------------------------------------------------------
           =2 // TCON Enums (Timer 0/1 Control @ 0x88)
           =2 //------------------------------------------------------------------------------
           =2 #define TCON_IT0__BMASK   0x01 ///< Interrupt 0 Type Select  
           =2 #define TCON_IT0__SHIFT   0x00 ///< Interrupt 0 Type Select  
           =2 #define TCON_IT0__LEVEL   0x00 ///< INT0 is level triggered. 
           =2 #define TCON_IT0__EDGE    0x01 ///< INT0 is edge triggered.  
           =2                                                              
           =2 #define TCON_IE0__BMASK   0x02 ///< External Interrupt 0     
           =2 #define TCON_IE0__SHIFT   0x01 ///< External Interrupt 0     
           =2 #define TCON_IE0__NOT_SET 0x00 ///< Edge/level not detected. 
           =2 #define TCON_IE0__SET     0x02 ///< Edge/level detected      
           =2                                                              
           =2 #define TCON_IT1__BMASK   0x04 ///< Interrupt 1 Type Select  
           =2 #define TCON_IT1__SHIFT   0x02 ///< Interrupt 1 Type Select  
           =2 #define TCON_IT1__LEVEL   0x00 ///< INT1 is level triggered. 
           =2 #define TCON_IT1__EDGE    0x04 ///< INT1 is edge triggered.  
           =2                                                              
           =2 #define TCON_IE1__BMASK   0x08 ///< External Interrupt 1     
           =2 #define TCON_IE1__SHIFT   0x03 ///< External Interrupt 1     
           =2 #define TCON_IE1__NOT_SET 0x00 ///< Edge/level not detected. 
           =2 #define TCON_IE1__SET     0x08 ///< Edge/level detected      
           =2                                                              
           =2 #define TCON_TR0__BMASK   0x10 ///< Timer 0 Run Control      
           =2 #define TCON_TR0__SHIFT   0x04 ///< Timer 0 Run Control      
           =2 #define TCON_TR0__STOP    0x00 ///< Stop Timer 0.            
           =2 #define TCON_TR0__RUN     0x10 ///< Start Timer 0 running.   
           =2                                                              
           =2 #define TCON_TF0__BMASK   0x20 ///< Timer 0 Overflow Flag    
           =2 #define TCON_TF0__SHIFT   0x05 ///< Timer 0 Overflow Flag    
           =2 #define TCON_TF0__NOT_SET 0x00 ///< Timer 0 did not overflow.
           =2 #define TCON_TF0__SET     0x20 ///< Timer 0 overflowed.      
           =2                                                              
           =2 #define TCON_TR1__BMASK   0x40 ///< Timer 1 Run Control      
           =2 #define TCON_TR1__SHIFT   0x06 ///< Timer 1 Run Control      
           =2 #define TCON_TR1__STOP    0x00 ///< Stop Timer 1.            
           =2 #define TCON_TR1__RUN     0x40 ///< Start Timer 1 running.   
           =2                                                              
           =2 #define TCON_TF1__BMASK   0x80 ///< Timer 1 Overflow Flag    
           =2 #define TCON_TF1__SHIFT   0x07 ///< Timer 1 Overflow Flag    
           =2 #define TCON_TF1__NOT_SET 0x00 ///< Timer 1 did not overflow.
           =2 #define TCON_TF1__SET     0x80 ///< Timer 1 overflowed.      
           =2                                                              
           =2 //------------------------------------------------------------------------------
           =2 // TMOD Enums (Timer 0/1 Mode @ 0x89)
           =2 //------------------------------------------------------------------------------
           =2 #define TMOD_T0M__FMASK      0x03 ///< Timer 0 Mode Select                               
           =2 #define TMOD_T0M__SHIFT      0x00 ///< Timer 0 Mode Select                               
           =2 #define TMOD_T0M__MODE0      0x00 ///< Mode 0, 13-bit Counter/Timer                      
           =2 #define TMOD_T0M__MODE1      0x01 ///< Mode 1, 16-bit Counter/Timer                      
           =2 #define TMOD_T0M__MODE2      0x02 ///< Mode 2, 8-bit Counter/Timer with Auto-Reload      
C51 COMPILER V9.56.0.0   SPI_0                                                             10/28/2016 17:37:02 PAGE 149 

           =2 #define TMOD_T0M__MODE3      0x03 ///< Mode 3, Two 8-bit Counter/Timers                  
           =2                                                                                          
           =2 #define TMOD_CT0__BMASK      0x04 ///< Counter/Timer 0 Select                            
           =2 #define TMOD_CT0__SHIFT      0x02 ///< Counter/Timer 0 Select                            
           =2 #define TMOD_CT0__TIMER      0x00 ///< Timer Mode. Timer 0 increments on the clock       
           =2                                   ///< defined by T0M in the CKCON0 register.            
           =2 #define TMOD_CT0__COUNTER    0x04 ///< Counter Mode. Timer 0 increments on high-to-low   
           =2                                   ///< transitions of an external pin (T0).              
           =2                                                                                          
           =2 #define TMOD_GATE0__BMASK    0x08 ///< Timer 0 Gate Control                              
           =2 #define TMOD_GATE0__SHIFT    0x03 ///< Timer 0 Gate Control                              
           =2 #define TMOD_GATE0__DISABLED 0x00 ///< Timer 0 enabled when TR0 = 1 irrespective of INT0 
           =2                                   ///< logic level.                                      
           =2 #define TMOD_GATE0__ENABLED  0x08 ///< Timer 0 enabled only when TR0 = 1 and INT0 is     
           =2                                   ///< active as defined by bit IN0PL in register IT01CF.
           =2                                                                                          
           =2 #define TMOD_T1M__FMASK      0x30 ///< Timer 1 Mode Select                               
           =2 #define TMOD_T1M__SHIFT      0x04 ///< Timer 1 Mode Select                               
           =2 #define TMOD_T1M__MODE0      0x00 ///< Mode 0, 13-bit Counter/Timer                      
           =2 #define TMOD_T1M__MODE1      0x10 ///< Mode 1, 16-bit Counter/Timer                      
           =2 #define TMOD_T1M__MODE2      0x20 ///< Mode 2, 8-bit Counter/Timer with Auto-Reload      
           =2 #define TMOD_T1M__MODE3      0x30 ///< Mode 3, Timer 1 Inactive                          
           =2                                                                                          
           =2 #define TMOD_CT1__BMASK      0x40 ///< Counter/Timer 1 Select                            
           =2 #define TMOD_CT1__SHIFT      0x06 ///< Counter/Timer 1 Select                            
           =2 #define TMOD_CT1__TIMER      0x00 ///< Timer Mode. Timer 1 increments on the clock       
           =2                                   ///< defined by T1M in the CKCON0 register.            
           =2 #define TMOD_CT1__COUNTER    0x40 ///< Counter Mode. Timer 1 increments on high-to-low   
           =2                                   ///< transitions of an external pin (T1).              
           =2                                                                                          
           =2 #define TMOD_GATE1__BMASK    0x80 ///< Timer 1 Gate Control                              
           =2 #define TMOD_GATE1__SHIFT    0x07 ///< Timer 1 Gate Control                              
           =2 #define TMOD_GATE1__DISABLED 0x00 ///< Timer 1 enabled when TR1 = 1 irrespective of INT1 
           =2                                   ///< logic level.                                      
           =2 #define TMOD_GATE1__ENABLED  0x80 ///< Timer 1 enabled only when TR1 = 1 and INT1 is     
           =2                                   ///< active as defined by bit IN1PL in register IT01CF.
           =2                                                                                          
           =2 //------------------------------------------------------------------------------
           =2 // SBCON1 Enums (UART1 Baud Rate Generator Control @ 0xAC)
           =2 //------------------------------------------------------------------------------
           =2 #define SBCON1_BPS__FMASK     0x03 ///< Baud Rate Prescaler Select                     
           =2 #define SBCON1_BPS__SHIFT     0x00 ///< Baud Rate Prescaler Select                     
           =2 #define SBCON1_BPS__DIV_BY_12 0x00 ///< Prescaler = 12.                                
           =2 #define SBCON1_BPS__DIV_BY_4  0x01 ///< Prescaler = 4.                                 
           =2 #define SBCON1_BPS__DIV_BY_48 0x02 ///< Prescaler = 48.                                
           =2 #define SBCON1_BPS__DIV_BY_1  0x03 ///< Prescaler = 1.                                 
           =2                                                                                        
           =2 #define SBCON1_BREN__BMASK    0x40 ///< Baud Rate Generator Enable                     
           =2 #define SBCON1_BREN__SHIFT    0x06 ///< Baud Rate Generator Enable                     
           =2 #define SBCON1_BREN__DISABLED 0x00 ///< Disable the baud rate generator. UART1 will not
           =2                                    ///< function.                                      
           =2 #define SBCON1_BREN__ENABLED  0x40 ///< Enable the baud rate generator.                
           =2                                                                                        
           =2 //------------------------------------------------------------------------------
           =2 // SBRLH1 Enums (UART1 Baud Rate Generator High Byte @ 0xB5)
           =2 //------------------------------------------------------------------------------
           =2 #define SBRLH1_BRH__FMASK 0xFF ///< UART1 Baud Rate Reload High
           =2 #define SBRLH1_BRH__SHIFT 0x00 ///< UART1 Baud Rate Reload High
           =2                                                                
           =2 //------------------------------------------------------------------------------
           =2 // SBRLL1 Enums (UART1 Baud Rate Generator Low Byte @ 0xB4)
           =2 //------------------------------------------------------------------------------
C51 COMPILER V9.56.0.0   SPI_0                                                             10/28/2016 17:37:02 PAGE 150 

           =2 #define SBRLL1_BRL__FMASK 0xFF ///< UART1 Baud Rate Reload Low
           =2 #define SBRLL1_BRL__SHIFT 0x00 ///< UART1 Baud Rate Reload Low
           =2                                                               
           =2 //------------------------------------------------------------------------------
           =2 // SBUF1 Enums (UART1 Serial Port Data Buffer @ 0xD3)
           =2 //------------------------------------------------------------------------------
           =2 #define SBUF1_SBUF1__FMASK 0xFF ///< Serial Port Data Buffer
           =2 #define SBUF1_SBUF1__SHIFT 0x00 ///< Serial Port Data Buffer
           =2                                                             
           =2 //------------------------------------------------------------------------------
           =2 // SCON1 Enums (UART1 Serial Port Control @ 0xD2)
           =2 //------------------------------------------------------------------------------
           =2 #define SCON1_RI__BMASK             0x01 ///< Receive Interrupt Flag                           
           =2 #define SCON1_RI__SHIFT             0x00 ///< Receive Interrupt Flag                           
           =2 #define SCON1_RI__NOT_SET           0x00 ///< New data has not been received by UART1.         
           =2 #define SCON1_RI__SET               0x01 ///< UART1 received one or more data bytes.           
           =2                                                                                                
           =2 #define SCON1_TI__BMASK             0x02 ///< Transmit Interrupt Flag                          
           =2 #define SCON1_TI__SHIFT             0x01 ///< Transmit Interrupt Flag                          
           =2 #define SCON1_TI__NOT_SET           0x00 ///< A byte of data has not been transmitted by UART1.
           =2 #define SCON1_TI__SET               0x02 ///< UART1 transmitted a byte of data.                
           =2                                                                                                
           =2 #define SCON1_RBX__BMASK            0x04 ///< Extra Receive Bit                                
           =2 #define SCON1_RBX__SHIFT            0x02 ///< Extra Receive Bit                                
           =2 #define SCON1_RBX__LOW              0x00 ///< The extra bit or the first stop bit is 0.        
           =2 #define SCON1_RBX__HIGH             0x04 ///< The extra bit or the first stop bit is 1.        
           =2                                                                                                
           =2 #define SCON1_TBX__BMASK            0x08 ///< Extra Transmission Bit                           
           =2 #define SCON1_TBX__SHIFT            0x03 ///< Extra Transmission Bit                           
           =2 #define SCON1_TBX__LOW              0x00 ///< Set extra bit to 0 (low).                        
           =2 #define SCON1_TBX__HIGH             0x08 ///< Set extra bit to 1 (high).                       
           =2                                                                                                
           =2 #define SCON1_REN__BMASK            0x10 ///< Receive Enable                                   
           =2 #define SCON1_REN__SHIFT            0x04 ///< Receive Enable                                   
           =2 #define SCON1_REN__RECEIVE_DISABLED 0x00 ///< UART1 reception disabled.                        
           =2 #define SCON1_REN__RECEIVE_ENABLED  0x10 ///< UART1 reception enabled.                         
           =2                                                                                                
           =2 #define SCON1_PERR__BMASK           0x40 ///< Parity Error Flag                                
           =2 #define SCON1_PERR__SHIFT           0x06 ///< Parity Error Flag                                
           =2 #define SCON1_PERR__NOT_SET         0x00 ///< Parity error has not occurred.                   
           =2 #define SCON1_PERR__SET             0x40 ///< Parity error has occurred.                       
           =2                                                                                                
           =2 #define SCON1_OVR__BMASK            0x80 ///< Receive FIFO Overrun Flag                        
           =2 #define SCON1_OVR__SHIFT            0x07 ///< Receive FIFO Overrun Flag                        
           =2 #define SCON1_OVR__NOT_SET          0x00 ///< Receive FIFO overrun has not occurred.           
           =2 #define SCON1_OVR__SET              0x80 ///< Receive FIFO overrun has occurred.               
           =2                                                                                                
           =2 //------------------------------------------------------------------------------
           =2 // SMOD1 Enums (UART1 Mode @ 0xE5)
           =2 //------------------------------------------------------------------------------
           =2 #define SMOD1_SBL__BMASK          0x01 ///< Stop Bit Length                                 
           =2 #define SMOD1_SBL__SHIFT          0x00 ///< Stop Bit Length                                 
           =2 #define SMOD1_SBL__SHORT          0x00 ///< Short: Stop bit is active for one bit time.     
           =2 #define SMOD1_SBL__LONG           0x01 ///< Long: Stop bit is active for two bit times (data
           =2                                        ///< length = 6, 7, or 8 bits) or 1.5 bit times (data
           =2                                        ///< length = 5 bits).                               
           =2                                                                                             
           =2 #define SMOD1_XBE__BMASK          0x02 ///< Extra Bit Enable                                
           =2 #define SMOD1_XBE__SHIFT          0x01 ///< Extra Bit Enable                                
           =2 #define SMOD1_XBE__DISABLED       0x00 ///< Disable the extra bit.                          
           =2 #define SMOD1_XBE__ENABLED        0x02 ///< Enable the extra bit.                           
           =2                                                                                             
C51 COMPILER V9.56.0.0   SPI_0                                                             10/28/2016 17:37:02 PAGE 151 

           =2 #define SMOD1_SDL__FMASK          0x0C ///< Data Length                                     
           =2 #define SMOD1_SDL__SHIFT          0x02 ///< Data Length                                     
           =2 #define SMOD1_SDL__5_BITS         0x00 ///< 5 bits.                                         
           =2 #define SMOD1_SDL__6_BITS         0x04 ///< 6 bits.                                         
           =2 #define SMOD1_SDL__7_BITS         0x08 ///< 7 bits.                                         
           =2 #define SMOD1_SDL__8_BITS         0x0C ///< 8 bits.                                         
           =2                                                                                             
           =2 #define SMOD1_PE__BMASK           0x10 ///< Parity Enable                                   
           =2 #define SMOD1_PE__SHIFT           0x04 ///< Parity Enable                                   
           =2 #define SMOD1_PE__PARITY_DISABLED 0x00 ///< Disable hardware parity.                        
           =2 #define SMOD1_PE__PARITY_ENABLED  0x10 ///< Enable hardware parity.                         
           =2                                                                                             
           =2 #define SMOD1_SPT__FMASK          0x60 ///< Parity Type                                     
           =2 #define SMOD1_SPT__SHIFT          0x05 ///< Parity Type                                     
           =2 #define SMOD1_SPT__ODD_PARITY     0x00 ///< Odd.                                            
           =2 #define SMOD1_SPT__EVEN_PARITY    0x20 ///< Even.                                           
           =2 #define SMOD1_SPT__MARK_PARITY    0x40 ///< Mark.                                           
           =2 #define SMOD1_SPT__SPACE_PARITY   0x60 ///< Space.                                          
           =2                                                                                             
           =2 #define SMOD1_MCE__BMASK          0x80 ///< Multiprocessor Communication Enable             
           =2 #define SMOD1_MCE__SHIFT          0x07 ///< Multiprocessor Communication Enable             
           =2 #define SMOD1_MCE__MULTI_DISABLED 0x00 ///< RI will be activated if the stop bits are 1.    
           =2 #define SMOD1_MCE__MULTI_ENABLED  0x80 ///< RI will be activated if the stop bits and extra 
           =2                                        ///< bit are 1. The extra bit must be enabled using  
           =2                                        ///< XBE.                                            
           =2                                                                                             
           =2 //------------------------------------------------------------------------------
           =2 // SBUF0 Enums (UART0 Serial Port Data Buffer @ 0x99)
           =2 //------------------------------------------------------------------------------
           =2 #define SBUF0_SBUF0__FMASK 0xFF ///< Serial Data Buffer
           =2 #define SBUF0_SBUF0__SHIFT 0x00 ///< Serial Data Buffer
           =2                                                        
           =2 //------------------------------------------------------------------------------
           =2 // SCON0 Enums (UART0 Serial Port Control @ 0x98)
           =2 //------------------------------------------------------------------------------
           =2 #define SCON0_RI__BMASK             0x01 ///< Receive Interrupt Flag                           
           =2 #define SCON0_RI__SHIFT             0x00 ///< Receive Interrupt Flag                           
           =2 #define SCON0_RI__NOT_SET           0x00 ///< A byte of data has not been received by UART0.   
           =2 #define SCON0_RI__SET               0x01 ///< UART0 received a byte of data.                   
           =2                                                                                                
           =2 #define SCON0_TI__BMASK             0x02 ///< Transmit Interrupt Flag                          
           =2 #define SCON0_TI__SHIFT             0x01 ///< Transmit Interrupt Flag                          
           =2 #define SCON0_TI__NOT_SET           0x00 ///< A byte of data has not been transmitted by UART0.
           =2 #define SCON0_TI__SET               0x02 ///< UART0 transmitted a byte of data.                
           =2                                                                                                
           =2 #define SCON0_RB8__BMASK            0x04 ///< Ninth Receive Bit                                
           =2 #define SCON0_RB8__SHIFT            0x02 ///< Ninth Receive Bit                                
           =2 #define SCON0_RB8__CLEARED_TO_0     0x00 ///< In Mode 0, the STOP bit was 0. In Mode 1, the 9th
           =2                                          ///< bit was 0.                                       
           =2 #define SCON0_RB8__SET_TO_1         0x04 ///< In Mode 0, the STOP bit was 1. In Mode 1, the 9th
           =2                                          ///< bit was 1.                                       
           =2                                                                                                
           =2 #define SCON0_TB8__BMASK            0x08 ///< Ninth Transmission Bit                           
           =2 #define SCON0_TB8__SHIFT            0x03 ///< Ninth Transmission Bit                           
           =2 #define SCON0_TB8__CLEARED_TO_0     0x00 ///< In Mode 1, set the 9th transmission bit to 0.    
           =2 #define SCON0_TB8__SET_TO_1         0x08 ///< In Mode 1, set the 9th transmission bit to 1.    
           =2                                                                                                
           =2 #define SCON0_REN__BMASK            0x10 ///< Receive Enable                                   
           =2 #define SCON0_REN__SHIFT            0x04 ///< Receive Enable                                   
           =2 #define SCON0_REN__RECEIVE_DISABLED 0x00 ///< UART0 reception disabled.                        
           =2 #define SCON0_REN__RECEIVE_ENABLED  0x10 ///< UART0 reception enabled.                         
           =2                                                                                                
C51 COMPILER V9.56.0.0   SPI_0                                                             10/28/2016 17:37:02 PAGE 152 

           =2 #define SCON0_MCE__BMASK            0x20 ///< Multiprocessor Communication Enable              
           =2 #define SCON0_MCE__SHIFT            0x05 ///< Multiprocessor Communication Enable              
           =2 #define SCON0_MCE__MULTI_DISABLED   0x00 ///< Ignore level of 9th bit / Stop bit.              
           =2 #define SCON0_MCE__MULTI_ENABLED    0x20 ///< RI is set and an interrupt is generated only when
           =2                                          ///< the stop bit is logic 1 (Mode 0) or when the 9th 
           =2                                          ///< bit is logic 1 (Mode 1).                         
           =2                                                                                                
           =2 #define SCON0_SMODE__BMASK          0x80 ///< Serial Port 0 Operation Mode                     
           =2 #define SCON0_SMODE__SHIFT          0x07 ///< Serial Port 0 Operation Mode                     
           =2 #define SCON0_SMODE__8_BIT          0x00 ///< 8-bit UART with Variable Baud Rate (Mode 0).     
           =2 #define SCON0_SMODE__9_BIT          0x80 ///< 9-bit UART with Variable Baud Rate (Mode 1).     
           =2                                                                                                
           =2 //------------------------------------------------------------------------------
           =2 // CLKREC Enums (USB0 Clock Recovery Control @ 0x0F)
           =2 //------------------------------------------------------------------------------
           =2 #define CLKREC_CRLOW__BMASK      0x20 ///< Low Speed Clock Recovery Mode               
           =2 #define CLKREC_CRLOW__SHIFT      0x05 ///< Low Speed Clock Recovery Mode               
           =2 #define CLKREC_CRLOW__FULL_SPEED 0x00 ///< Full Speed Mode.                            
           =2 #define CLKREC_CRLOW__LOW_SPEED  0x20 ///< Low Speed Mode.                             
           =2                                                                                        
           =2 #define CLKREC_CRSSEN__BMASK     0x40 ///< Clock Recovery Single Step                  
           =2 #define CLKREC_CRSSEN__SHIFT     0x06 ///< Clock Recovery Single Step                  
           =2 #define CLKREC_CRSSEN__DISABLED  0x00 ///< Disable single-step mode (normal calibration
           =2                                       ///< mode).                                      
           =2 #define CLKREC_CRSSEN__ENABLED   0x40 ///< Enable single-step mode.                    
           =2                                                                                        
           =2 #define CLKREC_CRE__BMASK        0x80 ///< Clock Recovery Enable                       
           =2 #define CLKREC_CRE__SHIFT        0x07 ///< Clock Recovery Enable                       
           =2 #define CLKREC_CRE__DISABLED     0x00 ///< Disable clock recovery.                     
           =2 #define CLKREC_CRE__ENABLED      0x80 ///< Enable clock recovery.                      
           =2                                                                                        
           =2 //------------------------------------------------------------------------------
           =2 // CMIE Enums (USB0 Common Interrupt Enable @ 0x0B)
           =2 //------------------------------------------------------------------------------
           =2 #define CMIE_SUSINTE__BMASK    0x01 ///< Suspend Interrupt Enable       
           =2 #define CMIE_SUSINTE__SHIFT    0x00 ///< Suspend Interrupt Enable       
           =2 #define CMIE_SUSINTE__DISABLED 0x00 ///< Disable suspend interrupts.    
           =2 #define CMIE_SUSINTE__ENABLED  0x01 ///< Enable suspend interrupts.     
           =2                                                                         
           =2 #define CMIE_RSUINTE__BMASK    0x02 ///< Resume Interrupt Enable        
           =2 #define CMIE_RSUINTE__SHIFT    0x01 ///< Resume Interrupt Enable        
           =2 #define CMIE_RSUINTE__DISABLED 0x00 ///< Disable resume interrupts.     
           =2 #define CMIE_RSUINTE__ENABLED  0x02 ///< Enable resume interrupts.      
           =2                                                                         
           =2 #define CMIE_RSTINTE__BMASK    0x04 ///< Reset Interrupt Enable         
           =2 #define CMIE_RSTINTE__SHIFT    0x02 ///< Reset Interrupt Enable         
           =2 #define CMIE_RSTINTE__DISABLED 0x00 ///< Disable reset interrupts.      
           =2 #define CMIE_RSTINTE__ENABLED  0x04 ///< Enable reset interrupts.       
           =2                                                                         
           =2 #define CMIE_SOFE__BMASK       0x08 ///< Start of Frame Interrupt Enable
           =2 #define CMIE_SOFE__SHIFT       0x03 ///< Start of Frame Interrupt Enable
           =2 #define CMIE_SOFE__DISABLED    0x00 ///< Disable SOF interrupts.        
           =2 #define CMIE_SOFE__ENABLED     0x08 ///< Enable SOF interrupts.         
           =2                                                                         
           =2 //------------------------------------------------------------------------------
           =2 // CMINT Enums (USB0 Common Interrupt @ 0x06)
           =2 //------------------------------------------------------------------------------
           =2 #define CMINT_SUSINT__BMASK   0x01 ///< Suspend Interrupt Flag       
           =2 #define CMINT_SUSINT__SHIFT   0x00 ///< Suspend Interrupt Flag       
           =2 #define CMINT_SUSINT__NOT_SET 0x00 ///< Suspend interrupt inactive.  
           =2 #define CMINT_SUSINT__SET     0x01 ///< Suspend interrupt active.    
           =2                                                                      
C51 COMPILER V9.56.0.0   SPI_0                                                             10/28/2016 17:37:02 PAGE 153 

           =2 #define CMINT_RSUINT__BMASK   0x02 ///< Resume Interrupt Flag        
           =2 #define CMINT_RSUINT__SHIFT   0x01 ///< Resume Interrupt Flag        
           =2 #define CMINT_RSUINT__NOT_SET 0x00 ///< Resume interrupt inactive.   
           =2 #define CMINT_RSUINT__SET     0x02 ///< Resume interrupt active.     
           =2                                                                      
           =2 #define CMINT_RSTINT__BMASK   0x04 ///< Reset Interrupt Flag         
           =2 #define CMINT_RSTINT__SHIFT   0x02 ///< Reset Interrupt Flag         
           =2 #define CMINT_RSTINT__NOT_SET 0x00 ///< Reset interrupt inactive.    
           =2 #define CMINT_RSTINT__SET     0x04 ///< Reset interrupt active.      
           =2                                                                      
           =2 #define CMINT_SOF__BMASK      0x08 ///< Start of Frame Interrupt Flag
           =2 #define CMINT_SOF__SHIFT      0x03 ///< Start of Frame Interrupt Flag
           =2 #define CMINT_SOF__NOT_SET    0x00 ///< SOF interrupt inactive.      
           =2 #define CMINT_SOF__SET        0x08 ///< SOF interrupt active.        
           =2                                                                      
           =2 //------------------------------------------------------------------------------
           =2 // E0CNT Enums (USB0 Endpoint0 Data Count @ 0x16)
           =2 //------------------------------------------------------------------------------
           =2 #define E0CNT_E0CNT__FMASK 0x7F ///< Endpoint 0 Data Count
           =2 #define E0CNT_E0CNT__SHIFT 0x00 ///< Endpoint 0 Data Count
           =2                                                           
           =2 //------------------------------------------------------------------------------
           =2 // E0CSR Enums (USB0 Endpoint0 Control @ 0x11)
           =2 //------------------------------------------------------------------------------
           =2 #define E0CSR_OPRDY__BMASK     0x01 ///< OUT Packet Ready                                  
           =2 #define E0CSR_OPRDY__SHIFT     0x00 ///< OUT Packet Ready                                  
           =2 #define E0CSR_OPRDY__NOT_SET   0x00 ///< A data packet has not been received.              
           =2 #define E0CSR_OPRDY__SET       0x01 ///< A data packet has been received.                  
           =2                                                                                            
           =2 #define E0CSR_INPRDY__BMASK    0x02 ///< IN Packet Ready                                   
           =2 #define E0CSR_INPRDY__SHIFT    0x01 ///< IN Packet Ready                                   
           =2 #define E0CSR_INPRDY__NOT_SET  0x00 ///< An IN packet is not ready to transmit.            
           =2 #define E0CSR_INPRDY__SET      0x02 ///< An IN packet is ready to transmit.                
           =2                                                                                            
           =2 #define E0CSR_STSTL__BMASK     0x04 ///< Sent Stall                                        
           =2 #define E0CSR_STSTL__SHIFT     0x02 ///< Sent Stall                                        
           =2 #define E0CSR_STSTL__NOT_SET   0x00 ///< A STALL handshake signal was not transmitted.     
           =2 #define E0CSR_STSTL__SET       0x04 ///< A STALL handshake signal was transmitted.         
           =2                                                                                            
           =2 #define E0CSR_DATAEND__BMASK   0x08 ///< Data End                                          
           =2 #define E0CSR_DATAEND__SHIFT   0x03 ///< Data End                                          
           =2 #define E0CSR_DATAEND__NOT_SET 0x00 ///< This is not the last data packet.                 
           =2 #define E0CSR_DATAEND__SET     0x08 ///< This is the last data packet.                     
           =2                                                                                            
           =2 #define E0CSR_SUEND__BMASK     0x10 ///< Setup End                                         
           =2 #define E0CSR_SUEND__SHIFT     0x04 ///< Setup End                                         
           =2 #define E0CSR_SUEND__NOT_SET   0x00 ///< A control transaction did not end before firmware 
           =2                                     ///< wrote a 1 to the DATAEND bit.                     
           =2 #define E0CSR_SUEND__SET       0x10 ///< A control transaction ended before firmware wrote 
           =2                                     ///< a 1 to the DATAEND bit.                           
           =2                                                                                            
           =2 #define E0CSR_SDSTL__BMASK     0x20 ///< Send Stall                                        
           =2 #define E0CSR_SDSTL__SHIFT     0x05 ///< Send Stall                                        
           =2 #define E0CSR_SDSTL__NOT_SET   0x00 ///< Do not send a STALL.                              
           =2 #define E0CSR_SDSTL__SET       0x20 ///< Send a STALL.                                     
           =2                                                                                            
           =2 #define E0CSR_SOPRDY__BMASK    0x40 ///< Serviced OPRDY                                    
           =2 #define E0CSR_SOPRDY__SHIFT    0x06 ///< Serviced OPRDY                                    
           =2 #define E0CSR_SOPRDY__NOT_SET  0x00 ///< OUT packet has not been serviced.                 
           =2 #define E0CSR_SOPRDY__SET      0x40 ///< OUT packet has been serviced.                     
           =2                                                                                            
           =2 #define E0CSR_SSUEND__BMASK    0x80 ///< Serviced Setup End                                
C51 COMPILER V9.56.0.0   SPI_0                                                             10/28/2016 17:37:02 PAGE 154 

           =2 #define E0CSR_SSUEND__SHIFT    0x07 ///< Serviced Setup End                                
           =2 #define E0CSR_SSUEND__NOT_SET  0x00 ///< The setup end (SUEND) event has not been serviced.
           =2 #define E0CSR_SSUEND__SET      0x80 ///< The setup end (SUEND) event has been serviced.    
           =2                                                                                            
           =2 //------------------------------------------------------------------------------
           =2 // EENABLE Enums (USB0 Endpoint Enable @ 0x1E)
           =2 //------------------------------------------------------------------------------
           =2 #define EENABLE_EEN1__BMASK    0x02 ///< Endpoint 1 Enable                                
           =2 #define EENABLE_EEN1__SHIFT    0x01 ///< Endpoint 1 Enable                                
           =2 #define EENABLE_EEN1__DISABLED 0x00 ///< Disable Endpoint 1 (no NACK, ACK, or STALL on the
           =2                                     ///< USB network).                                    
           =2 #define EENABLE_EEN1__ENABLED  0x02 ///< Enable Endpoint 1 (normal).                      
           =2                                                                                           
           =2 #define EENABLE_EEN2__BMASK    0x04 ///< Endpoint 2 Enable                                
           =2 #define EENABLE_EEN2__SHIFT    0x02 ///< Endpoint 2 Enable                                
           =2 #define EENABLE_EEN2__DISABLED 0x00 ///< Disable Endpoint 2 (no NACK, ACK, or STALL on the
           =2                                     ///< USB network).                                    
           =2 #define EENABLE_EEN2__ENABLED  0x04 ///< Enable Endpoint 2 (normal).                      
           =2                                                                                           
           =2 #define EENABLE_EEN3__BMASK    0x08 ///< Endpoint 3 Enable                                
           =2 #define EENABLE_EEN3__SHIFT    0x03 ///< Endpoint 3 Enable                                
           =2 #define EENABLE_EEN3__DISABLED 0x00 ///< Disable Endpoint 3 (no NACK, ACK, or STALL on the
           =2                                     ///< USB network).                                    
           =2 #define EENABLE_EEN3__ENABLED  0x08 ///< Enable Endpoint 3 (normal).                      
           =2                                                                                           
           =2 //------------------------------------------------------------------------------
           =2 // EINCSRH Enums (USB0 IN Endpoint Control High @ 0x12)
           =2 //------------------------------------------------------------------------------
           =2 #define EINCSRH_SPLIT__BMASK        0x04 ///< FIFO Split Enable                                
           =2 #define EINCSRH_SPLIT__SHIFT        0x02 ///< FIFO Split Enable                                
           =2 #define EINCSRH_SPLIT__DISABLED     0x00 ///< Disable split mode.                              
           =2 #define EINCSRH_SPLIT__ENABLED      0x04 ///< Enable split mode.                               
           =2                                                                                                
           =2 #define EINCSRH_FCDT__BMASK         0x08 ///< Force Data Toggle                                
           =2 #define EINCSRH_FCDT__SHIFT         0x03 ///< Force Data Toggle                                
           =2 #define EINCSRH_FCDT__ACK_TOGGLE    0x00 ///< Endpoint data toggle switches only when an ACK is
           =2                                          ///< received following a data packet transmission.   
           =2 #define EINCSRH_FCDT__ALWAYS_TOGGLE 0x08 ///< Endpoint data toggle forced to switch after every
           =2                                          ///< data packet is transmitted, regardless of ACK    
           =2                                          ///< reception.                                       
           =2                                                                                                
           =2 #define EINCSRH_DIRSEL__BMASK       0x20 ///< Endpoint Direction Select                        
           =2 #define EINCSRH_DIRSEL__SHIFT       0x05 ///< Endpoint Direction Select                        
           =2 #define EINCSRH_DIRSEL__OUT         0x00 ///< Endpoint direction selected as OUT.              
           =2 #define EINCSRH_DIRSEL__IN          0x20 ///< Endpoint direction selected as IN.               
           =2                                                                                                
           =2 #define EINCSRH_ISO__BMASK          0x40 ///< Isochronous Transfer Enable                      
           =2 #define EINCSRH_ISO__SHIFT          0x06 ///< Isochronous Transfer Enable                      
           =2 #define EINCSRH_ISO__DISABLED       0x00 ///< Endpoint configured for Bulk/Interrupt transfers.
           =2 #define EINCSRH_ISO__ENABLED        0x40 ///< Endpoint configured for Isochronous transfers.   
           =2                                                                                                
           =2 #define EINCSRH_DBIEN__BMASK        0x80 ///< IN Endpoint Double-Buffer Enable                 
           =2 #define EINCSRH_DBIEN__SHIFT        0x07 ///< IN Endpoint Double-Buffer Enable                 
           =2 #define EINCSRH_DBIEN__DISABLED     0x00 ///< Disable double-buffering for the selected IN     
           =2                                          ///< endpoint.                                        
           =2 #define EINCSRH_DBIEN__ENABLED      0x80 ///< Enable double-buffering for the selected IN      
           =2                                          ///< endpoint.                                        
           =2                                                                                                
           =2 //------------------------------------------------------------------------------
           =2 // EINCSRL Enums (USB0 IN Endpoint Control Low @ 0x11)
           =2 //------------------------------------------------------------------------------
           =2 #define EINCSRL_INPRDY__BMASK     0x01 ///< In Packet Ready                                   
C51 COMPILER V9.56.0.0   SPI_0                                                             10/28/2016 17:37:02 PAGE 155 

           =2 #define EINCSRL_INPRDY__SHIFT     0x00 ///< In Packet Ready                                   
           =2 #define EINCSRL_INPRDY__NOT_SET   0x00 ///< A packet is not available in the Endpoint IN FIFO.
           =2 #define EINCSRL_INPRDY__SET       0x01 ///< A packet is available in the Endpoint IN FIFO.    
           =2                                                                                               
           =2 #define EINCSRL_FIFONE__BMASK     0x02 ///< FIFO Not Empty                                    
           =2 #define EINCSRL_FIFONE__SHIFT     0x01 ///< FIFO Not Empty                                    
           =2 #define EINCSRL_FIFONE__EMPTY     0x00 ///< The IN Endpoint FIFO is empty.                    
           =2 #define EINCSRL_FIFONE__NOT_EMPTY 0x02 ///< The IN Endpoint FIFO contains one or more packets.
           =2                                                                                               
           =2 #define EINCSRL_UNDRUN__BMASK     0x04 ///< Data Underrun Flag                                
           =2 #define EINCSRL_UNDRUN__SHIFT     0x02 ///< Data Underrun Flag                                
           =2 #define EINCSRL_UNDRUN__NOT_SET   0x00 ///< A data underrun did not occur.                    
           =2 #define EINCSRL_UNDRUN__SET       0x04 ///< A data underrun occurred.                         
           =2                                                                                               
           =2 #define EINCSRL_FLUSH__BMASK      0x08 ///< FIFO Flush                                        
           =2 #define EINCSRL_FLUSH__SHIFT      0x03 ///< FIFO Flush                                        
           =2 #define EINCSRL_FLUSH__NOT_SET    0x00 ///< Do not flush the next packet.                     
           =2 #define EINCSRL_FLUSH__SET        0x08 ///< Flush the next packet to be transmitted from the  
           =2                                        ///< IN Endpoint FIFO.                                 
           =2                                                                                               
           =2 #define EINCSRL_SDSTL__BMASK      0x10 ///< Send Stall                                        
           =2 #define EINCSRL_SDSTL__SHIFT      0x04 ///< Send Stall                                        
           =2 #define EINCSRL_SDSTL__NOT_SET    0x00 ///< Terminate the STALL.                              
           =2 #define EINCSRL_SDSTL__SET        0x10 ///< Generate a STALL in response to an IN token.      
           =2                                                                                               
           =2 #define EINCSRL_STSTL__BMASK      0x20 ///< Sent Stall Flag                                   
           =2 #define EINCSRL_STSTL__SHIFT      0x05 ///< Sent Stall Flag                                   
           =2 #define EINCSRL_STSTL__NOT_SET    0x00 ///< A STALL handshake was not transmitted.            
           =2 #define EINCSRL_STSTL__SET        0x20 ///< A STALL handshake was transmitted.                
           =2                                                                                               
           =2 #define EINCSRL_CLRDT__BMASK      0x40 ///< Clear Data Toggle                                 
           =2 #define EINCSRL_CLRDT__SHIFT      0x06 ///< Clear Data Toggle                                 
           =2 #define EINCSRL_CLRDT__CLEAR      0x00 ///< Clear the IN Endpoint data toggle.                
           =2                                                                                               
           =2 //------------------------------------------------------------------------------
           =2 // EOUTCNTH Enums (USB0 OUT Endpoint Count High @ 0x17)
           =2 //------------------------------------------------------------------------------
           =2 #define EOUTCNTH_EOCH__FMASK 0x03 ///< OUT Endpoint Count High
           =2 #define EOUTCNTH_EOCH__SHIFT 0x00 ///< OUT Endpoint Count High
           =2                                                               
           =2 //------------------------------------------------------------------------------
           =2 // EOUTCNTL Enums (USB0 OUT Endpoint Count Low @ 0x16)
           =2 //------------------------------------------------------------------------------
           =2 #define EOUTCNTL_EOCL__FMASK 0xFF ///< OUT Endpoint Count Low
           =2 #define EOUTCNTL_EOCL__SHIFT 0x00 ///< OUT Endpoint Count Low
           =2                                                              
           =2 //------------------------------------------------------------------------------
           =2 // EOUTCSRH Enums (USB0 OUT Endpoint Control High @ 0x15)
           =2 //------------------------------------------------------------------------------
           =2 #define EOUTCSRH_ISO__BMASK      0x40 ///< Isochronous Transfer Enable                      
           =2 #define EOUTCSRH_ISO__SHIFT      0x06 ///< Isochronous Transfer Enable                      
           =2 #define EOUTCSRH_ISO__DISABLED   0x00 ///< Endpoint configured for Bulk/Interrupt transfers.
           =2 #define EOUTCSRH_ISO__ENABLED    0x40 ///< Endpoint configured for Isochronous transfers.   
           =2                                                                                             
           =2 #define EOUTCSRH_DBOEN__BMASK    0x80 ///< Double-Buffer Enable                             
           =2 #define EOUTCSRH_DBOEN__SHIFT    0x07 ///< Double-Buffer Enable                             
           =2 #define EOUTCSRH_DBOEN__DISABLED 0x00 ///< Disable double-buffering for the selected OUT    
           =2                                       ///< endpoint.                                        
           =2 #define EOUTCSRH_DBOEN__ENABLED  0x80 ///< Enable double-buffering for the selected OUT     
           =2                                       ///< endpoint.                                        
           =2                                                                                             
           =2 //------------------------------------------------------------------------------
C51 COMPILER V9.56.0.0   SPI_0                                                             10/28/2016 17:37:02 PAGE 156 

           =2 // EOUTCSRL Enums (USB0 OUT Endpoint Control Low @ 0x14)
           =2 //------------------------------------------------------------------------------
           =2 #define EOUTCSRL_OPRDY__BMASK      0x01 ///< OUT Packet Ready                                  
           =2 #define EOUTCSRL_OPRDY__SHIFT      0x00 ///< OUT Packet Ready                                  
           =2 #define EOUTCSRL_OPRDY__NOT_SET    0x00 ///< A data packet is not available in the Endpoint OUT
           =2                                         ///< FIFO.                                             
           =2 #define EOUTCSRL_OPRDY__SET        0x01 ///< A data packet is available in the Endpoint OUT    
           =2                                         ///< FIFO.                                             
           =2                                                                                                
           =2 #define EOUTCSRL_FIFOFUL__BMASK    0x02 ///< OUT FIFO Full                                     
           =2 #define EOUTCSRL_FIFOFUL__SHIFT    0x01 ///< OUT FIFO Full                                     
           =2 #define EOUTCSRL_FIFOFUL__NOT_FULL 0x00 ///< OUT endpoint FIFO is not full.                    
           =2 #define EOUTCSRL_FIFOFUL__FULL     0x02 ///< OUT endpoint FIFO is full.                        
           =2                                                                                                
           =2 #define EOUTCSRL_OVRUN__BMASK      0x04 ///< Data Overrun Flag                                 
           =2 #define EOUTCSRL_OVRUN__SHIFT      0x02 ///< Data Overrun Flag                                 
           =2 #define EOUTCSRL_OVRUN__NOT_SET    0x00 ///< No data overrun.                                  
           =2 #define EOUTCSRL_OVRUN__SET        0x04 ///< A data packet was lost because of a full FIFO     
           =2                                         ///< since this flag was last cleared.                 
           =2                                                                                                
           =2 #define EOUTCSRL_DATERR__BMASK     0x08 ///< Data Error Flag                                   
           =2 #define EOUTCSRL_DATERR__SHIFT     0x03 ///< Data Error Flag                                   
           =2 #define EOUTCSRL_DATERR__NOT_SET   0x00 ///< A received packet does not have a CRC or bit-     
           =2                                         ///< stuffing error.                                   
           =2 #define EOUTCSRL_DATERR__SET       0x08 ///< A received packet has a CRC or bit-stuffing error.
           =2                                                                                                
           =2 #define EOUTCSRL_FLUSH__BMASK      0x10 ///< FIFO Flush                                        
           =2 #define EOUTCSRL_FLUSH__SHIFT      0x04 ///< FIFO Flush                                        
           =2 #define EOUTCSRL_FLUSH__NOT_SET    0x00 ///< Do not flush the next packet.                     
           =2 #define EOUTCSRL_FLUSH__SET        0x10 ///< Flush the next packet to be read from the OUT     
           =2                                         ///< endpoint FIFO.                                    
           =2                                                                                                
           =2 #define EOUTCSRL_SDSTL__BMASK      0x20 ///< Send Stall                                        
           =2 #define EOUTCSRL_SDSTL__SHIFT      0x05 ///< Send Stall                                        
           =2 #define EOUTCSRL_SDSTL__NOT_SET    0x00 ///< Terminate the STALL.                              
           =2 #define EOUTCSRL_SDSTL__SET        0x20 ///< Generate a STALL handshake.                       
           =2                                                                                                
           =2 #define EOUTCSRL_STSTL__BMASK      0x40 ///< Sent Stall Flag                                   
           =2 #define EOUTCSRL_STSTL__SHIFT      0x06 ///< Sent Stall Flag                                   
           =2 #define EOUTCSRL_STSTL__NOT_SET    0x00 ///< A STALL handshake was not transmitted.            
           =2 #define EOUTCSRL_STSTL__SET        0x40 ///< A STALL handshake was transmitted.                
           =2                                                                                                
           =2 #define EOUTCSRL_CLRDT__BMASK      0x80 ///< Clear Data Toggle                                 
           =2 #define EOUTCSRL_CLRDT__SHIFT      0x07 ///< Clear Data Toggle                                 
           =2 #define EOUTCSRL_CLRDT__CLEAR      0x00 ///< Clear the OUT Endpoint data toggle.               
           =2                                                                                                
           =2 //------------------------------------------------------------------------------
           =2 // FADDR Enums (USB0 Function Address @ 0x00)
           =2 //------------------------------------------------------------------------------
           =2 #define FADDR_FADDR__FMASK    0x7F ///< Function Address                               
           =2 #define FADDR_FADDR__SHIFT    0x00 ///< Function Address                               
           =2                                                                                        
           =2 #define FADDR_UPDATE__BMASK   0x80 ///< Function Address Update                        
           =2 #define FADDR_UPDATE__SHIFT   0x07 ///< Function Address Update                        
           =2 #define FADDR_UPDATE__NOT_SET 0x00 ///< The last address written to FADDR is in effect.
           =2 #define FADDR_UPDATE__SET     0x80 ///< The last address written to FADDR is not yet in
           =2                                    ///< effect.                                        
           =2                                                                                        
           =2 //------------------------------------------------------------------------------
           =2 // FIFO0 Enums (USB0 Endpoint 0 FIFO Access @ 0x20)
           =2 //------------------------------------------------------------------------------
           =2 #define FIFO0_FIFODATA__FMASK 0xFF ///< Endpoint 0 FIFO Access
C51 COMPILER V9.56.0.0   SPI_0                                                             10/28/2016 17:37:02 PAGE 157 

           =2 #define FIFO0_FIFODATA__SHIFT 0x00 ///< Endpoint 0 FIFO Access
           =2                                                               
           =2 //------------------------------------------------------------------------------
           =2 // FIFO1 Enums (USB0 Endpoint 1 FIFO Access @ 0x21)
           =2 //------------------------------------------------------------------------------
           =2 #define FIFO1_FIFODATA__FMASK 0xFF ///< Endpoint 1 FIFO Access
           =2 #define FIFO1_FIFODATA__SHIFT 0x00 ///< Endpoint 1 FIFO Access
           =2                                                               
           =2 //------------------------------------------------------------------------------
           =2 // FIFO2 Enums (USB0 Endpoint 2 FIFO Access @ 0x22)
           =2 //------------------------------------------------------------------------------
           =2 #define FIFO2_FIFODATA__FMASK 0xFF ///< Endpoint 2 FIFO Access
           =2 #define FIFO2_FIFODATA__SHIFT 0x00 ///< Endpoint 2 FIFO Access
           =2                                                               
           =2 //------------------------------------------------------------------------------
           =2 // FIFO3 Enums (USB0 Endpoint 3 FIFO Access @ 0x23)
           =2 //------------------------------------------------------------------------------
           =2 #define FIFO3_FIFODATA__FMASK 0xFF ///< Endpoint 3 FIFO Access
           =2 #define FIFO3_FIFODATA__SHIFT 0x00 ///< Endpoint 3 FIFO Access
           =2                                                               
           =2 //------------------------------------------------------------------------------
           =2 // FRAMEH Enums (USB0 Frame Number High @ 0x0D)
           =2 //------------------------------------------------------------------------------
           =2 #define FRAMEH_FRMEH__FMASK 0x07 ///< Frame Number High
           =2 #define FRAMEH_FRMEH__SHIFT 0x00 ///< Frame Number High
           =2                                                        
           =2 //------------------------------------------------------------------------------
           =2 // FRAMEL Enums (USB0 Frame Number Low @ 0x0C)
           =2 //------------------------------------------------------------------------------
           =2 #define FRAMEL_FRMEL__FMASK 0xFF ///< Frame Number Low
           =2 #define FRAMEL_FRMEL__SHIFT 0x00 ///< Frame Number Low
           =2                                                       
           =2 //------------------------------------------------------------------------------
           =2 // IN1IE Enums (USB0 IN Endpoint Interrupt Enable @ 0x07)
           =2 //------------------------------------------------------------------------------
           =2 #define IN1IE_EP0E__BMASK    0x01 ///< Endpoint 0 Interrupt Enable      
           =2 #define IN1IE_EP0E__SHIFT    0x00 ///< Endpoint 0 Interrupt Enable      
           =2 #define IN1IE_EP0E__DISABLED 0x00 ///< Disable Endpoint 0 interrupts.   
           =2 #define IN1IE_EP0E__ENABLED  0x01 ///< Enable Endpoint 0 interrupts.    
           =2                                                                         
           =2 #define IN1IE_IN1E__BMASK    0x02 ///< IN Endpoint 1 Interrupt Enable   
           =2 #define IN1IE_IN1E__SHIFT    0x01 ///< IN Endpoint 1 Interrupt Enable   
           =2 #define IN1IE_IN1E__DISABLED 0x00 ///< Disable Endpoint 1 IN interrupts.
           =2 #define IN1IE_IN1E__ENABLED  0x02 ///< Enable Endpoint 1 IN interrupts. 
           =2                                                                         
           =2 #define IN1IE_IN2E__BMASK    0x04 ///< IN Endpoint 2 Interrupt Enable   
           =2 #define IN1IE_IN2E__SHIFT    0x02 ///< IN Endpoint 2 Interrupt Enable   
           =2 #define IN1IE_IN2E__DISABLED 0x00 ///< Disable Endpoint 2 IN interrupts.
           =2 #define IN1IE_IN2E__ENABLED  0x04 ///< Enable Endpoint 2 IN interrupts. 
           =2                                                                         
           =2 #define IN1IE_IN3E__BMASK    0x08 ///< IN Endpoint 3 Interrupt Enable   
           =2 #define IN1IE_IN3E__SHIFT    0x03 ///< IN Endpoint 3 Interrupt Enable   
           =2 #define IN1IE_IN3E__DISABLED 0x00 ///< Disable Endpoint 3 IN interrupts.
           =2 #define IN1IE_IN3E__ENABLED  0x08 ///< Enable Endpoint 3 IN interrupts. 
           =2                                                                         
           =2 //------------------------------------------------------------------------------
           =2 // IN1INT Enums (USB0 IN Endpoint Interrupt @ 0x02)
           =2 //------------------------------------------------------------------------------
           =2 #define IN1INT_EP0__BMASK   0x01 ///< Endpoint 0 Interrupt Flag        
           =2 #define IN1INT_EP0__SHIFT   0x00 ///< Endpoint 0 Interrupt Flag        
           =2 #define IN1INT_EP0__NOT_SET 0x00 ///< Endpoint 0 interrupt inactive.   
           =2 #define IN1INT_EP0__SET     0x01 ///< Endpoint 0 interrupt active.     
C51 COMPILER V9.56.0.0   SPI_0                                                             10/28/2016 17:37:02 PAGE 158 

           =2                                                                        
           =2 #define IN1INT_IN1__BMASK   0x02 ///< IN Endpoint 1 Interrupt Flag     
           =2 #define IN1INT_IN1__SHIFT   0x01 ///< IN Endpoint 1 Interrupt Flag     
           =2 #define IN1INT_IN1__NOT_SET 0x00 ///< IN Endpoint 1 interrupt inactive.
           =2 #define IN1INT_IN1__SET     0x02 ///< IN Endpoint 1 interrupt active.  
           =2                                                                        
           =2 #define IN1INT_IN2__BMASK   0x04 ///< IN Endpoint 2 Interrupt Flag     
           =2 #define IN1INT_IN2__SHIFT   0x02 ///< IN Endpoint 2 Interrupt Flag     
           =2 #define IN1INT_IN2__NOT_SET 0x00 ///< IN Endpoint 2 interrupt inactive.
           =2 #define IN1INT_IN2__SET     0x04 ///< IN Endpoint 2 interrupt active.  
           =2                                                                        
           =2 #define IN1INT_IN3__BMASK   0x08 ///< IN Endpoint 3 Interrupt Flag     
           =2 #define IN1INT_IN3__SHIFT   0x03 ///< IN Endpoint 3 Interrupt Flag     
           =2 #define IN1INT_IN3__NOT_SET 0x00 ///< IN Endpoint 3 interrupt inactive.
           =2 #define IN1INT_IN3__SET     0x08 ///< IN Endpoint 3 interrupt active.  
           =2                                                                        
           =2 //------------------------------------------------------------------------------
           =2 // INDEX Enums (USB0 Endpoint Index @ 0x0E)
           =2 //------------------------------------------------------------------------------
           =2 #define INDEX_EPSEL__FMASK      0x0F ///< Endpoint Select Bits
           =2 #define INDEX_EPSEL__SHIFT      0x00 ///< Endpoint Select Bits
           =2 #define INDEX_EPSEL__ENDPOINT_0 0x00 ///< Endpoint 0.         
           =2 #define INDEX_EPSEL__ENDPOINT_1 0x01 ///< Endpoint 1.         
           =2 #define INDEX_EPSEL__ENDPOINT_2 0x02 ///< Endpoint 2.         
           =2 #define INDEX_EPSEL__ENDPOINT_3 0x03 ///< Endpoint 3.         
           =2                                                               
           =2 //------------------------------------------------------------------------------
           =2 // OUT1IE Enums (USB0 OUT Endpoint Interrupt Enable @ 0x09)
           =2 //------------------------------------------------------------------------------
           =2 #define OUT1IE_OUT1E__BMASK    0x02 ///< OUT Endpoint 1 Interrupt Enable   
           =2 #define OUT1IE_OUT1E__SHIFT    0x01 ///< OUT Endpoint 1 Interrupt Enable   
           =2 #define OUT1IE_OUT1E__DISABLED 0x00 ///< Disable Endpoint 1 OUT interrupts.
           =2 #define OUT1IE_OUT1E__ENABLED  0x02 ///< Enable Endpoint 1 OUT interrupts. 
           =2                                                                            
           =2 #define OUT1IE_OUT2E__BMASK    0x04 ///< OUT Endpoint 2 Interrupt Enable   
           =2 #define OUT1IE_OUT2E__SHIFT    0x02 ///< OUT Endpoint 2 Interrupt Enable   
           =2 #define OUT1IE_OUT2E__DISABLED 0x00 ///< Disable Endpoint 2 OUT interrupts.
           =2 #define OUT1IE_OUT2E__ENABLED  0x04 ///< Enable Endpoint 2 OUT interrupts. 
           =2                                                                            
           =2 #define OUT1IE_OUT3E__BMASK    0x08 ///< OUT Endpoint 3 Interrupt Enable   
           =2 #define OUT1IE_OUT3E__SHIFT    0x03 ///< OUT Endpoint 3 Interrupt Enable   
           =2 #define OUT1IE_OUT3E__DISABLED 0x00 ///< Disable Endpoint 3 OUT interrupts.
           =2 #define OUT1IE_OUT3E__ENABLED  0x08 ///< Enable Endpoint 3 OUT interrupts. 
           =2                                                                            
           =2 //------------------------------------------------------------------------------
           =2 // OUT1INT Enums (USB0 OUT Endpoint Interrupt @ 0x04)
           =2 //------------------------------------------------------------------------------
           =2 #define OUT1INT_OUT1__BMASK   0x02 ///< OUT Endpoint 1 Interrupt Flag     
           =2 #define OUT1INT_OUT1__SHIFT   0x01 ///< OUT Endpoint 1 Interrupt Flag     
           =2 #define OUT1INT_OUT1__NOT_SET 0x00 ///< OUT Endpoint 1 interrupt inactive.
           =2 #define OUT1INT_OUT1__SET     0x02 ///< OUT Endpoint 1 interrupt active.  
           =2                                                                           
           =2 #define OUT1INT_OUT2__BMASK   0x04 ///< OUT Endpoint 2 Interrupt Flag     
           =2 #define OUT1INT_OUT2__SHIFT   0x02 ///< OUT Endpoint 2 Interrupt Flag     
           =2 #define OUT1INT_OUT2__NOT_SET 0x00 ///< OUT Endpoint 2 interrupt inactive.
           =2 #define OUT1INT_OUT2__SET     0x04 ///< OUT Endpoint 2 interrupt active.  
           =2                                                                           
           =2 #define OUT1INT_OUT3__BMASK   0x08 ///< OUT Endpoint 3 Interrupt Flag     
           =2 #define OUT1INT_OUT3__SHIFT   0x03 ///< OUT Endpoint 3 Interrupt Flag     
           =2 #define OUT1INT_OUT3__NOT_SET 0x00 ///< OUT Endpoint 3 interrupt inactive.
           =2 #define OUT1INT_OUT3__SET     0x08 ///< OUT Endpoint 3 interrupt active.  
           =2                                                                           
C51 COMPILER V9.56.0.0   SPI_0                                                             10/28/2016 17:37:02 PAGE 159 

           =2 //------------------------------------------------------------------------------
           =2 // POWER Enums (USB0 Power @ 0x01)
           =2 //------------------------------------------------------------------------------
           =2 #define POWER_SUSEN__BMASK         0x01 ///< Suspend Detection Enable                          
           =2 #define POWER_SUSEN__SHIFT         0x00 ///< Suspend Detection Enable                          
           =2 #define POWER_SUSEN__DISABLED      0x00 ///< Disable suspend detection. USB0 will ignore       
           =2                                         ///< suspend signaling on the bus.                     
           =2 #define POWER_SUSEN__ENABLED       0x01 ///< Enable suspend detection. USB0 will enter suspend 
           =2                                         ///< mode if it detects suspend signaling on the bus.  
           =2                                                                                                
           =2 #define POWER_SUSMD__BMASK         0x02 ///< Suspend Mode                                      
           =2 #define POWER_SUSMD__SHIFT         0x01 ///< Suspend Mode                                      
           =2 #define POWER_SUSMD__NOT_SUSPENDED 0x00 ///< USB0 not in suspend mode.                         
           =2 #define POWER_SUSMD__SUSPENDED     0x02 ///< USB0 in suspend mode.                             
           =2                                                                                                
           =2 #define POWER_RESUME__BMASK        0x04 ///< Force Resume                                      
           =2 #define POWER_RESUME__SHIFT        0x02 ///< Force Resume                                      
           =2 #define POWER_RESUME__START        0x04 ///< Generate resume signalling to create a remote     
           =2                                         ///< wakeup event.                                     
           =2                                                                                                
           =2 #define POWER_USBRST__BMASK        0x08 ///< Reset Detect                                      
           =2 #define POWER_USBRST__SHIFT        0x03 ///< Reset Detect                                      
           =2 #define POWER_USBRST__NOT_SET      0x00 ///< USB reset signalling not detected.                
           =2 #define POWER_USBRST__SET          0x08 ///< USB reset signalling detected.                    
           =2                                                                                                
           =2 #define POWER_USBINH__BMASK        0x10 ///< USB0 Inhibit                                      
           =2 #define POWER_USBINH__SHIFT        0x04 ///< USB0 Inhibit                                      
           =2 #define POWER_USBINH__ENABLED      0x00 ///< USB0 enabled.                                     
           =2 #define POWER_USBINH__DISABLED     0x10 ///< USB0 inhibited. All USB traffic is ignored.       
           =2                                                                                                
           =2 #define POWER_ISOUD__BMASK         0x80 ///< Isochronous Update Mode                           
           =2 #define POWER_ISOUD__SHIFT         0x07 ///< Isochronous Update Mode                           
           =2 #define POWER_ISOUD__IN_TOKEN      0x00 ///< When firmware writes INPRDY = 1, USB0 will send   
           =2                                         ///< the packet when the next IN token is received.    
           =2 #define POWER_ISOUD__SOF_TOKEN     0x80 ///< When firmware writes INPRDY = 1, USB0 will wait   
           =2                                         ///< for a SOF token before sending the packet. If an  
           =2                                         ///< IN token is received before a SOF token, USB0 will
           =2                                         ///< send a zero-length data packet.                   
           =2                                                                                                
           =2 //------------------------------------------------------------------------------
           =2 // USB0ADR Enums (USB0 Indirect Address @ 0x96)
           =2 //------------------------------------------------------------------------------
           =2 #define USB0ADR_USB0ADR__FMASK          0x3F ///< USB0 Indirect Register Address                    
           =2 #define USB0ADR_USB0ADR__SHIFT          0x00 ///< USB0 Indirect Register Address                    
           =2 #define USB0ADR_USB0ADR__FADDR          0x00 ///< Function Address.                                 
           =2 #define USB0ADR_USB0ADR__POWER          0x01 ///< Power Management.                                 
           =2 #define USB0ADR_USB0ADR__IN1INT         0x02 ///< Endpoint 0 and Endpoints 1-3 IN Interrupt Flags.  
           =2 #define USB0ADR_USB0ADR__OUT1INT        0x04 ///< Endpoints 1-3 OUT Interrupt Flags.                
           =2 #define USB0ADR_USB0ADR__CMINT          0x06 ///< Common USB Interrupt Flags.                       
           =2 #define USB0ADR_USB0ADR__IN1IE          0x07 ///< Endpoint 0 and Endpoints 1-3 IN Interrupt Enables.
           =2 #define USB0ADR_USB0ADR__OUT1IE         0x09 ///< Endpoints 1-3 OUT Interrupt Enables.              
           =2 #define USB0ADR_USB0ADR__CMIE           0x0B ///< Common USB Interrupt Enables.                     
           =2 #define USB0ADR_USB0ADR__FRAMEL         0x0C ///< Frame Number Low Byte.                            
           =2 #define USB0ADR_USB0ADR__FRAMEH         0x0D ///< Frame Number High Byte.                           
           =2 #define USB0ADR_USB0ADR__INDEX          0x0E ///< Endpoint Index Selection.                         
           =2 #define USB0ADR_USB0ADR__CLKREC         0x0F ///< Clock Recovery Control.                           
           =2 #define USB0ADR_USB0ADR__E0CSR_EINCSRL  0x11 ///< Endpoint 0 Control / Status, Endpoint IN Control /
           =2                                              ///< Status Low Byte.                                  
           =2 #define USB0ADR_USB0ADR__EINCSRH        0x12 ///< Endpoint IN Control / Status High Byte.           
           =2 #define USB0ADR_USB0ADR__EOUTCSRL       0x14 ///< Endpoint OUT Control / Status Low Byte.           
           =2 #define USB0ADR_USB0ADR__EOUTCSRH       0x15 ///< Endpoint OUT Control / Status High Byte.          
           =2 #define USB0ADR_USB0ADR__E0CNT_EOUTCNTL 0x16 ///< Number of Received Bytes in Endpoint 0 FIFO,      
C51 COMPILER V9.56.0.0   SPI_0                                                             10/28/2016 17:37:02 PAGE 160 

           =2                                              ///< Endpoint OUT Packet Count Low Byte.               
           =2 #define USB0ADR_USB0ADR__EOUTCNTH       0x17 ///< Endpoint OUT Packet Count High Byte.              
           =2 #define USB0ADR_USB0ADR__EENABLE        0x1E ///< Endpoint Enable.                                  
           =2 #define USB0ADR_USB0ADR__FIFO0          0x20 ///< Endpoint 0 FIFO.                                  
           =2 #define USB0ADR_USB0ADR__FIFO1          0x21 ///< Endpoint 1 FIFO.                                  
           =2 #define USB0ADR_USB0ADR__FIFO2          0x22 ///< Endpoint 2 FIFO.                                  
           =2 #define USB0ADR_USB0ADR__FIFO3          0x23 ///< Endpoint 3 FIFO.                                  
           =2                                                                                                     
           =2 #define USB0ADR_AUTORD__BMASK           0x40 ///< USB0 Register Auto-Read Flag                      
           =2 #define USB0ADR_AUTORD__SHIFT           0x06 ///< USB0 Register Auto-Read Flag                      
           =2 #define USB0ADR_AUTORD__DISABLED        0x00 ///< BUSY must be written manually for each USB0       
           =2                                              ///< indirect register read.                           
           =2 #define USB0ADR_AUTORD__ENABLED         0x40 ///< The next indirect register read will automatically
           =2                                              ///< be initiated when firmware reads USB0DAT (USBADDR 
           =2                                              ///< bits will not be changed).                        
           =2                                                                                                     
           =2 #define USB0ADR_BUSY__BMASK             0x80 ///< USB0 Register Read Busy Flag                      
           =2 #define USB0ADR_BUSY__SHIFT             0x07 ///< USB0 Register Read Busy Flag                      
           =2 #define USB0ADR_BUSY__NOT_SET           0x00 ///< A read is not in progress.                        
           =2 #define USB0ADR_BUSY__SET               0x80 ///< Initiate a read or a read is in progress.         
           =2                                                                                                     
           =2 //------------------------------------------------------------------------------
           =2 // USB0DAT Enums (USB0 Data @ 0x97)
           =2 //------------------------------------------------------------------------------
           =2 #define USB0DAT_USB0DAT__FMASK 0xFF ///< USB0 Data
           =2 #define USB0DAT_USB0DAT__SHIFT 0x00 ///< USB0 Data
           =2                                                   
           =2 //------------------------------------------------------------------------------
           =2 // USB0XCN Enums (USB0 Transceiver Control @ 0xD7)
           =2 //------------------------------------------------------------------------------
           =2 #define USB0XCN_Dn__BMASK                0x01 ///< D- Signal Status                                 
           =2 #define USB0XCN_Dn__SHIFT                0x00 ///< D- Signal Status                                 
           =2 #define USB0XCN_Dn__LOW                  0x00 ///< D- signal currently at logic 0.                  
           =2 #define USB0XCN_Dn__HIGH                 0x01 ///< D- signal currently at logic 1.                  
           =2                                                                                                     
           =2 #define USB0XCN_Dp__BMASK                0x02 ///< D+ Signal Status                                 
           =2 #define USB0XCN_Dp__SHIFT                0x01 ///< D+ Signal Status                                 
           =2 #define USB0XCN_Dp__LOW                  0x00 ///< D+ signal currently at logic 0.                  
           =2 #define USB0XCN_Dp__HIGH                 0x02 ///< D+ signal currently at logic 1.                  
           =2                                                                                                     
           =2 #define USB0XCN_DFREC__BMASK             0x04 ///< Differential Receiver                            
           =2 #define USB0XCN_DFREC__SHIFT             0x02 ///< Differential Receiver                            
           =2 #define USB0XCN_DFREC__DIFFERENTIAL_ZERO 0x00 ///< Differential 0 signalling on the bus.            
           =2 #define USB0XCN_DFREC__DIFFERENTIAL_ONE  0x04 ///< Differential 1 signalling on the bus.            
           =2                                                                                                     
           =2 #define USB0XCN_PHYTST__FMASK            0x18 ///< Physical Layer Test                              
           =2 #define USB0XCN_PHYTST__SHIFT            0x03 ///< Physical Layer Test                              
           =2 #define USB0XCN_PHYTST__MODE0            0x00 ///< Mode 0: Normal (non-test mode) (D+ = X, D- = X). 
           =2 #define USB0XCN_PHYTST__MODE1            0x08 ///< Mode 1: Differential 1 forced (D+ = 1, D- = 0).  
           =2 #define USB0XCN_PHYTST__MODE2            0x10 ///< Mode 2: Differential 0 forced (D+ = 0, D- = 1).  
           =2 #define USB0XCN_PHYTST__MODE3            0x18 ///< Mode 3: Single-Ended 0 forced (D+ = 0, D- = 0).  
           =2                                                                                                     
           =2 #define USB0XCN_SPEED__BMASK             0x20 ///< USB0 Speed Select                                
           =2 #define USB0XCN_SPEED__SHIFT             0x05 ///< USB0 Speed Select                                
           =2 #define USB0XCN_SPEED__LOW_SPEED         0x00 ///< USB0 operates as a Low Speed device. If enabled, 
           =2                                               ///< the internal pull-up resistor appears on the D-  
           =2                                               ///< line.                                            
           =2 #define USB0XCN_SPEED__FULL_SPEED        0x20 ///< USB0 operates as a Full Speed device. If enabled,
           =2                                               ///< the internal pull-up resistor appears on the D+  
           =2                                               ///< line.                                            
           =2                                                                                                     
           =2 #define USB0XCN_PHYEN__BMASK             0x40 ///< Physical Layer Enable                            
C51 COMPILER V9.56.0.0   SPI_0                                                             10/28/2016 17:37:02 PAGE 161 

           =2 #define USB0XCN_PHYEN__SHIFT             0x06 ///< Physical Layer Enable                            
           =2 #define USB0XCN_PHYEN__DISABLED          0x00 ///< Disable the USB0 physical layer transceiver      
           =2                                               ///< (suspend).                                       
           =2 #define USB0XCN_PHYEN__ENABLED           0x40 ///< Enable the USB0 physical layer transceiver       
           =2                                               ///< (normal).                                        
           =2                                                                                                     
           =2 #define USB0XCN_PREN__BMASK              0x80 ///< Internal Pull-up Resistor Enable                 
           =2 #define USB0XCN_PREN__SHIFT              0x07 ///< Internal Pull-up Resistor Enable                 
           =2 #define USB0XCN_PREN__PULL_UP_DISABLED   0x00 ///< Internal pull-up resistor disabled (device       
           =2                                               ///< effectively detached from USB network).          
           =2 #define USB0XCN_PREN__PULL_UP_ENABLED    0x80 ///< Internal pull-up resistor enabled when VBUS is   
           =2                                               ///< present (device attached to the USB network).    
           =2                                                                                                     
           =2 //------------------------------------------------------------------------------
           =2 // VDM0CN Enums (Supply Monitor Control @ 0xFF)
           =2 //------------------------------------------------------------------------------
           =2 #define VDM0CN_VDDSTAT__BMASK  0x40 ///< Supply Status                                   
           =2 #define VDM0CN_VDDSTAT__SHIFT  0x06 ///< Supply Status                                   
           =2 #define VDM0CN_VDDSTAT__BELOW  0x00 ///< VDD is at or below the supply monitor threshold.
           =2 #define VDM0CN_VDDSTAT__ABOVE  0x40 ///< VDD is above the supply monitor threshold.      
           =2                                                                                          
           =2 #define VDM0CN_VDMEN__BMASK    0x80 ///< Supply Monitor Enable                           
           =2 #define VDM0CN_VDMEN__SHIFT    0x07 ///< Supply Monitor Enable                           
           =2 #define VDM0CN_VDMEN__DISABLED 0x00 ///< Supply Monitor Disabled.                        
           =2 #define VDM0CN_VDMEN__ENABLED  0x80 ///< Supply Monitor Enabled.                         
           =2                                                                                          
           =2 //------------------------------------------------------------------------------
           =2 // REF0CN Enums (Voltage Reference Control @ 0xD1)
           =2 //------------------------------------------------------------------------------
           =2 #define REF0CN_REFBE__BMASK    0x01 ///< Internal Reference Buffer Enable                  
           =2 #define REF0CN_REFBE__SHIFT    0x00 ///< Internal Reference Buffer Enable                  
           =2 #define REF0CN_REFBE__DISABLED 0x00 ///< Disable the internal reference buffer.            
           =2 #define REF0CN_REFBE__ENABLED  0x01 ///< Enable the internal reference buffer. The internal
           =2                                     ///< voltage reference is driven on the VREF pin.      
           =2                                                                                            
           =2 #define REF0CN_TEMPE__BMASK    0x04 ///< Temperature Sensor Enable                         
           =2 #define REF0CN_TEMPE__SHIFT    0x02 ///< Temperature Sensor Enable                         
           =2 #define REF0CN_TEMPE__DISABLED 0x00 ///< Disable the internal Temperature Sensor.          
           =2 #define REF0CN_TEMPE__ENABLED  0x04 ///< Enable the internal Temperature Sensor.           
           =2                                                                                            
           =2 #define REF0CN_REFSL__BMASK    0x08 ///< Voltage Reference Select                          
           =2 #define REF0CN_REFSL__SHIFT    0x03 ///< Voltage Reference Select                          
           =2 #define REF0CN_REFSL__VREF     0x00 ///< Use the VREF pin as the voltage reference.        
           =2 #define REF0CN_REFSL__VDD      0x08 ///< Use VDD as the voltage reference.                 
           =2                                                                                            
           =2 #define REF0CN_REGOVR__BMASK   0x10 ///< Regulator Reference Override                      
           =2 #define REF0CN_REGOVR__SHIFT   0x04 ///< Regulator Reference Override                      
           =2 #define REF0CN_REGOVR__REFSL   0x00 ///< The REFSL bit selects the voltage reference       
           =2                                     ///< source.                                           
           =2 #define REF0CN_REGOVR__VREG    0x10 ///< Use the output of the internal regulator as the   
           =2                                     ///< voltage reference source.                         
           =2                                                                                            
           =2 #define REF0CN_REFBGS__BMASK   0x80 ///< Reference Buffer Gain Select                      
           =2 #define REF0CN_REFBGS__SHIFT   0x07 ///< Reference Buffer Gain Select                      
           =2 #define REF0CN_REFBGS__GAIN_2  0x00 ///< The on-chip voltage reference buffer gain is 2.   
           =2 #define REF0CN_REFBGS__GAIN_1  0x80 ///< The on-chip voltage reference buffer gain is 1.   
           =2                                                                                            
           =2 //------------------------------------------------------------------------------
           =2 // REG01CN Enums (Voltage Regulator Control @ 0xC9)
           =2 //------------------------------------------------------------------------------
           =2 #define REG01CN_REG1MD__BMASK     0x02 ///< VREG1 Voltage Regulator Mode                     
           =2 #define REG01CN_REG1MD__SHIFT     0x01 ///< VREG1 Voltage Regulator Mode                     
C51 COMPILER V9.56.0.0   SPI_0                                                             10/28/2016 17:37:02 PAGE 162 

           =2 #define REG01CN_REG1MD__NORMAL    0x00 ///< VREG1 Voltage Regulator in normal mode.          
           =2 #define REG01CN_REG1MD__LOW_POWER 0x02 ///< VREG1 Voltage Regulator in low power mode.       
           =2                                                                                              
           =2 #define REG01CN_STOPCF__BMASK     0x08 ///< VREG1 Stop and Shutdown Mode Configuration       
           =2 #define REG01CN_STOPCF__SHIFT     0x03 ///< VREG1 Stop and Shutdown Mode Configuration       
           =2 #define REG01CN_STOPCF__ACTIVE    0x00 ///< VREG1 Regulator is still active in stop mode. Any
           =2                                        ///< enabled reset source will reset the device.      
           =2 #define REG01CN_STOPCF__SHUTDOWN  0x08 ///< VREG1 Regulator is shut down in stop mode (device
           =2                                        ///< enters Shutdown mode). Only the RSTb pin or power
           =2                                        ///< cycle can reset the device.                      
           =2                                                                                              
           =2 #define REG01CN_REG0MD__BMASK     0x10 ///< VREG0 Voltage Regulator Mode                     
           =2 #define REG01CN_REG0MD__SHIFT     0x04 ///< VREG0 Voltage Regulator Mode                     
           =2 #define REG01CN_REG0MD__NORMAL    0x00 ///< VREG0 Voltage Regulator in normal mode.          
           =2 #define REG01CN_REG0MD__LOW_POWER 0x10 ///< VREG0 Voltage Regulator in low power mode.       
           =2                                                                                              
           =2 #define REG01CN_VBSTAT__BMASK     0x40 ///< VBUS Signal Status                               
           =2 #define REG01CN_VBSTAT__SHIFT     0x06 ///< VBUS Signal Status                               
           =2 #define REG01CN_VBSTAT__NOT_SET   0x00 ///< VBUS signal currently absent (device not attached
           =2                                        ///< to USB network).                                 
           =2 #define REG01CN_VBSTAT__SET       0x40 ///< VBUS signal currently present (device attached to
           =2                                        ///< USB network).                                    
           =2                                                                                              
           =2 #define REG01CN_REG0DIS__BMASK    0x80 ///< Voltage Regulator (REG0) Disable                 
           =2 #define REG01CN_REG0DIS__SHIFT    0x07 ///< Voltage Regulator (REG0) Disable                 
           =2 #define REG01CN_REG0DIS__ENABLED  0x00 ///< Enable the VREG0 Voltage Regulator.              
           =2 #define REG01CN_REG0DIS__DISABLED 0x80 ///< Disable the VREG0 Voltage Regulator.             
           =2                                                                                              
           =2 //------------------------------------------------------------------------------
           =2 // EMI0CF Enums (External Memory Configuration @ 0x85)
           =2 //------------------------------------------------------------------------------
           =2 #define EMI0CF_EALE__FMASK                    0x03 ///< ALE Pulse-Width Select                            
           =2 #define EMI0CF_EALE__SHIFT                    0x00 ///< ALE Pulse-Width Select                            
           =2 #define EMI0CF_EALE__1_CLOCK                  0x00 ///< ALE high and ALE low pulse width = 1 SYSCLK cycle.
           =2 #define EMI0CF_EALE__2_CLOCKS                 0x01 ///< ALE high and ALE low pulse width = 2 SYSCLK       
           =2                                                    ///< cycles.                                           
           =2 #define EMI0CF_EALE__3_CLOCKS                 0x02 ///< ALE high and ALE low pulse width = 3 SYSCLK       
           =2                                                    ///< cycles.                                           
           =2 #define EMI0CF_EALE__4_CLOCKS                 0x03 ///< ALE high and ALE low pulse width = 4 SYSCLK       
           =2                                                    ///< cycles.                                           
           =2                                                                                                           
           =2 #define EMI0CF_EMD__FMASK                     0x0C ///< EMIF Operating Mode Select                        
           =2 #define EMI0CF_EMD__SHIFT                     0x02 ///< EMIF Operating Mode Select                        
           =2 #define EMI0CF_EMD__INTERNAL_ONLY             0x00 ///< Internal Only: MOVX accesses on-chip XRAM only.   
           =2                                                    ///< All effective addresses alias to on-chip memory   
           =2                                                    ///< space.                                            
           =2 #define EMI0CF_EMD__SPLIT_WITHOUT_BANK_SELECT 0x04 ///< Split Mode without Bank Select: Accesses below the
           =2                                                    ///< internal XRAM boundary are directed on-chip.      
           =2                                                    ///< Accesses above the internal XRAM boundary are     
           =2                                                    ///< directed off-chip. 8-bit off-chip MOVX operations 
           =2                                                    ///< use the current contents of the Address high port 
           =2                                                    ///< latches to resolve the upper address byte. To     
           =2                                                    ///< access off chip space, EMI0CN must be set to a    
           =2                                                    ///< page that is not contained in the on-chip address 
           =2                                                    ///< space.                                            
           =2 #define EMI0CF_EMD__SPLIT_WITH_BANK_SELECT    0x08 ///< Split Mode with Bank Select: Accesses below the   
           =2                                                    ///< internal XRAM boundary are directed on-chip.      
           =2                                                    ///< Accesses above the internal XRAM boundary are     
           =2                                                    ///< directed off-chip. 8-bit off-chip MOVX operations 
           =2                                                    ///< uses the contents of EMI0CN to determine the high-
           =2                                                    ///< byte of the address.                              
           =2 #define EMI0CF_EMD__EXTERNAL_ONLY             0x0C ///< External Only: MOVX accesses off-chip XRAM only.  
C51 COMPILER V9.56.0.0   SPI_0                                                             10/28/2016 17:37:02 PAGE 163 

           =2                                                    ///< On-chip XRAM is not visible to the core.          
           =2                                                                                                           
           =2 #define EMI0CF_MUXMD__BMASK                   0x10 ///< EMIF Multiplex Mode Select                        
           =2 #define EMI0CF_MUXMD__SHIFT                   0x04 ///< EMIF Multiplex Mode Select                        
           =2 #define EMI0CF_MUXMD__MULTIPLEXED             0x00 ///< EMIF operates in multiplexed address/data mode.   
           =2 #define EMI0CF_MUXMD__NON_MULTIPLEXED         0x10 ///< EMIF operates in non-multiplexed mode (separate   
           =2                                                    ///< address and data pins).                           
           =2                                                                                                           
           =2 #define EMI0CF_USBFAE__BMASK                  0x40 ///< USB FIFO Access Enable                            
           =2 #define EMI0CF_USBFAE__SHIFT                  0x06 ///< USB FIFO Access Enable                            
           =2 #define EMI0CF_USBFAE__FIFO_ACCESS_DISABLED   0x00 ///< USB FIFO RAM not available through MOVX           
           =2                                                    ///< instructions.                                     
           =2 #define EMI0CF_USBFAE__FIFO_ACCESS_ENABLED    0x40 ///< USB FIFO RAM available using MOVX instructions.   
           =2                                                    ///< The 1 KB of USB RAM will be mapped in XRAM space  
           =2                                                    ///< at addresses 0x0400 to 0x07FF. The USB clock must 
           =2                                                    ///< be active and greater than or equal to twice the  
           =2                                                    ///< SYSCLK (USBCLK > 2 x SYSCLK) to access this area  
           =2                                                    ///< with MOVX instructions.                           
           =2                                                                                                           
           =2 //------------------------------------------------------------------------------
           =2 // EMI0CN Enums (External Memory Interface Control @ 0xAA)
           =2 //------------------------------------------------------------------------------
           =2 #define EMI0CN_PGSEL__FMASK 0xFF ///< XRAM Page Select
           =2 #define EMI0CN_PGSEL__SHIFT 0x00 ///< XRAM Page Select
           =2                                                       
           =2 //------------------------------------------------------------------------------
           =2 // EMI0TC Enums (External Memory Timing Control @ 0x84)
           =2 //------------------------------------------------------------------------------
           =2 #define EMI0TC_AHOLD__FMASK      0x03 ///< EMIF Address Hold Time                      
           =2 #define EMI0TC_AHOLD__SHIFT      0x00 ///< EMIF Address Hold Time                      
           =2 #define EMI0TC_AHOLD__0_CLOCKS   0x00 ///< Address hold time = 0 SYSCLK cycles.        
           =2 #define EMI0TC_AHOLD__1_CLOCK    0x01 ///< Address hold time = 1 SYSCLK cycle.         
           =2 #define EMI0TC_AHOLD__2_CLOCKS   0x02 ///< Address hold time = 2 SYSCLK cycles.        
           =2 #define EMI0TC_AHOLD__3_CLOCKS   0x03 ///< Address hold time = 3 SYSCLK cycles.        
           =2                                                                                        
           =2 #define EMI0TC_PWIDTH__FMASK     0x3C ///< EMIF /WR and /RD Pulse-Width Control        
           =2 #define EMI0TC_PWIDTH__SHIFT     0x02 ///< EMIF /WR and /RD Pulse-Width Control        
           =2 #define EMI0TC_PWIDTH__1_CLOCK   0x00 ///< /WR and /RD pulse width is 1 SYSCLK cycle.  
           =2 #define EMI0TC_PWIDTH__2_CLOCKS  0x04 ///< /WR and /RD pulse width is 2 SYSCLK cycles. 
           =2 #define EMI0TC_PWIDTH__3_CLOCKS  0x08 ///< /WR and /RD pulse width is 3 SYSCLK cycles. 
           =2 #define EMI0TC_PWIDTH__4_CLOCKS  0x0C ///< /WR and /RD pulse width is 4 SYSCLK cycles. 
           =2 #define EMI0TC_PWIDTH__5_CLOCKS  0x10 ///< /WR and /RD pulse width is 5 SYSCLK cycles. 
           =2 #define EMI0TC_PWIDTH__6_CLOCKS  0x14 ///< /WR and /RD pulse width is 6 SYSCLK cycles. 
           =2 #define EMI0TC_PWIDTH__7_CLOCKS  0x18 ///< /WR and /RD pulse width is 7 SYSCLK cycles. 
           =2 #define EMI0TC_PWIDTH__8_CLOCKS  0x1C ///< /WR and /RD pulse width is 8 SYSCLK cycles. 
           =2 #define EMI0TC_PWIDTH__9_CLOCKS  0x20 ///< /WR and /RD pulse width is 9 SYSCLK cycles. 
           =2 #define EMI0TC_PWIDTH__10_CLOCKS 0x24 ///< /WR and /RD pulse width is 10 SYSCLK cycles.
           =2 #define EMI0TC_PWIDTH__11_CLOCKS 0x28 ///< /WR and /RD pulse width is 11 SYSCLK cycles.
           =2 #define EMI0TC_PWIDTH__12_CLOCKS 0x2C ///< /WR and /RD pulse width is 12 SYSCLK cycles.
           =2 #define EMI0TC_PWIDTH__13_CLOCKS 0x30 ///< /WR and /RD pulse width is 13 SYSCLK cycles.
           =2 #define EMI0TC_PWIDTH__14_CLOCKS 0x34 ///< /WR and /RD pulse width is 14 SYSCLK cycles.
           =2 #define EMI0TC_PWIDTH__15_CLOCKS 0x38 ///< /WR and /RD pulse width is 15 SYSCLK cycles.
           =2 #define EMI0TC_PWIDTH__16_CLOCKS 0x3C ///< /WR and /RD pulse width is 16 SYSCLK cycles.
           =2                                                                                        
           =2 #define EMI0TC_ASETUP__FMASK     0xC0 ///< EMIF Address Setup Time                     
           =2 #define EMI0TC_ASETUP__SHIFT     0x06 ///< EMIF Address Setup Time                     
           =2 #define EMI0TC_ASETUP__0_CLOCKS  0x00 ///< Address setup time = 0 SYSCLK cycles.       
           =2 #define EMI0TC_ASETUP__1_CLOCK   0x40 ///< Address setup time = 1 SYSCLK cycle.        
           =2 #define EMI0TC_ASETUP__2_CLOCKS  0x80 ///< Address setup time = 2 SYSCLK cycles.       
           =2 #define EMI0TC_ASETUP__3_CLOCKS  0xC0 ///< Address setup time = 3 SYSCLK cycles.       
           =2                                                                                        
           =2 #endif // SI_EFM8UB2_REGISTER_ENUMS_H
C51 COMPILER V9.56.0.0   SPI_0                                                             10/28/2016 17:37:02 PAGE 164 

3982      =2  //-eof--------------------------------------------------------------------------
3983      =2  
  12      =1  
  13      =1  /**************************************************************************//**
  14      =1   *
  15      =1   * @addtogroup spi_0_group SPI0 Driver
  16      =1   * @{
  17      =1   *
  18      =1   * @brief Peripheral driver for SPI 0
  19      =1   *
  20      =1   * # Introduction #
  21      =1   *
  22      =1   * This module provides an API for using the SPI0 peripheral.  There is a
  23      =1   * basic API to provide simple access to the SPI features, and a more advanced
  24      =1   * buffered API that provides interrupt based transfers.  The user can also
  25      =1   * choose to configure the SPI peripheral at run-time using the initialization
  26      =1   * API or to bypass the initialization API and configure the peripheral during
  27      =1   * a central system initialization function.
  28      =1   *
  29      =1   * ## Multibyte Transfers ##
  30      =1   *
  31      =1   * There are two methods of performing multibyte transfers, using a polling
  32      =1   * (blocking) method or an interrupt (non-blocking) method.  The setup and
  33      =1   * function call signature is the same for both.  In each case the caller
  34      =1   * provides buffers for transmit and receive data.  The transmit data buffer
  35      =1   * must be pre-filled with the data to be sent, while the receive buffer will
  36      =1   * be filled with received data bytes.  The caller must provide pointers to
  37      =1   * buffers of sufficient size to complete the transfer.
  38      =1   *
  39      =1   * If you want to only perform a transfer in one direction, then you can supply
  40      =1   * a NULL pointer for the unused buffer.  For transmit-only transfers, all
  41      =1   * received bytes are discarded.  For receive-only transfers, zero bytes will
  42      =1   * be transmitted.
  43      =1   *
  44      =1   * For bidirectional transfers, the same number of bytes are transmitted and
  45      =1   * received.  For a transfer where the number of transmitted and received bytes
  46      =1   * are not the same, you must chain together transfers as needed to get the
  47      =1   * number of bytes needed in each direction.
  48      =1   *
  49      =1   * ## Chip Select ##
  50      =1   *
  51      =1   * The SPI interface can be used in 3-wire or 4-wire mode.  If 3-wire mode
  52      =1   * is used, then the SPI interface can be used with no chip select, or the
  53      =1   * application can use a separate GPIO for the chip select.  For example, if
  54      =1   * a SPI master needs to control several SPI slaves, then you would choose
  55      =1   * 3-wire mode, and use a separate GPIO as the chip select for each SPI
  56      =1   * slave.  In this case, the application must control the GPIO as chip select,
  57      =1   * asserting it before starting a transfer and de-asserting when the transfer
  58      =1   * is complete.
  59      =1   *
  60      =1   * If 4-wire mode is used, then the chip select is managed by the driver and
  61      =1   * the peripheral.  When a SPI master, the chip select signal (NSS) will be
  62      =1   * asserted automatically at the start of the transfer and de-asserted when
  63      =1   * complete.  If a SPI slave, then the NSS signal is monitored and used to
  64      =1   * gate SPI transfers.
  65      =1   *
  66      =1   *****************************************************************************/
  67      =1  
  68      =1  // The following section is used to document configuration options
  69      =1  
  70      =1  /**************************************************************************//**
  71      =1   * @addtogroup spi0_config SPI Driver Configuration
C51 COMPILER V9.56.0.0   SPI_0                                                             10/28/2016 17:37:02 PAGE 165 

  72      =1   * @{
  73      =1   *
  74      =1   * @brief Driver configuration constants read from SI_EFM8UB2_Defs.h
  75      =1   *
  76      =1   * This peripheral driver will look for configuration constants in
  77      =1   * **SI_EFM8UB2_Defs.h**. This file is provided/written by the user and should be
  78      =1   * located in a directory that is part of the include path.
  79      =1   *
  80      =1   *****************************************************************************/
  81      =1  
  82      =1  /**************************************************************************//**
  83      =1   * @def EFM8PDL_SPI0_USE_BUFFER
  84      =1   * @brief Controls inclusion of SPI0 Buffer Access API.
  85      =1   *
  86      =1   * The Buffer Access API includes code in the SPI driver to buffer incoming
  87      =1   * and outgoing SPI data including an interrupt handler that makes callbacks.
  88      =1   * When set to '1' the SPI0 Buffered Access API is included in the driver.
  89      =1   *
  90      =1   * @note When this feature is enabled, a SPI0 interrupt handler will be
  91      =1   * included in the driver.  If you want to manage SPI interrupts with
  92      =1   * application code, then this option should be disabled.
  93      =1   *
  94      =1   * The default setting is '0' and may be overridden by defining the value
  95      =1   * in 'SI_EFM8UB2_Defs.h'.
  96      =1   *****************************************************************************/
  97      =1  
  98      =1  /**************************************************************************//**
  99      =1   * @def EFM8PDL_SPI0_USE_ERR_CALLBACK
 100      =1   * @brief Controls whether buffered API uses an error callback function.
 101      =1   *
 102      =1   * This option is only meaningful if @ref EFM8PDL_SPI0_USE_BUFFER is enabled.
 103      =1   * If this option is enabled, when an error is detected in the SPI interrupt
 104      =1   * handler, the callback function SPI0_transferErrorCallback() will be called.
 105      =1   * If this option is not enabled, then the error callback will not be called
 106      =1   * and it does not need to be provided by the application.
 107      =1   *
 108      =1   * @note This feature is only useful if the SPI peripheral is to be used
 109      =1   * in slave mode.
 110      =1   *
 111      =1   * The default setting is '0' and may be overridden by defining the value
 112      =1   * in 'SI_EFM8UB2_Defs.h'.
 113      =1   *****************************************************************************/
 114      =1  
 115      =1  /**************************************************************************//**
 116      =1   * @def EFM8PDL_SPI0_USE_PIPELINE
 117      =1   * @brief Controls buffered mode data pipelining.
 118      =1   *
 119      =1   * When using a buffered transfer with SPI0_transfer() the data can be
 120      =1   * pipelined such that the driver attempts to keep the transmit buffer as
 121      =1   * full as possible.  This will use the full bandwidth of the hardware
 122      =1   * peripheral, but can cause data loss if system interrupt latency is too
 123      =1   * high.  The SPI interrupt must be serviced within 2 byte-times or received
 124      =1   * data can be lost.  If this feature is disabled, then writes and reads
 125      =1   * will be matched to ensure that no receive data is lost.  However then
 126      =1   * there can be irregular timing gaps between bytes and the full bandwidth
 127      =1   * of the SPI bus is not used.
 128      =1   *
 129      =1   * @note This applies to master mode.  If you intend to use slave mode,
 130      =1   * then this feature must be turned on.
 131      =1   *
 132      =1   * If you are using slave mode then this feature should be enabled.  If you
 133      =1   * are only using master mode then you can leave this disabled if you are
C51 COMPILER V9.56.0.0   SPI_0                                                             10/28/2016 17:37:02 PAGE 166 

 134      =1   * concerned about interrupt latency in your system and SPI bus performance
 135      =1   * is not important.  You can enable this if the interrupt latency in your
 136      =1   * system is not too high, or if the SPI interrupt priority is set high
 137      =1   * enough that it cannot miss SPI interrupts.
 138      =1   *
 139      =1   * The default setting is '0' and may be overridden by defining the value
 140      =1   * in 'SI_EFM8UB2_Defs.h'.
 141      =1   *****************************************************************************/
 142      =1  
 143      =1  /**************************************************************************//**
 144      =1   * @def EFM8PDL_SPI0_RX_SEGTYPE
 145      =1   * @brief Controls the type of pointer used for receive buffers.
 146      =1   *
 147      =1   * Sets the memory segment type for the receive buffer pointer when using
 148      =1   * SPI0_pollTransfer() or SPI0_transfer().  Valid values are:
 149      =1   *
 150      =1   * - SI_SEG_XDATA (default)
 151      =1   * - SI_SEG_PDATA
 152      =1   * - SI_SEG_IDATA
 153      =1   * - SI_SEG_CODE
 154      =1   * - SI_SEG_GENERIC
 155      =1   *
 156      =1   * @warning Use of generic pointers will increase the code size and reduce
 157      =1   * performance of buffering functions.  The specific memory segment should
 158      =1   * always be specified if possible.
 159      =1   *****************************************************************************/
 160      =1  
 161      =1  /**************************************************************************//**
 162      =1   * @def EFM8PDL_SPI0_TX_SEGTYPE
 163      =1   * @brief Controls the type of pointer used for transmit buffers.
 164      =1   *
 165      =1   * Sets the memory segment type for the transmit buffer pointer when using
 166      =1   * SPI0_pollTransfer() or SPI0_transfer().  Valid values are:
 167      =1   *
 168      =1   * - SI_SEG_XDATA (default)
 169      =1   * - SI_SEG_PDATA
 170      =1   * - SI_SEG_IDATA
 171      =1   * - SI_SEG_CODE
 172      =1   * - SI_SEG_GENERIC
 173      =1   *****************************************************************************/
 174      =1  
 175      =1  /**  @} (end addtogroup spi0_config */
 176      =1  
 177      =1  // Option macro default values
 178      =1  
 179      =1  #ifdef IS_DOXYGEN
           =1 #define EFM8PDL_SPI0_USE_BUFFER 1
           =1 #define EFM8PDL_SPI0_USE_ERR_CALLBACK 1
           =1 #endif
 183      =1  
 184      =1  #ifndef EFM8PDL_SPI0_USE_BUFFER
 185      =1  #define EFM8PDL_SPI0_USE_BUFFER 0
 186      =1  #endif
 187      =1  #ifndef EFM8PDL_SPI0_TX_SEGTYPE
 188      =1  #define EFM8PDL_SPI0_TX_SEGTYPE SI_SEG_XDATA
 189      =1  #endif
 190      =1  #ifndef EFM8PDL_SPI0_RX_SEGTYPE
 191      =1  #define EFM8PDL_SPI0_RX_SEGTYPE SI_SEG_XDATA
 192      =1  #endif
 193      =1  #ifndef EFM8PDL_SPI0_USE_PIPELINE
 194      =1  #define EFM8PDL_SPI0_USE_PIPELINE 0
 195      =1  #endif
C51 COMPILER V9.56.0.0   SPI_0                                                             10/28/2016 17:37:02 PAGE 167 

 196      =1  #ifndef EFM8PDL_SPI0_USE_ERR_CALLBACK
 197      =1  #define EFM8PDL_SPI0_USE_ERR_CALLBACK 0
 198      =1  #endif
 199      =1  
 200      =1  // Runtime API
 201      =1  
 202      =1  /**************************************************************************//**
 203      =1   * @addtogroup spi0_runtime SPI0 Runtime API
 204      =1   * @{
 205      =1   *****************************************************************************/
 206      =1  
 207      =1  /**************************************************************************//**
 208      =1   * @addtogroup spi0_if SPI Interrupt Flag Enums
 209      =1   *
 210      =1   * The following macros define the interrupt bits in the SPI interrupt flag
 211      =1   * register.  These value are used with the functions SPI0_getIntFlags() and
 212      =1   * SPI0_clearIntFlags().
 213      =1   *
 214      =1   * @{
 215      =1   *****************************************************************************/
 216      =1  
 217      =1  /// SPI interrupt flag.  This flag will be set when a transfer is complete.
 218      =1  #define SPI0_INT_IF SPI0CN0_SPIF__BMASK
 219      =1  
 220      =1  /// Write collision interrupt flag.  This flag will be set when new data
 221      =1  /// is written before the prior transfer is complete.
 222      =1  #define SPI0_WCOL_IF SPI0CN0_WCOL__BMASK
 223      =1  
 224      =1  /// Mode fault interrupt flag.  This flag will be set when the peripheral
 225      =1  /// is configured for master mode, but another SPI master tries to drive
 226      =1  /// the select (NSS) signal.
 227      =1  #define SPI0_MODF_IF SPI0CN0_MODF__BMASK
 228      =1  
 229      =1  /// Receive overrun interrupt flag.  This flag is used only in slave mode
 230      =1  /// and indicates that a new byte was received before the prior received
 231      =1  /// byte was read from the receive buffer.
 232      =1  #define SPI0_RXOVR_IF SPI0CN0_RXOVRN__BMASK
 233      =1  
 234      =1  /**  @} (end addtogroup spi0_if) */
 235      =1  
 236      =1  /**************************************************************************//**
 237      =1   * Return the value of the interrupt flags.
 238      =1   *
 239      =1   * @return The state of the interrupt flags register.  This will be non-zero
 240      =1   * if any interrupt bits are set.
 241      =1   *
 242      =1   * This function returns the value of the SPI interrupt flags.  The returned
 243      =1   * value can be tested against the [Interrupt flag enums](@ref spi0_if ) by
 244      =1   * performing a logical AND of an enum value and the interrupt flags value.
 245      =1   * It is possible that multiple flags can be set so all values should be
 246      =1   * checked:
 247      =1   *
 248      =1   * ~~~~~~~~.c
 249      =1   * uint8_t intFlags = SPI0_getIntFlags();
 250      =1   *
 251      =1   * if (intFlags & SPI0_INT_IF)
 252      =1   * {
 253      =1   *   // handle transfer complete interrupt
 254      =1   * }
 255      =1   * if (intFlags & SPI0_RXOVR_IF)
 256      =1   * {
 257      =1   *   // handle receive overflow
C51 COMPILER V9.56.0.0   SPI_0                                                             10/28/2016 17:37:02 PAGE 168 

 258      =1   * }
 259      =1   *
 260      =1   * // Clear interrupts
 261      =1   * SPI0_clearIntFlags(intFlags);
 262      =1   * ~~~~~~~~
 263      =1   *
 264      =1   * @note This function is implemented as a macro.
 265      =1   *****************************************************************************/
 266      =1  #if defined(IS_DOXYGEN)
           =1 extern uint8_t SPI0_getIntFlags(void);
           =1 #else
 269      =1  #define SPI0_getIntFlags(x) (SPI0CN0 & 0xF0)
 270      =1  #endif
 271      =1  
 272      =1  /**************************************************************************//**
 273      =1   * Clear interrupt flags.
 274      =1   *
 275      =1   * @param flags is the bitmask of all interrupt flags to clear
 276      =1   *
 277      =1   * This function will clear specific interrupt flags.  The _flags_ parameter
 278      =1   * is a bit mask of all interrupt flags to clear.  It is the logical OR
 279      =1   * of one or more [Interrupt flag enums](@ref spi0_if).
 280      =1   *
 281      =1   * @note This function is implemented as a macro.
 282      =1   *****************************************************************************/
 283      =1  #if defined(IS_DOXYGEN)
           =1 extern void SPI0_clearIntFlags(uint8_t flags);
           =1 #else
 286      =1  #define SPI0_clearIntFlags(flags)                                             \
 287      =1              do {SPI0CN0 = (SPI0CN0 & (~flags | 0x0F));} while (0)
 288      =1  #endif
 289      =1  
 290      =1  /**************************************************************************//**
 291      =1   * Enable SPI interrupts.
 292      =1   *
 293      =1   * @note This function is implemented as a macro.
 294      =1   *****************************************************************************/
 295      =1  #if defined(IS_DOXYGEN)
           =1 extern bool SPI0_enableInt(void);
           =1 #else
 298      =1  #define SPI0_enableInt(x) IE_ESPI0 = 1
 299      =1  #endif
 300      =1  
 301      =1  /**************************************************************************//**
 302      =1   * Disable SPI interrupts.
 303      =1   *
 304      =1   * @note This function is implemented as a macro.
 305      =1   *****************************************************************************/
 306      =1  #if defined(IS_DOXYGEN)
           =1 extern bool SPI0_disableInt(void);
           =1 #else
 309      =1  #define SPI0_disableInt(x) IE_ESPI0 = 0
 310      =1  #endif
 311      =1  
 312      =1  /**************************************************************************//**
 313      =1   * Write a byte to the SPI transmit buffer.
 314      =1   *
 315      =1   * @param value Data byte to transmit
 316      =1   * @return **True** if the byte was written, or **false** if the transmit
 317      =1   * buffer was not empty.
 318      =1   *
 319      =1   * This function will write the byte to the SPI transmit register.  If the
C51 COMPILER V9.56.0.0   SPI_0                                                             10/28/2016 17:37:02 PAGE 169 

 320      =1   * transmit buffer is full then the write will fail and the function
 321      =1   * will return **false**.  If SPI interrupts are enabled, then this will also
 322      =1   * cause a "write collision" interrupt.
 323      =1   *****************************************************************************/
 324      =1  extern bool SPI0_writeByte(uint8_t value);
 325      =1  
 326      =1  /**************************************************************************//**
 327      =1   * Write a byte to the SPI transmit buffer using polling.
 328      =1   *
 329      =1   * @param value Data byte to transmit
 330      =1   *
 331      =1   * This function will wait until the SPI transmit register is not full and then
 332      =1   * write the value to the register.
 333      =1   *****************************************************************************/
 334      =1  extern void SPI0_pollWriteByte(uint8_t value);
 335      =1  
 336      =1  /**************************************************************************//**
 337      =1   * Read the last received byte from the SPI receive buffer.
 338      =1   *
 339      =1   * @return The last byte received into the SPI receive buffer.
 340      =1   *
 341      =1   * This function will read and return the most recent byte from the SPI
 342      =1   * receive buffer register.  If no new byte has been received since the last
 343      =1   * read, then the same value is return again.
 344      =1   *
 345      =1   * @note This function is implemented as a macro.
 346      =1   *****************************************************************************/
 347      =1  #if defined(IS_DOXYGEN)
           =1 extern uint8_t SPI0_readByte(void);
           =1 #else
 350      =1  #define SPI0_readByte(x) (SPI0DAT)
 351      =1  #endif
 352      =1  
 353      =1  /**************************************************************************//**
 354      =1   * Define SPI transfer direction.  The direction can be RX-only, TX-only,
 355      =1   * or RX/TX.
 356      =1   *****************************************************************************/
 357      =1  typedef enum
 358      =1  {
 359      =1    SPI0_TRANSFER_RX = 1,     /**< RX only */
 360      =1    SPI0_TRANSFER_TX = 2,     /**< TX only */
 361      =1    SPI0_TRANSFER_RXTX = 3,   /**< both directions */
 362      =1  } SPI0_TransferDirection_t;
 363      =1  
 364      =1  /**************************************************************************//**
 365      =1   * Perform multibyte SPI transfer using polling.
 366      =1   *
 367      =1   * @param pTxBuffer The buffer holding the data to transmit.
 368      =1   * @param pRxBuffer The buffer to use for holding received data.
 369      =1   * @param dir The direction of the transfer, RX, TX, or RXTX.
 370      =1   * @param xferCount The number of bytes to transfer.
 371      =1   *
 372      =1   * This function is used to perform a SPI multibyte receive and/or transmit
 373      =1   * operation.  It will block using polling until all the bytes have been
 374      =1   * transferred.  The caller supplies transmit and receive buffers and a count
 375      =1   * of the number of bytes to transfer.  The _xferCount_ must not be larger
 376      =1   * than the space in either buffer.
 377      =1   *
 378      =1   * The _dir_ argument is used to specify the direction of the transfer.
 379      =1   * If transfer is needed only in one direction, then the other buffer can
 380      =1   * be **NULL**.  For example, to only transmit some bytes and not receive any,
 381      =1   * the _dir_ argument should be SPI0_TRANSFER_TX, and the _pRxBuffer_
C51 COMPILER V9.56.0.0   SPI_0                                                             10/28/2016 17:37:02 PAGE 170 

 382      =1   * argument can be **NULL**.
 383      =1   *
 384      =1   * Because SPI always transfers in both directions, bytes will be transmitted
 385      =1   * and received for all SPI transfers.  For a transmit-only operation,
 386      =1   * _dir_ should be set to SPI0_TRANSFER_TX and _pRxBuffer_ can be set to
 387      =1   * **NULL** and all bytes received from the interface will be discarded.
 388      =1   * For a receive-only operation, _dir_ should be set to SPI0_TRANSFER_RX,
 389      =1   * _pTxBuffer_ can be set to **NULL** and zeroes will be transmitted on the
 390      =1   * SPI interface while all received bytes are stored.
 391      =1   *
 392      =1   * __Example__
 393      =1   *
 394      =1   * ~~~~~~~~.c
 395      =1   * // Declare transmit and receive buffers in XDATA, each 16 bytes
 396      =1   * SI_SEGMENT_VARIABLE(myTxBuf[16], uint8_t, SI_SEG_XDATA);
 397      =1   * SI_SEGMENT_VARIABLE(myRxBuf[16], uint8_t, SI_SEG_XDATA);
 398      =1   *
 399      =1   * // Transfer 16 bytes in and out
 400      =1   * SPI0_pollTransfer(myTxBuf, myRxBuf, SPI0_TRANSFER_RXTX, 16);
 401      =1   *
 402      =1   * // Receive 12 bytes, and send none
 403      =1   * // (This will cause 12 zero bytes to be sent)
 404      =1   * SPI0_pollTransfer(NULL, myRxBuf, SPI0_TRANSFER_RX, 12);
 405      =1   * ~~~~~~~~
 406      =1   *
 407      =1   * @note The memory type of the TX and RX buffers much match the type
 408      =1   * of the configuration macros @ref EFM8PDL_SPI0_TX_SEGTYPE and
 409      =1   * @ref EFM8PDL_SPI0_RX_SEGTYPE.
 410      =1   *
 411      =1   * @note If using slave mode and non-zero is returned, there could still
 412      =1   * be bytes remaining in the transmit buffer.  In this case you should
 413      =1   * reset and re-init the SPI.
 414      =1   *
 415      =1   * @return The number of bytes remaining to transfer.  This should almost
 416      =1   * always be 0, meaning that all the bytes have been transferred.  It could
 417      =1   * be non-zero if the SPI is configured for 4-wire slave mode, and the
 418      =1   * master de-asserted the chip select in the middle of a transfer.  In
 419      =1   * this case the function will return with the number of bytes that were
 420      =1   * not transferred.
 421      =1   *****************************************************************************/
 422      =1  extern uint8_t
 423      =1  SPI0_pollTransfer(SI_VARIABLE_SEGMENT_POINTER(pTxBuffer, uint8_t, EFM8PDL_SPI0_TX_SEGTYPE),
 424      =1                    SI_VARIABLE_SEGMENT_POINTER(pRxBuffer, uint8_t, EFM8PDL_SPI0_RX_SEGTYPE),
 425      =1                    SPI0_TransferDirection_t dir, uint8_t xferCount);
 426      =1  
 427      =1  /**************************************************************************//**
 428      =1   * Check if SPI transmit register is full.
 429      =1   *
 430      =1   * @return __True__ if the SPI TX buffer is full and can not take another byte.
 431      =1   *
 432      =1   * @note This function is implemented as a macro.
 433      =1   *****************************************************************************/
 434      =1  #if defined(IS_DOXYGEN)
           =1 extern bool SPI0_isTxFull(void);
           =1 #else
 437      =1  #define SPI0_isTxFull(x) (!((bool)(SPI0CN0_TXBMT)))
 438      =1  #endif
 439      =1  
 440      =1  /**************************************************************************//**
 441      =1   * Check if SPI is busy with a transfer.
 442      =1   *
 443      =1   * @return __True__ if a SPI transfer is in progress.
C51 COMPILER V9.56.0.0   SPI_0                                                             10/28/2016 17:37:02 PAGE 171 

 444      =1   *****************************************************************************/
 445      =1  extern bool SPI0_isBusy(void);
 446      =1  
 447      =1  /**************************************************************************//**
 448      =1   * Check if SPI slave is selected (assumes SPI is slave mode).
 449      =1   *
 450      =1   * @return __True__ if this SPI slave is selected.
 451      =1   *
 452      =1   * @note This function is only valid for SPI slave mode.
 453      =1   * @note This function is implemented as a macro.
 454      =1   *****************************************************************************/
 455      =1  #if defined(IS_DOXYGEN)
           =1 extern bool SPI0_isSlaveSelected(void);
           =1 #else
 458      =1  #define SPI0_isSlaveSelected(x) ((bool)(SPI0CFG & 0x8))
 459      =1  #endif
 460      =1  
 461      =1  /**************************************************************************//**
 462      =1   * Check if SPI slave shift register is empty.
 463      =1   *
 464      =1   * @return __True__ if this SPI slave shift register is empty.
 465      =1   *
 466      =1   * @note This function is only valid for SPI slave mode.
 467      =1   * @note This function is implemented as a macro.
 468      =1   *****************************************************************************/
 469      =1  #if defined(IS_DOXYGEN)
           =1 extern bool SPI0_isShiftEmpty(void);
           =1 #else
 472      =1  #define SPI0_isShiftEmpty(x) ((bool)(SPI0CFG & 0x2))
 473      =1  #endif
 474      =1  
 475      =1  /**************************************************************************//**
 476      =1   * Check if SPI slave receive buffer is empty.
 477      =1   *
 478      =1   * @return __True__ if this SPI slave RX buffer is empty.
 479      =1   *
 480      =1   * @note This function is only valid for SPI slave mode.
 481      =1   * @note This function is implemented as a macro.
 482      =1   *****************************************************************************/
 483      =1  #if defined(IS_DOXYGEN)
           =1 extern bool SPI0_isRxEmpty(void);
           =1 #else
 486      =1  #define SPI0_isRxEmpty(x) ((bool)(SPI0CFG & 0x1))
 487      =1  #endif
 488      =1  
 489      =1  /**  @} (end addtogroup spi0_runtime) */
 490      =1  
 491      =1  /**************************************************************************//**
 492      =1   * @addtogroup spi0_init SPI0 Initialization API
 493      =1   *
 494      =1   * The following functions are part of the SPI initialization API.  These
 495      =1   * functions are used to configure the SPI peripheral at run-time.  It is
 496      =1   * possible to also configure the SPI peripheral as part of system
 497      =1   * initialization in which case it is not necessary to use these functions.
 498      =1   * @{
 499      =1   *****************************************************************************/
 500      =1  
 501      =1  /**************************************************************************//**
 502      =1   * Define the SPI clocking mode.  There are 4 modes which define the SPI
 503      =1   * clock polarity and phase.  The polarity refers to whether the clock is
 504      =1   * resting low or high.  The phase refers to which edge is used to capture
 505      =1   * the data, relative to the clock polarity.  The following table shows
C51 COMPILER V9.56.0.0   SPI_0                                                             10/28/2016 17:37:02 PAGE 172 

 506      =1   * the relation between the SPI mode and the clock polarity and phase.  The
 507      =1   * EFM8 device data sheet has timing diagrams to show this in more detail.
 508      =1   *
 509      =1   * |Mode|Polarity|Phase|Description                                      |
 510      =1   * |----|--------|-----|-------------------------------------------------|
 511      =1   * | 0  |   0    |  0  |Clock normally low, data capture on rising edge  |
 512      =1   * | 1  |   0    |  1  |Clock normally low, data capture on falling edge |
 513      =1   * | 2  |   1    |  0  |Clock normally high, data capture on rising edge|
 514      =1   * | 3  |   1    |  1  |Clock normally high, data capture on falling edge |
 515      =1   *****************************************************************************/
 516      =1  typedef enum
 517      =1  {
 518      =1    /// POL=0, PHA=0
 519      =1    SPI0_CLKMODE_0 = SPI0CFG_CKPOL__IDLE_LOW | SPI0CFG_CKPHA__DATA_CENTERED_FIRST,
 520      =1    /// POL=0, PHA=1
 521      =1    SPI0_CLKMODE_1 = SPI0CFG_CKPOL__IDLE_LOW | SPI0CFG_CKPHA__DATA_CENTERED_SECOND,
 522      =1    /// POL=1, PHA=0
 523      =1    SPI0_CLKMODE_2 = SPI0CFG_CKPOL__IDLE_HIGH | SPI0CFG_CKPHA__DATA_CENTERED_FIRST,
 524      =1    /// POL=1, PHA=1
 525      =1    SPI0_CLKMODE_3 = SPI0CFG_CKPOL__IDLE_HIGH | SPI0CFG_CKPHA__DATA_CENTERED_SECOND
 526      =1  } SPI0_ClockMode_t;
 527      =1  
 528      =1  /**************************************************************************//**
 529      =1   * Initialize the SPI peripheral.
 530      =1   *
 531      =1   * @param clockMode Selects the phase and polarity of the SPI clock.
 532      =1   * @param isMasterMode Select master mode (true=master, false=slave).
 533      =1   * @param is4wire Select 4-wire mode (true=4-wire, false=3-wire)
 534      =1   *
 535      =1   * This function is used to initialize the SPI peripheral clock and interface
 536      =1   * mode.  The SPI can be in master mode or slave mode, and can use the 3-wire
 537      =1   * or 4-wire interface.
 538      =1   *
 539      =1   * **Master Mode**
 540      =1   *
 541      =1   * In master mode, this peripheral is the SPI master and will drive the SPI
 542      =1   * clock, transmit data on the MOSI signal and receive data on the MISO signal.
 543      =1   * In 4-wire mode, the chip select (NSS) signal will also be driven low at
 544      =1   * the start of a transfer and high at the end of the transfer.  In 3-wire
 545      =1   * mode, the NSS signal is not managed.  The SPI interface can either be used
 546      =1   * without a chip select, or the chip select can be managed separately as a
 547      =1   * GPIO pin.
 548      =1   *
 549      =1   * **Slave Mode**
 550      =1   *
 551      =1   * In slave mode, this peripheral is the SPI slave.  There must be an
 552      =1   * external SPI device that is the SPI master and that drives the SPI
 553      =1   * clock and the chip select (if used).  When in slave mode, this peripheral
 554      =1   * receives data on MOSI and transmits data on MISO.  In 4-wire mode, SPI
 555      =1   * data transfer is gated by the assertion of NSS by the external SPI master.
 556      =1   * In 3-wire mode, the peripheral will perform transfers whenever the SPI
 557      =1   * clock is active.
 558      =1   *
 559      =1   * **Clock Configuration**
 560      =1   *
 561      =1   * The _clockMode_ controls the polarity and phase of the SPI clock.  The
 562      =1   * SPI master and SPI slave must use the same configuration.  See the
 563      =1   * @ref SPI0_ClockMode_t for clock configuration choices.
 564      =1   *
 565      =1   * @note Be aware that changing between 4-wire and 3-wire mode will affect
 566      =1   * the way pins are enabled in the crossbar.  Normally you should not change
 567      =1   * modes at run-time.  You should set the mode at the beginning and leave
C51 COMPILER V9.56.0.0   SPI_0                                                             10/28/2016 17:37:02 PAGE 173 

 568      =1   * it that way.  Otherwise you will have pin IO functions shifting to
 569      =1   * different pins every time you change between 4/3 wire mode.
 570      =1   *****************************************************************************/
 571      =1  extern void SPI0_init(SPI0_ClockMode_t clockMode,
 572      =1                        bool isMasterMode, bool is4wire);
 573      =1  
 574      =1  /**************************************************************************//**
 575      =1   * Reset SPI peripheral and disable interrupt.
 576      =1   *
 577      =1   * Disables the SPI peripheral and also disables all SPI interrupts.
 578      =1   *
 579      =1   * @note This function is implemented as a macro.
 580      =1   *****************************************************************************/
 581      =1  #if defined(IS_DOXYGEN)
           =1 extern void SPI0_reset(void);
           =1 #else
 584      =1  #define SPI0_reset(x) do{SPI0CN0 &= 0x0E; IE_ESPI0 = 0;}while(0)
 585      =1  #endif
 586      =1  
 587      =1  /**************************************************************************//**
 588      =1   * Set the SPI clock divider.
 589      =1   *
 590      =1   * @param divider The system clock divider to use for the SPI clock rate.
 591      =1   *
 592      =1   * The clock divider is divided into the system clock frequency to determine
 593      =1   * the SPI clock rate.  The SPI clock rate is determined by the following
 594      =1   * equation:
 595      =1   *
 596      =1   * `Fspi = SysClock / divider`
 597      =1   *
 598      =1   * The _divider_ parameter is constrained as follows:
 599      =1   *
 600      =1   * - range 2 - 512
 601      =1   * - must be even number
 602      =1   *
 603      =1   * If the divider does not meet the above constraints, the nearest valid
 604      =1   * value will be used.
 605      =1   *****************************************************************************/
 606      =1  extern void SPI0_setClockDivider(uint16_t divider);
 607      =1  
 608      =1  /** @} spi0_init */
 609      =1  
 610      =1  #if EFM8PDL_SPI0_USE_BUFFER == 1
           =1 /**************************************************************************//**
           =1  * @addtogroup spi0_buffer SPI0 Buffered API
           =1  *
           =1  * The following functions are part of the SPI buffered API.  These functions
           =1  * are used to perform buffered, interrupt driven transfers on the SPI bus.
           =1  *
           =1  * The buffered API functions are available when @ref EFM8PDL_SPI0_USE_BUFFER
           =1  * is set to 1 in 'SI_EFM8UB2_Defs.h'.
           =1  * @{
           =1  *****************************************************************************/
           =1 
           =1 /**************************************************************************//**
           =1  * User callback for SPI transfer complete.
           =1  *
           =1  * This function is called when an interrupt-driven SPI transfer is complete.
           =1  * The transfer must have been started using SPI0_transfer().
           =1  *
           =1  * @note This function is called in interrupt context.
           =1  *****************************************************************************/
C51 COMPILER V9.56.0.0   SPI_0                                                             10/28/2016 17:37:02 PAGE 174 

           =1 extern void SPI0_transferCompleteCb(void);
           =1 
           =1 #if EFM8PDL_SPI0_USE_ERR_CALLBACK == 1
           =1 /**************************************************************************//**
           =1  * User callback for SPI transfer errors.
           =1  *
           =1  * @param errFlags Bit mask of error flags.
           =1  *
           =1  * This function is called when an error occurs during an interrupt-driven
           =1  * SPI transfer.  The transfer must have been started using SPI0_transfer().
           =1  * The cause of the error can be determined from the _errFlags_ argument.
           =1  * This is a bit mask and can be the logical OR of the following:
           =1  *
           =1  * - @ref SPI0_MODF_IF - master mode conflict with external SPI master
           =1  * - @ref SPI0_RXOVR_IF - receive overrun
           =1  *
           =1  * If there is a receive overrun, it probably means that the SPI interrupt
           =1  * was not serviced soon enough because the system interrupt latency is
           =1  * too high.  The receive overrun condition is only detected in slave mode.
           =1  *
           =1  * This function will only be called if the option
           =1  * @ref EFM8PDL_SPI0_USE_ERR_CALLBACK is set to 1 in 'SI_EFM8UB2_Defs.h'.
           =1  *
           =1  * @note This function is called in interrupt context.
           =1  *****************************************************************************/
           =1 extern void SPI0_transferErrorCb(uint8_t errFlags);
           =1 #endif // EFM8PDL_SPI0_USE_ERR_CALLBACK
           =1 
           =1 /**************************************************************************//**
           =1  * Perform interrupt-driven multibyte SPI transfer.
           =1  *
           =1  * @param pTxBuffer The buffer holding the data to transmit.
           =1  * @param pRxBuffer The buffer to use for holding received data.
           =1  * @param dir The direction of the transfer, RX, TX, or RXTX.
           =1  * @param xferCount The number of bytes to transfer.
           =1  *
           =1  * This function is used to perform a SPI multibyte receive and/or transmit
           =1  * operation.  The transfer will be started and this function will return
           =1  * immediately.  The transfer will be carried out using interrupts and the
           =1  * user callback function SPI0_transferCompleteCb() will be called when
           =1  * all bytes have been transferred.
           =1  *
           =1  * The caller supplies transmit and receive buffers and a count of the number
           =1  * of bytes to transfer.  The _xferCount_ must not be larger than the space
           =1  * in either buffer.
           =1  *
           =1  * The _dir_ argument is used to specify the direction of the transfer.
           =1  * If transfer is needed only in one direction, then the other buffer can
           =1  * be **NULL**.  For example, to only transmit some bytes and not receive any,
           =1  * the _dir_ argument should be SPI0_TRANSFER_TX, and the _pRxBuffer_
           =1  * argument can be **NULL**.
           =1  *
           =1  * Because SPI always transfers in both directions, bytes will be transmitted
           =1  * and received for all SPI transfers.  For a transmit-only operation,
           =1  * _dir_ should be set to SPI0_TRANSFER_TX and _pRxBuffer_ can be set to
           =1  * **NULL** and all bytes received from the interface will be discarded.
           =1  * For a receive-only operation, _dir_ should be set to SPI0_TRANSFER_RX,
           =1  * _pTxBuffer_ can be set to **NULL** and zeroes will be transmitted on the
           =1  * SPI interface while all received bytes are stored.
           =1  *
           =1  * __Example__
           =1  *
C51 COMPILER V9.56.0.0   SPI_0                                                             10/28/2016 17:37:02 PAGE 175 

           =1  * ~~~~~~~~.c
           =1  * // Declare transmit and receive buffers in XDATA, each 16 bytes
           =1  * SI_SEGMENT_VARIABLE(myTxBuf[16], uint8_t, SI_SEG_XDATA);
           =1  * SI_SEGMENT_VARIABLE(myRxBuf[16], uint8_t, SI_SEG_XDATA);
           =1  *
           =1  * // Implement callback function
           =1  * SPI0_transferCompleteCb(void)
           =1  * {
           =1  *   // set flag to indicate transfer is done
           =1  *   // this function is called in interrupt context so
           =1  *   // work should be minimized
           =1  *   myTransferComplete = true;
           =1  * }
           =1  *
           =1  * // Transfer 16 bytes in and out
           =1  * SPI0_transfer(myTxBuf, myRxBuf, SPI0_TRANSFER_RXTX, 16);
           =1  *
           =1  * // Receive 12 bytes, and send none
           =1  * // (This will cause 12 zero bytes to be sent)
           =1  * SPI0_transfer(NULL, myRxBuf, SPI0_TRANSFER_RX, 12);
           =1  * ~~~~~~~~
           =1  *
           =1  * @note The memory type of the TX and RX buffers much match the type
           =1  * of the configuration macros @ref EFM8PDL_SPI0_TX_SEGTYPE and
           =1  * @ref EFM8PDL_SPI0_RX_SEGTYPE.
           =1  *****************************************************************************/
           =1 extern void
           =1 SPI0_transfer(SI_VARIABLE_SEGMENT_POINTER(pTxBuffer, uint8_t, EFM8PDL_SPI0_TX_SEGTYPE),
           =1               SI_VARIABLE_SEGMENT_POINTER(pRxBuffer, uint8_t, EFM8PDL_SPI0_RX_SEGTYPE),
           =1               SPI0_TransferDirection_t dir, uint8_t xferCount);
           =1 
           =1 /**************************************************************************//**
           =1  * Abort a buffered SPI transfer.
           =1  *
           =1  * Stop a buffered SPI transfer that is in progress.  No remaining bytes
           =1  * will be transferred and the callback function will not be called.
           =1  *****************************************************************************/
           =1 extern void SPI0_abortTransfer(void);
           =1 
           =1 /**************************************************************************//**
           =1  * Get the remaining bytes for a buffered transfer.
           =1  *
           =1  * @return The number of bytes remaining to transfer.
           =1  *
           =1  * When a transfer is started with SPI0_transfer(), this function can be
           =1  * used to determine how many bytes are remaining to transfer.  This value
           =1  * will be zero if the transfer is complete.
           =1  *****************************************************************************/
           =1 extern uint8_t SPI0_bytesRemaining(void);
           =1 
           =1 /** @} spi0_buffer */
           =1 #endif // EFM8PDL_SPI0_USE_BUFFER
 744      =1  
 745      =1  /** @} (end spi_0_group) */
 746      =1  
 747      =1  #endif // __SPI_0_H__
  10          
  11          // Runtime API
  12          
  13          // Flag to indicate if driver should control Nss (chip select)
  14          static bool useNss  = false;
  15          
C51 COMPILER V9.56.0.0   SPI_0                                                             10/28/2016 17:37:02 PAGE 176 

  16          // flag to indicate we are in master mode (else slave)
  17          static bool modeIsMaster = false;
  18          
  19          // flag to indicate that init vars (above) are valid.  If they are
  20          // not valid then a special one-time init will be called to set them
  21          static bool initIsValid = false;
  22          
  23          // ----------------------------------------------------------------------------
  24          // Initialize internal state variables.  This is used if init API is
  25          // not called.
  26          // ----------------------------------------------------------------------------
  27          static void SPI0_internalInit(void)
  28          {
  29   1        // figure out if we are master mode, and using 4-wire or not
  30   1        modeIsMaster = SPI0CFG & SPI0CFG_MSTEN__MASTER_ENABLED;
  31   1        useNss = SPI0CN0 & SPI0CN0_NSSMD__FMASK;
  32   1      
  33   1        // indicate that init has now been done
  34   1        initIsValid = true;
  35   1      }
  36          
  37          // ----------------------------------------------------------------------------
  38          // Write a byte if transmit buffer is not full.
  39          // ----------------------------------------------------------------------------
  40          bool SPI0_writeByte(uint8_t value)
  41          {
  42   1        bool ret = false;
  43   1        // check to see if transmit buffer is not full
  44   1        if (SPI0CN0_TXBMT)
  45   1        {
  46   2          SPI0DAT = value;
  47   2          ret = true;
  48   2        }
  49   1        return ret;
  50   1      }
  51          
  52          // ----------------------------------------------------------------------------
  53          // Write a byte, waiting for transmit buffer to be empty
  54          // ----------------------------------------------------------------------------
  55          void SPI0_pollWriteByte(uint8_t value)
  56          {
  57   1        // wait for TX empty
  58   1        while (!SPI0CN0_TXBMT)
  59   1        {}
  60   1      
  61   1        SPI0DAT = value;
  62   1      }
  63          
  64          // ----------------------------------------------------------------------------
  65          // Perform a multi-byte transfer, waiting for each byte to complete.
  66          // ----------------------------------------------------------------------------
  67          uint8_t
  68          SPI0_pollTransfer(SI_VARIABLE_SEGMENT_POINTER(pTxBuffer, uint8_t,
  69                                                        EFM8PDL_SPI0_TX_SEGTYPE),
  70                            SI_VARIABLE_SEGMENT_POINTER(pRxBuffer, uint8_t,
  71                                                        EFM8PDL_SPI0_RX_SEGTYPE),
  72                            SPI0_TransferDirection_t dir,
  73                            uint8_t xferCount)
  74          {
  75   1        uint8_t txCount = xferCount;
  76   1        bool checkNss = false;
  77   1      
C51 COMPILER V9.56.0.0   SPI_0                                                             10/28/2016 17:37:02 PAGE 177 

  78   1        // This function is not interrupt driven and if SPI interrupts are
  79   1        // enabled, it can cause interference.
  80   1        SPI0_disableInt();
  81   1      
  82   1        // make sure SPI is not already busy
  83   1        while (SPI0CFG & SPI0CFG_SPIBSY__BMASK)
  84   1        {}
  85   1      
  86   1        // Check to see if run-time mode variables have been set up
  87   1        if (!initIsValid)
  88   1        {
  89   2          SPI0_internalInit();
  90   2        }
  91   1      
  92   1        // Flush the RX buffer in case something is in there
  93   1        {
  94   2          uint8_t dummy = SPI0DAT;
  95   2        }
  96   1      
  97   1        // Clear the interrupt flag that is used to indicate transfer complete
  98   1        SPI0CN0_SPIF = 0;
  99   1      
 100   1        // assert NSS (if used)
 101   1        if (modeIsMaster && useNss)
 102   1        {
 103   2          SPI0CN0_NSSMD0 = 0;
 104   2        }
 105   1      
 106   1        // Wait in loop until the requested number of transfers are complete
 107   1        // Note: xferCount tracks the number of bytes received
 108   1        while (xferCount)
 109   1        {
 110   2          // If the transmit buffer is empty and there are still bytes to
 111   2          // write, then write a byte out
 112   2          if (SPI0CN0_TXBMT && txCount)
 113   2          {
 114   3            // If user provided a write buffer then use that
 115   3            if (dir & SPI0_TRANSFER_TX)
 116   3            {
 117   4              SPI0DAT = *pTxBuffer;
 118   4              ++pTxBuffer;
 119   4            }
 120   3      
 121   3            // else user did not provide write buffer so just use zeroes
 122   3            else
 123   3            {
 124   4              SPI0DAT = 0;
 125   4            }
 126   3      
 127   3            --txCount;
 128   3          }
 129   2      
 130   2          // If the interrupt flag is set it means a transfer has completed
 131   2          // so read a byte
 132   2          if (SPI0CN0_SPIF)
 133   2          {
 134   3            SPI0CN0_SPIF = 0;
 135   3      
 136   3            // If user provided RX buffer, then read byte into buffer
 137   3            if (dir & SPI0_TRANSFER_RX)
 138   3            {
 139   4              *pRxBuffer = SPI0DAT;
C51 COMPILER V9.56.0.0   SPI_0                                                             10/28/2016 17:37:02 PAGE 178 

 140   4              ++pRxBuffer;
 141   4            }
 142   3      
 143   3            // else there is no RX buffer so just throw away the incoming byte
 144   3            else
 145   3            {
 146   4              uint8_t dummy = SPI0DAT;
 147   4            }
 148   3      
 149   3            --xferCount;
 150   3          }
 151   2      
 152   2          // If we are in slave mode and 4-wire, then check to make sure
 153   2          // slave is selected.  If not it means the spi master stopped
 154   2          // the transfer.  Bust out of the polling loop so we dont hang
 155   2          // here forever.
 156   2          if (!modeIsMaster && useNss)
 157   2          {
 158   3            // wait for nss to be asserted the first time before we
 159   3            // start checking it
 160   3            if (!checkNss)
 161   3            {
 162   4              if ((SPI0CFG & SPI0CFG_SLVSEL__BMASK))
 163   4              {
 164   5                checkNss = true;
 165   5              }
 166   4            }
 167   3            else
 168   3            {
 169   4              if (!(SPI0CFG & SPI0CFG_SLVSEL__BMASK))
 170   4              {
 171   5                break;
 172   5              }
 173   4            }
 174   3          }
 175   2        }
 176   1      
 177   1        // Transfer is done.  Deassert NSS (if used)
 178   1        if (modeIsMaster && useNss)
 179   1        {
 180   2          SPI0CN0_NSSMD0 = 1;
 181   2        }
 182   1      
 183   1        return xferCount;
 184   1      }
 185          
 186          // ----------------------------------------------------------------------------
 187          // Check if SPI is busy with a transfer in progress.
 188          // ----------------------------------------------------------------------------
 189          bool SPI0_isBusy(void)
 190          {
 191   1        uint8_t count = 0;
 192   1        bool ret = false;
 193   1      
 194   1        // the SPI busy bit can drop between bytes so you cant just poll
 195   1        // it to find out when all the bytes have been transferred.  Or sometimes
 196   1        // you will catch it not set, between bytes when it is really still
 197   1        // busy.  To make busy test useful, we need to know when it is done
 198   1        // with all bytes.  That is why there is a loop below.
 199   1      
 200   1        // Read it several times and if the bit is ever marked busy, then
 201   1        // return busy indication.
C51 COMPILER V9.56.0.0   SPI_0                                                             10/28/2016 17:37:02 PAGE 179 

 202   1        for (count = 0; count < 3; count++)
 203   1        {
 204   2          if (SPI0CFG & SPI0CFG_SPIBSY__BMASK)
 205   2          {
 206   3            ret = true;
 207   3          }
 208   2        }
 209   1      
 210   1        // If it makes it through the loops above without find the busy bit
 211   1        // then it is not busy.
 212   1        return ret;
 213   1      }
 214          
 215          // ----------------------------------------------------------------------------
 216          // Initialize the SPI peripheral operating parameters
 217          // ----------------------------------------------------------------------------
 218          void SPI0_init(SPI0_ClockMode_t clockMode, bool isMasterMode, bool is4wire)
 219          {
 220   1        // Figure out if this driver controls NSS signal (chip select)
 221   1        modeIsMaster = isMasterMode;
 222   1        useNss = is4wire;
 223   1        initIsValid = true;
 224   1      
 225   1        // disable SPI before configuring
 226   1        SPI0CN0_SPIEN = 0;
 227   1      
 228   1        // Set up the clock mode (phase and polarity), and the
 229   1        // master/slave selection
 230   1        SPI0CFG = clockMode | (isMasterMode ? SPI0CFG_MSTEN__MASTER_ENABLED
 231   1                                            : SPI0CFG_MSTEN__MASTER_DISABLED);
 232   1      
 233   1        // Set up the NSS mode bits depending on whether 3-wire or 4-wire
 234   1        // is used, and whether master or slave mode
 235   1        if (is4wire)
 236   1        {
 237   2          SPI0CN0_NSSMD0 = 1;
 238   2          SPI0CN0_NSSMD1 = isMasterMode ? 1 : 0;
 239   2        }
 240   1        else
 241   1        {
 242   2          SPI0CN0_NSSMD0 = 0;
 243   2          SPI0CN0_NSSMD1 = 0;
 244   2        }
 245   1      
 246   1        // clear all the interrupt bits and enable the SPI
 247   1        SPI0CN0 &= ~0xF0;
 248   1        SPI0CN0_SPIEN = 1;
 249   1      }
 250          
 251          // ----------------------------------------------------------------------------
 252          // Set the clock divider used to determine SPI clock rate
 253          // ----------------------------------------------------------------------------
 254          void SPI0_setClockDivider(uint16_t divider)
 255          {
 256   1        // constrain input in case user passes a bad value
 257   1        if (divider > 512)
 258   1        {
 259   2          divider = 512;
 260   2        }
 261   1        if (divider < 2)
 262   1        {
 263   2          divider = 2;
C51 COMPILER V9.56.0.0   SPI_0                                                             10/28/2016 17:37:02 PAGE 180 

 264   2        }
 265   1        // make even value
 266   1        divider &= ~1;
 267   1      
 268   1        // Transform the divider to the form needed by SFR.
 269   1        // See equation in the data sheet for more information
 270   1        divider /= 2;
 271   1        divider -= 1;
 272   1      
 273   1        // disable SPI before configuring, then update the value
 274   1        SPI0CN0_SPIEN = 0;
 275   1        SPI0CKR = (uint8_t)divider;
 276   1        SPI0CN0_SPIEN = 1;
 277   1      }
 278          
 279          #if EFM8PDL_SPI0_USE_BUFFER == 1
              
              // flag to indicate that RX buffer should be used for buffered transfers
              static bool useRx = false;
              
              // flag to indicate that TX buffer should be used for buffered transfers
              static bool useTx = false;
              
              static uint8_t rxCountRemaining = 0;
              static uint8_t txCountRemaining = 0;
              static uint8_t bytesRemaining = 0;
              static SI_VARIABLE_SEGMENT_POINTER(pTxBuf, uint8_t, EFM8PDL_SPI0_TX_SEGTYPE) = NULL;
              static SI_VARIABLE_SEGMENT_POINTER(pRxBuf, uint8_t, EFM8PDL_SPI0_RX_SEGTYPE) = NULL;
              
              // ----------------------------------------------------------------------------
              // Set up an interrupt driven SPI transfer.
              // ----------------------------------------------------------------------------
              void
              SPI0_transfer(SI_VARIABLE_SEGMENT_POINTER(pTxBuffer, uint8_t,
                                                        EFM8PDL_SPI0_TX_SEGTYPE),
                            SI_VARIABLE_SEGMENT_POINTER(pRxBuffer, uint8_t,
                                                        EFM8PDL_SPI0_RX_SEGTYPE),
                            SPI0_TransferDirection_t dir,
                            uint8_t xferCount)
              {
                rxCountRemaining = xferCount;
                txCountRemaining = xferCount;
                bytesRemaining = xferCount;
                pTxBuf = pTxBuffer;
                pRxBuf = pRxBuffer;
                useRx = dir & SPI0_TRANSFER_RX;
                useTx = dir & SPI0_TRANSFER_TX;
              
                // Check to see if run-time mode variables have been set up
                if (!initIsValid)
                {
                  SPI0_internalInit();
                }
              
                // Flush the RX buffer in case something is in there
                {
                  uint8_t dummy = SPI0DAT;
                }
              
                // Clear all the interrupt flags
                SPI0CN0 &= ~0xF0;
              
C51 COMPILER V9.56.0.0   SPI_0                                                             10/28/2016 17:37:02 PAGE 181 

                // assert NSS (if used)
                if (modeIsMaster && useNss)
                {
                  SPI0CN0_NSSMD0 = 0;
                }
              
              #if EFM8PDL_SPI0_USE_PIPELINE == 0
                // Write the first byte to get the transfer started
                if (SPI0CN0_TXBMT && txCountRemaining)
                {
                  // If user provided tx data, then use that
                  if (useTx)
                  {
                    SPI0DAT = *pTxBuf;
                    ++pTxBuf;
                  }
              
                  // Otherwise no tx data, so just stuff zeroes
                  else
                  {
                    SPI0DAT = 0;
                  }
                  --txCountRemaining;
                }
              #else
                // Stuff as many bytes as we can in the tx buffer to start.
                while (SPI0CN0_TXBMT && txCountRemaining)
                {
                  // If user provided tx data, then use that
                  if (useTx)
                  {
                    SPI0DAT = *pTxBuf;
                    ++pTxBuf;
                  }
              
                  // Otherwise no tx data, so just stuff zeroes
                  else
                  {
                    SPI0DAT = 0;
                  }
                  --txCountRemaining;
                }
              #endif
              
                // At this point SPI should be running and the rest will be handled
                // in the interrupt service routine
              }
              
              // ----------------------------------------------------------------------------
              // Stop a running SPI transfer.
              // ----------------------------------------------------------------------------
              void SPI0_abortTransfer(void)
              {
                // Resetting the counters will cause the ISR to ignore any remaining
                // SPI interrupts.
                txCountRemaining = 0;
                rxCountRemaining = 0;
                useTx = false;
                useRx = false;
                pTxBuf = NULL;
                pRxBuf = NULL;
              
C51 COMPILER V9.56.0.0   SPI_0                                                             10/28/2016 17:37:02 PAGE 182 

                // drop the chip select if used
                if (modeIsMaster && useNss)
                {
                  SPI0CN0_NSSMD0 = 1;
                }
              }
              
              // ----------------------------------------------------------------------------
              // Get the number of bytes remaining in the transfer.  This will really
              // be the number of RX bytes.
              // ----------------------------------------------------------------------------
              uint8_t SPI0_bytesRemaining(void)
              {
                return bytesRemaining;
              }
              
              // ----------------------------------------------------------------------------
              // Handler for interrupt driven SPI data transfers.
              // ----------------------------------------------------------------------------
              SI_INTERRUPT(SPI0_ISR, SPI0_IRQn)
              {
                uint8_t intFlags;
              
                // Get the interrupt flags and then clear any that are pending
                intFlags = SPI0CN0 & 0xF0;
                SPI0CN0 = (SPI0CN0 & (~intFlags | 0x0F));
              
                // Handle completion of one frame (byte) of data transferred.
                // This means we are ready to read a received byte, and write
                // the next TX byte.
                if (intFlags & SPI0_INT_IF)
                {
                  // Read bytes as long as the read count is non-zero
                  if (rxCountRemaining)
                  {
                    // If the user provided an RX buffer then read a byte into that.
                    if (useRx)
                    {
                      *pRxBuf = SPI0DAT;
                      ++pRxBuf;
                    }
              
                    // Else, user does not care about RX data so do a dummy read.
                    else
                    {
                      uint8_t dummy = SPI0DAT;
                    }
                    --rxCountRemaining;
              
                    // If we get to zero remaining, it means that all the
                    // bytes have been transferred.
                    if (rxCountRemaining == 0)
                    {
                      // deassert NSS (if used)
                      if (modeIsMaster && useNss)
                      {
                        SPI0CN0_NSSMD0 = 1;
                      }
                      // Tell user that the transfer is complete.
                      SPI0_transferCompleteCb();
                    }
              
C51 COMPILER V9.56.0.0   SPI_0                                                             10/28/2016 17:37:02 PAGE 183 

                    // If there are more RX bytes to receive, then remember the
                    // current count to be used by _bytesRemaining()
                    else
                    {
                      bytesRemaining = rxCountRemaining;
                    }
                  }
              
                  // Write bytes if there are more TX bytes to send and the
                  // TX buffer is not full
                  if (txCountRemaining && SPI0CN0_TXBMT)
                  {
                    // If user provided a TX buffer then write the next byte
                    if (useTx)
                    {
                      SPI0DAT = *pTxBuf;
                      ++pTxBuf;
                    }
              
                    // Otherwise user did not provide a buffer so just write a zero.
                    else
                    {
                      SPI0DAT = 0;
                    }
                    --txCountRemaining;
                  }
                }
              
              #if EFM8PDL_SPI0_USE_ERR_CALLBACK == 1
                // Check for errors and notify user
                if (intFlags & (SPI0_MODF_IF | SPI0_RXOVR_IF))
                {
                  // Note, the RXOVRN bit only happens in slave mode, and the MODF
                  // bit is not very likely, so in master mode this block will
                  // probably not ever be used.
                  SPI0_transferErrorCb(intFlags & (SPI0_MODF_IF | SPI0_RXOVR_IF));
                }
              #endif // EFM8PDL_SPI0_USE_ERR_CALLBACK
              }
              
              #endif // EFM8PDL_SPI0_USE_BUFFER
 491          
 492          /** @} (end spi_0_group) */
C51 COMPILER V9.56.0.0   SPI_0                                                             10/28/2016 17:37:02 PAGE 184 

ASSEMBLY LISTING OF GENERATED OBJECT CODE


             ; FUNCTION SPI0_internalInit (BEGIN)
                                           ; SOURCE LINE # 27
                                           ; SOURCE LINE # 28
                                           ; SOURCE LINE # 30
0000 E5A1              MOV     A,SPI0CFG
0002 A2E6              MOV     C,ACC.6
0004 9200        R     MOV     modeIsMaster,C
                                           ; SOURCE LINE # 31
0006 E5F8              MOV     A,SPI0CN0
0008 540C              ANL     A,#0CH
000A FF                MOV     R7,A
000B EF                MOV     A,R7
000C 24FF              ADD     A,#0FFH
000E 9200        R     MOV     useNss,C
                                           ; SOURCE LINE # 34
0010 D200        R     SETB    initIsValid
                                           ; SOURCE LINE # 35
0012         ?C0001:
0012 22                RET     
             ; FUNCTION SPI0_internalInit (END)

             ; FUNCTION _SPI0_writeByte (BEGIN)
                                           ; SOURCE LINE # 40
0000 900000      R     MOV     DPTR,#value
0003 EF                MOV     A,R7
0004 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 41
                                           ; SOURCE LINE # 42
0005 C200        R     CLR     ret
                                           ; SOURCE LINE # 44
0007 30F909            JNB     SPI0CN0_TXBMT,?C0002
                                           ; SOURCE LINE # 45
                                           ; SOURCE LINE # 46
000A 900000      R     MOV     DPTR,#value
000D E0                MOVX    A,@DPTR
000E FF                MOV     R7,A
000F 8FA3              MOV     SPI0DAT,R7
                                           ; SOURCE LINE # 47
0011 D200        R     SETB    ret
                                           ; SOURCE LINE # 48
0013         ?C0002:
                                           ; SOURCE LINE # 49
0013 A200        R     MOV     C,ret
                                           ; SOURCE LINE # 50
0015         ?C0003:
0015 22                RET     
             ; FUNCTION _SPI0_writeByte (END)

             ; FUNCTION _SPI0_pollWriteByte (BEGIN)
                                           ; SOURCE LINE # 55
0000 900000      R     MOV     DPTR,#value
0003 EF                MOV     A,R7
0004 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 56
0005         ?C0004:
                                           ; SOURCE LINE # 58
0005 30F9FD            JNB     SPI0CN0_TXBMT,?C0004
                                           ; SOURCE LINE # 59
0008         ?C0005:
C51 COMPILER V9.56.0.0   SPI_0                                                             10/28/2016 17:37:02 PAGE 185 

                                           ; SOURCE LINE # 61
0008 900000      R     MOV     DPTR,#value
000B E0                MOVX    A,@DPTR
000C FF                MOV     R7,A
000D 8FA3              MOV     SPI0DAT,R7
                                           ; SOURCE LINE # 62
000F         ?C0006:
000F 22                RET     
             ; FUNCTION _SPI0_pollWriteByte (END)

             ; FUNCTION _SPI0_pollTransfer (BEGIN)
                                           ; SOURCE LINE # 68
0000 900000      R     MOV     DPTR,#pTxBuffer
0003 EE                MOV     A,R6
0004 F0                MOVX    @DPTR,A
0005 A3                INC     DPTR
0006 EF                MOV     A,R7
0007 F0                MOVX    @DPTR,A
0008 900000      R     MOV     DPTR,#pRxBuffer
000B EC                MOV     A,R4
000C F0                MOVX    @DPTR,A
000D A3                INC     DPTR
000E ED                MOV     A,R5
000F F0                MOVX    @DPTR,A
0010 900000      R     MOV     DPTR,#dir
0013 EB                MOV     A,R3
0014 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 74
                                           ; SOURCE LINE # 75
0015 900000      R     MOV     DPTR,#xferCount
0018 E0                MOVX    A,@DPTR
0019 FF                MOV     R7,A
001A 900000      R     MOV     DPTR,#txCount
001D EF                MOV     A,R7
001E F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 76
001F C200        R     CLR     checkNss
                                           ; SOURCE LINE # 80
0021 C2AE              CLR     IE_ESPI0
0023         ?C0007:
                                           ; SOURCE LINE # 83
0023 E5A1              MOV     A,SPI0CFG
0025 20E7FB            JB      ACC.7,?C0007
                                           ; SOURCE LINE # 84
0028         ?C0008:
                                           ; SOURCE LINE # 87
0028 200003            JB      initIsValid,?C0009
                                           ; SOURCE LINE # 88
                                           ; SOURCE LINE # 89
002B 120000      R     LCALL   SPI0_internalInit
                                           ; SOURCE LINE # 90
002E         ?C0009:
                                           ; SOURCE LINE # 93
                                           ; SOURCE LINE # 94
002E 900000      R     MOV     DPTR,#dummy
0031 E5A3              MOV     A,SPI0DAT
0033 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 95
                                           ; SOURCE LINE # 98
0034 C2FF              CLR     SPI0CN0_SPIF
                                           ; SOURCE LINE # 101
0036 300005            JNB     modeIsMaster,?C0011
C51 COMPILER V9.56.0.0   SPI_0                                                             10/28/2016 17:37:02 PAGE 186 

0039 300002            JNB     useNss,?C0011
                                           ; SOURCE LINE # 102
                                           ; SOURCE LINE # 103
003C C2FA              CLR     SPI0CN0_NSSMD0
                                           ; SOURCE LINE # 104
003E         ?C0010:
003E         ?C0011:
                                           ; SOURCE LINE # 108
003E 900000      R     MOV     DPTR,#xferCount
0041 E0                MOVX    A,@DPTR
0042 FF                MOV     R7,A
0043 EF                MOV     A,R7
0044 7003              JNZ     $ + 5H
0046 020000      R     LJMP    ?C0012
                                           ; SOURCE LINE # 109
                                           ; SOURCE LINE # 112
0049 30F93A            JNB     SPI0CN0_TXBMT,?C0013
004C 900000      R     MOV     DPTR,#txCount
004F E0                MOVX    A,@DPTR
0050 FF                MOV     R7,A
0051 EF                MOV     A,R7
0052 6032              JZ      ?C0013
                                           ; SOURCE LINE # 113
                                           ; SOURCE LINE # 115
0054 900000      R     MOV     DPTR,#dir
0057 E0                MOVX    A,@DPTR
0058 FF                MOV     R7,A
0059 EF                MOV     A,R7
005A 30E120            JNB     ACC.1,?C0014
                                           ; SOURCE LINE # 116
                                           ; SOURCE LINE # 117
005D 900000      R     MOV     DPTR,#pTxBuffer
0060 E0                MOVX    A,@DPTR
0061 FE                MOV     R6,A
0062 A3                INC     DPTR
0063 E0                MOVX    A,@DPTR
0064 FF                MOV     R7,A
0065 8F82              MOV     DPL,R7
0067 8E83              MOV     DPH,R6
0069 E0                MOVX    A,@DPTR
006A FF                MOV     R7,A
006B 8FA3              MOV     SPI0DAT,R7
                                           ; SOURCE LINE # 118
006D 900000      R     MOV     DPTR,#pTxBuffer+01H
0070 E0                MOVX    A,@DPTR
0071 04                INC     A
0072 F0                MOVX    @DPTR,A
0073 7006              JNZ     ?C0041
0075 900000      R     MOV     DPTR,#pTxBuffer
0078 E0                MOVX    A,@DPTR
0079 04                INC     A
007A F0                MOVX    @DPTR,A
007B         ?C0041:
                                           ; SOURCE LINE # 119
007B 8003              SJMP    ?C0015
007D         ?C0014:
                                           ; SOURCE LINE # 123
                                           ; SOURCE LINE # 124
007D 75A300            MOV     SPI0DAT,#00H
                                           ; SOURCE LINE # 125
0080         ?C0015:
                                           ; SOURCE LINE # 127
C51 COMPILER V9.56.0.0   SPI_0                                                             10/28/2016 17:37:02 PAGE 187 

0080 900000      R     MOV     DPTR,#txCount
0083 E0                MOVX    A,@DPTR
0084 14                DEC     A
0085 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 128
0086         ?C0013:
                                           ; SOURCE LINE # 132
0086 30FF36            JNB     SPI0CN0_SPIF,?C0016
                                           ; SOURCE LINE # 133
                                           ; SOURCE LINE # 134
0089 C2FF              CLR     SPI0CN0_SPIF
                                           ; SOURCE LINE # 137
008B 900000      R     MOV     DPTR,#dir
008E E0                MOVX    A,@DPTR
008F FF                MOV     R7,A
0090 EF                MOV     A,R7
0091 30E01F            JNB     ACC.0,?C0017
                                           ; SOURCE LINE # 138
                                           ; SOURCE LINE # 139
0094 900000      R     MOV     DPTR,#pRxBuffer
0097 E0                MOVX    A,@DPTR
0098 FE                MOV     R6,A
0099 A3                INC     DPTR
009A E0                MOVX    A,@DPTR
009B FF                MOV     R7,A
009C 8F82              MOV     DPL,R7
009E 8E83              MOV     DPH,R6
00A0 E5A3              MOV     A,SPI0DAT
00A2 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 140
00A3 900000      R     MOV     DPTR,#pRxBuffer+01H
00A6 E0                MOVX    A,@DPTR
00A7 04                INC     A
00A8 F0                MOVX    @DPTR,A
00A9 7006              JNZ     ?C0042
00AB 900000      R     MOV     DPTR,#pRxBuffer
00AE E0                MOVX    A,@DPTR
00AF 04                INC     A
00B0 F0                MOVX    @DPTR,A
00B1         ?C0042:
                                           ; SOURCE LINE # 141
00B1 8006              SJMP    ?C0018
00B3         ?C0017:
                                           ; SOURCE LINE # 145
                                           ; SOURCE LINE # 146
00B3 900000      R     MOV     DPTR,#dummy
00B6 E5A3              MOV     A,SPI0DAT
00B8 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 147
00B9         ?C0018:
                                           ; SOURCE LINE # 149
00B9 900000      R     MOV     DPTR,#xferCount
00BC E0                MOVX    A,@DPTR
00BD 14                DEC     A
00BE F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 150
00BF         ?C0016:
                                           ; SOURCE LINE # 156
00BF 300003      R     JNB     modeIsMaster,$ + 6H
00C2 020000      R     LJMP    ?C0011
00C5 200003      R     JB      useNss,$ + 6H
00C8 020000      R     LJMP    ?C0011
C51 COMPILER V9.56.0.0   SPI_0                                                             10/28/2016 17:37:02 PAGE 188 

                                           ; SOURCE LINE # 157
                                           ; SOURCE LINE # 160
00CB 20000D            JB      checkNss,?C0020
                                           ; SOURCE LINE # 161
                                           ; SOURCE LINE # 162
00CE E5A1              MOV     A,SPI0CFG
00D0 20E303            JB      ACC.3,$ + 6H
00D3 020000      R     LJMP    ?C0011
                                           ; SOURCE LINE # 163
                                           ; SOURCE LINE # 164
00D6 D200        R     SETB    checkNss
                                           ; SOURCE LINE # 165
00D8         ?C0021:
                                           ; SOURCE LINE # 166
00D8 020000      R     LJMP    ?C0011
00DB         ?C0020:
                                           ; SOURCE LINE # 168
                                           ; SOURCE LINE # 169
00DB E5A1              MOV     A,SPI0CFG
00DD 30E303            JNB     ACC.3,$ + 6H
00E0 020000      R     LJMP    ?C0011
                                           ; SOURCE LINE # 170
                                           ; SOURCE LINE # 171
00E3 8003              SJMP    ?C0012
                                           ; SOURCE LINE # 172
00E5         ?C0023:
                                           ; SOURCE LINE # 173
00E5         ?C0022:
                                           ; SOURCE LINE # 174
00E5         ?C0019:
                                           ; SOURCE LINE # 175
00E5 020000      R     LJMP    ?C0011
00E8         ?C0012:
                                           ; SOURCE LINE # 178
00E8 300005            JNB     modeIsMaster,?C0024
00EB 300002            JNB     useNss,?C0024
                                           ; SOURCE LINE # 179
                                           ; SOURCE LINE # 180
00EE D2FA              SETB    SPI0CN0_NSSMD0
                                           ; SOURCE LINE # 181
00F0         ?C0024:
                                           ; SOURCE LINE # 183
00F0 900000      R     MOV     DPTR,#xferCount
00F3 E0                MOVX    A,@DPTR
00F4 FF                MOV     R7,A
                                           ; SOURCE LINE # 184
00F5         ?C0025:
00F5 22                RET     
             ; FUNCTION _SPI0_pollTransfer (END)

             ; FUNCTION SPI0_isBusy (BEGIN)
                                           ; SOURCE LINE # 189
                                           ; SOURCE LINE # 190
                                           ; SOURCE LINE # 191
0000 900000      R     MOV     DPTR,#count
0003 E4                CLR     A
0004 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 192
0005 C200        R     CLR     ret
                                           ; SOURCE LINE # 202
0007 900000      R     MOV     DPTR,#count
000A E4                CLR     A
C51 COMPILER V9.56.0.0   SPI_0                                                             10/28/2016 17:37:02 PAGE 189 

000B F0                MOVX    @DPTR,A
000C         ?C0026:
000C 900000      R     MOV     DPTR,#count
000F E0                MOVX    A,@DPTR
0010 FF                MOV     R7,A
0011 EF                MOV     A,R7
0012 C3                CLR     C
0013 9403              SUBB    A,#03H
0015 500F              JNC     ?C0027
                                           ; SOURCE LINE # 203
                                           ; SOURCE LINE # 204
0017 E5A1              MOV     A,SPI0CFG
0019 30E702            JNB     ACC.7,?C0028
                                           ; SOURCE LINE # 205
                                           ; SOURCE LINE # 206
001C D200        R     SETB    ret
                                           ; SOURCE LINE # 207
001E         ?C0029:
                                           ; SOURCE LINE # 208
001E         ?C0028:
001E 900000      R     MOV     DPTR,#count
0021 E0                MOVX    A,@DPTR
0022 04                INC     A
0023 F0                MOVX    @DPTR,A
0024 80E6              SJMP    ?C0026
0026         ?C0027:
                                           ; SOURCE LINE # 212
0026 A200        R     MOV     C,ret
                                           ; SOURCE LINE # 213
0028         ?C0030:
0028 22                RET     
             ; FUNCTION SPI0_isBusy (END)

             ; FUNCTION _SPI0_init (BEGIN)
                                           ; SOURCE LINE # 218
0000 900000      R     MOV     DPTR,#clockMode
0003 EF                MOV     A,R7
0004 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 219
                                           ; SOURCE LINE # 221
0005 A200        R     MOV     C,isMasterMode
0007 9200        R     MOV     modeIsMaster,C
                                           ; SOURCE LINE # 222
0009 A200        R     MOV     C,is4wire
000B 9200        R     MOV     useNss,C
                                           ; SOURCE LINE # 223
000D D200        R     SETB    initIsValid
                                           ; SOURCE LINE # 226
000F C2F8              CLR     SPI0CN0_SPIEN
                                           ; SOURCE LINE # 230
0011 900000      R     MOV     DPTR,#clockMode
0014 E0                MOVX    A,@DPTR
0015 FF                MOV     R7,A
0016 300004            JNB     isMasterMode,?C0031
0019 7E40              MOV     R6,#040H
001B 8002              SJMP    ?C0032
001D         ?C0031:
001D 7E00              MOV     R6,#00H
001F         ?C0032:
001F EE                MOV     A,R6
0020 4F                ORL     A,R7
0021 F5A1              MOV     SPI0CFG,A
C51 COMPILER V9.56.0.0   SPI_0                                                             10/28/2016 17:37:02 PAGE 190 

                                           ; SOURCE LINE # 235
0023 30000D            JNB     is4wire,?C0033
                                           ; SOURCE LINE # 236
                                           ; SOURCE LINE # 237
0026 D2FA              SETB    SPI0CN0_NSSMD0
                                           ; SOURCE LINE # 238
0028 300003            JNB     isMasterMode,?C0034
002B D3                SETB    C
002C 8001              SJMP    ?C0035
002E         ?C0034:
002E C3                CLR     C
002F         ?C0035:
002F 92FB              MOV     SPI0CN0_NSSMD1,C
                                           ; SOURCE LINE # 239
0031 8004              SJMP    ?C0036
0033         ?C0033:
                                           ; SOURCE LINE # 241
                                           ; SOURCE LINE # 242
0033 C2FA              CLR     SPI0CN0_NSSMD0
                                           ; SOURCE LINE # 243
0035 C2FB              CLR     SPI0CN0_NSSMD1
                                           ; SOURCE LINE # 244
0037         ?C0036:
                                           ; SOURCE LINE # 247
0037 53F80F            ANL     SPI0CN0,#0FH
                                           ; SOURCE LINE # 248
003A D2F8              SETB    SPI0CN0_SPIEN
                                           ; SOURCE LINE # 249
003C         ?C0037:
003C 22                RET     
             ; FUNCTION _SPI0_init (END)

             ; FUNCTION _SPI0_setClockDivider (BEGIN)
                                           ; SOURCE LINE # 254
0000 900000      R     MOV     DPTR,#divider
0003 EE                MOV     A,R6
0004 F0                MOVX    @DPTR,A
0005 A3                INC     DPTR
0006 EF                MOV     A,R7
0007 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 255
                                           ; SOURCE LINE # 257
0008 900000      R     MOV     DPTR,#divider
000B E0                MOVX    A,@DPTR
000C FE                MOV     R6,A
000D A3                INC     DPTR
000E E0                MOVX    A,@DPTR
000F FF                MOV     R7,A
0010 D3                SETB    C
0011 EF                MOV     A,R7
0012 9400              SUBB    A,#00H
0014 EE                MOV     A,R6
0015 9402              SUBB    A,#02H
0017 4009              JC      ?C0038
                                           ; SOURCE LINE # 258
                                           ; SOURCE LINE # 259
0019 900000      R     MOV     DPTR,#divider
001C 7402              MOV     A,#02H
001E F0                MOVX    @DPTR,A
001F A3                INC     DPTR
0020 E4                CLR     A
0021 F0                MOVX    @DPTR,A
C51 COMPILER V9.56.0.0   SPI_0                                                             10/28/2016 17:37:02 PAGE 191 

                                           ; SOURCE LINE # 260
0022         ?C0038:
                                           ; SOURCE LINE # 261
0022 900000      R     MOV     DPTR,#divider
0025 E0                MOVX    A,@DPTR
0026 FE                MOV     R6,A
0027 A3                INC     DPTR
0028 E0                MOVX    A,@DPTR
0029 FF                MOV     R7,A
002A C3                CLR     C
002B EF                MOV     A,R7
002C 9402              SUBB    A,#02H
002E EE                MOV     A,R6
002F 9400              SUBB    A,#00H
0031 5009              JNC     ?C0039
                                           ; SOURCE LINE # 262
                                           ; SOURCE LINE # 263
0033 900000      R     MOV     DPTR,#divider
0036 E4                CLR     A
0037 F0                MOVX    @DPTR,A
0038 A3                INC     DPTR
0039 7402              MOV     A,#02H
003B F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 264
003C         ?C0039:
                                           ; SOURCE LINE # 266
003C 900000      R     MOV     DPTR,#divider
003F E0                MOVX    A,@DPTR
0040 FE                MOV     R6,A
0041 A3                INC     DPTR
0042 E0                MOVX    A,@DPTR
0043 FF                MOV     R7,A
0044 EF                MOV     A,R7
0045 54FE              ANL     A,#0FEH
0047 FF                MOV     R7,A
0048 900000      R     MOV     DPTR,#divider
004B EE                MOV     A,R6
004C F0                MOVX    @DPTR,A
004D A3                INC     DPTR
004E EF                MOV     A,R7
004F F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 270
0050 900000      R     MOV     DPTR,#divider
0053 E0                MOVX    A,@DPTR
0054 FE                MOV     R6,A
0055 A3                INC     DPTR
0056 E0                MOVX    A,@DPTR
0057 FF                MOV     R7,A
0058 EE                MOV     A,R6
0059 C3                CLR     C
005A 13                RRC     A
005B FE                MOV     R6,A
005C EF                MOV     A,R7
005D 13                RRC     A
005E FF                MOV     R7,A
005F 900000      R     MOV     DPTR,#divider
0062 EE                MOV     A,R6
0063 F0                MOVX    @DPTR,A
0064 A3                INC     DPTR
0065 EF                MOV     A,R7
0066 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 271
C51 COMPILER V9.56.0.0   SPI_0                                                             10/28/2016 17:37:02 PAGE 192 

0067 900000      R     MOV     DPTR,#divider+01H
006A E0                MOVX    A,@DPTR
006B 24FF              ADD     A,#0FFH
006D F0                MOVX    @DPTR,A
006E 900000      R     MOV     DPTR,#divider
0071 E0                MOVX    A,@DPTR
0072 34FF              ADDC    A,#0FFH
0074 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 274
0075 C2F8              CLR     SPI0CN0_SPIEN
                                           ; SOURCE LINE # 275
0077 900000      R     MOV     DPTR,#divider
007A E0                MOVX    A,@DPTR
007B FE                MOV     R6,A
007C A3                INC     DPTR
007D E0                MOVX    A,@DPTR
007E FF                MOV     R7,A
007F 8FA2              MOV     SPI0CKR,R7
                                           ; SOURCE LINE # 276
0081 D2F8              SETB    SPI0CN0_SPIEN
                                           ; SOURCE LINE # 277
0083         ?C0040:
0083 22                RET     
             ; FUNCTION _SPI0_setClockDivider (END)

C51 COMPILER V9.56.0.0   SPI_0                                                             10/28/2016 17:37:02 PAGE 193 

NAME                                    CLASS   MSPACE  TYPE    OFFSET  SIZE
====                                    =====   ======  ====    ======  ====


SPI0CKR. . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00A2H  1
uint16_t . . . . . . . . . . . . . . .  TYPEDEF  -----  U_INT    -----  2
P0 . . . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   0080H  1
SPI0_isBusy. . . . . . . . . . . . . .  PUBLIC   CODE   PROC     0000H  -----
  count. . . . . . . . . . . . . . . .  AUTO     XDATA  U_CHAR   0000H  1
  ret. . . . . . . . . . . . . . . . .  AUTO     DATA   BIT      0000H  1
PSW_OV . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00D2H  1
XOSC0CN. . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00B1H  1
P1 . . . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   0090H  1
P2 . . . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00A0H  1
uint64_t . . . . . . . . . . . . . . .  TYPEDEF  -----  ARRAY    -----  8
_SPI0_pollTransfer . . . . . . . . . .  PUBLIC   CODE   PROC     0000H  -----
  pTxBuffer. . . . . . . . . . . . . .  AUTO     XDATA  PTR      0000H  2
  pRxBuffer. . . . . . . . . . . . . .  AUTO     XDATA  PTR      0002H  2
  dir. . . . . . . . . . . . . . . . .  AUTO     XDATA  U_CHAR   0004H  1
  xferCount. . . . . . . . . . . . . .  AUTO     XDATA  U_CHAR   0005H  1
  dummy. . . . . . . . . . . . . . . .  AUTO     XDATA  U_CHAR   0007H  1
  dummy. . . . . . . . . . . . . . . .  AUTO     XDATA  U_CHAR   0007H  1
  txCount. . . . . . . . . . . . . . .  AUTO     XDATA  U_CHAR   0006H  1
  checkNss . . . . . . . . . . . . . .  AUTO     DATA   BIT      0000H  1
P3 . . . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00B0H  1
ADC0CF . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00BCH  1
TMR2CN0_T2XCLK . . . . . . . . . . . .  ABSBIT   -----  BIT      00C8H  1
P4 . . . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00C7H  1
SI_GEN_PTR_t . . . . . . . . . . . . .  TYPEDEF  -----  UNION    -----  3
  u8 . . . . . . . . . . . . . . . . .  MEMBER   -----  ARRAY    0000H  3
  gptr . . . . . . . . . . . . . . . .  MEMBER   -----  STRUCT   0000H  3
useNss . . . . . . . . . . . . . . . .  STATIC   DATA   BIT      0000H  1
SMB0CN0_MASTER . . . . . . . . . . . .  ABSBIT   -----  BIT      00C7H  1
PCA0 . . . . . . . . . . . . . . . . .  SFR      DATA   U_INT    00F9H  2
EIE1 . . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00E6H  1
SMB1CN0_MASTER . . . . . . . . . . . .  ABSBIT   -----  BIT      00C7H  1
SMB0CN0_ACK. . . . . . . . . . . . . .  ABSBIT   -----  BIT      00C1H  1
USB0XCN. . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00D7H  1
EIE2 . . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00E7H  1
SMB1CN0_ACK. . . . . . . . . . . . . .  ABSBIT   -----  BIT      00C1H  1
int32_t. . . . . . . . . . . . . . . .  TYPEDEF  -----  LONG     -----  4
_SPI0_setClockDivider. . . . . . . . .  PUBLIC   CODE   PROC     0000H  -----
  divider. . . . . . . . . . . . . . .  AUTO     XDATA  U_INT    0000H  2
PSCTL. . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   008FH  1
IT01CF . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00E4H  1
int16_t. . . . . . . . . . . . . . . .  TYPEDEF  -----  INT      -----  2
TMR5CN0_T5XCLK . . . . . . . . . . . .  ABSBIT   -----  BIT      00C8H  1
SMB0CN0_TXMODE . . . . . . . . . . . .  ABSBIT   -----  BIT      00C6H  1
SMB1CN0_TXMODE . . . . . . . . . . . .  ABSBIT   -----  BIT      00C6H  1
SFRPAGE. . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00BFH  1
P0MDOUT. . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00A4H  1
int64_t. . . . . . . . . . . . . . . .  TYPEDEF  -----  ARRAY    -----  8
P1MDOUT. . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00A5H  1
SI_UU32. . . . . . . . . . . . . . . .  * TAG *  -----  UNION    -----  4
  u32. . . . . . . . . . . . . . . . .  MEMBER   -----  U_LONG   0000H  4
  s32. . . . . . . . . . . . . . . . .  MEMBER   -----  LONG     0000H  4
  uu16 . . . . . . . . . . . . . . . .  MEMBER   -----  ARRAY    0000H  4
  u16. . . . . . . . . . . . . . . . .  MEMBER   -----  ARRAY    0000H  4
  s16. . . . . . . . . . . . . . . . .  MEMBER   -----  ARRAY    0000H  4
  u8 . . . . . . . . . . . . . . . . .  MEMBER   -----  ARRAY    0000H  4
  s8 . . . . . . . . . . . . . . . . .  MEMBER   -----  ARRAY    0000H  4
C51 COMPILER V9.56.0.0   SPI_0                                                             10/28/2016 17:37:02 PAGE 194 

NAME                                    CLASS   MSPACE  TYPE    OFFSET  SIZE
====                                    =====   ======  ====    ======  ====


ADC0CN0_ADINT. . . . . . . . . . . . .  ABSBIT   -----  BIT      00EDH  1
TMR2RLH. . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00CBH  1
P2MDOUT. . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00A6H  1
IE . . . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00A8H  1
false. . . . . . . . . . . . . . . . .  E_CONST  -----  U_CHAR   -----  1
TMR3RLH. . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   0093H  1
P3MDOUT. . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00A7H  1
SI_UU16. . . . . . . . . . . . . . . .  * TAG *  -----  UNION    -----  2
  u16. . . . . . . . . . . . . . . . .  MEMBER   -----  U_INT    0000H  2
  s16. . . . . . . . . . . . . . . . .  MEMBER   -----  INT      0000H  2
  u8 . . . . . . . . . . . . . . . . .  MEMBER   -----  ARRAY    0000H  2
  s8 . . . . . . . . . . . . . . . . .  MEMBER   -----  ARRAY    0000H  2
SPI0_CLKMODE_0 . . . . . . . . . . . .  E_CONST  -----  U_CHAR   -----  1
TMR4RLH. . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   0093H  1
P4MDOUT. . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00AEH  1
EIP1 . . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00F6H  1
SPI0_CLKMODE_1 . . . . . . . . . . . .  E_CONST  -----  U_CHAR   -----  1
TMR5RLH. . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00CBH  1
EIP2 . . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00F7H  1
SPI0_CLKMODE_2 . . . . . . . . . . . .  E_CONST  -----  U_CHAR   -----  1
SCON0_RB8. . . . . . . . . . . . . . .  ABSBIT   -----  BIT      009AH  1
TMR2RLL. . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00CAH  1
PCA0CPH0 . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00FCH  1
SPI0_CLKMODE_3 . . . . . . . . . . . .  E_CONST  -----  U_CHAR   -----  1
TMR3RLL. . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   0092H  1
PCA0CPH1 . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00EAH  1
GPTR_t . . . . . . . . . . . . . . . .  TYPEDEF  -----  STRUCT   -----  3
  memtype. . . . . . . . . . . . . . .  MEMBER   -----  U_CHAR   0000H  1
  address. . . . . . . . . . . . . . .  MEMBER   -----  UNION    0001H  2
SCON0_TB8. . . . . . . . . . . . . . .  ABSBIT   -----  BIT      009BH  1
B_B0 . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00F0H  1
DP . . . . . . . . . . . . . . . . . .  SFR      DATA   U_INT    0082H  2
TMR4RLL. . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   0092H  1
PCA0CPH2 . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00ECH  1
B_B1 . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00F1H  1
ADC0GT . . . . . . . . . . . . . . . .  SFR      DATA   U_INT    00C3H  2
TMR5RLL. . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00CAH  1
PCA0CPH3 . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00EEH  1
B_B2 . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00F2H  1
PCA0CPL0 . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00FBH  1
PCA0CPH4 . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00FEH  1
EMI0CF . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   0085H  1
B_B3 . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00F3H  1
PCA0MD . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00D9H  1
PCA0CPM0 . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00DAH  1
PCA0CPL1 . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00E9H  1
B_B4 . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00F4H  1
PCA0CPM1 . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00DBH  1
PCA0CPL2 . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00EBH  1
B_B5 . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00F5H  1
PCA0CPM2 . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00DCH  1
PCA0CPL3 . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00EDH  1
IP . . . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00B8H  1
B_B6 . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00F6H  1
ADC0LT . . . . . . . . . . . . . . . .  SFR      DATA   U_INT    00C5H  2
PCA0CPM3 . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00DDH  1
PCA0CPL4 . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00FDH  1
C51 COMPILER V9.56.0.0   SPI_0                                                             10/28/2016 17:37:02 PAGE 195 

NAME                                    CLASS   MSPACE  TYPE    OFFSET  SIZE
====                                    =====   ======  ====    ======  ====


SCON0_MCE. . . . . . . . . . . . . . .  ABSBIT   -----  BIT      009DH  1
B_B7 . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00F7H  1
PCA0CPM4 . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00DEH  1
XBR0 . . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00E1H  1
SMB0CF . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00C1H  1
XBR1 . . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00E2H  1
SMB1CF . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00C1H  1
PFE0CN . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00AFH  1
EMI0CN . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00AAH  1
SPI0_TRANSFER_RXTX . . . . . . . . . .  E_CONST  -----  U_CHAR   -----  1
SMB0CN0_STA. . . . . . . . . . . . . .  ABSBIT   -----  BIT      00C5H  1
XBR2 . . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00E3H  1
SMB1CN0_STA. . . . . . . . . . . . . .  ABSBIT   -----  BIT      00C5H  1
ACC_ACC0 . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00E0H  1
REF0CN . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00D1H  1
HFO0CN . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00B2H  1
CKCON0 . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   008EH  1
ACC_ACC1 . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00E1H  1
CKCON1 . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00E4H  1
TMR2CN0_TR2. . . . . . . . . . . . . .  ABSBIT   -----  BIT      00CAH  1
ACC_ACC2 . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00E2H  1
ACC_ACC3 . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00E3H  1
SP . . . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   0081H  1
CMP0MD . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   009DH  1
ACC_ACC4 . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00E4H  1
LFO0CN . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   0086H  1
EMI0TC . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   0084H  1
CMP1MD . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   009CH  1
PCA0CN0_CCF0 . . . . . . . . . . . . .  ABSBIT   -----  BIT      00D8H  1
ACC_ACC5 . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00E5H  1
PCA0CN0_CCF1 . . . . . . . . . . . . .  ABSBIT   -----  BIT      00D9H  1
ACC_ACC6 . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00E6H  1
TMR2 . . . . . . . . . . . . . . . . .  SFR      DATA   U_INT    00CCH  2
PCA0CN0_CCF2 . . . . . . . . . . . . .  ABSBIT   -----  BIT      00DAH  1
ACC_ACC7 . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00E7H  1
TMR3 . . . . . . . . . . . . . . . . .  SFR      DATA   U_INT    0094H  2
TMR5CN0_TR5. . . . . . . . . . . . . .  ABSBIT   -----  BIT      00CAH  1
PCA0CN0_CCF3 . . . . . . . . . . . . .  ABSBIT   -----  BIT      00DBH  1
TMR4 . . . . . . . . . . . . . . . . .  SFR      DATA   U_INT    0094H  2
SBCON1 . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00ACH  1
PCA0CN0_CCF4 . . . . . . . . . . . . .  ABSBIT   -----  BIT      00DCH  1
TMR5 . . . . . . . . . . . . . . . . .  SFR      DATA   U_INT    00CCH  2
SMB0CN0_ACKRQ. . . . . . . . . . . . .  ABSBIT   -----  BIT      00C3H  1
VDM0CN . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00FFH  1
P0MDIN . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00F1H  1
SMB1CN0_ACKRQ. . . . . . . . . . . . .  ABSBIT   -----  BIT      00C3H  1
SCON0_REN. . . . . . . . . . . . . . .  ABSBIT   -----  BIT      009CH  1
P1MDIN . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00F2H  1
P2MDIN . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00F3H  1
SMB0CN0_STO. . . . . . . . . . . . . .  ABSBIT   -----  BIT      00C4H  1
P3MDIN . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00F4H  1
SMB1CN0_STO. . . . . . . . . . . . . .  ABSBIT   -----  BIT      00C4H  1
SBRLH1 . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00B5H  1
P4MDIN . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00F5H  1
bool . . . . . . . . . . . . . . . . .  TYPEDEF  DATA   BIT      -----  1
SI_GEN_PTR . . . . . . . . . . . . . .  * TAG *  -----  UNION    -----  3
  u8 . . . . . . . . . . . . . . . . .  MEMBER   -----  ARRAY    0000H  3
C51 COMPILER V9.56.0.0   SPI_0                                                             10/28/2016 17:37:02 PAGE 196 

NAME                                    CLASS   MSPACE  TYPE    OFFSET  SIZE
====                                    =====   ======  ====    ======  ====


  gptr . . . . . . . . . . . . . . . .  MEMBER   -----  STRUCT   0000H  3
PSW_RS0. . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00D3H  1
PCA0CN0_CF . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00DFH  1
SPI0CN0_RXOVRN . . . . . . . . . . . .  ABSBIT   -----  BIT      00FCH  1
PSW_RS1. . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00D4H  1
SBRLL1 . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00B4H  1
_SPI0_init . . . . . . . . . . . . . .  PUBLIC   CODE   PROC     0000H  -----
  clockMode. . . . . . . . . . . . . .  AUTO     XDATA  U_CHAR   0000H  1
  isMasterMode . . . . . . . . . . . .  AUTO     DATA   BIT      0000H  1
  is4wire. . . . . . . . . . . . . . .  AUTO     DATA   BIT      0001H  1
ADC0CN0_ADEN . . . . . . . . . . . . .  ABSBIT   -----  BIT      00EFH  1
TMOD . . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   0089H  1
TCON . . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   0088H  1
PSW_PARITY . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00D0H  1
IE_ES0 . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00ACH  1
CMP0MX . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   009FH  1
IE_ET0 . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00A9H  1
CMP1MX . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   009EH  1
IE_ET1 . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00ABH  1
P0SKIP . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00D4H  1
TMR2CN0_T2CSS. . . . . . . . . . . . .  ABSBIT   -----  BIT      00C9H  1
IE_ET2 . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00ADH  1
P1SKIP . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00D5H  1
P2SKIP . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00D6H  1
ADC0CN0. . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00E8H  1
IE_EX0 . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00A8H  1
P3SKIP . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00DFH  1
PCA0CN0_CR . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00DEH  1
IE_EX1 . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00AAH  1
SCON0_SMODE. . . . . . . . . . . . . .  ABSBIT   -----  BIT      009FH  1
CLKSEL . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00A9H  1
SPI0CN0_SPIEN. . . . . . . . . . . . .  ABSBIT   -----  BIT      00F8H  1
B. . . . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00F0H  1
ADC0H. . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00BEH  1
true . . . . . . . . . . . . . . . . .  E_CONST  -----  U_CHAR   -----  1
_SPI0_writeByte. . . . . . . . . . . .  PUBLIC   CODE   PROC     0000H  -----
  value. . . . . . . . . . . . . . . .  AUTO     XDATA  U_CHAR   0000H  1
  ret. . . . . . . . . . . . . . . . .  AUTO     DATA   BIT      0000H  1
ADC0CN0_ADTM . . . . . . . . . . . . .  ABSBIT   -----  BIT      00EEH  1
SPI0_TransferDirection_t . . . . . . .  TYPEDEF  -----  U_CHAR   -----  1
TMR2RL . . . . . . . . . . . . . . . .  SFR      DATA   U_INT    00CAH  2
ADC0L. . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00BDH  1
TMR3RL . . . . . . . . . . . . . . . .  SFR      DATA   U_INT    0092H  2
TMR4RL . . . . . . . . . . . . . . . .  SFR      DATA   U_INT    0092H  2
PCA0CN0. . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00D8H  1
ACC. . . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00E0H  1
TMR5RL . . . . . . . . . . . . . . . .  SFR      DATA   U_INT    00CAH  2
SPI0_ClockMode_t . . . . . . . . . . .  TYPEDEF  -----  U_CHAR   -----  1
PCA0CP0. . . . . . . . . . . . . . . .  SFR      DATA   U_INT    00FBH  2
PCA0CP1. . . . . . . . . . . . . . . .  SFR      DATA   U_INT    00E9H  2
PCA0CP2. . . . . . . . . . . . . . . .  SFR      DATA   U_INT    00EBH  2
PCA0CP3. . . . . . . . . . . . . . . .  SFR      DATA   U_INT    00EDH  2
TH0. . . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   008CH  1
IP_PS0 . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00BCH  1
PCA0CP4. . . . . . . . . . . . . . . .  SFR      DATA   U_INT    00FDH  2
TH1. . . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   008DH  1
PCA0H. . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00FAH  1
C51 COMPILER V9.56.0.0   SPI_0                                                             10/28/2016 17:37:02 PAGE 197 

NAME                                    CLASS   MSPACE  TYPE    OFFSET  SIZE
====                                    =====   ======  ====    ======  ====


IP_PT0 . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00B9H  1
IP_PT1 . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00BBH  1
uint8_t. . . . . . . . . . . . . . . .  TYPEDEF  -----  U_CHAR   -----  1
SMB0CN0_ARBLOST. . . . . . . . . . . .  ABSBIT   -----  BIT      00C2H  1
IP_PT2 . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00BDH  1
TL0. . . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   008AH  1
SPI0CN0_TXBMT. . . . . . . . . . . . .  ABSBIT   -----  BIT      00F9H  1
SMB1CN0_ARBLOST. . . . . . . . . . . .  ABSBIT   -----  BIT      00C2H  1
PSW_F0 . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00D5H  1
IE_ESPI0 . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00AEH  1
TL1. . . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   008BH  1
PCA0L. . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00F9H  1
SMB0CN0_SI . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00C0H  1
PSW_F1 . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00D1H  1
P0_B0. . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      0080H  1
IP_PX0 . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00B8H  1
REG01CN. . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00C9H  1
SMB1CN0_SI . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00C0H  1
P1_B0. . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      0090H  1
P0_B1. . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      0081H  1
IP_PX1 . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00BAH  1
CMP0CN0. . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   009BH  1
TCON_IE0 . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      0089H  1
P2_B0. . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00A0H  1
P1_B1. . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      0091H  1
P0_B2. . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      0082H  1
CMP1CN0. . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   009AH  1
modeIsMaster . . . . . . . . . . . . .  STATIC   DATA   BIT      0001H  1
TCON_IE1 . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      008BH  1
P3_B0. . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00B0H  1
P2_B1. . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00A1H  1
P1_B2. . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      0092H  1
P0_B3. . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      0083H  1
SMB0CN0. . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00C0H  1
P3_B1. . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00B1H  1
P2_B2. . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00A2H  1
P1_B3. . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      0093H  1
P0_B4. . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      0084H  1
SMB1CN0. . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00C0H  1
P3_B2. . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00B2H  1
P2_B3. . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00A3H  1
P1_B4. . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      0094H  1
P0_B5. . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      0085H  1
P3_B3. . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00B3H  1
P2_B4. . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00A4H  1
P1_B5. . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      0095H  1
P0_B6. . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      0086H  1
P3_B4. . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00B4H  1
P2_B5. . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00A5H  1
P1_B6. . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      0096H  1
P0_B7. . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      0087H  1
int8_t . . . . . . . . . . . . . . . .  TYPEDEF  -----  CHAR     -----  1
P3_B5. . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00B5H  1
P2_B6. . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00A6H  1
P1_B7. . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      0097H  1
P3_B6. . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00B6H  1
P2_B7. . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00A7H  1
C51 COMPILER V9.56.0.0   SPI_0                                                             10/28/2016 17:37:02 PAGE 198 

NAME                                    CLASS   MSPACE  TYPE    OFFSET  SIZE
====                                    =====   ======  ====    ======  ====


P3_B7. . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00B7H  1
DPH. . . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   0083H  1
_SPI0_pollWriteByte. . . . . . . . . .  PUBLIC   CODE   PROC     0000H  -----
  value. . . . . . . . . . . . . . . .  AUTO     XDATA  U_CHAR   0000H  1
ADC0GTH. . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00C4H  1
TMR2CN0_TF2H . . . . . . . . . . . . .  ABSBIT   -----  BIT      00CFH  1
TMR2CN0_T2SPLIT. . . . . . . . . . . .  ABSBIT   -----  BIT      00CBH  1
PSW_AC . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00D6H  1
SPI0CN0. . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00F8H  1
HFO0CAL. . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00B3H  1
TCON_TF0 . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      008DH  1
SCON0_RI . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      0098H  1
DPL. . . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   0082H  1
TCON_TF1 . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      008FH  1
SBUF0. . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   0099H  1
PCON0. . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   0087H  1
ADC0GTL. . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00C3H  1
SI_UU32_t. . . . . . . . . . . . . . .  TYPEDEF  -----  UNION    -----  4
  u32. . . . . . . . . . . . . . . . .  MEMBER   -----  U_LONG   0000H  4
  s32. . . . . . . . . . . . . . . . .  MEMBER   -----  LONG     0000H  4
  uu16 . . . . . . . . . . . . . . . .  MEMBER   -----  ARRAY    0000H  4
  u16. . . . . . . . . . . . . . . . .  MEMBER   -----  ARRAY    0000H  4
  s16. . . . . . . . . . . . . . . . .  MEMBER   -----  ARRAY    0000H  4
  u8 . . . . . . . . . . . . . . . . .  MEMBER   -----  ARRAY    0000H  4
  s8 . . . . . . . . . . . . . . . . .  MEMBER   -----  ARRAY    0000H  4
TMR2CN0_TF2L . . . . . . . . . . . . .  ABSBIT   -----  BIT      00CEH  1
SCON0_TI . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      0099H  1
ADC0CN0_ADCM0. . . . . . . . . . . . .  ABSBIT   -----  BIT      00E8H  1
SBUF1. . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00D3H  1
ADC0LTH. . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00C6H  1
TCON_IT0 . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      0088H  1
ADC0CN0_ADCM1. . . . . . . . . . . . .  ABSBIT   -----  BIT      00E9H  1
RSTSRC . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00EFH  1
SI_UU16_t. . . . . . . . . . . . . . .  TYPEDEF  -----  UNION    -----  2
  u16. . . . . . . . . . . . . . . . .  MEMBER   -----  U_INT    0000H  2
  s16. . . . . . . . . . . . . . . . .  MEMBER   -----  INT      0000H  2
  u8 . . . . . . . . . . . . . . . . .  MEMBER   -----  ARRAY    0000H  2
  s8 . . . . . . . . . . . . . . . . .  MEMBER   -----  ARRAY    0000H  2
TMR5CN0_TF5H . . . . . . . . . . . . .  ABSBIT   -----  BIT      00CFH  1
TMR5CN0_T5SPLIT. . . . . . . . . . . .  ABSBIT   -----  BIT      00CBH  1
TCON_IT1 . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      008AH  1
ADC0CN0_ADCM2. . . . . . . . . . . . .  ABSBIT   -----  BIT      00EAH  1
SCON0. . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   0098H  1
ADC0CN0_ADWINT . . . . . . . . . . . .  ABSBIT   -----  BIT      00EBH  1
SBRL1. . . . . . . . . . . . . . . . .  SFR      DATA   U_INT    00B4H  2
SMOD1. . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00E5H  1
SCON1. . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00D2H  1
AMX0N. . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00BAH  1
ADC0CN0_ADBUSY . . . . . . . . . . . .  ABSBIT   -----  BIT      00ECH  1
SMB0ADM. . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00CEH  1
ADC0LTL. . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00C5H  1
initIsValid. . . . . . . . . . . . . .  STATIC   DATA   BIT      0002H  1
SPI0CN0_MODF . . . . . . . . . . . . .  ABSBIT   -----  BIT      00FDH  1
IP_PSPI0 . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00BEH  1
SMB1ADM. . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00CEH  1
AMX0P. . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00BBH  1
TMR5CN0_TF5L . . . . . . . . . . . . .  ABSBIT   -----  BIT      00CEH  1
C51 COMPILER V9.56.0.0   SPI_0                                                             10/28/2016 17:37:02 PAGE 199 

NAME                                    CLASS   MSPACE  TYPE    OFFSET  SIZE
====                                    =====   ======  ====    ======  ====


TMR2CN0. . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00C8H  1
TMR3CN0. . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   0091H  1
TMR4CN0. . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   0091H  1
TMR5CN0. . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00C8H  1
SMB0ADR. . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00CFH  1
TCON_TR0 . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      008CH  1
SMB1ADR. . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00CFH  1
TMR2CN0_TF2CEN . . . . . . . . . . . .  ABSBIT   -----  BIT      00CCH  1
TCON_TR1 . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      008EH  1
SMB0DAT. . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00C2H  1
TMR2H. . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00CDH  1
SPI0CFG. . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00A1H  1
SMB1DAT. . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00C2H  1
TMR3H. . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   0095H  1
TMR4H. . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   0095H  1
SPI0_TRANSFER_RX . . . . . . . . . . .  E_CONST  -----  U_CHAR   -----  1
TMR5H. . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00CDH  1
TMR2L. . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00CCH  1
SPI0_TRANSFER_TX . . . . . . . . . . .  E_CONST  -----  U_CHAR   -----  1
SPI0CN0_SPIF . . . . . . . . . . . . .  ABSBIT   -----  BIT      00FFH  1
USB0ADR. . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   0096H  1
TMR3L. . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   0094H  1
IE_EA. . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00AFH  1
TMR4L. . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   0094H  1
USB0DAT. . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   0097H  1
TMR5L. . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00CCH  1
FLSCL. . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00B6H  1
TMR2CN0_TF2LEN . . . . . . . . . . . .  ABSBIT   -----  BIT      00CDH  1
SPI0CN0_WCOL . . . . . . . . . . . . .  ABSBIT   -----  BIT      00FEH  1
SPI0_internalInit. . . . . . . . . . .  STATIC   CODE   PROC     0000H  -----
SPI0CN0_NSSMD0 . . . . . . . . . . . .  ABSBIT   -----  BIT      00FAH  1
PSW_CY . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00D7H  1
SPI0DAT. . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00A3H  1
SPI0CN0_NSSMD1 . . . . . . . . . . . .  ABSBIT   -----  BIT      00FBH  1
ADC0 . . . . . . . . . . . . . . . . .  SFR      DATA   U_INT    00BDH  2
SMBTC. . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00B9H  1
PSW. . . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00D0H  1
TMR5CN0_TF5LEN . . . . . . . . . . . .  ABSBIT   -----  BIT      00CDH  1
FLKEY. . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00B7H  1
uint32_t . . . . . . . . . . . . . . .  TYPEDEF  -----  U_LONG   -----  4


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    537    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =     14    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =      8    ----
   EDATA SIZE       =   ----    ----
   HDATA SIZE       =   ----    ----
   XDATA CONST SIZE =   ----    ----
   FAR CONST SIZE   =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
